var away;
(function (away) {
    /**
    * Base event class
    * @class away.events.Event
    */
    (function (events) {
        var Event = (function () {
            function Event(type) {
                /**
                * Type of event
                * @property type
                * @type String
                */
                this.type = undefined;
                /**
                * Reference to target object
                * @property target
                * @type Object
                */
                this.target = undefined;
                this.type = type;
            }
            /**
            * Clones the current event.
            * @return An exact duplicate of the current event.
            */
            Event.prototype.clone = function () {
                return new Event(this.type);
            };
            Event.COMPLETE = 'Event_Complete';
            Event.OPEN = 'Event_Open';

            Event.ENTER_FRAME = 'enterframe';
            Event.EXIT_FRAME = 'exitframe';

            Event.RESIZE = "resize";
            Event.CONTEXT3D_CREATE = "context3DCreate";
            Event.ERROR = "error";
            Event.CHANGE = "change";
            return Event;
        })();
        events.Event = Event;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        /**
        * Base class for dispatching events
        *
        * @class away.events.EventDispatcher
        *
        */
        var EventDispatcher = (function () {
            function EventDispatcher() {
                this.listeners = new Array();
            }
            /**
            * Add an event listener
            * @method addEventListener
            * @param {String} Name of event to add a listener for
            * @param {Function} Callback function
            * @param {Object} Target object listener is added to
            */
            EventDispatcher.prototype.addEventListener = function (type, listener, target) {
                if (this.listeners[type] === undefined) {
                    this.listeners[type] = new Array();
                }

                if (this.getEventListenerIndex(type, listener, target) === -1) {
                    var d = new EventData();
                    d.listener = listener;
                    d.type = type;
                    d.target = target;

                    this.listeners[type].push(d);
                }
            };

            /**
            * Remove an event listener
            * @method removeEventListener
            * @param {String} Name of event to remove a listener for
            * @param {Function} Callback function
            * @param {Object} Target object listener is added to
            */
            EventDispatcher.prototype.removeEventListener = function (type, listener, target) {
                var index = this.getEventListenerIndex(type, listener, target);

                if (index !== -1) {
                    this.listeners[type].splice(index, 1);
                }
            };

            /**
            * Dispatch an event
            * @method dispatchEvent
            * @param {Event} Event to dispatch
            */
            EventDispatcher.prototype.dispatchEvent = function (event) {
                var listenerArray = this.listeners[event.type];

                if (listenerArray !== undefined) {
                    this.lFncLength = listenerArray.length;
                    event.target = this;

                    var eventData;

                    for (var i = 0, l = this.lFncLength; i < l; i++) {
                        eventData = listenerArray[i];
                        eventData.listener.call(eventData.target, event);
                    }
                }
            };

            /**
            * get Event Listener Index in array. Returns -1 if no listener is added
            * @method getEventListenerIndex
            * @param {String} Name of event to remove a listener for
            * @param {Function} Callback function
            * @param {Object} Target object listener is added to
            */
            EventDispatcher.prototype.getEventListenerIndex = function (type, listener, target) {
                if (this.listeners[type] !== undefined) {
                    var a = this.listeners[type];
                    var l = a.length;
                    var d;

                    for (var c = 0; c < l; c++) {
                        d = a[c];

                        if (target == d.target && listener == d.listener) {
                            return c;
                        }
                    }
                }

                return -1;
            };

            /**
            * check if an object has an event listener assigned to it
            * @method hasListener
            * @param {String} Name of event to remove a listener for
            * @param {Function} Callback function
            * @param {Object} Target object listener is added to
            */
            //todo: hasEventListener - relax check by not requiring target in param
            EventDispatcher.prototype.hasEventListener = function (type, listener, target) {
                if (typeof listener === "undefined") { listener = null; }
                if (typeof target === "undefined") { target = null; }
                if (this.listeners != null && target != null) {
                    return (this.getEventListenerIndex(type, listener, target) !== -1);
                } else {
                    if (this.listeners[type] !== undefined) {
                        var a = this.listeners[type];
                        return (a.length > 0);
                    }

                    return false;
                }

                return false;
            };
            return EventDispatcher;
        })();
        events.EventDispatcher = EventDispatcher;

        /**
        * Event listener data container
        */
        var EventData = (function () {
            function EventData() {
            }
            return EventData;
        })();
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    /**
    * @module away.events
    */
    (function (events) {
        var LightEvent = (function (_super) {
            __extends(LightEvent, _super);
            function LightEvent(type) {
                _super.call(this, type);
            }
            //@override
            LightEvent.prototype.clone = function () {
                return new away.events.LightEvent(this.type);
            };
            LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";
            return LightEvent;
        })(away.events.Event);
        events.LightEvent = LightEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../../_definitions.ts"/>
    (function (base) {
        /**
        * Vertex value object.
        */
        var Vertex = (function () {
            /**
            * Creates a new <code>Vertex</code> value object.
            *
            * @param    x            [optional]    The x value. Defaults to 0.
            * @param    y            [optional]    The y value. Defaults to 0.
            * @param    z            [optional]    The z value. Defaults to 0.
            * @param    index        [optional]    The index value. Defaults is NaN.
            */
            function Vertex(x, y, z, index) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof z === "undefined") { z = 0; }
                if (typeof index === "undefined") { index = 0; }
                this._x = x;
                this._y = y;
                this._z = z;
                this._index = index;
            }

            Object.defineProperty(Vertex.prototype, "index", {
                get: function () {
                    return this._index;
                },
                set: /**
                * To define/store the index of value object
                * @param    ind        The index
                */
                function (ind) {
                    this._index = ind;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Vertex.prototype, "x", {
                get: /**
                * To define/store the x value of the value object
                * @param    value        The x value
                */
                function () {
                    return this._x;
                },
                set: function (value) {
                    this._x = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Vertex.prototype, "y", {
                get: /**
                * To define/store the y value of the value object
                * @param    value        The y value
                */
                function () {
                    return this._y;
                },
                set: function (value) {
                    this._y = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Vertex.prototype, "z", {
                get: /**
                * To define/store the z value of the value object
                * @param    value        The z value
                */
                function () {
                    return this._z;
                },
                set: function (value) {
                    this._z = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * returns a new Vertex value Object
            */
            Vertex.prototype.clone = function () {
                return new Vertex(this._x, this._y, this._z);
            };

            /**
            * returns the value object as a string for trace/debug purpose
            */
            Vertex.prototype.toString = function () {
                return this._x + "," + this._y + "," + this._z;
            };
            return Vertex;
        })();
        base.Vertex = Vertex;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../../_definitions.ts"/>
    (function (base) {
        /**
        * Texture coordinates value object.
        */
        var UV = (function () {
            /**
            * Creates a new <code>UV</code> object.
            *
            * @param    u        [optional]    The horizontal coordinate of the texture value. Defaults to 0.
            * @param    v        [optional]    The vertical coordinate of the texture value. Defaults to 0.
            */
            function UV(u, v) {
                if (typeof u === "undefined") { u = 0; }
                if (typeof v === "undefined") { v = 0; }
                this._u = u;
                this._v = v;
            }
            Object.defineProperty(UV.prototype, "v", {
                get: /**
                * Defines the vertical coordinate of the texture value.
                */
                function () {
                    return this._v;
                },
                set: function (value) {
                    this._v = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(UV.prototype, "u", {
                get: /**
                * Defines the horizontal coordinate of the texture value.
                */
                function () {
                    return this._u;
                },
                set: function (value) {
                    this._u = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * returns a new UV value Object
            */
            UV.prototype.clone = function () {
                return new UV(this._u, this._v);
            };

            /**
            * returns the value object as a string for trace/debug purpose
            */
            UV.prototype.toString = function () {
                return this._u + "," + this._v;
            };
            return UV;
        })();
        base.UV = UV;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (events) {
        //import away3d.library.assets.IAsset;
        //import flash.events.Event;
        /**
        * @class away.events.AssetEvent
        */
        var AssetEvent = (function (_super) {
            __extends(AssetEvent, _super);
            function AssetEvent(type, asset, prevName) {
                if (typeof asset === "undefined") { asset = null; }
                if (typeof prevName === "undefined") { prevName = null; }
                _super.call(this, type);

                this._asset = asset;
                this._prevName = prevName || (this._asset ? this._asset.name : null);
            }
            Object.defineProperty(AssetEvent.prototype, "asset", {
                get: function () {
                    return this._asset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AssetEvent.prototype, "assetPrevName", {
                get: function () {
                    return this._prevName;
                },
                enumerable: true,
                configurable: true
            });

            AssetEvent.prototype.clone = function () {
                return new away.events.AssetEvent(this.type, this.asset, this.assetPrevName);
            };
            AssetEvent.ASSET_COMPLETE = "assetComplete";
            AssetEvent.ENTITY_COMPLETE = "entityComplete";
            AssetEvent.SKYBOX_COMPLETE = "skyboxComplete";
            AssetEvent.CAMERA_COMPLETE = "cameraComplete";
            AssetEvent.MESH_COMPLETE = "meshComplete";
            AssetEvent.GEOMETRY_COMPLETE = "geometryComplete";
            AssetEvent.SKELETON_COMPLETE = "skeletonComplete";
            AssetEvent.SKELETON_POSE_COMPLETE = "skeletonPoseComplete";
            AssetEvent.CONTAINER_COMPLETE = "containerComplete";
            AssetEvent.TEXTURE_COMPLETE = "textureComplete";
            AssetEvent.TEXTURE_PROJECTOR_COMPLETE = "textureProjectorComplete";
            AssetEvent.MATERIAL_COMPLETE = "materialComplete";
            AssetEvent.ANIMATOR_COMPLETE = "animatorComplete";
            AssetEvent.ANIMATION_SET_COMPLETE = "animationSetComplete";
            AssetEvent.ANIMATION_STATE_COMPLETE = "animationStateComplete";
            AssetEvent.ANIMATION_NODE_COMPLETE = "animationNodeComplete";
            AssetEvent.STATE_TRANSITION_COMPLETE = "stateTransitionComplete";
            AssetEvent.SEGMENT_SET_COMPLETE = "segmentSetComplete";
            AssetEvent.LIGHT_COMPLETE = "lightComplete";
            AssetEvent.LIGHTPICKER_COMPLETE = "lightPickerComplete";
            AssetEvent.EFFECTMETHOD_COMPLETE = "effectMethodComplete";
            AssetEvent.SHADOWMAPMETHOD_COMPLETE = "shadowMapMethodComplete";

            AssetEvent.ASSET_RENAME = 'assetRename';
            AssetEvent.ASSET_CONFLICT_RESOLVED = 'assetConflictResolved';

            AssetEvent.TEXTURE_SIZE_ERROR = 'textureSizeError';
            return AssetEvent;
        })(away.events.Event);
        events.AssetEvent = AssetEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (library) {
        var NamedAssetBase = (function (_super) {
            __extends(NamedAssetBase, _super);
            function NamedAssetBase(name) {
                if (typeof name === "undefined") { name = null; }
                _super.call(this);

                if (name == null)
                    name = 'null';

                this._name = name;
                this._originalName = name;

                this.updateFullPath();
            }
            Object.defineProperty(NamedAssetBase.prototype, "originalName", {
                get: /**
                * The original name used for this asset in the resource (e.g. file) in which
                * it was found. This may not be the same as <code>name</code>, which may
                * have changed due to of a name conflict.
                */
                function () {
                    return this._originalName;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(NamedAssetBase.prototype, "id", {
                get: function () {
                    return this._id;
                },
                set: function (newID) {
                    this._id = newID;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NamedAssetBase.prototype, "assetType", {
                get: function () {
                    return this._assetType;
                },
                set: function (type) {
                    this._assetType = type;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NamedAssetBase.prototype, "name", {
                get: function () {
                    return this._name;
                },
                set: function (val) {
                    var prev;

                    prev = this._name;
                    this._name = val;

                    if (this._name == null) {
                        this._name = 'null';
                    }

                    this.updateFullPath();

                    //if (hasEventListener(AssetEvent.ASSET_RENAME))
                    this.dispatchEvent(new away.events.AssetEvent(away.events.AssetEvent.ASSET_RENAME, this, prev));
                },
                enumerable: true,
                configurable: true
            });


            NamedAssetBase.prototype.dispose = function () {
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(NamedAssetBase.prototype, "assetNamespace", {
                get: function () {
                    return this._namespace;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(NamedAssetBase.prototype, "assetFullPath", {
                get: function () {
                    return this._full_path;
                },
                enumerable: true,
                configurable: true
            });

            NamedAssetBase.prototype.assetPathEquals = function (name, ns) {
                return (this._name == name && (!ns || this._namespace == ns));
            };

            NamedAssetBase.prototype.resetAssetPath = function (name, ns, overrideOriginal) {
                if (typeof ns === "undefined") { ns = null; }
                if (typeof overrideOriginal === "undefined") { overrideOriginal = true; }
                this._name = name ? name : 'null';
                this._namespace = ns ? ns : NamedAssetBase.DEFAULT_NAMESPACE;

                if (overrideOriginal) {
                    this._originalName = this._name;
                }

                this.updateFullPath();
            };

            NamedAssetBase.prototype.updateFullPath = function () {
                this._full_path = [this._namespace, this._name];
            };
            NamedAssetBase.DEFAULT_NAMESPACE = 'default';
            return NamedAssetBase;
        })(away.events.EventDispatcher);
        library.NamedAssetBase = NamedAssetBase;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (geom) {
        var Vector3D = (function () {
            /**
            * Creates an instance of a Vector3D object.
            */
            function Vector3D(x, y, z, w) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof z === "undefined") { z = 0; }
                if (typeof w === "undefined") { w = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            Object.defineProperty(Vector3D.prototype, "length", {
                get: /**
                * [read-only] The length, magnitude, of the current Vector3D object from the origin (0,0,0) to the object's
                * x, y, and z coordinates.
                * @returns The length of the Vector3D
                */
                function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Vector3D.prototype, "lengthSquared", {
                get: /**
                * [read-only] The square of the length of the current Vector3D object, calculated using the x, y, and z
                * properties.
                * @returns The squared length of the vector
                */
                function () {
                    return (this.x * this.x + this.y * this.y + this.z * this.z);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds the value of the x, y, and z elements of the current Vector3D object to the values of the x, y, and z
            * elements of another Vector3D object.
            */
            Vector3D.prototype.add = function (a) {
                return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w);
            };

            Vector3D.angleBetween = /**
            * [static] Returns the angle in radians between two vectors.
            */
            function (a, b) {
                return Math.acos(a.dotProduct(b) / (a.length * b.length));
            };

            /**
            * Returns a new Vector3D object that is an exact copy of the current Vector3D object.
            */
            Vector3D.prototype.clone = function () {
                return new Vector3D(this.x, this.y, this.z, this.w);
            };

            /**
            * Copies all of vector data from the source Vector3D object into the calling Vector3D object.
            */
            Vector3D.prototype.copyFrom = function (src) {
                this.x = src.x;
                this.y = src.y;
                this.z = src.z;
                this.w = src.w;
                //return new Vector3D(src.x, src.y, src.z, src.w);
            };

            /**
            * Returns a new Vector3D object that is perpendicular (at a right angle) to the current Vector3D and another
            * Vector3D object.
            */
            Vector3D.prototype.crossProduct = function (a) {
                return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
            };

            /**
            * Decrements the value of the x, y, and z elements of the current Vector3D object by the values of the x, y,
            * and z elements of specified Vector3D object.
            */
            Vector3D.prototype.decrementBy = function (a) {
                this.x -= a.x;
                this.y -= a.y;
                this.z -= a.z;
            };

            Vector3D.distance = /**
            * [static] Returns the distance between two Vector3D objects.
            */
            function (pt1, pt2) {
                var x = (pt1.x - pt2.x);
                var y = (pt1.y - pt2.y);
                var z = (pt1.z - pt2.z);
                return Math.sqrt(x * x + y * y + z * z);
            };

            /**
            * If the current Vector3D object and the one specified as the parameter are unit vertices, this method returns
            * the cosine of the angle between the two vertices.
            */
            Vector3D.prototype.dotProduct = function (a) {
                return this.x * a.x + this.y * a.y + this.z * a.z;
            };

            /**
            * Determines whether two Vector3D objects are equal by comparing the x, y, and z elements of the current
            * Vector3D object with a specified Vector3D object.
            */
            Vector3D.prototype.equals = function (cmp, allFour) {
                if (typeof allFour === "undefined") { allFour = false; }
                return (this.x == cmp.x && this.y == cmp.y && this.z == cmp.z && (!allFour || this.w == cmp.w));
            };

            /**
            * Increments the value of the x, y, and z elements of the current Vector3D object by the values of the x, y,
            * and z elements of a specified Vector3D object.
            */
            Vector3D.prototype.incrementBy = function (a) {
                this.x += a.x;
                this.y += a.y;
                this.z += a.z;
            };

            /**
            * Compares the elements of the current Vector3D object with the elements of a specified Vector3D object to
            * determine whether they are nearly equal.
            */
            Vector3D.prototype.nearEquals = function (cmp, epsilon, allFour) {
                if (typeof allFour === "undefined") { allFour = true; }
                return ((Math.abs(this.x - cmp.x) < epsilon) && (Math.abs(this.y - cmp.y) < epsilon) && (Math.abs(this.z - cmp.z) < epsilon) && (!allFour || Math.abs(this.w - cmp.w) < epsilon));
            };

            /**
            * Sets the current Vector3D object to its inverse.
            */
            Vector3D.prototype.negate = function () {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
            };

            /**
            * Converts a Vector3D object to a unit vector by dividing the first three elements (x, y, z) by the length of
            * the vector.
            */
            Vector3D.prototype.normalize = function () {
                var invLength = 1 / this.length;
                if (invLength != 0) {
                    this.x *= invLength;
                    this.y *= invLength;
                    this.z *= invLength;
                    return;
                }
                throw "Cannot divide by zero.";
            };

            /**
            * Divides the value of the x, y, and z properties of the current Vector3D object by the value of its w
            * property.
            */
            Vector3D.prototype.project = function () {
                this.x /= this.w;
                this.y /= this.w;
                this.z /= this.w;
            };

            /**
            * Scales the current Vector3D object by a scalar, a magnitude.
            */
            Vector3D.prototype.scaleBy = function (s) {
                this.x *= s;
                this.y *= s;
                this.z *= s;
            };

            /**
            * Sets the members of Vector3D to the specified values
            */
            Vector3D.prototype.setTo = function (xa, ya, za) {
                this.x = xa;
                this.y = ya;
                this.z = za;
            };

            /**
            * Subtracts the value of the x, y, and z elements of the current Vector3D object from the values of the x, y,
            * and z elements of another Vector3D object.
            */
            Vector3D.prototype.subtract = function (a) {
                return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
            };

            /**
            * Returns a string representation of the current Vector3D object.
            */
            Vector3D.prototype.toString = function () {
                return "[Vector3D] (x:" + this.x + " ,y:" + this.y + ", z" + this.z + ", w:" + this.w + ")";
            };
            Vector3D.X_AXIS = new Vector3D(1, 0, 0);
            Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
            Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
            return Vector3D;
        })();
        geom.Vector3D = Vector3D;
    })(away.geom || (away.geom = {}));
    var geom = away.geom;
})(away || (away = {}));
var away;
(function (away) {
    (function (errors) {
        var Error = (function () {
            function Error(message, id, _name) {
                if (typeof message === "undefined") { message = ''; }
                if (typeof id === "undefined") { id = 0; }
                if (typeof _name === "undefined") { _name = ''; }
                this._errorID = 0;
                this._messsage = '';
                this._name = '';
                this._messsage = message;
                this._name = name;
                this._errorID = id;
            }
            Object.defineProperty(Error.prototype, "message", {
                get: /**
                *
                * @returns {string}
                */
                function () {
                    return this._messsage;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    this._messsage = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Error.prototype, "name", {
                get: /**
                *
                * @returns {string}
                */
                function () {
                    return this._name;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    this._name = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Error.prototype, "errorID", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._errorID;
                },
                enumerable: true,
                configurable: true
            });
            return Error;
        })();
        errors.Error = Error;
    })(away.errors || (away.errors = {}));
    var errors = away.errors;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (errors) {
        /**
        * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
        * by a concrete subclass.
        */
        var ArgumentError = (function (_super) {
            __extends(ArgumentError, _super);
            /**
            * Create a new AbstractMethodError.
            * @param message An optional message to override the default error message.
            * @param id The id of the error.
            */
            function ArgumentError(message, id) {
                if (typeof message === "undefined") { message = null; }
                if (typeof id === "undefined") { id = 0; }
                _super.call(this, message || "ArgumentError", id);
            }
            return ArgumentError;
        })(errors.Error);
        errors.ArgumentError = ArgumentError;
    })(away.errors || (away.errors = {}));
    var errors = away.errors;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (geom) {
        var Matrix3D = (function () {
            /**
            * Creates a Matrix3D object.
            */
            function Matrix3D(v) {
                if (typeof v === "undefined") { v = null; }
                if (v != null && v.length == 16) {
                    this.rawData = v;
                } else {
                    this.rawData = [
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1
                    ];
                }
            }
            /**
            * Appends the matrix by multiplying another Matrix3D object by the current Matrix3D object.
            */
            Matrix3D.prototype.append = function (lhs) {
                // Initial Tests - OK
                var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];

                this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
                this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
                this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
                this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;

                this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
                this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
                this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
                this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;

                this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
                this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
                this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
                this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;

                this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
                this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
                this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
                this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
            };

            /**
            * Appends an incremental rotation to a Matrix3D object.
            */
            Matrix3D.prototype.appendRotation = function (degrees, axis) {
                // Initial Tests - OK
                var m = Matrix3D.getAxisRotation(axis.x, axis.y, axis.z, degrees);

                /*
                if (pivotPoint != null)
                {
                var p:Vector3D = pivotPoint;
                m.appendTranslation( p.x, p.y, p.z );
                }
                */
                this.append(m);
            };

            /**
            * Appends an incremental scale change along the x, y, and z axes to a Matrix3D object.
            */
            Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
                // Initial Tests - OK
                this.append(new Matrix3D([xScale, 0.0, 0.0, 0.0, 0.0, yScale, 0.0, 0.0, 0.0, 0.0, zScale, 0.0, 0.0, 0.0, 0.0, 1.0]));
            };

            /**
            * Appends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
            */
            Matrix3D.prototype.appendTranslation = function (x, y, z) {
                // Initial Tests - OK
                this.rawData[12] += x;
                this.rawData[13] += y;
                this.rawData[14] += z;
            };

            /**
            * Returns a new Matrix3D object that is an exact copy of the current Matrix3D object.
            */
            Matrix3D.prototype.clone = function () {
                // Initial Tests - OK
                return new Matrix3D(this.rawData.slice(0));
            };

            /**
            * Copies a Vector3D object into specific column of the calling Matrix3D object.
            */
            Matrix3D.prototype.copyColumnFrom = function (column, vector3D) {
                switch (column) {
                    case 0:
                        this.rawData[0] = vector3D.x;
                        this.rawData[1] = vector3D.y;
                        this.rawData[2] = vector3D.z;
                        this.rawData[3] = vector3D.w;
                        break;
                    case 1:
                        this.rawData[4] = vector3D.x;
                        this.rawData[5] = vector3D.y;
                        this.rawData[6] = vector3D.z;
                        this.rawData[7] = vector3D.w;
                        break;
                    case 2:
                        this.rawData[8] = vector3D.x;
                        this.rawData[9] = vector3D.y;
                        this.rawData[10] = vector3D.z;
                        this.rawData[11] = vector3D.w;
                        break;
                    case 3:
                        this.rawData[12] = vector3D.x;
                        this.rawData[13] = vector3D.y;
                        this.rawData[14] = vector3D.z;
                        this.rawData[15] = vector3D.w;
                        break;
                    default:
                        throw new away.errors.ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
                }
            };

            /**
            * Copies specific column of the calling Matrix3D object into the Vector3D object.
            */
            Matrix3D.prototype.copyColumnTo = function (column, vector3D) {
                switch (column) {
                    case 0:
                        vector3D.x = this.rawData[0];
                        vector3D.y = this.rawData[1];
                        vector3D.z = this.rawData[2];
                        vector3D.w = this.rawData[3];
                        break;
                    case 1:
                        vector3D.x = this.rawData[4];
                        vector3D.y = this.rawData[5];
                        vector3D.z = this.rawData[6];
                        vector3D.w = this.rawData[7];
                        break;
                    case 2:
                        vector3D.x = this.rawData[8];
                        vector3D.y = this.rawData[9];
                        vector3D.z = this.rawData[10];
                        vector3D.w = this.rawData[11];
                        break;
                    case 3:
                        vector3D.x = this.rawData[12];
                        vector3D.y = this.rawData[13];
                        vector3D.z = this.rawData[14];
                        vector3D.w = this.rawData[15];
                        break;
                    default:
                        throw new away.errors.ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
                }
            };

            /**
            * Copies all of the matrix data from the source Matrix3D object into the calling Matrix3D object.
            */
            Matrix3D.prototype.copyFrom = function (sourceMatrix3D) {
                // Initial Tests - OK
                var l = sourceMatrix3D.rawData.length;

                for (var c = 0; c < l; c++) {
                    this.rawData[c] = sourceMatrix3D.rawData[c];
                }
                //this.rawData = sourceMatrix3D.rawData.slice( 0 );
            };

            Matrix3D.prototype.copyRawDataFrom = function (vector, index, transpose) {
                if (typeof index === "undefined") { index = 0; }
                if (typeof transpose === "undefined") { transpose = false; }
                if (transpose) {
                    this.transpose();
                }

                var l = vector.length - index;
                for (var c = 0; c < l; c++) {
                    this.rawData[c] = vector[c + index];
                }

                if (transpose) {
                    this.transpose();
                }
            };

            Matrix3D.prototype.copyRawDataTo = function (vector, index, transpose) {
                if (typeof index === "undefined") { index = 0; }
                if (typeof transpose === "undefined") { transpose = false; }
                if (transpose) {
                    this.transpose();
                }

                var l = this.rawData.length;
                for (var c = 0; c < l; c++) {
                    vector[c + index] = this.rawData[c];
                }

                if (transpose) {
                    this.transpose();
                }
            };

            /**
            * Copies a Vector3D object into specific row of the calling Matrix3D object.
            */
            Matrix3D.prototype.copyRowFrom = function (row, vector3D) {
                switch (row) {
                    case 0:
                        this.rawData[0] = vector3D.x;
                        this.rawData[4] = vector3D.y;
                        this.rawData[8] = vector3D.z;
                        this.rawData[12] = vector3D.w;
                        break;
                    case 1:
                        this.rawData[1] = vector3D.x;
                        this.rawData[5] = vector3D.y;
                        this.rawData[9] = vector3D.z;
                        this.rawData[13] = vector3D.w;
                        break;
                    case 2:
                        this.rawData[2] = vector3D.x;
                        this.rawData[6] = vector3D.y;
                        this.rawData[10] = vector3D.z;
                        this.rawData[14] = vector3D.w;
                        break;
                    case 3:
                        this.rawData[3] = vector3D.x;
                        this.rawData[7] = vector3D.y;
                        this.rawData[11] = vector3D.z;
                        this.rawData[15] = vector3D.w;
                        break;
                    default:
                        throw new away.errors.ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
                }
            };

            /**
            * Copies specific row of the calling Matrix3D object into the Vector3D object.
            */
            Matrix3D.prototype.copyRowTo = function (row, vector3D) {
                switch (row) {
                    case 0:
                        vector3D.x = this.rawData[0];
                        vector3D.y = this.rawData[4];
                        vector3D.z = this.rawData[8];
                        vector3D.w = this.rawData[12];
                        break;
                    case 1:
                        vector3D.x = this.rawData[1];
                        vector3D.y = this.rawData[5];
                        vector3D.z = this.rawData[9];
                        vector3D.w = this.rawData[13];
                        break;
                    case 2:
                        vector3D.x = this.rawData[2];
                        vector3D.y = this.rawData[6];
                        vector3D.z = this.rawData[10];
                        vector3D.w = this.rawData[14];
                        break;
                    case 3:
                        vector3D.x = this.rawData[3];
                        vector3D.y = this.rawData[7];
                        vector3D.z = this.rawData[11];
                        vector3D.w = this.rawData[15];
                        break;
                    default:
                        throw new away.errors.ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
                }
            };

            /**
            * Copies this Matrix3D object into a destination Matrix3D object.
            */
            Matrix3D.prototype.copyToMatrix3D = function (dest) {
                // Initial Tests - OK
                dest.rawData = this.rawData.slice(0);
            };

            // TODO orientationStyle:string = "eulerAngles"
            /**
            * Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector3D objects.
            */
            Matrix3D.prototype.decompose = function () {
                // Initial Tests - Not OK
                var vec = [];
                var m = this.clone();
                var mr = m.rawData;

                var pos = new geom.Vector3D(mr[12], mr[13], mr[14]);
                mr[12] = 0;
                mr[13] = 0;
                mr[14] = 0;

                var scale = new geom.Vector3D();

                scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
                scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
                scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);

                if (mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0) {
                    scale.z = -scale.z;
                }

                mr[0] /= scale.x;
                mr[1] /= scale.x;
                mr[2] /= scale.x;
                mr[4] /= scale.y;
                mr[5] /= scale.y;
                mr[6] /= scale.y;
                mr[8] /= scale.z;
                mr[9] /= scale.z;
                mr[10] /= scale.z;

                var rot = new geom.Vector3D();
                rot.y = Math.asin(-mr[2]);

                if (mr[2] != 1 && mr[2] != -1) {
                    rot.x = Math.atan2(mr[6], mr[10]);
                    rot.z = Math.atan2(mr[1], mr[0]);
                } else {
                    rot.z = 0;
                    rot.x = Math.atan2(mr[4], mr[5]);
                }

                vec.push(pos);
                vec.push(rot);
                vec.push(scale);

                return vec;
            };

            /**
            * Uses the transformation matrix without its translation elements to transform a Vector3D object from one space
            * coordinate to another.
            */
            Matrix3D.prototype.deltaTransformVector = function (v) {
                var x = v.x, y = v.y, z = v.z;
                return new geom.Vector3D((x * this.rawData[0] + y * this.rawData[1] + z * this.rawData[2] + this.rawData[3]), (x * this.rawData[4] + y * this.rawData[5] + z * this.rawData[6] + this.rawData[7]), (x * this.rawData[8] + y * this.rawData[9] + z * this.rawData[10] + this.rawData[11]), 0);
            };

            /**
            * Converts the current matrix to an identity or unit matrix.
            */
            Matrix3D.prototype.identity = function () {
                this.rawData = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            };

            Matrix3D.interpolate = /**
            * [static] Interpolates the translation, rotation, and scale transformation of one matrix toward those of the target matrix.
            */
            function (thisMat, toMat, percent) {
                var m = new Matrix3D();
                for (var i = 0; i < 16; ++i) {
                    m.rawData[i] = thisMat.rawData[i] + (toMat.rawData[i] - thisMat.rawData[i]) * percent;
                }
                return m;
            };

            /**
            * Interpolates this matrix towards the translation, rotation, and scale transformations of the target matrix.
            */
            Matrix3D.prototype.interpolateTo = function (toMat, percent) {
                for (var i = 0; i < 16; ++i) {
                    this.rawData[i] = this.rawData[i] + (toMat.rawData[i] - this.rawData[i]) * percent;
                }
            };

            /**
            * Inverts the current matrix.
            */
            Matrix3D.prototype.invert = function () {
                // Initial Tests - OK
                var d = this.determinant;
                var invertable = Math.abs(d) > 0.00000000001;

                if (invertable) {
                    d = 1 / d;
                    var m11 = this.rawData[0];
                    var m21 = this.rawData[4];
                    var m31 = this.rawData[8];
                    var m41 = this.rawData[12];
                    var m12 = this.rawData[1];
                    var m22 = this.rawData[5];
                    var m32 = this.rawData[9];
                    var m42 = this.rawData[13];
                    var m13 = this.rawData[2];
                    var m23 = this.rawData[6];
                    var m33 = this.rawData[10];
                    var m43 = this.rawData[14];
                    var m14 = this.rawData[3];
                    var m24 = this.rawData[7];
                    var m34 = this.rawData[11];
                    var m44 = this.rawData[15];

                    this.rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
                    this.rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
                    this.rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
                    this.rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                    this.rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
                    this.rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
                    this.rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
                    this.rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
                    this.rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
                    this.rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
                    this.rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
                    this.rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
                    this.rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
                    this.rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
                    this.rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
                    this.rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
                }
                return invertable;
            };

            /* TODO implement pointAt
            public pointAt( pos:Vector3D, at:Vector3D = null, up:Vector3D = null )
            {
            }
            */
            /**
            * Prepends a matrix by multiplying the current Matrix3D object by another Matrix3D object.
            */
            Matrix3D.prototype.prepend = function (rhs) {
                // Initial Tests - OK
                var m111 = rhs.rawData[0], m121 = rhs.rawData[4], m131 = rhs.rawData[8], m141 = rhs.rawData[12], m112 = rhs.rawData[1], m122 = rhs.rawData[5], m132 = rhs.rawData[9], m142 = rhs.rawData[13], m113 = rhs.rawData[2], m123 = rhs.rawData[6], m133 = rhs.rawData[10], m143 = rhs.rawData[14], m114 = rhs.rawData[3], m124 = rhs.rawData[7], m134 = rhs.rawData[11], m144 = rhs.rawData[15], m211 = this.rawData[0], m221 = this.rawData[4], m231 = this.rawData[8], m241 = this.rawData[12], m212 = this.rawData[1], m222 = this.rawData[5], m232 = this.rawData[9], m242 = this.rawData[13], m213 = this.rawData[2], m223 = this.rawData[6], m233 = this.rawData[10], m243 = this.rawData[14], m214 = this.rawData[3], m224 = this.rawData[7], m234 = this.rawData[11], m244 = this.rawData[15];

                this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
                this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
                this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
                this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;

                this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
                this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
                this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
                this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;

                this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
                this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
                this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
                this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;

                this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
                this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
                this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
                this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
            };

            /**
            * Prepends an incremental rotation to a Matrix3D object.
            */
            Matrix3D.prototype.prependRotation = function (degrees, axis) {
                // Initial Tests - OK
                var m = Matrix3D.getAxisRotation(axis.x, axis.y, axis.z, degrees);

                /*
                if ( pivotPoint != null )
                {
                var p:Vector3D = pivotPoint;
                m.appendTranslation( p.x, p.y, p.z );
                }
                */
                this.prepend(m);
            };

            /**
            * Prepends an incremental scale change along the x, y, and z axes to a Matrix3D object.
            */
            Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
                // Initial Tests - OK
                this.prepend(new Matrix3D([xScale, 0, 0, 0, 0, yScale, 0, 0, 0, 0, zScale, 0, 0, 0, 0, 1]));
            };

            /**
            * Prepends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
            */
            Matrix3D.prototype.prependTranslation = function (x, y, z) {
                // Initial Tests - OK
                var m = new Matrix3D();
                m.position = new geom.Vector3D(x, y, z);
                this.prepend(m);
            };

            // TODO orientationStyle
            /**
            * Sets the transformation matrix's translation, rotation, and scale settings.
            */
            Matrix3D.prototype.recompose = function (components) {
                if (components.length < 3)
                    return false;

                //components[2].x == 0 || components[2].y == 0 || components[2].z == 0) return false;
                this.identity();
                this.appendScale(components[2].x, components[2].y, components[2].z);

                var angle;
                angle = -components[1].x;
                this.append(new Matrix3D([1, 0, 0, 0, 0, Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 0]));
                angle = -components[1].y;
                this.append(new Matrix3D([Math.cos(angle), 0, Math.sin(angle), 0, 0, 1, 0, 0, -Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 0]));
                angle = -components[1].z;
                this.append(new Matrix3D([Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]));

                this.position = components[0];
                this.rawData[15] = 1;

                return true;
            };

            Matrix3D.prototype.transformVector = function (v) {
                // Initial Tests - OK
                var x = v.x;
                var y = v.y;
                var z = v.z;
                return new away.geom.Vector3D((x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12]), (x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13]), (x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14]), (x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15]));
            };

            /**
            * Uses the transformation matrix to transform a Vector of Numbers from one coordinate space to another.
            */
            Matrix3D.prototype.transformVectors = function (vin, vout) {
                // Initial Tests - OK
                var i = 0;
                var x = 0, y = 0, z = 0;

                while (i + 3 <= vin.length) {
                    x = vin[i];
                    y = vin[i + 1];
                    z = vin[i + 2];
                    vout[i] = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
                    vout[i + 1] = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
                    vout[i + 2] = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
                    i += 3;
                }
            };

            /**
            * Converts the current Matrix3D object to a matrix where the rows and columns are swapped.
            */
            Matrix3D.prototype.transpose = function () {
                // Initial Tests - OK
                var oRawData = this.rawData.slice(0);

                this.rawData[1] = oRawData[4];
                this.rawData[2] = oRawData[8];
                this.rawData[3] = oRawData[12];
                this.rawData[4] = oRawData[1];
                this.rawData[6] = oRawData[9];
                this.rawData[7] = oRawData[13];
                this.rawData[8] = oRawData[2];
                this.rawData[9] = oRawData[6];
                this.rawData[11] = oRawData[14];
                this.rawData[12] = oRawData[3];
                this.rawData[13] = oRawData[7];
                this.rawData[14] = oRawData[11];
            };

            Matrix3D.getAxisRotation = function (x, y, z, degrees) {
                // internal class use by rotations which have been tested
                var m = new Matrix3D();

                var a1 = new geom.Vector3D(x, y, z);
                var rad = -degrees * (Math.PI / 180);
                var c = Math.cos(rad);
                var s = Math.sin(rad);
                var t = 1.0 - c;

                m.rawData[0] = c + a1.x * a1.x * t;
                m.rawData[5] = c + a1.y * a1.y * t;
                m.rawData[10] = c + a1.z * a1.z * t;

                var tmp1 = a1.x * a1.y * t;
                var tmp2 = a1.z * s;
                m.rawData[4] = tmp1 + tmp2;
                m.rawData[1] = tmp1 - tmp2;
                tmp1 = a1.x * a1.z * t;
                tmp2 = a1.y * s;
                m.rawData[8] = tmp1 - tmp2;
                m.rawData[2] = tmp1 + tmp2;
                tmp1 = a1.y * a1.z * t;
                tmp2 = a1.x * s;
                m.rawData[9] = tmp1 + tmp2;
                m.rawData[6] = tmp1 - tmp2;

                return m;
            };

            Object.defineProperty(Matrix3D.prototype, "determinant", {
                get: /**
                * [read-only] A Number that determines whether a matrix is invertible.
                */
                function () {
                    // Initial Tests - OK
                    return ((this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]));
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Matrix3D.prototype, "position", {
                get: /**
                * A Vector3D object that holds the position, the 3D coordinate (x,y,z) of a display object within the
                * transformation's frame of reference.
                */
                function () {
                    // Initial Tests - OK
                    return new geom.Vector3D(this.rawData[12], this.rawData[13], this.rawData[14]);
                },
                set: function (value) {
                    // Initial Tests - OK
                    this.rawData[12] = value.x;
                    this.rawData[13] = value.y;
                    this.rawData[14] = value.z;
                },
                enumerable: true,
                configurable: true
            });

            return Matrix3D;
        })();
        geom.Matrix3D = Matrix3D;
    })(away.geom || (away.geom = {}));
    var geom = away.geom;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (math) {
        /**
        * MathConsts provides some commonly used mathematical constants
        */
        var MathConsts = (function () {
            function MathConsts() {
            }
            MathConsts.RADIANS_TO_DEGREES = 180 / Math.PI;

            MathConsts.DEGREES_TO_RADIANS = Math.PI / 180;
            return MathConsts;
        })();
        math.MathConsts = MathConsts;
    })(away.math || (away.math = {}));
    var math = away.math;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (math) {
        //import flash.geom.Matrix3D;
        //import flash.geom.Orientation3D;
        //import flash.geom.Vector3D;
        /**
        * A Quaternion object which can be used to represent rotations.
        */
        var Quaternion = (function () {
            /**
            * Creates a new Quaternion object.
            * @param x The x value of the quaternion.
            * @param y The y value of the quaternion.
            * @param z The z value of the quaternion.
            * @param w The w value of the quaternion.
            */
            function Quaternion(x, y, z, w) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof z === "undefined") { z = 0; }
                if (typeof w === "undefined") { w = 1; }
                /**
                * The x value of the quaternion.
                */
                this.x = 0;
                /**
                * The y value of the quaternion.
                */
                this.y = 0;
                /**
                * The z value of the quaternion.
                */
                this.z = 0;
                /**
                * The w value of the quaternion.
                */
                this.w = 1;
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            Object.defineProperty(Quaternion.prototype, "magnitude", {
                get: /**
                * Returns the magnitude of the quaternion object.
                */
                function () {
                    return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Fills the quaternion object with the result from a multiplication of two quaternion objects.
            *
            * @param    qa    The first quaternion in the multiplication.
            * @param    qb    The second quaternion in the multiplication.
            */
            Quaternion.prototype.multiply = function (qa, qb) {
                var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
                var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;

                this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
                this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
                this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
                this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            };

            Quaternion.prototype.multiplyVector = function (vector, target) {
                if (typeof target === "undefined") { target = null; }
                if (target === null) {
                    target = new Quaternion();
                }

                var x2 = vector.x;
                var y2 = vector.y;
                var z2 = vector.z;

                target.w = -this.x * x2 - this.y * y2 - this.z * z2;
                target.x = this.w * x2 + this.y * z2 - this.z * y2;
                target.y = this.w * y2 - this.x * z2 + this.z * x2;
                target.z = this.w * z2 + this.x * y2 - this.y * x2;

                return target;
            };

            /**
            * Fills the quaternion object with values representing the given rotation around a vector.
            *
            * @param    axis    The axis around which to rotate
            * @param    angle    The angle in radians of the rotation.
            */
            Quaternion.prototype.fromAxisAngle = function (axis, angle) {
                var sin_a = Math.sin(angle / 2);
                var cos_a = Math.cos(angle / 2);

                this.x = axis.x * sin_a;
                this.y = axis.y * sin_a;
                this.z = axis.z * sin_a;
                this.w = cos_a;

                this.normalize();
            };

            /**
            * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
            * @param qa The first quaternion to interpolate.
            * @param qb The second quaternion to interpolate.
            * @param t The interpolation weight, a value between 0 and 1.
            */
            Quaternion.prototype.slerp = function (qa, qb, t) {
                var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
                var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
                var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;

                if (dot < 0) {
                    dot = -dot;
                    w2 = -w2;
                    x2 = -x2;
                    y2 = -y2;
                    z2 = -z2;
                }

                if (dot < 0.95) {
                    // interpolate angle linearly
                    var angle = Math.acos(dot);
                    var s = 1 / Math.sin(angle);
                    var s1 = Math.sin(angle * (1 - t)) * s;
                    var s2 = Math.sin(angle * t) * s;
                    this.w = w1 * s1 + w2 * s2;
                    this.x = x1 * s1 + x2 * s2;
                    this.y = y1 * s1 + y2 * s2;
                    this.z = z1 * s1 + z2 * s2;
                } else {
                    // nearly identical angle, interpolate linearly
                    this.w = w1 + t * (w2 - w1);
                    this.x = x1 + t * (x2 - x1);
                    this.y = y1 + t * (y2 - y1);
                    this.z = z1 + t * (z2 - z1);
                    var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                    this.w *= len;
                    this.x *= len;
                    this.y *= len;
                    this.z *= len;
                }
            };

            /**
            * Linearly interpolates between two quaternions.
            * @param qa The first quaternion to interpolate.
            * @param qb The second quaternion to interpolate.
            * @param t The interpolation weight, a value between 0 and 1.
            */
            Quaternion.prototype.lerp = function (qa, qb, t) {
                var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
                var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
                var len;

                if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                    w2 = -w2;
                    x2 = -x2;
                    y2 = -y2;
                    z2 = -z2;
                }

                this.w = w1 + t * (w2 - w1);
                this.x = x1 + t * (x2 - x1);
                this.y = y1 + t * (y2 - y1);
                this.z = z1 + t * (z2 - z1);

                len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                this.w *= len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
            };

            /**
            * Fills the quaternion object with values representing the given euler rotation.
            *
            * @param    ax        The angle in radians of the rotation around the ax axis.
            * @param    ay        The angle in radians of the rotation around the ay axis.
            * @param    az        The angle in radians of the rotation around the az axis.
            */
            Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
                var halfX = ax * .5, halfY = ay * .5, halfZ = az * .5;
                var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
                var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
                var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);

                this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
                this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
                this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
                this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            };

            /**
            * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
            * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
            * @return The Vector3D containing the Euler angles.
            */
            Quaternion.prototype.toEulerAngles = function (target) {
                if (typeof target === "undefined") { target = null; }
                if (target === null) {
                    target = new away.geom.Vector3D();
                }

                target.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
                target.y = Math.asin(2 * (this.w * this.y - this.z * this.x));
                target.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));

                return target;
            };

            /**
            * Normalises the quaternion object.
            */
            Quaternion.prototype.normalize = function (val) {
                if (typeof val === "undefined") { val = 1; }
                var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

                this.x *= mag;
                this.y *= mag;
                this.z *= mag;
                this.w *= mag;
            };

            /**
            * Used to trace the values of a quaternion.
            *
            * @return A string representation of the quaternion object.
            */
            Quaternion.prototype.toString = function () {
                return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
            };

            /**
            * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
            * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
            * @return A Matrix3D object representing an equivalent rotation.
            */
            Quaternion.prototype.toMatrix3D = function (target) {
                if (typeof target === "undefined") { target = null; }
                var rawData = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;
                var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
                var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
                var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;

                rawData[0] = xx - yy - zz + ww;
                rawData[4] = xy2 - zw2;
                rawData[8] = xz2 + yw2;
                rawData[12] = 0;
                rawData[1] = xy2 + zw2;
                rawData[5] = -xx + yy - zz + ww;
                rawData[9] = yz2 - xw2;
                rawData[13] = 0;
                rawData[2] = xz2 - yw2;
                rawData[6] = yz2 + xw2;
                rawData[10] = -xx - yy + zz + ww;
                rawData[14] = 0;
                rawData[3] = 0.0;
                rawData[7] = 0.0;
                rawData[11] = 0;
                rawData[15] = 1;

                if (!target)
                    return new away.geom.Matrix3D(rawData);

                target.copyRawDataFrom(rawData);

                return target;
            };

            /**
            * Extracts a quaternion rotation matrix out of a given Matrix3D object.
            * @param matrix The Matrix3D out of which the rotation will be extracted.
            */
            Quaternion.prototype.fromMatrix = function (matrix) {
                // todo: this isn't right, doesn't take into account transforms
                //var v:away.geom.Vector3D = matrix.decompose(Orientation3D.QUATERNION)[1];
                var v = matrix.decompose()[1];
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                this.w = v.w;
            };

            /**
            * Converts the quaternion to a Vector.&lt;Number&gt; matrix representation of a rotation equivalent to this quaternion.
            * @param target The Vector.&lt;Number&gt; to contain the raw matrix data.
            * @param exclude4thRow If true, the last row will be omitted, and a 4x3 matrix will be generated instead of a 4x4.
            */
            Quaternion.prototype.toRawData = function (target, exclude4thRow) {
                if (typeof exclude4thRow === "undefined") { exclude4thRow = false; }
                var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
                var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
                var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;

                target[0] = xx - yy - zz + ww;
                target[1] = xy2 - zw2;
                target[2] = xz2 + yw2;
                target[4] = xy2 + zw2;
                target[5] = -xx + yy - zz + ww;
                target[6] = yz2 - xw2;
                target[8] = xz2 - yw2;
                target[9] = yz2 + xw2;
                target[10] = -xx - yy + zz + ww;
                target[3] = target[7] = target[11] = 0;

                if (!exclude4thRow) {
                    target[12] = target[13] = target[14] = 0;
                    target[15] = 1;
                }
            };

            /**
            * Clones the quaternion.
            * @return An exact duplicate of the current Quaternion.
            */
            Quaternion.prototype.clone = function () {
                return new Quaternion(this.x, this.y, this.z, this.w);
            };

            /**
            * Rotates a point.
            * @param vector The Vector3D object to be rotated.
            * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
            * @return A Vector3D object containing the rotated point.
            */
            Quaternion.prototype.rotatePoint = function (vector, target) {
                if (typeof target === "undefined") { target = null; }
                var x1, y1, z1, w1;
                var x2 = vector.x, y2 = vector.y, z2 = vector.z;

                if (target === null) {
                    target = new away.geom.Vector3D();
                }

                // p*q'
                w1 = -this.x * x2 - this.y * y2 - this.z * z2;
                x1 = this.w * x2 + this.y * z2 - this.z * y2;
                y1 = this.w * y2 - this.x * z2 + this.z * x2;
                z1 = this.w * z2 + this.x * y2 - this.y * x2;

                target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
                target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
                target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;

                return target;
            };

            /**
            * Copies the data from a quaternion into this instance.
            * @param q The quaternion to copy from.
            */
            Quaternion.prototype.copyFrom = function (q) {
                this.x = q.x;
                this.y = q.y;
                this.z = q.z;
                this.w = q.w;
            };
            return Quaternion;
        })();
        math.Quaternion = Quaternion;
    })(away.math || (away.math = {}));
    var math = away.math;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (math) {
        var PlaneClassification = (function () {
            function PlaneClassification() {
            }
            PlaneClassification.BACK = 0;
            PlaneClassification.FRONT = 1;

            PlaneClassification.IN = 0;
            PlaneClassification.OUT = 1;
            PlaneClassification.INTERSECT = 2;
            return PlaneClassification;
        })();
        math.PlaneClassification = PlaneClassification;
    })(away.math || (away.math = {}));
    var math = away.math;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (math) {
        var Plane3D = (function () {
            /**
            * Create a Plane3D with ABCD coefficients
            */
            function Plane3D(a, b, c, d) {
                if (typeof a === "undefined") { a = 0; }
                if (typeof b === "undefined") { b = 0; }
                if (typeof c === "undefined") { c = 0; }
                if (typeof d === "undefined") { d = 0; }
                this.a = a;
                this.b = b;
                this.c = c;
                this.d = d;

                if (a == 0 && b == 0) {
                    this._iAlignment = Plane3D.ALIGN_XY_AXIS;
                } else if (b == 0 && c == 0) {
                    this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
                } else if (a == 0 && c == 0) {
                    this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
                } else {
                    this._iAlignment = Plane3D.ALIGN_ANY;
                }
            }
            /**
            * Fills this Plane3D with the coefficients from 3 points in 3d space.
            * @param p0 Vector3D
            * @param p1 Vector3D
            * @param p2 Vector3D
            */
            Plane3D.prototype.fromPoints = function (p0, p1, p2) {
                var d1x = p1.x - p0.x;
                var d1y = p1.y - p0.y;
                var d1z = p1.z - p0.z;

                var d2x = p2.x - p0.x;
                var d2y = p2.y - p0.y;
                var d2z = p2.z - p0.z;

                this.a = d1y * d2z - d1z * d2y;
                this.b = d1z * d2x - d1x * d2z;
                this.c = d1x * d2y - d1y * d2x;
                this.d = this.a * p0.x + this.b * p0.y + this.c * p0.z;

                if (this.a == 0 && this.b == 0) {
                    this._iAlignment = Plane3D.ALIGN_XY_AXIS;
                } else if (this.b == 0 && this.c == 0) {
                    this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
                } else if (this.a == 0 && this.c == 0) {
                    this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
                } else {
                    this._iAlignment = Plane3D.ALIGN_ANY;
                }
            };

            /**
            * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
            * @param normal Vector3D
            * @param point  Vector3D
            */
            Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
                this.a = normal.x;
                this.b = normal.y;
                this.c = normal.z;
                this.d = this.a * point.x + this.b * point.y + this.c * point.z;
                if (this.a == 0 && this.b == 0) {
                    this._iAlignment = Plane3D.ALIGN_XY_AXIS;
                } else if (this.b == 0 && this.c == 0) {
                    this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
                } else if (this.a == 0 && this.c == 0) {
                    this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
                } else {
                    this._iAlignment = Plane3D.ALIGN_ANY;
                }
            };

            /**
            * Normalize this Plane3D
            * @return Plane3D This Plane3D.
            */
            Plane3D.prototype.normalize = function () {
                var len = 1 / Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
                this.a *= len;
                this.b *= len;
                this.c *= len;
                this.d *= len;
                return this;
            };

            /**
            * Returns the signed distance between this Plane3D and the point p.
            * @param p Vector3D
            * @returns Number
            */
            Plane3D.prototype.distance = function (p) {
                if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS) {
                    return this.a * p.x - this.d;
                } else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS) {
                    return this.b * p.y - this.d;
                } else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS) {
                    return this.c * p.z - this.d;
                } else {
                    return this.a * p.x + this.b * p.y + this.c * p.z - this.d;
                }
            };

            /**
            * Classify a point against this Plane3D. (in front, back or intersecting)
            * @param p Vector3D
            * @return int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
            */
            Plane3D.prototype.classifyPoint = function (p, epsilon) {
                if (typeof epsilon === "undefined") { epsilon = 0.01; }
                if (this.d != this.d)
                    return away.math.PlaneClassification.FRONT;

                var len;
                if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS)
                    len = this.a * p.x - this.d;
else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS)
                    len = this.b * p.y - this.d;
else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS)
                    len = this.c * p.z - this.d;
else
                    len = this.a * p.x + this.b * p.y + this.c * p.z - this.d;

                if (len < -epsilon)
                    return away.math.PlaneClassification.BACK;
else if (len > epsilon)
                    return away.math.PlaneClassification.FRONT;
else
                    return away.math.PlaneClassification.INTERSECT;
            };

            Plane3D.prototype.toString = function () {
                return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
            };
            Plane3D.ALIGN_ANY = 0;
            Plane3D.ALIGN_XY_AXIS = 1;
            Plane3D.ALIGN_YZ_AXIS = 2;
            Plane3D.ALIGN_XZ_AXIS = 3;
            return Plane3D;
        })();
        math.Plane3D = Plane3D;
    })(away.math || (away.math = {}));
    var math = away.math;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (math) {
        //import flash.geom.*;
        /**
        * away3d.math.Matrix3DUtils provides additional Matrix3D math functions.
        */
        var Matrix3DUtils = (function () {
            function Matrix3DUtils() {
            }
            Matrix3DUtils.quaternion2matrix = /**
            * Fills the 3d matrix object with values representing the transformation made by the given quaternion.
            *
            * @param    quarternion    The quarterion object to convert.
            */
            function (quarternion, m) {
                if (typeof m === "undefined") { m = null; }
                var x = quarternion.x;
                var y = quarternion.y;
                var z = quarternion.z;
                var w = quarternion.w;

                var xx = x * x;
                var xy = x * y;
                var xz = x * z;
                var xw = x * w;

                var yy = y * y;
                var yz = y * z;
                var yw = y * w;

                var zz = z * z;
                var zw = z * w;

                var raw = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;
                raw[0] = 1 - 2 * (yy + zz);
                raw[1] = 2 * (xy + zw);
                raw[2] = 2 * (xz - yw);
                raw[4] = 2 * (xy - zw);
                raw[5] = 1 - 2 * (xx + zz);
                raw[6] = 2 * (yz + xw);
                raw[8] = 2 * (xz + yw);
                raw[9] = 2 * (yz - xw);
                raw[10] = 1 - 2 * (xx + yy);
                raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
                raw[15] = 1;

                if (m) {
                    m.copyRawDataFrom(raw);
                    return m;
                } else
                    return new away.geom.Matrix3D(raw);
            };

            Matrix3DUtils.getForward = /**
            * Returns a normalised <code>Vector3D</code> object representing the forward vector of the given matrix.
            * @param    m        The Matrix3D object to use to get the forward vector
            * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
            * @return            The forward vector
            */
            function (m, v) {
                if (typeof v === "undefined") { v = null; }
                if (v === null) {
                    v = new away.geom.Vector3D(0.0, 0.0, 0.0);
                }

                m.copyColumnTo(2, v);
                v.normalize();

                return v;
            };

            Matrix3DUtils.getUp = /**
            * Returns a normalised <code>Vector3D</code> object representing the up vector of the given matrix.
            * @param    m        The Matrix3D object to use to get the up vector
            * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
            * @return            The up vector
            */
            function (m, v) {
                if (typeof v === "undefined") { v = null; }
                if (v === null) {
                    v = new away.geom.Vector3D(0.0, 0.0, 0.0);
                }

                m.copyColumnTo(1, v);
                v.normalize();

                return v;
            };

            Matrix3DUtils.getRight = /**
            * Returns a normalised <code>Vector3D</code> object representing the right vector of the given matrix.
            * @param    m        The Matrix3D object to use to get the right vector
            * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
            * @return            The right vector
            */
            function (m, v) {
                if (typeof v === "undefined") { v = null; }
                if (v === null) {
                    v = new away.geom.Vector3D(0.0, 0.0, 0.0);
                }

                m.copyColumnTo(0, v);
                v.normalize();

                return v;
            };

            Matrix3DUtils.compare = /**
            * Returns a boolean value representing whether there is any significant difference between the two given 3d matrices.
            */
            function (m1, m2) {
                var r1 = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;
                var r2 = m2.rawData;
                m1.copyRawDataTo(r1);

                for (var i = 0; i < 16; ++i) {
                    if (r1[i] != r2[i])
                        return false;
                }

                return true;
            };

            Matrix3DUtils.lookAt = function (matrix, pos, dir, up) {
                var dirN;
                var upN;
                var lftN;
                var raw = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;

                lftN = dir.crossProduct(up);
                lftN.normalize();

                upN = lftN.crossProduct(dir);
                upN.normalize();
                dirN = dir.clone();
                dirN.normalize();

                raw[0] = lftN.x;
                raw[1] = upN.x;
                raw[2] = -dirN.x;
                raw[3] = 0.0;

                raw[4] = lftN.y;
                raw[5] = upN.y;
                raw[6] = -dirN.y;
                raw[7] = 0.0;

                raw[8] = lftN.z;
                raw[9] = upN.z;
                raw[10] = -dirN.z;
                raw[11] = 0.0;

                raw[12] = -lftN.dotProduct(pos);
                raw[13] = -upN.dotProduct(pos);
                raw[14] = dirN.dotProduct(pos);
                raw[15] = 1.0;

                matrix.copyRawDataFrom(raw);
            };

            Matrix3DUtils.reflection = function (plane, target) {
                if (typeof target === "undefined") { target = null; }
                if (target === null) {
                    target = new away.geom.Matrix3D();
                }

                var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
                var rawData = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;
                var ab2 = -2 * a * b;
                var ac2 = -2 * a * c;
                var bc2 = -2 * b * c;

                // reflection matrix
                rawData[0] = 1 - 2 * a * a;
                rawData[4] = ab2;
                rawData[8] = ac2;
                rawData[12] = -2 * a * d;
                rawData[1] = ab2;
                rawData[5] = 1 - 2 * b * b;
                rawData[9] = bc2;
                rawData[13] = -2 * b * d;
                rawData[2] = ac2;
                rawData[6] = bc2;
                rawData[10] = 1 - 2 * c * c;
                rawData[14] = -2 * c * d;
                rawData[3] = 0;
                rawData[7] = 0;
                rawData[11] = 0;
                rawData[15] = 1;
                target.copyRawDataFrom(rawData);

                return target;
            };
            Matrix3DUtils.RAW_DATA_CONTAINER = new Array(16);

            Matrix3DUtils.CALCULATION_MATRIX = new away.geom.Matrix3D();
            return Matrix3DUtils;
        })();
        math.Matrix3DUtils = Matrix3DUtils;
    })(away.math || (away.math = {}));
    var math = away.math;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (math) {
        var PoissonLookup = (function () {
            function PoissonLookup() {
            }
            PoissonLookup.initDistributions = function () {
                // precalculated for best control
                this._distributions = new Array();
                this._distributions[0] = new Array(0.3082841, 0.4320919);
                this._distributions[1] = new Array(0.3082841, 0.4320919, -0.2274942, -0.6640266);
                this._distributions[2] = new Array(0.8742689, 0.0009265686, -0.6864116, -0.5536607, -0.2325206, 0.7678371);
                this._distributions[3] = new Array(0.3913446, -0.7084417, -0.7511101, -0.5935929, -0.2323436, 0.5320091, 0.8435315, 0.5035911);
                this._distributions[4] = new Array(0.2122471, -0.5771395, -0.8543506, -0.1763534, 0.5189021, 0.8323698, -0.3616908, 0.5865368, 0.9523004, -0.04948437);
                this._distributions[5] = new Array(0.5791035, 0.3496495, 0.2959551, -0.6006749, -0.2419119, -0.06879545, -0.7403072, 0.6110353, -0.04555973, 0.8059174, -0.5275017, -0.737129);
                this._distributions[6] = new Array(0.06941478, 0.8519508, -0.7441907, 0.2426432, 0.6439992, -0.2405252, -0.1007523, -0.2327587, -0.6427067, -0.7248485, 0.8050759, 0.5492936, 0.3573822, -0.8824506);
                this._distributions[7] = new Array(0.8509863, 0.4452587, -0.09507271, 0.2073005, 0.1706571, -0.6434793, 0.8029777, -0.2718274, -0.4401725, 0.8196304, 0.2715359, 0.8598521, -0.8121575, -0.006447683, -0.6486837, -0.7237598);
                this._distributions[8] = new Array(0.6951686, -0.2680728, -0.04933243, 0.3710589, 0.6592212, 0.3661054, -0.01579228, -0.6909603, -0.3275101, -0.1756866, 0.3811549, 0.9218544, -0.216032, 0.9755028, -0.7065172, 0.3355389, -0.6579109, -0.6798355);
                this._distributions[9] = new Array(0.6181276, -0.09790418, -0.2537868, -0.5570995, -0.1964931, 0.3459414, 0.3474613, -0.8885581, 0.5135743, 0.5753114, -0.9549091, 0.1480672, -0.8711916, -0.4293123, -0.6928071, 0.6190156, -0.13369, 0.8892705, 0.0548224, -0.1246777);
                this._distributions[10] = new Array(0.4853027, -0.5080479, -0.1331675, -0.506597, 0.139575, 0.01316885, 0.803486, -0.07568797, 0.5240274, 0.4883182, -0.4334005, 0.1207938, -0.7794577, -0.3985141, 0.1576432, -0.9861221, -0.3712867, 0.6959021, 0.1517378, 0.9847429, -0.9762396, 0.1661073);
                this._distributions[11] = new Array(-0.2790166, -0.01252619, 0.3389016, 0.3921154, 0.2408341, -0.313211, -0.8151779, -0.3898362, -0.6347761, 0.3486495, 0.09471484, -0.7722448, -0.1385674, 0.6364574, 0.2456331, 0.9295807, -0.3864306, -0.8247881, 0.6111673, -0.7164014, 0.8287669, 0.05466961, 0.837706, 0.5415626);
                this._distributions[12] = new Array(0.056417, 0.3185693, -0.8245888, 0.1882799, 0.8575996, 0.1136829, 0.1070375, 0.875332, 0.4076743, -0.06000621, -0.4311306, 0.7239349, 0.2677574, -0.538472, -0.08486642, -0.2083647, -0.888989, -0.3906443, -0.4768958, -0.6664082, 0.09334993, -0.9861541, 0.808736, -0.455949, 0.5889823, 0.7660807);
                this._distributions[13] = new Array(-0.2681346, -0.3955857, -0.1315102, -0.8852947, -0.5143692, 0.09551838, 0.4344836, -0.546945, -0.8620899, -0.3813288, 0.1650431, 0.02034803, -0.1543657, 0.3842218, -0.828457, 0.5376903, -0.6145, -0.7818927, -0.2639062, 0.8784655, 0.1912684, 0.9720125, 0.3135219, 0.5224229, 0.7850655, 0.4592297, 0.7465045, -0.1368916);
                this._distributions[14] = new Array(0.4241029, 0.695281, 0.150511, -0.02304107, -0.2482675, 0.9120338, 0.8057325, 0.2622084, -0.2445909, 0.2765962, 0.8588713, -0.1772072, 0.3117845, -0.4385471, -0.3923851, -0.3298936, -0.1751254, -0.7405846, 0.6926506, -0.684163, -0.9304563, -0.3254691, -0.8533293, 0.1523024, 0.2510415, -0.917345, -0.6239773, -0.7105472, -0.6104624, 0.6041355);
                this._distributions[15] = new Array(0.5844554, 0.06651045, 0.1343258, 0.6756578, 0.3799674, -0.6301104, 0.5590436, 0.7940555, 0.09574714, 0.02262517, 0.8697868, 0.393301, 0.003945862, -0.421735, 0.9043913, -0.2432393, -0.4844007, 0.7190998, -0.3201078, 0.2972371, -0.3852352, -0.6341155, -0.5413069, -0.09223081, -0.8468984, -0.5126905, 0.004156174, -0.8633173, -0.9681889, -0.03305046, -0.846509, 0.4414353);
                this._distributions[16] = new Array(0.4506488, 0.657668, 0.4621297, 0.07441051, -0.2782125, 0.6201044, 0.9750003, 0.09110117, 0.1019436, 0.2986514, 0.03457398, 0.9631706, 0.542098, -0.5505635, 0.8675668, 0.4938077, -0.5414361, 0.2655292, -0.7941836, 0.6003053, -0.09847672, -0.1001604, -0.9316511, -0.08572888, 0.07286467, -0.611899, -0.5232627, -0.4082253, -0.5481608, -0.827938, -0.1551939, -0.9621193, 0.9220031, -0.3315949);
                this._distributions[17] = new Array(0.197908, -0.4697656, -0.4474689, -0.3428435, 0.8529873, -0.2228634, 0.6022478, -0.5469642, 0.2545276, -0.931133, -0.1507547, -0.7855865, -0.07606658, 0.1011628, 0.3046715, 0.2785755, 0.4698432, -0.1064076, 0.6831254, 0.4152522, 0.1374381, 0.8363233, -0.2166121, 0.6682042, 0.5511393, 0.7996449, -0.4278994, 0.28836, -0.8875198, 0.2181732, -0.8772842, -0.2818254, -0.7000262, 0.5762185, -0.6062385, -0.7439126);
                this._distributions[18] = new Array(0.6645703, -0.05678739, 0.5720971, 0.4533803, -0.07660709, 0.08802763, 0.5163431, -0.4426552, 0.1163455, -0.3404382, -0.4004807, -0.5046007, 0.2932099, -0.8201418, -0.5322125, 0.03834766, -0.1490209, -0.8817304, -0.8000439, -0.3509448, 0.5260983, 0.8421043, 0.1197811, 0.6963812, 0.9498612, 0.3122156, -0.9285746, 0.02120355, -0.6670724, 0.7217396, 0.9155889, -0.3510147, -0.271941, 0.4727852, 0.318879, 0.1634057, -0.2686755, 0.9253026);
                this._distributions[19] = new Array(0.5064292, 0.422527, 0.8935515, -0.06610427, 0.1199719, 0.175568, 0.403388, -0.2003276, 0.1657927, 0.8154403, 0.9301245, 0.2929218, -0.1644068, 0.6201534, 0.7113559, -0.6589743, -0.3364046, -0.1799502, 0.02109996, -0.392765, -0.382213, 0.3219992, -0.9201946, 0.1207967, -0.726185, 0.4291916, -0.7443482, -0.2480059, -0.5147594, 0.7418784, 0.1935272, -0.7406143, -0.3643523, -0.5559214, -0.7147766, -0.6326278, -0.2524151, -0.9096627, 0.5161405, 0.7908453);
                this._distributions[20] = new Array(0.7921003, -0.3032096, 0.5992879, -0.009052323, 0.2538549, -0.1872749, 0.7053444, 0.3677175, 0.5417761, -0.8170255, 0.9749611, 0.1210478, 0.1969143, -0.6117041, -0.1824499, -0.4634196, -0.1181338, -0.8668742, -0.3050112, -0.1352596, -0.4409327, -0.7082354, -0.03225285, 0.1171548, 0.3113096, 0.3250439, -0.8166144, -0.463995, -0.01014475, 0.4715334, -0.6868284, 0.05091889, -0.4011163, 0.2717285, -0.06756835, 0.8307694, -0.7938535, 0.4352129, -0.4663842, 0.7165329, 0.559729, 0.8093995);
                this._distributions[21] = new Array(0.07832243, 0.426151, -0.3856795, 0.5799953, 0.01970797, 0.06706189, 0.4822682, 0.3014512, -0.1532982, 0.87485, -0.4959527, 0.07888043, 0.260601, -0.2304784, 0.4996209, 0.7167382, 0.585986, -0.04265174, -0.7679967, 0.5509416, -0.9041753, 0.1802134, -0.8407655, -0.4442826, -0.2058258, -0.2636995, -0.4984115, -0.5928579, 0.2926032, -0.7886473, -0.06933882, -0.621177, 0.578115, -0.4813387, 0.8981777, -0.3291056, 0.1942733, 0.9255584, 0.8084362, 0.5066984, 0.9920095, 0.03103104, -0.2403206, -0.9389018);
                this._distributions[22] = new Array(-0.5691095, 0.1014316, -0.7788262, 0.384012, -0.8253665, -0.1645582, -0.1830993, 0.002997211, -0.2555013, -0.4177977, -0.6640869, -0.4794711, -0.2351242, 0.5850121, 0.02436554, 0.2825883, 0.006061143, -0.8200245, 0.1618791, -0.3063331, -0.3765897, -0.7249815, 0.6092919, -0.6769328, -0.5956934, 0.6957655, 0.5383642, 0.4522677, -0.1489165, 0.9125596, 0.4167473, 0.1335986, 0.1898309, 0.5874342, 0.2288171, 0.9624356, 0.7540846, -0.07672304, 0.8986252, 0.2788797, 0.3555991, -0.9262139, 0.8454325, -0.4027667, 0.4945236, -0.2935512);
                this._distributions[23] = new Array(-0.4481403, -0.3758374, -0.8877251, 0.08739938, 0.05015831, -0.1339983, -0.4070427, -0.8534173, 0.1019274, -0.5503222, -0.445998, 0.1997541, -0.8686263, -0.2788867, -0.7695944, -0.6033704, -0.05515742, -0.885711, -0.7714347, 0.5790485, 0.3466263, -0.8799297, 0.4487582, -0.5321087, -0.2461368, 0.6053771, -0.05568117, 0.2457351, -0.4668669, 0.8523816, 0.8103387, -0.4255538, 0.4054182, -0.175663, -0.2802011, -0.08920153, 0.2665959, 0.382935, 0.555679, 0.1621837, 0.105246, 0.8420411, 0.6921161, 0.6902903, 0.880946, 0.2483067, 0.9699264, -0.1021767);
                this._distributions[24] = new Array(-0.1703323, -0.3119385, 0.2916039, -0.2988263, -0.008472982, -0.9277695, -0.7730271, -0.3277904, 0.3440474, -0.6815342, -0.2910278, 0.03461745, -0.6764899, -0.657078, -0.3505501, -0.7311988, -0.03478927, 0.3258755, -0.6048835, 0.159423, 0.2035525, 0.02212214, 0.5116573, 0.2226856, 0.6664805, -0.2500189, 0.7147882, -0.6609634, 0.03030632, -0.5763278, -0.2516585, 0.6116219, -0.9434413, -0.0116792, 0.9061816, 0.2491155, 0.182867, 0.6076167, 0.286593, 0.9485695, -0.5992439, 0.6970096, -0.2082874, 0.9416641, 0.9880044, -0.1541709, -0.9122881, 0.331555, 0.7324886, 0.6725098);
                this._distributions[25] = new Array(0.3869598, -0.04974834, 0.7168844, -0.0693711, -0.07166742, 0.1725325, 0.4599592, 0.3232779, 0.5872094, -0.4198674, 0.2442266, -0.625667, 0.1254557, 0.4500048, -0.2290154, -0.1803567, 0.890583, 0.3373493, 0.1256081, 0.7853789, -0.2676466, 0.5305805, -0.7063224, 0.252168, -0.3989835, 0.1189921, 0.09617215, -0.2451447, 0.6302541, 0.6085876, 0.9380925, -0.3234899, 0.5086241, -0.8573482, 0.03576187, -0.9876697, -0.0876712, -0.6365195, -0.5276513, 0.823456, -0.6935764, -0.2240411, -0.5212318, -0.5383121, -0.2116208, 0.9639363, -0.9840096, 0.02743555, -0.3991577, -0.8994547, -0.7830126, 0.614068);
                this._distributions[26] = new Array(-0.8366601, 0.4464895, -0.5917366, -0.02073906, -0.9845258, 0.1635625, -0.3097973, 0.4379579, -0.5478154, 0.7173221, -0.1685888, 0.9261969, 0.01503595, 0.6046097, 0.4452421, 0.5449086, 0.0315687, 0.1944619, 0.3753404, 0.8688548, 0.4143643, 0.1396648, 0.8711032, 0.4304703, 0.7328773, 0.1461501, 0.6374492, -0.3521495, 0.145613, -0.1341466, 0.9040975, -0.135123, -0.7839059, -0.5450199, -0.516019, -0.3320859, -0.206158, -0.4431106, -0.9703014, -0.2368356, -0.2473119, -0.0864351, 0.2130725, -0.4604077, -0.003726701, -0.7122303, -0.4072131, -0.6833169, 0.1632999, -0.9776646, 0.4686888, -0.680495, -0.2293511, -0.9509777);
                this._distributions[27] = new Array(0.107311, -0.1311369, -0.4194764, -0.3148777, 0.6171439, -0.2745973, 0.2796618, 0.1937153, -0.09106886, 0.4180236, 0.6044006, 0.05577846, 0.02927299, -0.6738263, -0.2580845, 0.1179939, -0.09023564, -0.3830024, 0.3570953, -0.5000587, 0.81591, -0.5518309, 0.9300217, -0.1257987, 0.4904627, -0.8381903, -0.3163182, -0.8632009, 0.1137595, -0.9875998, 0.8390043, 0.3538185, 0.2149114, 0.4993694, 0.5191584, 0.3833552, 0.5002763, 0.7061465, -0.2567276, 0.9068756, -0.5197366, 0.3467845, 0.03668867, 0.9734009, -0.5347553, 0.66747, -0.9028882, 0.1023768, -0.8967977, 0.412834, -0.5821944, 0.0426479, -0.8032165, -0.2397038, -0.5597343, -0.6358021);
                this._distributions[28] = new Array(-0.6562496, -0.1781036, -0.9301494, 0.1185208, -0.3861143, -0.4153562, -0.1560799, -0.1099607, -0.5587025, 0.395218, -0.5322112, -0.699701, -0.5008639, 0.08726846, -0.970524, -0.1963461, -0.813577, -0.5185111, -0.1644458, 0.298, -0.3216791, 0.639982, 0.3315373, 0.3339162, 0.2383235, -0.00105722, 0.1137828, 0.5450742, -0.01899921, 0.8798413, 0.2849685, 0.8255596, 0.6974412, 0.2123175, 0.7588523, 0.5470437, 0.5102502, -0.1687844, 0.5853448, 0.8033476, 0.2590716, -0.5262504, 0.5607718, -0.6342825, 0.8666443, -0.1491841, 0.8341052, -0.4935003, -0.1568441, -0.6634066, 0.2512113, -0.8769391, -0.2559827, -0.9572457, -0.01928852, -0.3966542, -0.750667, 0.6409678);
                this._distributions[29] = new Array(0.3454786, -0.04837726, 0.2649553, 0.2406852, 0.5599093, -0.3839145, -0.1111814, -0.05502108, 0.7586042, -0.05818377, 0.2519488, -0.4665135, -0.1264972, 0.2602723, -0.08766216, -0.3671907, 0.6428129, 0.3999204, -0.6105871, -0.1246869, -0.4589451, -0.7646643, -0.03021116, -0.7899352, -0.6036922, -0.4293956, -0.2481938, 0.6534185, 0.102798, 0.6784465, -0.6392644, 0.4821358, -0.6789002, 0.1779133, -0.9140783, -0.1989647, -0.9262617, 0.3381507, 0.4794891, -0.8093274, 0.3959447, 0.668478, 0.9602883, 0.2272305, -0.123672, 0.9210883, 0.2375148, 0.9523395, -0.52898, 0.7973378, -0.382433, 0.1228794, 0.695015, 0.6948439, 0.7530277, -0.6458191, 0.8777987, -0.3272956, 0.2318525, -0.962768);
                this._distributions[30] = new Array(0.4518921, -0.1146195, 0.4720805, -0.4238748, 0.3655423, 0.1806341, 0.1589939, -0.23568, 0.7673324, -0.5149941, 0.01163658, 0.09045836, 0.7010971, 0.1245747, 0.7518286, -0.1855433, 0.4960719, 0.4601022, 0.2566979, -0.6308268, -0.0654714, -0.5126389, -0.1823319, -0.1343282, -0.1464312, 0.4883236, -0.3858738, 0.203523, 0.1484799, 0.4432284, -0.477109, -0.116241, 0.2719092, 0.7208626, 0.9104174, 0.3578536, -0.5956199, 0.7662588, -0.6996251, 0.3678654, -0.2514512, 0.9251933, 0.1275825, -0.9478135, -0.204608, -0.8611552, 0.4264838, -0.877443, 0.9854161, 0.05521112, 0.5912951, 0.7997434, 0.1140349, 0.982093, -0.9324368, -0.2094094, -0.42436, -0.6441524, -0.6722705, -0.3554261, -0.7844236, 0.08587621);
                this._distributions[31] = new Array(-0.4206714, -0.5613642, -0.8733016, -0.3373051, -0.1046226, -0.2902999, -0.1318562, -0.8434365, 0.1145093, -0.5962623, -0.4965627, -0.1873259, -0.5011808, -0.8546229, -0.7165636, -0.5743566, 0.1090901, 0.2017643, 0.3404809, -0.220455, -0.1989015, 0.2372122, -0.4538706, 0.0979171, 0.4514146, -0.572846, 0.2314168, -0.8514503, -0.4247236, 0.5650803, -0.943347, 0.04514639, -0.1309718, 0.5221877, -0.7004157, 0.4561877, 0.6306441, 0.04448673, 0.4301621, 0.5766876, 0.1078042, 0.7245752, 0.3875354, 0.2794483, 0.702876, -0.2924213, 0.7360667, -0.6210318, 0.7486517, 0.6531103, 0.4898235, 0.8591025, 0.6549174, 0.3854057, -0.2596106, 0.7916998, 0.9251194, -0.05296265, -0.5620695, 0.820877, -0.01228026, 0.9937211, 0.9612103, 0.2628758);
            };

            PoissonLookup.getDistribution = function (n/*int*/ ) {
                if (!this._distributions)
                    this.initDistributions();

                if (n < 2 || n > 32)
                    return null;

                return this._distributions[n - 1];
            };
            return PoissonLookup;
        })();
        math.PoissonLookup = PoissonLookup;
    })(away.math || (away.math = {}));
    var math = away.math;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        var Object3DEvent = (function (_super) {
            __extends(Object3DEvent, _super);
            function Object3DEvent(type, object) {
                _super.call(this, type);
                this.object = object;
            }
            Object3DEvent.VISIBLITY_UPDATED = "visiblityUpdated";
            Object3DEvent.SCENETRANSFORM_CHANGED = "scenetransformChanged";
            Object3DEvent.SCENE_CHANGED = "sceneChanged";
            Object3DEvent.POSITION_CHANGED = "positionChanged";
            Object3DEvent.ROTATION_CHANGED = "rotationChanged";
            Object3DEvent.SCALE_CHANGED = "scaleChanged";
            return Object3DEvent;
        })(events.Event);
        events.Object3DEvent = Object3DEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        //import away3d.arcane;
        //import away3d.controllers.*;
        //import away3d.core.math.*;
        //import away3d.events.*;
        //import away3d.library.assets.*;
        //import flash.geom.Matrix3D;
        //import flash.geom.Vector3D;
        //use namespace arcane;
        /**
        * Dispatched when the position of the 3d object changes.
        *
        * @eventType away3d.events.Object3DEvent
        */
        //[Event(name="positionChanged", type="away3d.events.Object3DEvent")]
        /**
        * Dispatched when the scale of the 3d object changes.
        *
        * @eventType away3d.events.Object3DEvent
        */
        //[Event(name="scaleChanged", type="away3d.events.Object3DEvent")]
        /**
        * Dispatched when the rotation of the 3d object changes.
        *
        * @eventType away3d.events.Object3DEvent
        */
        //[Event(name="rotationChanged", type="away3d.events.Object3DEvent")]
        /**
        *
        * Object3D provides a base class for any 3D object that has a (local) transformation.<br/><br/>
        *
        * Standard Transform:
        * <ul>
        *     <li> The standard order for transformation is [parent transform] * (Translate+Pivot) * (Rotate) * (-Pivot) * (Scale) * [child transform] </li>
        *     <li> This is the order of matrix multiplications, left-to-right. </li>
        *     <li> The order of transformation is right-to-left, however!
        *          (Scale) happens before (-Pivot) happens before (Rotate) happens before (Translate+Pivot)
        *          with no pivot, the above transform works out to [parent transform] * Translate * Rotate * Scale * [child transform]
        *          (Scale) happens before (Rotate) happens before (Translate) </li>
        *     <li> This is based on code in updateTransform and ObjectContainer3D.updateSceneTransform(). </li>
        *     <li> Matrix3D prepend = operator on rhs - e.g. transform' = transform * rhs; </li>
        *     <li> Matrix3D append =  operator on lhr - e.g. transform' = lhs * transform; </li>
        * </ul>
        *
        * To affect Scale:
        * <ul>
        *     <li> set scaleX/Y/Z directly, or call scale(delta) </li>
        * </ul>
        *
        * To affect Pivot:
        * <ul>
        *     <li> set pivotPoint directly, or call movePivot() </li>
        * </ul>
        *
        * To affect Rotate:
        * <ul>
        *    <li> set rotationX/Y/Z individually (using degrees), set eulers [all 3 angles] (using radians), or call rotateTo()</li>
        *    <li> call pitch()/yaw()/roll()/rotate() to add an additional rotation *before* the current transform.
        *         rotationX/Y/Z will be reset based on these operations. </li>
        * </ul>
        *
        * To affect Translate (post-rotate translate):
        *
        * <ul>
        *    <li> set x/y/z/position or call moveTo(). </li>
        *    <li> call translate(), which modifies x/y/z based on a delta vector. </li>
        *    <li> call moveForward()/moveBackward()/moveLeft()/moveRight()/moveUp()/moveDown()/translateLocal() to add an
        *         additional translate *before* the current transform. x/y/z will be reset based on these operations. </li>
        * </ul>
        *
        * @class away.base.Object3D
        */
        var Object3D = (function (_super) {
            __extends(Object3D, _super);
            /**
            * Creates an Object3D object.
            */
            function Object3D() {
                _super.call(this);
                this._smallestNumber = 0.0000000000000000000001;
                this._transformDirty = true;
                this._positionDirty = true;
                this._rotationDirty = true;
                this._scaleDirty = true;
                this._rotationX = 0;
                this._rotationY = 0;
                this._rotationZ = 0;
                this._eulers = new away.geom.Vector3D();
                this._flipY = new away.geom.Matrix3D();
                this._zOffset = 0;
                this._pTransform = new away.geom.Matrix3D();
                this._pScaleX = 1;
                this._pScaleY = 1;
                this._pScaleZ = 1;
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._pivotPoint = new away.geom.Vector3D();
                this._pivotZero = true;
                this._pPos = new away.geom.Vector3D();
                this._rot = new away.geom.Vector3D();
                this._sca = new away.geom.Vector3D();

                // Cached vector of transformation components used when
                // recomposing the transform matrix in updateTransform()
                this._transformComponents = new Array(3);

                this._transformComponents[0] = this._pPos;
                this._transformComponents[1] = this._rot;
                this._transformComponents[2] = this._sca;

                this._pTransform.identity();

                this._flipY.appendScale(1, -1, 1);
            }
            Object3D.prototype.invalidatePivot = function () {
                this._pivotZero = (this._pivotPoint.x == 0) && (this._pivotPoint.y == 0) && (this._pivotPoint.z == 0);
                this.iInvalidateTransform();
            };

            Object3D.prototype.invalidatePosition = function () {
                if (this._positionDirty)
                    return;

                this._positionDirty = true;

                this.iInvalidateTransform();

                if (this._listenToPositionChanged)
                    this.notifyPositionChanged();
            };

            Object3D.prototype.notifyPositionChanged = function () {
                if (!this._positionChanged) {
                    this._positionChanged = new away.events.Object3DEvent(away.events.Object3DEvent.POSITION_CHANGED, this);
                }
                this.dispatchEvent(this._positionChanged);
            };

            Object3D.prototype.addEventListener = function (type, listener, target) {
                _super.prototype.addEventListener.call(this, type, listener, target);

                switch (type) {
                    case away.events.Object3DEvent.POSITION_CHANGED:
                        this._listenToPositionChanged = true;
                        break;
                    case away.events.Object3DEvent.ROTATION_CHANGED:
                        this._listenToRotationChanged = true;
                        break;
                    case away.events.Object3DEvent.SCALE_CHANGED:
                        this._listenToScaleChanged = true;
                        break;
                }
            };

            Object3D.prototype.removeEventListener = function (type, listener, target) {
                _super.prototype.removeEventListener.call(this, type, listener, target);

                if (this.hasEventListener(type, listener, target))
                    return;

                switch (type) {
                    case away.events.Object3DEvent.POSITION_CHANGED:
                        this._listenToPositionChanged = false;
                        break;

                    case away.events.Object3DEvent.ROTATION_CHANGED:
                        this._listenToRotationChanged = false;
                        break;

                    case away.events.Object3DEvent.SCALE_CHANGED:
                        this._listenToScaleChanged = false;
                        break;
                }
            };

            Object3D.prototype.invalidateRotation = function () {
                if (this._rotationDirty) {
                    return;
                }

                this._rotationDirty = true;

                this.iInvalidateTransform();

                if (this._listenToRotationChanged)
                    this.notifyRotationChanged();
            };

            Object3D.prototype.notifyRotationChanged = function () {
                if (!this._rotationChanged)
                    this._rotationChanged = new away.events.Object3DEvent(away.events.Object3DEvent.ROTATION_CHANGED, this);

                this.dispatchEvent(this._rotationChanged);
            };

            Object3D.prototype.invalidateScale = function () {
                if (this._scaleDirty) {
                    return;
                }

                this._scaleDirty = true;

                this.iInvalidateTransform();

                if (this._listenToScaleChanged)
                    this.notifyScaleChanged();
            };

            Object3D.prototype.notifyScaleChanged = function () {
                if (!this._scaleChanged)
                    this._scaleChanged = new away.events.Object3DEvent(away.events.Object3DEvent.SCALE_CHANGED, this);

                this.dispatchEvent(this._scaleChanged);
            };

            Object.defineProperty(Object3D.prototype, "x", {
                get: /**
                * Defines the x coordinate of the 3d object relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
                */
                function () {
                    return this._x;
                },
                set: function (val) {
                    if (this._x == val) {
                        return;
                    }

                    this._x = val;
                    this.invalidatePosition();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "y", {
                get: /**
                * Defines the y coordinate of the 3d object relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
                */
                function () {
                    return this._y;
                },
                set: function (val) {
                    if (this._y == val) {
                        return;
                    }

                    this._y = val;
                    this.invalidatePosition();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "z", {
                get: /**
                * Defines the z coordinate of the 3d object relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
                */
                function () {
                    return this._z;
                },
                set: function (val) {
                    if (this._z == val) {
                        return;
                    }

                    this._z = val;
                    this.invalidatePosition();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "rotationX", {
                get: /**
                * Defines the euler angle of rotation of the 3d object around the x-axis, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
                */
                function () {
                    return this._rotationX * away.math.MathConsts.RADIANS_TO_DEGREES;
                },
                set: function (val) {
                    if (this.rotationX == val) {
                        return;
                    }

                    this._rotationX = val * away.math.MathConsts.DEGREES_TO_RADIANS;
                    this.invalidateRotation();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "rotationY", {
                get: /**
                * Defines the euler angle of rotation of the 3d object around the y-axis, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
                */
                function () {
                    return this._rotationY * away.math.MathConsts.RADIANS_TO_DEGREES;
                },
                set: function (val) {
                    if (this.rotationY == val) {
                        return;
                    }

                    this._rotationY = val * away.math.MathConsts.DEGREES_TO_RADIANS;

                    this.invalidateRotation();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "rotationZ", {
                get: /**
                * Defines the euler angle of rotation of the 3d object around the z-axis, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
                */
                function () {
                    return this._rotationZ * away.math.MathConsts.RADIANS_TO_DEGREES;
                },
                set: function (val) {
                    if (this.rotationZ == val) {
                        return;
                    }

                    this._rotationZ = val * away.math.MathConsts.DEGREES_TO_RADIANS;

                    this.invalidateRotation();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "scaleX", {
                get: /**
                * Defines the scale of the 3d object along the x-axis, relative to local coordinates.
                */
                function () {
                    return this._pScaleX;
                },
                set: function (val) {
                    if (this._pScaleX == val) {
                        return;
                    }

                    this._pScaleX = val;

                    this.invalidateScale();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "scaleY", {
                get: /**
                * Defines the scale of the 3d object along the y-axis, relative to local coordinates.
                */
                function () {
                    return this._pScaleY;
                },
                set: function (val) {
                    if (this._pScaleY == val) {
                        return;
                    }

                    this._pScaleY = val;

                    this.invalidateScale();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "scaleZ", {
                get: /**
                * Defines the scale of the 3d object along the z-axis, relative to local coordinates.
                */
                function () {
                    return this._pScaleZ;
                },
                set: function (val) {
                    if (this._pScaleZ == val) {
                        return;
                    }

                    this._pScaleZ = val;
                    this.invalidateScale();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "eulers", {
                get: /**
                * Defines the rotation of the 3d object as a <code>Vector3D</code> object containing euler angles for rotation around x, y and z axis.
                */
                function () {
                    this._eulers.x = this._rotationX * away.math.MathConsts.RADIANS_TO_DEGREES;
                    this._eulers.y = this._rotationY * away.math.MathConsts.RADIANS_TO_DEGREES;
                    this._eulers.z = this._rotationZ * away.math.MathConsts.RADIANS_TO_DEGREES;

                    return this._eulers;
                },
                set: function (value) {
                    this._rotationX = value.x * away.math.MathConsts.DEGREES_TO_RADIANS;
                    this._rotationY = value.y * away.math.MathConsts.DEGREES_TO_RADIANS;
                    this._rotationZ = value.z * away.math.MathConsts.DEGREES_TO_RADIANS;

                    this.invalidateRotation();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "transform", {
                get: /**
                * The transformation of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
                */
                function () {
                    if (this._transformDirty) {
                        this.pUpdateTransform();
                    }

                    return this._pTransform;
                },
                set: function (val) {
                    if (!val.rawData[0]) {
                        var raw = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;
                        val.copyRawDataTo(raw);
                        raw[0] = this._smallestNumber;
                        val.copyRawDataFrom(raw);
                    }

                    //*/
                    var elements = val.decompose();
                    var vec;

                    vec = elements[0];

                    if (this._x != vec.x || this._y != vec.y || this._z != vec.z) {
                        this._x = vec.x;
                        this._y = vec.y;
                        this._z = vec.z;

                        this.invalidatePosition();
                    }

                    vec = elements[1];

                    if (this._rotationX != vec.x || this._rotationY != vec.y || this._rotationZ != vec.z) {
                        this._rotationX = vec.x;
                        this._rotationY = vec.y;
                        this._rotationZ = vec.z;

                        this.invalidateRotation();
                    }

                    vec = elements[2];

                    if (this._pScaleX != vec.x || this._pScaleY != vec.y || this._pScaleZ != vec.z) {
                        this._pScaleX = vec.x;
                        this._pScaleY = vec.y;
                        this._pScaleZ = vec.z;

                        this.invalidateScale();
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "pivotPoint", {
                get: /**
                * Defines the local point around which the object rotates.
                */
                function () {
                    return this._pivotPoint;
                },
                set: function (pivot) {
                    this._pivotPoint = pivot.clone();

                    this.invalidatePivot();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "position", {
                get: /**
                * Defines the position of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
                */
                function () {
                    this.transform.copyColumnTo(3, this._pPos);

                    return this._pPos.clone();
                },
                set: function (value) {
                    this._x = value.x;
                    this._y = value.y;
                    this._z = value.z;

                    this.invalidatePosition();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Object3D.prototype, "forwardVector", {
                get: /**
                *
                */
                function () {
                    return away.math.Matrix3DUtils.getForward(this.transform);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Object3D.prototype, "rightVector", {
                get: /**
                *
                */
                function () {
                    return away.math.Matrix3DUtils.getRight(this.transform);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Object3D.prototype, "upVector", {
                get: /**
                *
                */
                function () {
                    return away.math.Matrix3DUtils.getUp(this.transform);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Object3D.prototype, "backVector", {
                get: /**
                *
                */
                function () {
                    var director = away.math.Matrix3DUtils.getForward(this.transform);
                    director.negate();

                    return director;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Object3D.prototype, "leftVector", {
                get: /**
                *
                */
                function () {
                    var director = away.math.Matrix3DUtils.getRight(this.transform);
                    director.negate();

                    return director;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Object3D.prototype, "downVector", {
                get: /**
                *
                */
                function () {
                    var director = away.math.Matrix3DUtils.getUp(this.transform);
                    director.negate();

                    return director;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Appends a uniform scale to the current transformation.
            * @param value The amount by which to scale.
            */
            Object3D.prototype.scale = function (value) {
                this._pScaleX *= value;
                this._pScaleY *= value;
                this._pScaleZ *= value;

                this.invalidateScale();
            };

            /**
            * Moves the 3d object forwards along it's local z axis
            *
            * @param    distance    The length of the movement
            */
            Object3D.prototype.moveForward = function (distance) {
                this.translateLocal(away.geom.Vector3D.Z_AXIS, distance);
            };

            /**
            * Moves the 3d object backwards along it's local z axis
            *
            * @param    distance    The length of the movement
            */
            Object3D.prototype.moveBackward = function (distance) {
                this.translateLocal(away.geom.Vector3D.Z_AXIS, -distance);
            };

            /**
            * Moves the 3d object backwards along it's local x axis
            *
            * @param    distance    The length of the movement
            */
            Object3D.prototype.moveLeft = function (distance) {
                this.translateLocal(away.geom.Vector3D.X_AXIS, -distance);
            };

            /**
            * Moves the 3d object forwards along it's local x axis
            *
            * @param    distance    The length of the movement
            */
            Object3D.prototype.moveRight = function (distance) {
                this.translateLocal(away.geom.Vector3D.X_AXIS, distance);
            };

            /**
            * Moves the 3d object forwards along it's local y axis
            *
            * @param    distance    The length of the movement
            */
            Object3D.prototype.moveUp = function (distance) {
                this.translateLocal(away.geom.Vector3D.Y_AXIS, distance);
            };

            /**
            * Moves the 3d object backwards along it's local y axis
            *
            * @param    distance    The length of the movement
            */
            Object3D.prototype.moveDown = function (distance) {
                this.translateLocal(away.geom.Vector3D.Y_AXIS, -distance);
            };

            /**
            * Moves the 3d object directly to a point in space
            *
            * @param    dx        The amount of movement along the local x axis.
            * @param    dy        The amount of movement along the local y axis.
            * @param    dz        The amount of movement along the local z axis.
            */
            Object3D.prototype.moveTo = function (dx, dy, dz) {
                if (this._x == dx && this._y == dy && this._z == dz) {
                    return;
                }

                this._x = dx;
                this._y = dy;
                this._z = dz;

                this.invalidatePosition();
            };

            /**
            * Moves the local point around which the object rotates.
            *
            * @param    dx        The amount of movement along the local x axis.
            * @param    dy        The amount of movement along the local y axis.
            * @param    dz        The amount of movement along the local z axis.
            */
            Object3D.prototype.movePivot = function (dx, dy, dz) {
                if (this._pivotPoint == null) {
                    this._pivotPoint = new away.geom.Vector3D();
                }

                this._pivotPoint.x += dx;
                this._pivotPoint.y += dy;
                this._pivotPoint.z += dz;

                this.invalidatePivot();
            };

            /**
            * Moves the 3d object along a vector by a defined length
            *
            * @param    axis        The vector defining the axis of movement
            * @param    distance    The length of the movement
            */
            Object3D.prototype.translate = function (axis, distance) {
                var x = axis.x, y = axis.y, z = axis.z;
                var len = distance / Math.sqrt(x * x + y * y + z * z);

                this._x += x * len;
                this._y += y * len;
                this._z += z * len;

                this.invalidatePosition();
            };

            /**
            * Moves the 3d object along a vector by a defined length
            *
            * @param    axis        The vector defining the axis of movement
            * @param    distance    The length of the movement
            */
            Object3D.prototype.translateLocal = function (axis, distance) {
                var x = axis.x, y = axis.y, z = axis.z;
                var len = distance / Math.sqrt(x * x + y * y + z * z);

                this.transform.prependTranslation(x * len, y * len, z * len);

                this._pTransform.copyColumnTo(3, this._pPos);

                this._x = this._pPos.x;
                this._y = this._pPos.y;
                this._z = this._pPos.z;

                this.invalidatePosition();
            };

            /**
            * Rotates the 3d object around it's local x-axis
            *
            * @param    angle        The amount of rotation in degrees
            */
            Object3D.prototype.pitch = function (angle) {
                this.rotate(away.geom.Vector3D.X_AXIS, angle);
            };

            /**
            * Rotates the 3d object around it's local y-axis
            *
            * @param    angle        The amount of rotation in degrees
            */
            Object3D.prototype.yaw = function (angle) {
                this.rotate(away.geom.Vector3D.Y_AXIS, angle);
            };

            /**
            * Rotates the 3d object around it's local z-axis
            *
            * @param    angle        The amount of rotation in degrees
            */
            Object3D.prototype.roll = function (angle) {
                this.rotate(away.geom.Vector3D.Z_AXIS, angle);
            };
            Object3D.prototype.clone = function () {
                var clone = new away.base.Object3D();
                clone.pivotPoint = this.pivotPoint;
                clone.transform = this.transform;
                clone.name = name;

                // todo: implement for all subtypes
                return clone;
            };

            /**
            * Rotates the 3d object directly to a euler angle
            *
            * @param    ax        The angle in degrees of the rotation around the x axis.
            * @param    ay        The angle in degrees of the rotation around the y axis.
            * @param    az        The angle in degrees of the rotation around the z axis.
            */
            Object3D.prototype.rotateTo = function (ax, ay, az) {
                this._rotationX = ax * away.math.MathConsts.DEGREES_TO_RADIANS;
                this._rotationY = ay * away.math.MathConsts.DEGREES_TO_RADIANS;
                this._rotationZ = az * away.math.MathConsts.DEGREES_TO_RADIANS;

                this.invalidateRotation();
            };

            /**
            * Rotates the 3d object around an axis by a defined angle
            *
            * @param    axis        The vector defining the axis of rotation
            * @param    angle        The amount of rotation in degrees
            */
            Object3D.prototype.rotate = function (axis, angle) {
                var m = new away.geom.Matrix3D();
                m.prependRotation(angle, axis);

                var vec = m.decompose()[1];

                this._rotationX += vec.x;
                this._rotationY += vec.y;
                this._rotationZ += vec.z;

                this.invalidateRotation();
            };

            /**
            * Rotates the 3d object around to face a point defined relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
            *
            * @param    target        The vector defining the point to be looked at
            * @param    upAxis        An optional vector used to define the desired up orientation of the 3d object after rotation has occurred
            */
            Object3D.prototype.lookAt = function (target, upAxis) {
                if (typeof upAxis === "undefined") { upAxis = null; }
                var yAxis;
                var zAxis;
                var xAxis;
                var raw;

                if (upAxis == null) {
                    upAxis = away.geom.Vector3D.Y_AXIS;
                }

                zAxis = target.subtract(this.position);
                zAxis.normalize();

                xAxis = upAxis.crossProduct(zAxis);
                xAxis.normalize();

                if (isNaN(xAxis.length) || xAxis.length < .05)
                    xAxis = upAxis.crossProduct(away.geom.Vector3D.Z_AXIS);

                yAxis = zAxis.crossProduct(xAxis);

                raw = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;

                raw[0] = xAxis.x;
                raw[1] = xAxis.y;
                raw[2] = xAxis.z;
                raw[3] = 0;

                raw[4] = yAxis.x;
                raw[5] = yAxis.y;
                raw[6] = yAxis.z;
                raw[7] = 0;

                raw[8] = zAxis.x;
                raw[9] = zAxis.y;
                raw[10] = zAxis.z;
                raw[11] = 0;

                var m = new away.geom.Matrix3D();
                m.copyRawDataFrom(raw);

                var vec = m.decompose()[1];

                this._rotationX = vec.x;
                this._rotationY = vec.y;
                this._rotationZ = vec.z;

                this.invalidateRotation();
            };

            /**
            * Cleans up any resources used by the current object.
            */
            Object3D.prototype.dispose = function () {
            };

            /**
            * @inheritDoc
            */
            Object3D.prototype.disposeAsset = function () {
                this.dispose();
            };

            /**
            * Invalidates the transformation matrix, causing it to be updated upon the next request
            */
            Object3D.prototype.iInvalidateTransform = function () {
                this._transformDirty = true;
            };

            Object3D.prototype.pUpdateTransform = function () {
                this._pPos.x = this._x;
                this._pPos.y = this._y;
                this._pPos.z = this._z;

                this._rot.x = this._rotationX;
                this._rot.y = this._rotationY;
                this._rot.z = this._rotationZ;

                this._sca.x = this._pScaleX;
                this._sca.y = this._pScaleY;
                this._sca.z = this._pScaleZ;

                this._pTransform.recompose(this._transformComponents);

                if (!this._pivotZero) {
                    this._pTransform.prependTranslation(-this._pivotPoint.x, -this._pivotPoint.y, -this._pivotPoint.z);
                    this._pTransform.appendTranslation(this._pivotPoint.x, this._pivotPoint.y, this._pivotPoint.z);
                }

                this._transformDirty = false;
                this._positionDirty = false;
                this._rotationDirty = false;
                this._scaleDirty = false;
            };

            Object.defineProperty(Object3D.prototype, "zOffset", {
                get: function () {
                    return this._zOffset;
                },
                set: function (value) {
                    this._zOffset = value;
                },
                enumerable: true,
                configurable: true
            });

            return Object3D;
        })(away.library.NamedAssetBase);
        base.Object3D = Object3D;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (errors) {
        /**
        * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
        * by a concrete subclass.
        */
        var AbstractMethodError = (function (_super) {
            __extends(AbstractMethodError, _super);
            /**
            * Create a new AbstractMethodError.
            * @param message An optional message to override the default error message.
            * @param id The id of the error.
            */
            function AbstractMethodError(message, id) {
                if (typeof message === "undefined") { message = null; }
                if (typeof id === "undefined") { id = 0; }
                _super.call(this, message || "An abstract method was called! Either an instance of an abstract class was created, or an abstract method was not overridden by the subclass.", id);
            }
            return AbstractMethodError;
        })(errors.Error);
        errors.AbstractMethodError = AbstractMethodError;
    })(away.errors || (away.errors = {}));
    var errors = away.errors;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        var Scene3DEvent = (function (_super) {
            __extends(Scene3DEvent, _super);
            function Scene3DEvent(type, objectContainer) {
                this.objectContainer3D = objectContainer;
                _super.call(this, type);
            }
            Object.defineProperty(Scene3DEvent.prototype, "target", {
                get: //@override
                function () {
                    return this.objectContainer3D;
                },
                enumerable: true,
                configurable: true
            });
            Scene3DEvent.ADDED_TO_SCENE = "addedToScene";
            Scene3DEvent.REMOVED_FROM_SCENE = "removedFromScene";
            Scene3DEvent.PARTITION_CHANGED = "partitionChanged";
            return Scene3DEvent;
        })(away.events.Event);
        events.Scene3DEvent = Scene3DEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (containers) {
        var Scene3D = (function (_super) {
            __extends(Scene3D, _super);
            function Scene3D() {
                _super.call(this);
                this._partitions = [];
                this._iSceneGraphRoot = new away.containers.ObjectContainer3D();

                this._iSceneGraphRoot.scene = this;
                this._iSceneGraphRoot._iIsRoot = true;
                this._iSceneGraphRoot.partition = new away.partition.Partition3D(new away.partition.NodeBase());
            }
            Scene3D.prototype.traversePartitions = function (traverser) {
                var i = 0;
                var len = this._partitions.length;

                //console.log( 'Scene3D.traversePartitions' , len );
                traverser.scene = this;

                while (i < len) {
                    this._partitions[i++].traverse(traverser);
                }
            };

            Object.defineProperty(Scene3D.prototype, "partition", {
                get: function () {
                    return this._iSceneGraphRoot.partition;
                },
                set: function (value) {
                    //console.log( 'scene3D.setPartition' , value );
                    this._iSceneGraphRoot.partition = value;
                    this.dispatchEvent(new away.events.Scene3DEvent(away.events.Scene3DEvent.PARTITION_CHANGED, this._iSceneGraphRoot));
                },
                enumerable: true,
                configurable: true
            });


            Scene3D.prototype.contains = function (child) {
                return this._iSceneGraphRoot.contains(child);
            };

            Scene3D.prototype.addChild = function (child) {
                return this._iSceneGraphRoot.addChild(child);
            };

            Scene3D.prototype.removeChild = function (child) {
                this._iSceneGraphRoot.removeChild(child);
            };

            Scene3D.prototype.removeChildAt = function (index) {
                this._iSceneGraphRoot.removeChildAt(index);
            };

            Scene3D.prototype.getChildAt = function (index) {
                return this._iSceneGraphRoot.getChildAt(index);
            };

            Object.defineProperty(Scene3D.prototype, "numChildren", {
                get: function () {
                    return this._iSceneGraphRoot.numChildren;
                },
                enumerable: true,
                configurable: true
            });

            Scene3D.prototype.iRegisterEntity = function (entity) {
                //console.log( 'Scene3D' , 'iRegisterEntity' , entity._pImplicitPartition );
                var partition = entity.iGetImplicitPartition();

                //console.log( 'scene3D.iRegisterEntity' , entity , entity.iImplicitPartition , partition );
                this.iAddPartitionUnique(partition);
                this.partition.iMarkForUpdate(entity);
            };

            Scene3D.prototype.iUnregisterEntity = function (entity) {
                entity.iGetImplicitPartition().iRemoveEntity(entity);
            };

            Scene3D.prototype.iInvalidateEntityBounds = function (entity) {
                entity.iGetImplicitPartition().iMarkForUpdate(entity);
            };

            Scene3D.prototype.iRegisterPartition = function (entity) {
                this.iAddPartitionUnique(entity.iGetImplicitPartition());
            };

            Scene3D.prototype.iUnregisterPartition = function (entity) {
                entity.iGetImplicitPartition().iRemoveEntity(entity);
            };

            Scene3D.prototype.iAddPartitionUnique = function (partition) {
                if (this._partitions.indexOf(partition) == -1) {
                    this._partitions.push(partition);
                }
            };
            return Scene3D;
        })(away.events.EventDispatcher);
        containers.Scene3D = Scene3D;
    })(away.containers || (away.containers = {}));
    var containers = away.containers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display) {
        var BlendMode = (function () {
            function BlendMode() {
            }
            BlendMode.ADD = "add";
            BlendMode.ALPHA = "alpha";
            BlendMode.DARKEN = "darken";
            BlendMode.DIFFERENCE = "difference";
            BlendMode.ERASE = "erase";
            BlendMode.HARDLIGHT = "hardlight";
            BlendMode.INVERT = "invert";
            BlendMode.LAYER = "layer";
            BlendMode.LIGHTEN = "lighten";
            BlendMode.MULTIPLY = "multiply";
            BlendMode.NORMAL = "normal";
            BlendMode.OVERLAY = "overlay";
            BlendMode.SCREEN = "screen";
            BlendMode.SHADER = "shader";
            BlendMode.SUBTRACT = "subtract";
            return BlendMode;
        })();
        display.BlendMode = BlendMode;
    })(away.display || (away.display = {}));
    var display = away.display;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DClearMask = (function () {
            function Context3DClearMask() {
            }
            Context3DClearMask.COLOR = 8 << 11;
            Context3DClearMask.DEPTH = 8 << 5;
            Context3DClearMask.STENCIL = 8 << 7;
            Context3DClearMask.ALL = Context3DClearMask.COLOR | Context3DClearMask.DEPTH | Context3DClearMask.STENCIL;
            return Context3DClearMask;
        })();
        display3D.Context3DClearMask = Context3DClearMask;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var VertexBuffer3D = (function () {
            function VertexBuffer3D(gl, numVertices, data32PerVertex) {
                this._gl = gl;
                this._buffer = this._gl.createBuffer();
                this._numVertices = numVertices;
                this._data32PerVertex = data32PerVertex;
            }
            VertexBuffer3D.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);

                console.log("** WARNING upload not fully implemented, startVertex & numVertices not considered.");

                // TODO add offsets , startVertex, numVertices * this._data32PerVertex
                this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.STATIC_DRAW);
            };

            Object.defineProperty(VertexBuffer3D.prototype, "numVertices", {
                get: function () {
                    return this._numVertices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexBuffer3D.prototype, "data32PerVertex", {
                get: function () {
                    return this._data32PerVertex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexBuffer3D.prototype, "glBuffer", {
                get: function () {
                    return this._buffer;
                },
                enumerable: true,
                configurable: true
            });

            VertexBuffer3D.prototype.dispose = function () {
                this._gl.deleteBuffer(this._buffer);
            };
            return VertexBuffer3D;
        })();
        display3D.VertexBuffer3D = VertexBuffer3D;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var IndexBuffer3D = (function () {
            function IndexBuffer3D(gl, numIndices) {
                this._gl = gl;
                this._buffer = this._gl.createBuffer();
                this._numIndices = numIndices;
            }
            IndexBuffer3D.prototype.uploadFromArray = function (data, startOffset, count) {
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);

                // TODO add index offsets
                this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), this._gl.STATIC_DRAW);
            };

            IndexBuffer3D.prototype.dispose = function () {
                this._gl.deleteBuffer(this._buffer);
            };

            Object.defineProperty(IndexBuffer3D.prototype, "numIndices", {
                get: function () {
                    return this._numIndices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(IndexBuffer3D.prototype, "glBuffer", {
                get: function () {
                    return this._buffer;
                },
                enumerable: true,
                configurable: true
            });
            return IndexBuffer3D;
        })();
        display3D.IndexBuffer3D = IndexBuffer3D;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Program3D = (function () {
            function Program3D(gl) {
                this._gl = gl;
                this._program = this._gl.createProgram();
            }
            Program3D.prototype.upload = function (vertexProgram, fragmentProgram) {
                this._vertexShader = this._gl.createShader(this._gl.VERTEX_SHADER);
                this._fragmentShader = this._gl.createShader(this._gl.FRAGMENT_SHADER);

                this._gl.shaderSource(this._vertexShader, vertexProgram);
                this._gl.compileShader(this._vertexShader);

                if (!this._gl.getShaderParameter(this._vertexShader, this._gl.COMPILE_STATUS)) {
                    alert(this._gl.getShaderInfoLog(this._vertexShader));
                    return null;
                }

                this._gl.shaderSource(this._fragmentShader, fragmentProgram);
                this._gl.compileShader(this._fragmentShader);

                if (!this._gl.getShaderParameter(this._fragmentShader, this._gl.COMPILE_STATUS)) {
                    alert(this._gl.getShaderInfoLog(this._fragmentShader));
                    return null;
                }

                this._gl.attachShader(this._program, this._vertexShader);
                this._gl.attachShader(this._program, this._fragmentShader);
                this._gl.linkProgram(this._program);

                if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
                    alert("Could not link the program.");
                }
            };

            Program3D.prototype.dispose = function () {
                this._gl.deleteProgram(this._program);
            };

            Program3D.prototype.focusProgram = function () {
                this._gl.useProgram(this._program);
            };

            Object.defineProperty(Program3D.prototype, "glProgram", {
                get: function () {
                    return this._program;
                },
                enumerable: true,
                configurable: true
            });
            return Program3D;
        })();
        display3D.Program3D = Program3D;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var SamplerState = (function () {
            function SamplerState() {
                this.wrap = 0;
                this.filter = 0;
                this.mipfilter = 0;
            }
            return SamplerState;
        })();
        display3D.SamplerState = SamplerState;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (geom) {
        var Point = (function () {
            function Point(x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                this.x = x;
                this.y = y;
            }
            return Point;
        })();
        geom.Point = Point;
    })(away.geom || (away.geom = {}));
    var geom = away.geom;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (geom) {
        var Rectangle = (function () {
            function Rectangle(x, y, width, height) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof width === "undefined") { width = 0; }
                if (typeof height === "undefined") { height = 0; }
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            Object.defineProperty(Rectangle.prototype, "left", {
                get: function () {
                    return this.x;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "right", {
                get: function () {
                    return this.x + this.width;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "top", {
                get: function () {
                    return this.y;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "bottom", {
                get: function () {
                    return this.y + this.height;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "topLeft", {
                get: function () {
                    return new away.geom.Point(this.x, this.y);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "bottomRight", {
                get: function () {
                    return new away.geom.Point(this.x + this.width, this.y + this.height);
                },
                enumerable: true,
                configurable: true
            });

            Rectangle.prototype.clone = function () {
                return new Rectangle(this.x, this.y, this.width, this.height);
            };
            return Rectangle;
        })();
        geom.Rectangle = Rectangle;
    })(away.geom || (away.geom = {}));
    var geom = away.geom;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DTextureFormat = (function () {
            function Context3DTextureFormat() {
            }
            Context3DTextureFormat.BGRA = "bgra";
            Context3DTextureFormat.BGRA_PACKED = "bgraPacked4444";
            Context3DTextureFormat.BGR_PACKED = "bgrPacked565";
            Context3DTextureFormat.COMPRESSED = "compressed";
            Context3DTextureFormat.COMPRESSED_ALPHA = "compressedAlpha";
            return Context3DTextureFormat;
        })();
        display3D.Context3DTextureFormat = Context3DTextureFormat;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var TextureBase = (function () {
            function TextureBase(gl) {
                this.textureType = "";
                this._gl = gl;
            }
            TextureBase.prototype.dispose = function () {
                throw "Abstract method must be overridden.";
            };
            return TextureBase;
        })();
        display3D.TextureBase = TextureBase;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (geom) {
        var Matrix = (function () {
            function Matrix(a, b, c, d, tx, ty) {
                if (typeof a === "undefined") { a = 1; }
                if (typeof b === "undefined") { b = 0; }
                if (typeof c === "undefined") { c = 0; }
                if (typeof d === "undefined") { d = 1; }
                if (typeof tx === "undefined") { tx = 0; }
                if (typeof ty === "undefined") { ty = 0; }
                this.a = a;
                this.b = b;
                this.c = c;
                this.d = d;
                this.tx = tx;
                this.ty = ty;
            }
            /**
            *
            * @returns {away.geom.Matrix}
            */
            Matrix.prototype.clone = function () {
                return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
            };

            /**
            *
            * @param m
            */
            Matrix.prototype.concat = function (m) {
                var a1 = this.a * m.a + this.b * m.c;
                this.b = this.a * m.b + this.b * m.d;
                this.a = a1;

                var c1 = this.c * m.a + this.d * m.c;
                this.d = this.c * m.b + this.d * m.d;

                this.c = c1;

                var tx1 = this.tx * m.a + this.ty * m.c + m.tx;
                this.ty = this.tx * m.b + this.ty * m.d + m.ty;
                this.tx = tx1;
            };

            /**
            *
            * @param column
            * @param vector3D
            */
            Matrix.prototype.copyColumnFrom = function (column, vector3D) {
                if (column > 2) {
                    throw "Column " + column + " out of bounds (2)";
                } else if (column == 0) {
                    this.a = vector3D.x;
                    this.c = vector3D.y;
                } else if (column == 1) {
                    this.b = vector3D.x;
                    this.d = vector3D.y;
                } else {
                    this.tx = vector3D.x;
                    this.ty = vector3D.y;
                }
            };

            /**
            *
            * @param column
            * @param vector3D
            */
            Matrix.prototype.copyColumnTo = function (column, vector3D) {
                if (column > 2) {
                    throw new away.errors.ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 2]");
                } else if (column == 0) {
                    vector3D.x = this.a;
                    vector3D.y = this.c;
                    vector3D.z = 0;
                } else if (column == 1) {
                    vector3D.x = this.b;
                    vector3D.y = this.d;
                    vector3D.z = 0;
                } else {
                    vector3D.x = this.tx;
                    vector3D.y = this.ty;
                    vector3D.z = 1;
                }
            };

            /**
            *
            * @param other
            */
            Matrix.prototype.copyFrom = function (other) {
                this.a = other.a;
                this.b = other.b;
                this.c = other.c;
                this.d = other.d;
                this.tx = other.tx;
                this.ty = other.ty;
            };

            /**
            *
            * @param row
            * @param vector3D
            */
            Matrix.prototype.copyRowFrom = function (row, vector3D) {
                if (row > 2) {
                    throw new away.errors.ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
                } else if (row == 0) {
                    this.a = vector3D.x;
                    this.c = vector3D.y;
                } else if (row == 1) {
                    this.b = vector3D.x;
                    this.d = vector3D.y;
                } else {
                    this.tx = vector3D.x;
                    this.ty = vector3D.y;
                }
            };

            /**
            *
            * @param row
            * @param vector3D
            */
            Matrix.prototype.copyRowTo = function (row, vector3D) {
                if (row > 2) {
                    throw new away.errors.ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
                } else if (row == 0) {
                    vector3D.x = this.a;
                    vector3D.y = this.b;
                    vector3D.z = this.tx;
                } else if (row == 1) {
                    vector3D.x = this.c;
                    vector3D.y = this.d;
                    vector3D.z = this.ty;
                } else {
                    vector3D.setTo(0, 0, 1);
                }
            };

            /**
            *
            * @param scaleX
            * @param scaleY
            * @param rotation
            * @param tx
            * @param ty
            */
            Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
                if (typeof rotation === "undefined") { rotation = 0; }
                if (typeof tx === "undefined") { tx = 0; }
                if (typeof ty === "undefined") { ty = 0; }
                this.a = scaleX;
                this.d = scaleY;
                this.b = rotation;
                this.tx = tx;
                this.ty = ty;
            };

            /**
            *
            * @param width
            * @param height
            * @param rotation
            * @param tx
            * @param ty
            */
            Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
                if (typeof rotation === "undefined") { rotation = 0; }
                if (typeof tx === "undefined") { tx = 0; }
                if (typeof ty === "undefined") { ty = 0; }
                this.a = width / 1638.4;
                this.d = height / 1638.4;

                if (rotation != 0.0) {
                    var cos = Math.cos(rotation);
                    var sin = Math.sin(rotation);

                    this.b = sin * this.d;
                    this.c = -sin * this.a;
                    this.a *= cos;
                    this.d *= cos;
                } else {
                    this.b = this.c = 0;
                }

                this.tx = tx + width / 2;
                this.ty = ty + height / 2;
            };

            /**
            *
            * @param point
            * @returns {away.geom.Point}
            */
            Matrix.prototype.deltaTransformPoint = function (point) {
                return new away.geom.Point(point.x * this.a + point.y * this.c, point.x * this.b + point.y * this.d);
            };

            /**
            *
            */
            Matrix.prototype.identity = function () {
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.d = 1;
                this.tx = 0;
                this.ty = 0;
            };

            /**
            *
            * @returns {away.geom.Matrix}
            */
            Matrix.prototype.invert = function () {
                var norm = this.a * this.d - this.b * this.c;

                if (norm == 0) {
                    this.a = this.b = this.c = this.d = 0;
                    this.tx = -this.tx;
                    this.ty = -this.ty;
                } else {
                    norm = 1.0 / norm;
                    var a1 = this.d * norm;
                    this.d = this.a * norm;
                    this.a = a1;
                    this.b *= -norm;
                    this.c *= -norm;

                    var tx1 = -this.a * this.tx - this.c * this.ty;
                    this.ty = -this.b * this.tx - this.d * this.ty;
                    this.tx = tx1;
                }

                return this;
            };

            /**
            *
            * @param m
            * @returns {away.geom.Matrix}
            */
            Matrix.prototype.mult = function (m) {
                var result = new Matrix();

                result.a = this.a * m.a + this.b * m.c;
                result.b = this.a * m.b + this.b * m.d;
                result.c = this.c * m.a + this.d * m.c;
                result.d = this.c * m.b + this.d * m.d;

                result.tx = this.tx * m.a + this.ty * m.c + m.tx;
                result.ty = this.tx * m.b + this.ty * m.d + m.ty;

                return result;
            };

            /**
            *
            * @param angle
            */
            Matrix.prototype.rotate = function (angle) {
                var cos = Math.cos(angle);
                var sin = Math.sin(angle);

                var a1 = this.a * cos - this.b * sin;
                this.b = this.a * sin + this.b * cos;
                this.a = a1;

                var c1 = this.c * cos - this.d * sin;
                this.d = this.c * sin + this.d * cos;
                this.c = c1;

                var tx1 = this.tx * cos - this.ty * sin;
                this.ty = this.tx * sin + this.ty * cos;
                this.tx = tx1;
            };

            /**
            *
            * @param x
            * @param y
            */
            Matrix.prototype.scale = function (x, y) {
                this.a *= x;
                this.b *= y;

                this.c *= x;
                this.d *= y;

                this.tx *= x;
                this.ty *= y;
            };

            /**
            *
            * @param angle
            * @param scale
            */
            Matrix.prototype.setRotation = function (angle, scale) {
                if (typeof scale === "undefined") { scale = 1; }
                this.a = Math.cos(angle) * scale;
                this.c = Math.sin(angle) * scale;
                this.b = -this.c;
                this.d = this.a;
            };

            /**
            *
            * @param a
            * @param b
            * @param c
            * @param d
            * @param tx
            * @param ty
            */
            Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
                this.a = a;
                this.b = b;
                this.c = c;
                this.d = d;
                this.tx = tx;
                this.ty = ty;
            };

            /**
            *
            * @returns {string}
            */
            Matrix.prototype.toString = function () {
                return "[Matrix] (a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
            };

            /**
            *
            * @param point
            * @returns {away.geom.Point}
            */
            Matrix.prototype.transformPoint = function (point) {
                return new away.geom.Point(point.x * this.a + point.y * this.c + this.tx, point.x * this.b + point.y * this.d + this.ty);
            };

            /**
            *
            * @param x
            * @param y
            */
            Matrix.prototype.translate = function (x, y) {
                this.tx += x;
                this.ty += y;
            };
            return Matrix;
        })();
        geom.Matrix = Matrix;
    })(away.geom || (away.geom = {}));
    var geom = away.geom;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display) {
        /**
        *
        */
        var BitmapData = (function () {
            /**
            *
            * @param width
            * @param height
            * @param transparent
            * @param fillColor
            */
            function BitmapData(width, height, transparent, fillColor) {
                if (typeof transparent === "undefined") { transparent = true; }
                if (typeof fillColor === "undefined") { fillColor = null; }
                this._alpha = 1;
                this._locked = false;
                this._transparent = transparent;
                this._imageCanvas = document.createElement("canvas");
                this._imageCanvas.width = width;
                this._imageCanvas.height = height;
                this._context = this._imageCanvas.getContext("2d");
                this._rect = new away.geom.Rectangle(0, 0, width, height);

                if (fillColor != null) {
                    if (this._transparent) {
                        this._alpha = away.utils.ColorUtils.float32ColorToARGB(fillColor)[0] / 255;
                    } else {
                        this._alpha = 1;
                    }

                    this.fillRect(this._rect, fillColor);
                }
            }
            /**
            *
            */
            BitmapData.prototype.dispose = function () {
                this._context = null;
                this._imageCanvas = null;
                this._imageData = null;
                this._rect = null;
                this._transparent = null;
                this._locked = null;
            };

            /**
            *
            */
            BitmapData.prototype.lock = function () {
                this._locked = true;
                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
            };

            /**
            *
            */
            BitmapData.prototype.unlock = function () {
                this._locked = false;

                if (this._imageData) {
                    this._context.putImageData(this._imageData, 0, 0);
                    this._imageData = null;
                }
            };

            /**
            *
            * @param x
            * @param y
            * @param color
            */
            BitmapData.prototype.getPixel = function (x, y) {
                var r;
                var g;
                var b;
                var a;

                var index = (x + y * this._imageCanvas.width) * 4;

                if (!this._locked) {
                    this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);

                    r = this._imageData.data[index + 0];
                    g = this._imageData.data[index + 1];
                    b = this._imageData.data[index + 2];
                    a = this._imageData.data[index + 3];
                } else {
                    if (this._imageData) {
                        this._context.putImageData(this._imageData, 0, 0);
                    }

                    this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);

                    r = this._imageData.data[index + 0];
                    g = this._imageData.data[index + 1];
                    b = this._imageData.data[index + 2];
                    a = this._imageData.data[index + 3];
                }

                if (!this._locked) {
                    this._imageData = null;
                }

                return (a << 24) | (r << 16) | (g << 8) | b;
            };

            /**
            *
            * @param x
            * @param y
            * @param color
            */
            BitmapData.prototype.setPixel = function (x, y, color) {
                var argb = away.utils.ColorUtils.float32ColorToARGB(color);

                if (!this._locked) {
                    this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
                }

                if (this._imageData) {
                    var index = (x + y * this._imageCanvas.width) * 4;

                    this._imageData.data[index + 0] = argb[1];
                    this._imageData.data[index + 1] = argb[2];
                    this._imageData.data[index + 2] = argb[3];
                    this._imageData.data[index + 3] = 255;
                }

                if (!this._locked) {
                    this._context.putImageData(this._imageData, 0, 0);
                    this._imageData = null;
                }
            };

            /**
            *
            * @param x
            * @param y
            * @param color
            */
            BitmapData.prototype.setPixel32 = function (x, y, color) {
                var argb = away.utils.ColorUtils.float32ColorToARGB(color);

                if (!this._locked) {
                    this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
                }

                if (this._imageData) {
                    var index = (x + y * this._imageCanvas.width) * 4;

                    this._imageData.data[index + 0] = argb[1];
                    this._imageData.data[index + 1] = argb[2];
                    this._imageData.data[index + 2] = argb[3];
                    this._imageData.data[index + 3] = argb[0];
                }

                if (!this._locked) {
                    this._context.putImageData(this._imageData, 0, 0);
                    this._imageData = null;
                }
            };

            BitmapData.prototype.setVector = function (rect, inputVector) {
                if (!this._locked) {
                    this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
                }

                if (this._imageData) {
                    var i/*uint*/ , j, index, argb;
                    for (i = 0; i < rect.width; ++i) {
                        for (j = 0; j < rect.height; ++j) {
                            argb = away.utils.ColorUtils.float32ColorToARGB(i + j * rect.width);
                            index = (i + rect.x + (j + rect.y) * this._imageCanvas.width) * 4;

                            this._imageData.data[index + 0] = argb[1];
                            this._imageData.data[index + 1] = argb[2];
                            this._imageData.data[index + 2] = argb[3];
                            this._imageData.data[index + 3] = argb[0];
                        }
                    }
                }

                if (!this._locked) {
                    this._context.putImageData(this._imageData, 0, 0);
                    this._imageData = null;
                }
            };

            BitmapData.prototype.drawImage = function (img, sourceRect, destRect) {
                if (this._locked) {
                    if (this._imageData) {
                        this._context.putImageData(this._imageData, 0, 0);
                    }

                    this._drawImage(img, sourceRect, destRect);

                    if (this._imageData) {
                        this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
                    }
                } else {
                    this._drawImage(img, sourceRect, destRect);
                }
            };

            BitmapData.prototype._drawImage = function (img, sourceRect, destRect) {
                if (img instanceof away.display.BitmapData) {
                    this._context.drawImage(img.canvas, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
                } else if (img instanceof HTMLImageElement) {
                    this._context.drawImage(img, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
                }
            };

            BitmapData.prototype.copyPixels = function (bmpd, sourceRect, destRect) {
                if (this._locked) {
                    if (this._imageData) {
                        this._context.putImageData(this._imageData, 0, 0);
                    }

                    this._copyPixels(bmpd, sourceRect, destRect);

                    if (this._imageData) {
                        this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
                    }
                } else {
                    this._copyPixels(bmpd, sourceRect, destRect);
                }
            };

            BitmapData.prototype._copyPixels = function (bmpd, sourceRect, destRect) {
                if (bmpd instanceof away.display.BitmapData) {
                    this._context.drawImage(bmpd.canvas, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
                } else if (bmpd instanceof HTMLImageElement) {
                    this._context.drawImage(bmpd, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
                }
            };

            /**
            *
            * @param rect
            * @param color
            */
            BitmapData.prototype.fillRect = function (rect, color) {
                if (this._locked) {
                    if (this._imageData) {
                        this._context.putImageData(this._imageData, 0, 0);
                    }

                    this._context.fillStyle = this.hexToRGBACSS(color);
                    this._context.fillRect(rect.x, rect.y, rect.width, rect.height);

                    if (this._imageData) {
                        this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
                    }
                } else {
                    this._context.fillStyle = this.hexToRGBACSS(color);
                    this._context.fillRect(rect.x, rect.y, rect.width, rect.height);
                }
            };

            BitmapData.prototype.draw = function (source, matrix) {
                if (this._locked) {
                    if (this._imageData) {
                        this._context.putImageData(this._imageData, 0, 0);
                    }

                    this._draw(source, matrix);

                    if (this._imageData) {
                        this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
                    }
                } else {
                    this._draw(source, matrix);
                }
            };

            BitmapData.prototype._draw = function (source, matrix) {
                if (source instanceof away.display.BitmapData) {
                    this._context.save();
                    this._context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
                    this._context.drawImage(source.canvas, 0, 0);
                    this._context.restore();
                } else if (source instanceof HTMLImageElement) {
                    this._context.save();
                    this._context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
                    this._context.drawImage(source, 0, 0);
                    this._context.restore();
                }
            };


            Object.defineProperty(BitmapData.prototype, "imageData", {
                get: /**
                *
                * @returns {ImageData}
                */
                function () {
                    return this._context.getImageData(0, 0, this._rect.width, this._rect.height);
                },
                set: // Get / Set
                /**
                *
                * @param {ImageData}
                */
                function (value) {
                    this._context.putImageData(value, 0, 0);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(BitmapData.prototype, "width", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._imageCanvas.width;
                },
                set: /**
                *
                * @param {number}
                */
                function (value) {
                    this._rect.width = value;
                    this._imageCanvas.width = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BitmapData.prototype, "height", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._imageCanvas.height;
                },
                set: /**
                *
                * @param {number}
                */
                function (value) {
                    this._rect.height = value;
                    this._imageCanvas.height = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BitmapData.prototype, "rect", {
                get: /**
                *
                * @param {away.geom.Rectangle}
                */
                function () {
                    return this._rect;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(BitmapData.prototype, "canvas", {
                get: /**
                *
                * @returns {HTMLCanvasElement}
                */
                function () {
                    return this._imageCanvas;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(BitmapData.prototype, "context", {
                get: /**
                *
                * @returns {HTMLCanvasElement}
                */
                function () {
                    return this._context;
                },
                enumerable: true,
                configurable: true
            });

            // Private
            /**
            * convert decimal value to Hex
            */
            BitmapData.prototype.hexToRGBACSS = function (d) {
                var argb = away.utils.ColorUtils.float32ColorToARGB(d);

                if (this._transparent == false) {
                    argb[0] = 1;

                    return 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',' + argb[0] + ')';
                }

                return 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',' + argb[0] / 255 + ')';
            };
            return BitmapData;
        })();
        display.BitmapData = BitmapData;
    })(away.display || (away.display = {}));
    var display = away.display;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Texture = (function (_super) {
            __extends(Texture, _super);
            function Texture(gl, width, height) {
                _super.call(this, gl);
                this.textureType = "texture2d";
                this._width = width;
                this._height = height;

                this._glTexture = this._gl.createTexture();
            }
            Texture.prototype.dispose = function () {
                this._gl.deleteTexture(this._glTexture);
            };

            Object.defineProperty(Texture.prototype, "width", {
                get: function () {
                    return this._width;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Texture.prototype, "height", {
                get: function () {
                    return this._height;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Texture.prototype, "frameBuffer", {
                get: function () {
                    return this._frameBuffer;
                },
                enumerable: true,
                configurable: true
            });

            Texture.prototype.uploadFromHTMLImageElement = function (image, miplevel) {
                if (typeof miplevel === "undefined") { miplevel = 0; }
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
                this._gl.texImage2D(this._gl.TEXTURE_2D, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
                this._gl.bindTexture(this._gl.TEXTURE_2D, null);
            };

            Texture.prototype.uploadFromBitmapData = function (data, miplevel) {
                if (typeof miplevel === "undefined") { miplevel = 0; }
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
                this._gl.texImage2D(this._gl.TEXTURE_2D, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data.imageData);
                this._gl.bindTexture(this._gl.TEXTURE_2D, null);
            };

            Object.defineProperty(Texture.prototype, "glTexture", {
                get: function () {
                    return this._glTexture;
                },
                enumerable: true,
                configurable: true
            });

            Texture.prototype.generateFromRenderBuffer = function (data) {
                this._frameBuffer = this._gl.createFramebuffer();
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
                this._frameBuffer.width = this._width;
                this._frameBuffer.height = this._height;

                this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR_MIPMAP_NEAREST);

                //this._gl.generateMipmap(this._gl.TEXTURE_2D);
                //this._gl.texImage2D( this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data.imageData );
                this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._width, this._height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);

                var renderBuffer = this._gl.createRenderbuffer();
                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_COMPONENT16, this._width, this._height);

                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._glTexture, 0);
                this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);

                this._gl.bindTexture(this._gl.TEXTURE_2D, null);
                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
            };

            Texture.prototype.generateMipmaps = function () {
                //this._gl.bindTexture( this._gl.TEXTURE_2D, this._glTexture );
                //this._gl.generateMipmap(this._gl.TEXTURE_2D);
                //this._gl.bindTexture( this._gl.TEXTURE_2D, null );
            };
            return Texture;
        })(display3D.TextureBase);
        display3D.Texture = Texture;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var CubeTexture = (function (_super) {
            __extends(CubeTexture, _super);
            function CubeTexture(gl, size) {
                _super.call(this, gl);
                this.textureType = "textureCube";
                this._size = size;

                this._textures = [];
                for (var i = 0; i < 6; ++i) {
                    this._textures[i] = this._gl.createTexture();
                }
            }
            CubeTexture.prototype.dispose = function () {
                for (var i = 0; i < 6; ++i) {
                    this._gl.deleteTexture(this._textures[i]);
                }
            };

            CubeTexture.prototype.uploadFromHTMLImageElement = function (image, side, miplevel) {
                if (typeof miplevel === "undefined") { miplevel = 0; }
                switch (side) {
                    case 0:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[0]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_X, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 1:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[1]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_NEGATIVE_X, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 2:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[2]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_Y, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 3:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[3]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 4:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[4]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_Z, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 5:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[5]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    default:
                        throw "unknown side type";
                }
            };

            CubeTexture.prototype.uploadFromBitmapData = function (data, side, miplevel) {
                if (typeof miplevel === "undefined") { miplevel = 0; }
                switch (side) {
                    case 0:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[0]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_X, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data.imageData);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 1:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[1]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_NEGATIVE_X, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data.imageData);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 2:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[2]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_Y, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data.imageData);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 3:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[3]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data.imageData);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 4:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[4]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_Z, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data.imageData);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    case 5:
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._textures[5]);
                        this._gl.texImage2D(this._gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data.imageData);
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                        break;
                    default:
                        throw "unknown side type";
                }
            };

            Object.defineProperty(CubeTexture.prototype, "size", {
                get: function () {
                    return this._size;
                },
                enumerable: true,
                configurable: true
            });

            CubeTexture.prototype.glTextureAt = function (index) {
                return this._textures[index];
            };
            return CubeTexture;
        })(away.display3D.TextureBase);
        display3D.CubeTexture = CubeTexture;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DTriangleFace = (function () {
            function Context3DTriangleFace() {
            }
            Context3DTriangleFace.BACK = "back";
            Context3DTriangleFace.FRONT = "front";
            Context3DTriangleFace.FRONT_AND_BACK = "frontAndBack";
            Context3DTriangleFace.NONE = "none";
            return Context3DTriangleFace;
        })();
        display3D.Context3DTriangleFace = Context3DTriangleFace;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DVertexBufferFormat = (function () {
            function Context3DVertexBufferFormat() {
            }
            Context3DVertexBufferFormat.BYTES_4 = "bytes4";
            Context3DVertexBufferFormat.FLOAT_1 = "float1";
            Context3DVertexBufferFormat.FLOAT_2 = "float2";
            Context3DVertexBufferFormat.FLOAT_3 = "float3";
            Context3DVertexBufferFormat.FLOAT_4 = "float4";
            return Context3DVertexBufferFormat;
        })();
        display3D.Context3DVertexBufferFormat = Context3DVertexBufferFormat;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DProgramType = (function () {
            function Context3DProgramType() {
            }
            Context3DProgramType.FRAGMENT = "fragment";
            Context3DProgramType.VERTEX = "vertex";
            return Context3DProgramType;
        })();
        display3D.Context3DProgramType = Context3DProgramType;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DBlendFactor = (function () {
            function Context3DBlendFactor() {
            }
            Context3DBlendFactor.DESTINATION_ALPHA = "destinationAlpha";
            Context3DBlendFactor.DESTINATION_COLOR = "destinationColor";
            Context3DBlendFactor.ONE = "one";
            Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA = "oneMinusDestinationAlpha";
            Context3DBlendFactor.ONE_MINUS_DESTINATION_COLOR = "oneMinusDestinationColor";
            Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA = "oneMinusSourceAlpha";
            Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR = "oneMinusSourceColor";
            Context3DBlendFactor.SOURCE_ALPHA = "sourceAlpha";
            Context3DBlendFactor.SOURCE_COLOR = "sourceColor";
            Context3DBlendFactor.ZERO = "zero";
            return Context3DBlendFactor;
        })();
        display3D.Context3DBlendFactor = Context3DBlendFactor;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DCompareMode = (function () {
            function Context3DCompareMode() {
            }
            Context3DCompareMode.ALWAYS = "always";
            Context3DCompareMode.EQUAL = "equal";
            Context3DCompareMode.GREATER = "greater";
            Context3DCompareMode.GREATER_EQUAL = "greaterEqual";
            Context3DCompareMode.LESS = "less";
            Context3DCompareMode.LESS_EQUAL = "lessEqual";
            Context3DCompareMode.NEVER = "never";
            Context3DCompareMode.NOT_EQUAL = "notEqual";
            return Context3DCompareMode;
        })();
        display3D.Context3DCompareMode = Context3DCompareMode;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DMipFilter = (function () {
            function Context3DMipFilter() {
            }
            Context3DMipFilter.MIPLINEAR = "miplinear";
            Context3DMipFilter.MIPNEAREST = "mipnearest";
            Context3DMipFilter.MIPNONE = "mipnone";
            return Context3DMipFilter;
        })();
        display3D.Context3DMipFilter = Context3DMipFilter;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DProfile = (function () {
            function Context3DProfile() {
            }
            Context3DProfile.BASELINE = "baseline";
            Context3DProfile.BASELINE_CONSTRAINED = "baselineConstrained";
            Context3DProfile.BASELINE_EXTENDED = "baselineExtended";
            return Context3DProfile;
        })();
        display3D.Context3DProfile = Context3DProfile;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DStencilAction = (function () {
            function Context3DStencilAction() {
            }
            Context3DStencilAction.DECREMENT_SATURATE = "decrementSaturate";
            Context3DStencilAction.DECREMENT_WRAP = "decrementWrap";
            Context3DStencilAction.INCREMENT_SATURATE = "incrementSaturate";
            Context3DStencilAction.INCREMENT_WRAP = "incrementWrap";
            Context3DStencilAction.INVERT = "invert";
            Context3DStencilAction.KEEP = "keep";
            Context3DStencilAction.SET = "set";
            Context3DStencilAction.ZERO = "zero";
            return Context3DStencilAction;
        })();
        display3D.Context3DStencilAction = Context3DStencilAction;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DTextureFilter = (function () {
            function Context3DTextureFilter() {
            }
            Context3DTextureFilter.LINEAR = "linear";
            Context3DTextureFilter.NEAREST = "nearest";
            return Context3DTextureFilter;
        })();
        display3D.Context3DTextureFilter = Context3DTextureFilter;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3DWrapMode = (function () {
            function Context3DWrapMode() {
            }
            Context3DWrapMode.CLAMP = "clamp";
            Context3DWrapMode.REPEAT = "repeat";
            return Context3DWrapMode;
        })();
        display3D.Context3DWrapMode = Context3DWrapMode;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var Context3D = (function () {
            function Context3D(canvas) {
                this._currentWrap = 0;
                this._currentFilter = 0;
                this._currentMipFilter = 0;
                this._indexBufferList = [];
                this._vertexBufferList = [];
                this._textureList = [];
                this._programList = [];
                this._samplerStates = [];
                try  {
                    this._gl = canvas.getContext("experimental-webgl");
                    if (!this._gl) {
                        this._gl = canvas.getContext("webgl");
                    }
                } catch (e) {
                    //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_FAILED, e ) );
                }

                if (this._gl) {
                    //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_SUCCESS ) );
                } else {
                    //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_FAILED, e ) );
                    alert("WebGL is not available.");
                }

                for (var i = 0; i < Context3D.MAX_SAMPLERS; ++i) {
                    this._samplerStates[i] = new away.display3D.SamplerState();
                    this._samplerStates[i].wrap = this._gl.REPEAT;
                    this._samplerStates[i].filter = this._gl.LINEAR;
                    this._samplerStates[i].mipfilter = 0;
                }
            }
            Context3D.prototype.gl = function () {
                return this._gl;
            };

            Context3D.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
                if (typeof red === "undefined") { red = 0; }
                if (typeof green === "undefined") { green = 0; }
                if (typeof blue === "undefined") { blue = 0; }
                if (typeof alpha === "undefined") { alpha = 1; }
                if (typeof depth === "undefined") { depth = 1; }
                if (typeof stencil === "undefined") { stencil = 0; }
                if (typeof mask === "undefined") { mask = display3D.Context3DClearMask.ALL; }
                if (!this._drawing) {
                    this.updateBlendStatus();
                    this._drawing = true;
                }
                this._gl.clearColor(red, green, blue, alpha);
                this._gl.clearDepth(depth);
                this._gl.clearStencil(stencil);
                this._gl.clear(mask);
            };

            Context3D.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
                if (typeof enableDepthAndStencil === "undefined") { enableDepthAndStencil = true; }
                if (enableDepthAndStencil) {
                    this._gl.enable(this._gl.STENCIL_TEST);
                    this._gl.enable(this._gl.DEPTH_TEST);
                }

                this._gl.viewport.width = width;
                this._gl.viewport.height = height;

                this._gl.viewport(0, 0, width, height);
            };

            Context3D.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
                if (typeof streamingLevels === "undefined") { streamingLevels = 0; }
                var texture = new away.display3D.CubeTexture(this._gl, size);
                this._textureList.push(texture);
                return texture;
            };

            Context3D.prototype.createIndexBuffer = function (numIndices) {
                var indexBuffer = new away.display3D.IndexBuffer3D(this._gl, numIndices);
                this._indexBufferList.push(indexBuffer);
                return indexBuffer;
            };

            Context3D.prototype.createProgram = function () {
                var program = new away.display3D.Program3D(this._gl);
                this._programList.push(program);
                return program;
            };

            Context3D.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
                if (typeof streamingLevels === "undefined") { streamingLevels = 0; }
                //TODO streaming
                var texture = new away.display3D.Texture(this._gl, width, height);
                this._textureList.push(texture);
                return texture;
            };

            Context3D.prototype.createVertexBuffer = function (numVertices, data32PerVertex) {
                var vertexBuffer = new away.display3D.VertexBuffer3D(this._gl, numVertices, data32PerVertex);
                this._vertexBufferList.push(vertexBuffer);
                return vertexBuffer;
            };

            Context3D.prototype.dispose = function () {
                var i;
                for (i = 0; i < this._indexBufferList.length; ++i) {
                    this._indexBufferList[i].dispose();
                }
                this._indexBufferList = null;

                for (i = 0; i < this._vertexBufferList.length; ++i) {
                    this._vertexBufferList[i].dispose();
                }
                this._vertexBufferList = null;

                for (i = 0; i < this._textureList.length; ++i) {
                    this._textureList[i].dispose();
                }
                this._textureList = null;

                for (i = 0; i < this._programList.length; ++i) {
                    this._programList[i].dispose();
                }

                for (i = 0; i < this._samplerStates.length; ++i) {
                    this._samplerStates[i] = null;
                }

                this._programList = null;
            };

            Context3D.prototype.drawToBitmapData = function (destination) {
                throw new away.errors.PartialImplementationError();
            };

            Context3D.prototype.drawTriangles = function (indexBuffer, firstIndex, numTriangles) {
                if (typeof firstIndex === "undefined") { firstIndex = 0; }
                if (typeof numTriangles === "undefined") { numTriangles = -1; }
                if (!this._drawing) {
                    throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
                }

                var numIndices = 0;

                if (numTriangles == -1) {
                    numIndices = indexBuffer.numIndices;
                } else {
                    numIndices = numTriangles * 3;
                }

                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
                this._gl.drawElements(this._gl.TRIANGLES, numIndices, this._gl.UNSIGNED_SHORT, firstIndex);
            };

            Context3D.prototype.present = function () {
                this._drawing = false;
                //this._gl.useProgram( null );
            };

            Context3D.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
                this._blendEnabled = true;

                switch (sourceFactor) {
                    case away.display3D.Context3DBlendFactor.ONE:
                        this._blendSourceFactor = this._gl.ONE;
                        break;
                    case away.display3D.Context3DBlendFactor.DESTINATION_ALPHA:
                        this._blendSourceFactor = this._gl.DST_ALPHA;
                        break;
                    case away.display3D.Context3DBlendFactor.DESTINATION_COLOR:
                        this._blendSourceFactor = this._gl.DST_COLOR;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE:
                        this._blendSourceFactor = this._gl.ONE;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA:
                        this._blendSourceFactor = this._gl.ONE_MINUS_DST_ALPHA;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE_MINUS_DESTINATION_COLOR:
                        this._blendSourceFactor = this._gl.ONE_MINUS_DST_COLOR;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA:
                        this._blendSourceFactor = this._gl.ONE_MINUS_SRC_ALPHA;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR:
                        this._blendSourceFactor = this._gl.ONE_MINUS_SRC_COLOR;
                        break;
                    case away.display3D.Context3DBlendFactor.SOURCE_ALPHA:
                        this._blendSourceFactor = this._gl.SRC_ALPHA;
                        break;
                    case away.display3D.Context3DBlendFactor.SOURCE_COLOR:
                        this._blendSourceFactor = this._gl.SRC_COLOR;
                        break;
                    case away.display3D.Context3DBlendFactor.ZERO:
                        this._blendSourceFactor = this._gl.ZERO;
                        break;
                    default:
                        throw "Unknown blend source factor";
                        break;
                }

                switch (destinationFactor) {
                    case away.display3D.Context3DBlendFactor.ONE:
                        this._blendDestinationFactor = this._gl.ONE;
                        break;
                    case away.display3D.Context3DBlendFactor.DESTINATION_ALPHA:
                        this._blendDestinationFactor = this._gl.DST_ALPHA;
                        break;
                    case away.display3D.Context3DBlendFactor.DESTINATION_COLOR:
                        this._blendDestinationFactor = this._gl.DST_COLOR;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE:
                        this._blendDestinationFactor = this._gl.ONE;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA:
                        this._blendDestinationFactor = this._gl.ONE_MINUS_DST_ALPHA;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE_MINUS_DESTINATION_COLOR:
                        this._blendDestinationFactor = this._gl.ONE_MINUS_DST_COLOR;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA:
                        this._blendDestinationFactor = this._gl.ONE_MINUS_SRC_ALPHA;
                        break;
                    case away.display3D.Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR:
                        this._blendDestinationFactor = this._gl.ONE_MINUS_SRC_COLOR;
                        break;
                    case away.display3D.Context3DBlendFactor.SOURCE_ALPHA:
                        this._blendDestinationFactor = this._gl.SRC_ALPHA;
                        break;
                    case away.display3D.Context3DBlendFactor.SOURCE_COLOR:
                        this._blendDestinationFactor = this._gl.SRC_COLOR;
                        break;
                    case away.display3D.Context3DBlendFactor.ZERO:
                        this._blendDestinationFactor = this._gl.ZERO;
                        break;
                    default:
                        throw "Unknown blend destination factor";
                        break;
                }

                this.updateBlendStatus();
            };

            Context3D.prototype.setColorMask = function (red, green, blue, alpha) {
                this._gl.colorMask(red, green, blue, alpha);
            };

            Context3D.prototype.setCulling = function (triangleFaceToCull) {
                if (triangleFaceToCull == display3D.Context3DTriangleFace.NONE) {
                    this._gl.disable(this._gl.CULL_FACE);
                } else {
                    this._gl.enable(this._gl.CULL_FACE);
                    switch (triangleFaceToCull) {
                        case display3D.Context3DTriangleFace.FRONT:
                            this._gl.cullFace(this._gl.FRONT);
                            break;
                        case display3D.Context3DTriangleFace.BACK:
                            this._gl.cullFace(this._gl.BACK);
                            break;
                        case display3D.Context3DTriangleFace.FRONT_AND_BACK:
                            this._gl.cullFace(this._gl.FRONT_AND_BACK);
                            break;
                        default:
                            throw "Unknown Context3DTriangleFace type.";
                    }
                }
            };

            // TODO Context3DCompareMode
            Context3D.prototype.setDepthTest = function (depthMask, passCompareMode) {
                switch (passCompareMode) {
                    case display3D.Context3DCompareMode.ALWAYS:
                        this._gl.depthFunc(this._gl.ALWAYS);
                        break;
                    case display3D.Context3DCompareMode.EQUAL:
                        this._gl.depthFunc(this._gl.EQUAL);
                        break;
                    case display3D.Context3DCompareMode.GREATER:
                        this._gl.depthFunc(this._gl.GREATER);
                        break;
                    case display3D.Context3DCompareMode.GREATER_EQUAL:
                        this._gl.depthFunc(this._gl.GEQUAL);
                        break;
                    case display3D.Context3DCompareMode.LESS:
                        this._gl.depthFunc(this._gl.LESS);
                        break;
                    case display3D.Context3DCompareMode.LESS_EQUAL:
                        this._gl.depthFunc(this._gl.LEQUAL);
                        break;
                    case display3D.Context3DCompareMode.NEVER:
                        this._gl.depthFunc(this._gl.NEVER);
                        break;
                    case display3D.Context3DCompareMode.NOT_EQUAL:
                        this._gl.depthFunc(this._gl.NOTEQUAL);
                        break;
                    default:
                        throw "Unknown Context3DCompareMode type.";
                        break;
                }
                this._gl.depthMask(depthMask);
            };

            Context3D.prototype.setProgram = function (program3D) {
                //TODO decide on construction/reference resposibilities
                this._currentProgram = program3D;
                program3D.focusProgram();
            };

            Context3D.prototype.getUniformLocationNameFromAgalRegisterIndex = function (programType, firstRegister) {
                switch (programType) {
                    case display3D.Context3DProgramType.VERTEX:
                        return "vc";
                        break;
                    case display3D.Context3DProgramType.FRAGMENT:
                        return "fc";
                        break;
                    default:
                        throw "Program Type " + programType + " not supported";
                }
            };

            /*
            public setProgramConstantsFromByteArray
            */
            Context3D.prototype.setProgramConstantsFromMatrix = function (programType, firstRegister, matrix, transposedMatrix) {
                if (typeof transposedMatrix === "undefined") { transposedMatrix = false; }
                var locationName = this.getUniformLocationNameFromAgalRegisterIndex(programType, firstRegister);
                this.setGLSLProgramConstantsFromMatrix(locationName, matrix, transposedMatrix);
            };

            Context3D.prototype.setProgramConstantsFromArray = function (programType, firstRegister, data, numRegisters) {
                if (typeof numRegisters === "undefined") { numRegisters = -1; }
                for (var i = 0; i < numRegisters; ++i) {
                    var currentIndex = i * 4;
                    var locationName = this.getUniformLocationNameFromAgalRegisterIndex(programType, firstRegister + i) + (i + firstRegister);

                    this.setGLSLProgramConstantsFromArray(locationName, data, currentIndex);
                }
            };

            /*
            public setGLSLProgramConstantsFromByteArray
            
            */
            Context3D.prototype.setGLSLProgramConstantsFromMatrix = function (locationName, matrix, transposedMatrix) {
                if (typeof transposedMatrix === "undefined") { transposedMatrix = false; }
                var location = this._gl.getUniformLocation(this._currentProgram.glProgram, locationName);
                this._gl.uniformMatrix4fv(location, !transposedMatrix, new Float32Array(matrix.rawData));
            };

            Context3D.prototype.setGLSLProgramConstantsFromArray = function (locationName, data, startIndex) {
                if (typeof startIndex === "undefined") { startIndex = 0; }
                var location = this._gl.getUniformLocation(this._currentProgram.glProgram, locationName);
                this._gl.uniform4f(location, data[startIndex], data[startIndex + 1], data[startIndex + 2], data[startIndex + 3]);
            };

            Context3D.prototype.setScissorRectangle = function (rectangle) {
                if (!rectangle) {
                    this._gl.disable(this._gl.SCISSOR_TEST);
                    return;
                }

                this._gl.enable(this._gl.SCISSOR_TEST);
                this._gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
            };

            Context3D.prototype.setTextureAt = function (sampler, texture) {
                var locationName = "fs" + sampler;
                this.setGLSLTextureAt(locationName, texture, sampler);
            };

            Context3D.prototype.setGLSLTextureAt = function (locationName, texture, textureIndex) {
                if (!texture) {
                    this._gl.activeTexture(this._gl.TEXTURE0 + (textureIndex));
                    this._gl.bindTexture(this._gl.TEXTURE_2D, null);
                    this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
                    return;
                }

                switch (textureIndex) {
                    case 0:
                        this._gl.activeTexture(this._gl.TEXTURE0);
                        break;
                    case 1:
                        this._gl.activeTexture(this._gl.TEXTURE1);
                        break;
                    case 2:
                        this._gl.activeTexture(this._gl.TEXTURE2);
                        break;
                    case 3:
                        this._gl.activeTexture(this._gl.TEXTURE3);
                        break;
                    case 4:
                        this._gl.activeTexture(this._gl.TEXTURE4);
                        break;
                    case 5:
                        this._gl.activeTexture(this._gl.TEXTURE5);
                        break;
                    case 6:
                        this._gl.activeTexture(this._gl.TEXTURE6);
                        break;
                    case 7:
                        this._gl.activeTexture(this._gl.TEXTURE7);
                        break;
                    default:
                        throw "Texture " + textureIndex + " is out of bounds.";
                }

                var location = this._gl.getUniformLocation(this._currentProgram.glProgram, locationName);

                if (texture.textureType == "texture2d") {
                    this._gl.bindTexture(this._gl.TEXTURE_2D, (texture).glTexture);
                    this._gl.uniform1i(location, textureIndex);

                    var samplerState = this._samplerStates[textureIndex];

                    if (samplerState.wrap != this._currentWrap) {
                        this._currentWrap = samplerState.wrap;
                        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, samplerState.wrap);
                        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, samplerState.wrap);
                    }

                    if (samplerState.filter != this._currentFilter) {
                        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, samplerState.filter);
                        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, samplerState.filter);
                    }
                    //this._gl.bindTexture( this._gl.TEXTURE_2D, null );
                } else if (texture.textureType == "textureCube") {
                    for (var i = 0; i < 6; ++i) {
                        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, (texture).glTextureAt(i));
                        this._gl.uniform1i(location, textureIndex);

                        var samplerState = this._samplerStates[textureIndex];

                        if (samplerState.wrap != this._currentWrap) {
                            this._currentWrap = samplerState.wrap;
                            this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_S, samplerState.wrap);
                            this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_T, samplerState.wrap);
                        }

                        if (samplerState.filter != this._currentFilter) {
                            this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_MIN_FILTER, samplerState.filter);
                            this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_MAG_FILTER, samplerState.filter);
                        }
                        //this._gl.bindTexture( this._gl.TEXTURE_CUBE_MAP, null );
                    }
                }
            };

            Context3D.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
                var glWrap = 0;
                var glFilter = 0;
                var glMipFilter = 0;

                switch (wrap) {
                    case display3D.Context3DWrapMode.REPEAT:
                        glWrap = this._gl.REPEAT;
                        break;
                    case display3D.Context3DWrapMode.CLAMP:
                        glWrap = this._gl.CLAMP_TO_EDGE;
                        break;
                    default:
                        throw "Wrap is not supported: " + wrap;
                }

                switch (filter) {
                    case display3D.Context3DTextureFilter.LINEAR:
                        glFilter = this._gl.LINEAR;
                        break;
                    case display3D.Context3DTextureFilter.NEAREST:
                        glFilter = this._gl.NEAREST;
                        break;
                    default:
                        throw "Filter is not supported " + filter;
                }

                switch (mipfilter) {
                    case display3D.Context3DMipFilter.MIPNEAREST:
                        glMipFilter = this._gl.NEAREST_MIPMAP_NEAREST;
                        break;
                    case display3D.Context3DMipFilter.MIPLINEAR:
                        glMipFilter = this._gl.LINEAR_MIPMAP_LINEAR;
                        break;
                    case display3D.Context3DMipFilter.MIPNONE:
                        glMipFilter = this._gl.NONE;
                        break;
                    default:
                        throw "MipFilter is not supported " + mipfilter;
                }

                if (0 <= sampler && sampler < Context3D.MAX_SAMPLERS) {
                    this._samplerStates[sampler].wrap = glWrap;
                    this._samplerStates[sampler].filter = glFilter;
                    this._samplerStates[sampler].mipfilter = glMipFilter;
                } else {
                    throw "Sampler is out of bounds.";
                }
            };

            Context3D.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
                if (typeof bufferOffset === "undefined") { bufferOffset = 0; }
                if (typeof format === "undefined") { format = null; }
                var locationName = "va" + index;
                this.setGLSLVertexBufferAt(locationName, buffer, bufferOffset, format);
            };

            Context3D.prototype.setGLSLVertexBufferAt = function (locationName, buffer, bufferOffset, format) {
                if (typeof bufferOffset === "undefined") { bufferOffset = 0; }
                if (typeof format === "undefined") { format = null; }
                //if ( buffer == null )return;
                var location = this._gl.getAttribLocation(this._currentProgram.glProgram, locationName);
                if (!buffer) {
                    if (location > -1) {
                        this._gl.disableVertexAttribArray(location);
                    }
                    return;
                }

                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer.glBuffer);

                var dimension;
                var type = this._gl.FLOAT;
                var numBytes = 4;

                switch (format) {
                    case display3D.Context3DVertexBufferFormat.BYTES_4:
                        dimension = 4;
                        break;
                    case display3D.Context3DVertexBufferFormat.FLOAT_1:
                        dimension = 1;
                        break;
                    case display3D.Context3DVertexBufferFormat.FLOAT_2:
                        dimension = 2;
                        break;
                    case display3D.Context3DVertexBufferFormat.FLOAT_3:
                        dimension = 3;
                        break;
                    case display3D.Context3DVertexBufferFormat.FLOAT_4:
                        dimension = 4;
                        break;
                    default:
                        throw "Buffer format " + format + " is not supported.";
                }

                this._gl.enableVertexAttribArray(location);
                this._gl.vertexAttribPointer(location, dimension, type, false, buffer.data32PerVertex * numBytes, bufferOffset * numBytes);
            };

            Context3D.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
                if (typeof enableDepthAndStencil === "undefined") { enableDepthAndStencil = false; }
                if (typeof antiAlias === "undefined") { antiAlias = 0; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                var frameBuffer = (target).frameBuffer;
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, frameBuffer);

                if (enableDepthAndStencil) {
                    this._gl.enable(this._gl.STENCIL_TEST);
                    this._gl.enable(this._gl.DEPTH_TEST);
                }

                this._gl.viewport.width = frameBuffer.width;
                this._gl.viewport.height = frameBuffer.height;

                this._gl.viewport(0, 0, frameBuffer.width, frameBuffer.height);
            };

            Context3D.prototype.setRenderToBackBuffer = function () {
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
            };

            Context3D.prototype.updateBlendStatus = function () {
                if (this._blendEnabled) {
                    this._gl.enable(this._gl.BLEND);
                    this._gl.blendEquation(this._gl.FUNC_ADD);
                    this._gl.blendFunc(this._blendSourceFactor, this._blendDestinationFactor);
                } else {
                    this._gl.disable(this._gl.BLEND);
                }
            };
            Context3D.MAX_SAMPLERS = 8;

            Context3D.modulo = 0;
            return Context3D;
        })();
        display3D.Context3D = Context3D;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display3D) {
        var AGLSLContext3D = (function (_super) {
            __extends(AGLSLContext3D, _super);
            function AGLSLContext3D(canvas) {
                _super.call(this, canvas);
                this._yFlip = -1;
            }
            //@override
            AGLSLContext3D.prototype.setProgramConstantsFromMatrix = function (programType, firstRegister, matrix, transposedMatrix) {
                if (typeof transposedMatrix === "undefined") { transposedMatrix = false; }
                /*
                console.log( "======== setProgramConstantsFromMatrix ========" );
                console.log( "programType       >>> " + programType );
                console.log( "firstRegister     >>> " + firstRegister );
                console.log( "matrix            >>> " + matrix.rawData );
                console.log( "transposedMatrix  >>> " + transposedMatrix );
                */
                var d = matrix.rawData;
                if (transposedMatrix) {
                    this.setProgramConstantsFromArray(programType, firstRegister, [d[0], d[4], d[8], d[12]], 1);
                    this.setProgramConstantsFromArray(programType, firstRegister + 1, [d[1], d[5], d[9], d[13]], 1);
                    this.setProgramConstantsFromArray(programType, firstRegister + 2, [d[2], d[6], d[10], d[14]], 1);
                    this.setProgramConstantsFromArray(programType, firstRegister + 3, [d[3], d[7], d[11], d[15]], 1);
                } else {
                    this.setProgramConstantsFromArray(programType, firstRegister, [d[0], d[1], d[2], d[3]], 1);
                    this.setProgramConstantsFromArray(programType, firstRegister + 1, [d[4], d[5], d[6], d[7]], 1);
                    this.setProgramConstantsFromArray(programType, firstRegister + 2, [d[8], d[9], d[10], d[11]], 1);
                    this.setProgramConstantsFromArray(programType, firstRegister + 3, [d[12], d[13], d[14], d[15]], 1);
                }
            };

            //@override
            AGLSLContext3D.prototype.drawTriangles = function (indexBuffer, firstIndex, numTriangles) {
                if (typeof firstIndex === "undefined") { firstIndex = 0; }
                if (typeof numTriangles === "undefined") { numTriangles = -1; }
                /*
                console.log( "======= drawTriangles ========" );
                console.log( indexBuffer );
                console.log( "firstIndex: " +  firstIndex );
                console.log( "numTriangles:" + numTriangles );
                */
                var location = this._gl.getUniformLocation(this._currentProgram.glProgram, "yflip");
                this._gl.uniform1f(location, this._yFlip);
                _super.prototype.drawTriangles.call(this, indexBuffer, firstIndex, numTriangles);
            };

            //@override
            AGLSLContext3D.prototype.setCulling = function (triangleFaceToCull) {
                switch (triangleFaceToCull) {
                    case display3D.Context3DTriangleFace.FRONT:
                        this._yFlip = -1;
                        break;
                    case display3D.Context3DTriangleFace.BACK:
                        this._yFlip = 1;
                        break;
                    case display3D.Context3DTriangleFace.FRONT_AND_BACK:
                        this._yFlip = 1;
                        break;
                    case display3D.Context3DTriangleFace.NONE:
                        this._yFlip = 1;
                        break;
                    default:
                        throw "Unknown culling mode " + triangleFaceToCull + ".";
                        break;
                }
            };
            return AGLSLContext3D;
        })(display3D.Context3D);
        display3D.AGLSLContext3D = AGLSLContext3D;
    })(away.display3D || (away.display3D = {}));
    var display3D = away.display3D;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * MaterialBase forms an abstract base class for any material.
        * A material consists of several passes, each of which constitutes at least one render call. Several passes could
        * be used for special effects (render lighting for many lights in several passes, render an outline in a separate
        * pass) or to provide additional render-to-texture passes (rendering diffuse light to texture for texture-space
        * subsurface scattering, or rendering a depth map for specialized self-shadowing).
        *
        * Away3D provides default materials trough SinglePassMaterialBase and MultiPassMaterialBase, which use modular
        * methods to build the shader code. MaterialBase can be extended to build specific and high-performant custom
        * shaders, or entire new material frameworks.
        */
        var MaterialBase = (function (_super) {
            __extends(MaterialBase, _super);
            /**
            * Creates a new MaterialBase object.
            */
            function MaterialBase() {
                _super.call(this);
                /**
                * An id for this material used to sort the renderables by shader program, which reduces Program3D state changes.
                *
                * @private
                */
                this._iRenderOrderId = 0;
                this._bothSides = false;
                this._pBlendMode = away.display.BlendMode.NORMAL;
                this._numPasses = 0;
                this._pMipmap = true;
                this._smooth = true;
                this._repeat = false;
                this._pDepthCompareMode = away.display3D.Context3DCompareMode.LESS_EQUAL;

                this._owners = new Array();
                this._passes = new Array();
                this._pDepthPass = new away.materials.DepthMapPass();
                this._pDistancePass = new away.materials.DistanceMapPass();

                this._pDepthPass.addEventListener(away.events.Event.CHANGE, this.onDepthPassChange, this);
                this._pDistancePass.addEventListener(away.events.Event.CHANGE, this.onDistancePassChange, this);

                this.alphaPremultiplied = true;

                this._iUniqueId = away.materials.MaterialBase.MATERIAL_ID_COUNT++;
            }
            Object.defineProperty(MaterialBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.MATERIAL;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialBase.prototype, "lightPicker", {
                get: /**
                * The light picker used by the material to provide lights to the material if it supports lighting.
                *
                * @see away3d.materials.lightpickers.LightPickerBase
                * @see away3d.materials.lightpickers.StaticLightPicker
                */
                function () {
                    return this._pLightPicker;
                },
                set: function (value) {
                    this.setLightPicker(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setLightPicker = function (value) {
                if (value != this._pLightPicker) {
                    this._pLightPicker = value;
                    var len = this._passes.length;

                    for (var i = 0; i < len; ++i) {
                        this._passes[i].lightPicker = this._pLightPicker;
                    }
                }
            };

            Object.defineProperty(MaterialBase.prototype, "mipmap", {
                get: /**
                * Indicates whether or not any used textures should use mipmapping. Defaults to true.
                */
                function () {
                    return this._pMipmap;
                },
                set: function (value) {
                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setMipMap = function (value) {
                this._pMipmap = value;

                for (var i = 0; i < this._numPasses; ++i) {
                    this._passes[i].mipmap = value;
                }
            };

            Object.defineProperty(MaterialBase.prototype, "smooth", {
                get: /**
                * Indicates whether or not any used textures should use smoothing.
                */
                function () {
                    return this._smooth;
                },
                set: function (value) {
                    this._smooth = value;

                    for (var i = 0; i < this._numPasses; ++i) {
                        this._passes[i].smooth = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "depthCompareMode", {
                get: /**
                * The depth compare mode used to render the renderables using this material.
                *
                * @see flash.display3D.Context3DCompareMode
                */
                function () {
                    return this._pDepthCompareMode;
                },
                set: function (value) {
                    this.setDepthCompareMode(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialBase.prototype.setDepthCompareMode = function (value) {
                this._pDepthCompareMode = value;
            };

            Object.defineProperty(MaterialBase.prototype, "repeat", {
                get: /**
                * Indicates whether or not any used textures should be tiled. If set to false, texture samples are clamped to
                * the texture's borders when the uv coordinates are outside the [0, 1] interval.
                */
                function () {
                    return this._repeat;
                },
                set: function (value) {
                    this._repeat = value;

                    for (var i = 0; i < this._numPasses; ++i) {
                        this._passes[i].repeat = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Cleans up resources owned by the material, including passes. Textures are not owned by the material since they
            * could be used by other materials and will not be disposed.
            */
            MaterialBase.prototype.dispose = function () {
                var i;

                for (i = 0; i < this._numPasses; ++i) {
                    this._passes[i].dispose();
                }

                this._pDepthPass.dispose();
                this._pDistancePass.dispose();

                this._pDepthPass.removeEventListener(away.events.Event.CHANGE, this.onDepthPassChange, this);
                this._pDistancePass.removeEventListener(away.events.Event.CHANGE, this.onDistancePassChange, this);
            };

            Object.defineProperty(MaterialBase.prototype, "bothSides", {
                get: /**
                * Defines whether or not the material should cull triangles facing away from the camera.
                */
                function () {
                    return this._bothSides;
                },
                set: function (value) {
                    this._bothSides = value;

                    for (var i = 0; i < this._numPasses; ++i) {
                        this._passes[i].bothSides = value;
                    }

                    this._pDepthPass.bothSides = value;
                    this._pDistancePass.bothSides = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "blendMode", {
                get: /**
                * The blend mode to use when drawing this renderable. The following blend modes are supported:
                * <ul>
                * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
                * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
                * <li>BlendMode.MULTIPLY</li>
                * <li>BlendMode.ADD</li>
                * <li>BlendMode.ALPHA</li>
                * </ul>
                */
                function () {
                    return this.getBlendMode();
                },
                set: function (value) {
                    this.setBlendMode(value);
                },
                enumerable: true,
                configurable: true
            });

            MaterialBase.prototype.getBlendMode = function () {
                return this._pBlendMode;
            };


            MaterialBase.prototype.setBlendMode = function (value) {
                this._pBlendMode = value;
            };

            Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
                get: /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied. Toggle this if you are seeing black halos around your
                * blended alpha edges.
                */
                function () {
                    return this._alphaPremultiplied;
                },
                set: function (value) {
                    this._alphaPremultiplied = value;

                    for (var i = 0; i < this._numPasses; ++i) {
                        this._passes[i].alphaPremultiplied = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialBase.prototype, "requiresBlending", {
                get: /**
                * Indicates whether or not the material requires alpha blending during rendering.
                */
                function () {
                    return this.getRequiresBlending();
                },
                enumerable: true,
                configurable: true
            });

            MaterialBase.prototype.getRequiresBlending = function () {
                return this._pBlendMode != away.display.BlendMode.NORMAL;
            };

            Object.defineProperty(MaterialBase.prototype, "uniqueId", {
                get: /**
                * An id for this material used to sort the renderables by material, which reduces render state changes across
                * materials using the same Program3D.
                */
                function () {
                    return this._iUniqueId;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialBase.prototype, "_iNumPasses", {
                get: /**
                * The amount of passes used by the material.
                *
                * @private
                */
                function () {
                    return this._numPasses;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates that the depth pass uses transparency testing to discard pixels.
            *
            * @private
            */
            MaterialBase.prototype.iHasDepthAlphaThreshold = function () {
                return this._pDepthPass.alphaThreshold > 0;
            };

            /**
            * Sets the render state for the depth pass that is independent of the rendered object. Used when rendering
            * depth or distances (fe: shadow maps, depth pre-pass).
            *
            * @param stage3DProxy The Stage3DProxy used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @param distanceBased Whether or not the depth pass or distance pass should be activated. The distance pass
            * is required for shadow cube maps.
            *
            * @private
            */
            MaterialBase.prototype.iActivateForDepth = function (stage3DProxy, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                this._distanceBasedDepthRender = distanceBased;

                if (distanceBased) {
                    this._pDistancePass.iActivate(stage3DProxy, camera);
                } else {
                    this._pDepthPass.iActivate(stage3DProxy, camera);
                }
            };

            /**
            * Clears the render state for the depth pass.
            *
            * @param stage3DProxy The Stage3DProxy used for rendering.
            *
            * @private
            */
            MaterialBase.prototype.iDeactivateForDepth = function (stage3DProxy) {
                if (this._distanceBasedDepthRender) {
                    this._pDistancePass.iDeactivate(stage3DProxy);
                } else {
                    this._pDepthPass.iDeactivate(stage3DProxy);
                }
            };

            /**
            * Renders a renderable using the depth pass.
            *
            * @param renderable The IRenderable instance that needs to be rendered.
            * @param stage3DProxy The Stage3DProxy used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
            * camera.viewProjection as it includes the scaling factors when rendering to textures.
            *
            * @private
            */
            MaterialBase.prototype.iRenderDepth = function (renderable, stage3DProxy, camera, viewProjection) {
                if (this._distanceBasedDepthRender) {
                    if (renderable.animator) {
                        this._pDistancePass.iUpdateAnimationState(renderable, stage3DProxy, camera);
                    }

                    this._pDistancePass.iRender(renderable, stage3DProxy, camera, viewProjection);
                } else {
                    if (renderable.animator) {
                        this._pDepthPass.iUpdateAnimationState(renderable, stage3DProxy, camera);
                    }

                    this._pDepthPass.iRender(renderable, stage3DProxy, camera, viewProjection);
                }
            };

            //*/
            /**
            * Indicates whether or not the pass with the given index renders to texture or not.
            * @param index The index of the pass.
            * @return True if the pass renders to texture, false otherwise.
            *
            * @private
            */
            MaterialBase.prototype.iPassRendersToTexture = function (index) {
                return this._passes[index].renderToTexture;
            };

            /**
            * Sets the render state for a pass that is independent of the rendered object. This needs to be called before
            * calling renderPass. Before activating a pass, the previously used pass needs to be deactivated.
            * @param index The index of the pass to activate.
            * @param stage3DProxy The Stage3DProxy object which is currently used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @private
            */
            MaterialBase.prototype.iActivatePass = function (index, stage3DProxy, camera) {
                this._passes[index].iActivate(stage3DProxy, camera);
            };

            /**
            * Clears the render state for a pass. This needs to be called before activating another pass.
            * @param index The index of the pass to deactivate.
            * @param stage3DProxy The Stage3DProxy used for rendering
            *
            * @private
            */
            MaterialBase.prototype.iDeactivatePass = function (index, stage3DProxy) {
                this._passes[index].iDeactivate(stage3DProxy);
            };

            /**
            * Renders the current pass. Before calling renderPass, activatePass needs to be called with the same index.
            * @param index The index of the pass used to render the renderable.
            * @param renderable The IRenderable object to draw.
            * @param stage3DProxy The Stage3DProxy object used for rendering.
            * @param entityCollector The EntityCollector object that contains the visible scene data.
            * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
            * camera.viewProjection as it includes the scaling factors when rendering to textures.
            */
            MaterialBase.prototype.iRenderPass = function (index, renderable, stage3DProxy, entityCollector, viewProjection) {
                if (this._pLightPicker) {
                    this._pLightPicker.collectLights(renderable, entityCollector);
                }

                var pass = this._passes[index];

                if (renderable.animator) {
                    pass.iUpdateAnimationState(renderable, stage3DProxy, entityCollector.camera);
                }

                pass.iRender(renderable, stage3DProxy, entityCollector.camera, viewProjection);
            };

            //
            // MATERIAL MANAGEMENT
            //
            /**
            * Mark an IMaterialOwner as owner of this material.
            * Assures we're not using the same material across renderables with different animations, since the
            * Program3Ds depend on animation. This method needs to be called when a material is assigned.
            *
            * @param owner The IMaterialOwner that had this material assigned
            *
            * @private
            */
            MaterialBase.prototype.iAddOwner = function (owner) {
                this._owners.push(owner);

                if (owner.animator) {
                    if (this._animationSet && owner.animator.animationSet != this._animationSet) {
                        throw new Error("A Material instance cannot be shared across renderables with different animator libraries");
                    } else {
                        if (this._animationSet != owner.animator.animationSet) {
                            this._animationSet = owner.animator.animationSet;

                            for (var i = 0; i < this._numPasses; ++i) {
                                this._passes[i].setAnimationSet(this._animationSet);
                            }

                            this._pDepthPass.setAnimationSet(this._animationSet);
                            this._pDistancePass.setAnimationSet(this._animationSet);

                            this.iInvalidatePasses(null);
                        }
                    }
                }
            };

            //*/
            /**
            * Removes an IMaterialOwner as owner.
            * @param owner
            * @private
            */
            MaterialBase.prototype.iRemoveOwner = function (owner) {
                this._owners.splice(this._owners.indexOf(owner), 1);

                if (this._owners.length == 0) {
                    this._animationSet = null;

                    for (var i = 0; i < this._numPasses; ++i) {
                        this._passes[i].setAnimationSet(this._animationSet);
                    }

                    this._pDepthPass.setAnimationSet(this._animationSet);
                    this._pDistancePass.setAnimationSet(this._animationSet);
                    this.iInvalidatePasses(null);
                }
            };

            Object.defineProperty(MaterialBase.prototype, "iOwners", {
                get: //*/
                /**
                * A list of the IMaterialOwners that use this material
                *
                * @private
                */
                function () {
                    return this._owners;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Performs any processing that needs to occur before any of its passes are used.
            *
            * @private
            */
            MaterialBase.prototype.iUpdateMaterial = function (context) {
                //throw new away.errors.AbstractMethodError();
            };

            /**
            * Deactivates the last pass of the material.
            *
            * @private
            */
            MaterialBase.prototype.iDeactivate = function (stage3DProxy) {
                this._passes[this._numPasses - 1].iDeactivate(stage3DProxy);
            };

            /**
            * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
            * @param triggerPass The pass triggering the invalidation, if any. This is passed to prevent invalidating the
            * triggering pass, which would result in an infinite loop.
            *
            * @private
            */
            MaterialBase.prototype.iInvalidatePasses = function (triggerPass) {
                var owner;

                var l;
                var c;

                this._pDepthPass.iInvalidateShaderProgram();
                this._pDistancePass.iInvalidateShaderProgram();

                if (this._animationSet) {
                    this._animationSet.resetGPUCompatibility();

                    l = this._owners.length;

                    for (c = 0; c < l; c++) {
                        owner = this._owners[c];

                        if (owner.animator) {
                            owner.animator.testGPUCompatibility(this._pDepthPass);
                            owner.animator.testGPUCompatibility(this._pDistancePass);
                        }
                    }
                }

                for (var i = 0; i < this._numPasses; ++i) {
                    if (this._passes[i] != triggerPass) {
                        this._passes[i].iInvalidateShaderProgram(false);
                    }

                    if (this._animationSet) {
                        l = this._owners.length;

                        for (c = 0; c < l; c++) {
                            owner = this._owners[c];

                            if (owner.animator) {
                                owner.animator.testGPUCompatibility(this._passes[i]);
                            }
                        }
                    }
                }
            };

            /**
            * Removes a pass from the material.
            * @param pass The pass to be removed.
            */
            MaterialBase.prototype.pRemovePass = function (pass) {
                this._passes.splice(this._passes.indexOf(pass), 1);
                --this._numPasses;
            };

            /**
            * Removes all passes from the material
            */
            MaterialBase.prototype.pClearPasses = function () {
                for (var i = 0; i < this._numPasses; ++i) {
                    this._passes[i].removeEventListener(away.events.Event.CHANGE, this.onPassChange, this);
                }

                this._passes.length = 0;
                this._numPasses = 0;
            };

            /**
            * Adds a pass to the material
            * @param pass
            */
            MaterialBase.prototype.pAddPass = function (pass) {
                this._passes[this._numPasses++] = pass;
                pass.animationSet = this._animationSet;
                pass.alphaPremultiplied = this._alphaPremultiplied;
                pass.mipmap = this._pMipmap;
                pass.smooth = this._smooth;
                pass.repeat = this._repeat;
                pass.lightPicker = this._pLightPicker;
                pass.bothSides = this._bothSides;
                pass.addEventListener(away.events.Event.CHANGE, this.onPassChange, this);
                this.iInvalidatePasses(null);
            };

            /**
            * Listener for when a pass's shader code changes. It recalculates the render order id.
            */
            MaterialBase.prototype.onPassChange = function (event) {
                var mult = 1;
                var ids;
                var len;

                this._iRenderOrderId = 0;

                for (var i = 0; i < this._numPasses; ++i) {
                    ids = this._passes[i]._iProgram3Dids;
                    len = ids.length;

                    for (var j = 0; j < len; ++j) {
                        if (ids[j] != -1) {
                            this._iRenderOrderId += mult * ids[j];
                            j = len;
                        }
                    }

                    mult *= 1000;
                }
            };

            /**
            * Listener for when the distance pass's shader code changes. It recalculates the depth pass id.
            */
            MaterialBase.prototype.onDistancePassChange = function (event) {
                var ids = this._pDistancePass._iProgram3Dids;
                var len = ids.length;

                this._iDepthPassId = 0;

                for (var j = 0; j < len; ++j) {
                    if (ids[j] != -1) {
                        this._iDepthPassId += ids[j];
                        j = len;
                    }
                }
            };

            /**
            * Listener for when the depth pass's shader code changes. It recalculates the depth pass id.
            */
            MaterialBase.prototype.onDepthPassChange = function (event) {
                var ids = this._pDepthPass._iProgram3Dids;
                var len = ids.length;

                this._iDepthPassId = 0;

                for (var j = 0; j < len; ++j) {
                    if (ids[j] != -1) {
                        this._iDepthPassId += ids[j];
                        j = len;
                    }
                }
            };
            MaterialBase.MATERIAL_ID_COUNT = 0;
            return MaterialBase;
        })(away.library.NamedAssetBase);
        materials.MaterialBase = MaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (primitives) {
        var Segment = (function () {
            function Segment(start, end, anchor, colorStart, colorEnd, thickness) {
                if (typeof colorStart === "undefined") { colorStart = 0x333333; }
                if (typeof colorEnd === "undefined") { colorEnd = 0x333333; }
                if (typeof thickness === "undefined") { thickness = 1; }
                this._index = -1;
                this._subSetIndex = -1;
                // TODO: not yet used: for CurveSegment support
                anchor = null;

                this._pThickness = thickness * 0.5;

                // TODO: add support for curve using anchor v1
                // Prefer removing v1 from this, and make Curve a separate class extending Segment? (- David)
                this._pStart = start;
                this._pEnd = end;
                this.startColor = colorStart;
                this.endColor = colorEnd;
            }
            Segment.prototype.updateSegment = function (start, end, anchor, colorStart, colorEnd, thickness) {
                if (typeof colorStart === "undefined") { colorStart = 0x333333; }
                if (typeof colorEnd === "undefined") { colorEnd = 0x333333; }
                if (typeof thickness === "undefined") { thickness = 1; }
                // TODO: not yet used: for CurveSegment support
                anchor = null;
                this._pStart = start;
                this._pEnd = end;

                if (this._startColor != colorStart) {
                    this.startColor = colorStart;
                }
                if (this._endColor != colorEnd) {
                    this.endColor = colorEnd;
                }
                this._pThickness = thickness * 0.5;
                this.update();
            };

            Object.defineProperty(Segment.prototype, "start", {
                get: function () {
                    return this._pStart;
                },
                set: function (value) {
                    this._pStart = value;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "end", {
                get: function () {
                    return this._pEnd;
                },
                set: function (value) {
                    this._pEnd = value;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "thickness", {
                get: function () {
                    return this._pThickness * 2;
                },
                set: function (value) {
                    this._pThickness = value * 0.5;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "startColor", {
                get: function () {
                    return this._startColor;
                },
                set: function (color) {
                    this._pStartR = ((color >> 16) & 0xff) / 255;
                    this._pStartG = ((color >> 8) & 0xff) / 255;
                    this._pStartB = (color & 0xff) / 255;

                    this._startColor = color;

                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "endColor", {
                get: function () {
                    return this._endColor;
                },
                set: function (color) {
                    this._pEndR = ((color >> 16) & 0xff) / 255;
                    this._pEndG = ((color >> 8) & 0xff) / 255;
                    this._pEndB = (color & 0xff) / 255;

                    this._endColor = color;

                    this.update();
                },
                enumerable: true,
                configurable: true
            });


            Segment.prototype.dispose = function () {
                this._pStart = null;
                this._pEnd = null;
            };

            Object.defineProperty(Segment.prototype, "iIndex", {
                get: function () {
                    return this._index;
                },
                set: function (ind) {
                    this._index = ind;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "iSubSetIndex", {
                get: function () {
                    return this._subSetIndex;
                },
                set: function (ind) {
                    this._subSetIndex = ind;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Segment.prototype, "iSegmentsBase", {
                set: function (segBase) {
                    this._pSegmentsBase = segBase;
                },
                enumerable: true,
                configurable: true
            });

            Segment.prototype.update = function () {
                if (!this._pSegmentsBase) {
                    return;
                }
                this._pSegmentsBase.iUpdateSegment(this);
            };
            return Segment;
        })();
        primitives.Segment = Segment;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (bounds) {
        var BoundingVolumeBase = (function () {
            function BoundingVolumeBase() {
                this._pAabbPoints = [];
                this._pAabbPointsDirty = true;
                this._pMin = new away.geom.Vector3D();
                this._pMax = new away.geom.Vector3D();
            }
            Object.defineProperty(BoundingVolumeBase.prototype, "max", {
                get: function () {
                    return this._pMax;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(BoundingVolumeBase.prototype, "min", {
                get: function () {
                    return this._pMin;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(BoundingVolumeBase.prototype, "aabbPoints", {
                get: function () {
                    if (this._pAabbPointsDirty) {
                        this.pUpdateAABBPoints();
                    }
                    return this._pAabbPoints;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(BoundingVolumeBase.prototype, "boundingRenderable", {
                get: function () {
                    if (!this._pBoundingRenderable) {
                        this._pBoundingRenderable = this.pCreateBoundingRenderable();
                        this.pUpdateBoundingRenderable();
                    }
                    return this._pBoundingRenderable;
                },
                enumerable: true,
                configurable: true
            });

            BoundingVolumeBase.prototype.nullify = function () {
                this._pMin.x = this._pMin.y = this._pMin.z = 0;
                this._pMax.x = this._pMax.y = this._pMax.z = 0;
                this._pAabbPointsDirty = true;

                if (this._pBoundingRenderable) {
                    this.pUpdateBoundingRenderable();
                }
            };

            BoundingVolumeBase.prototype.disposeRenderable = function () {
                if (this._pBoundingRenderable) {
                    this._pBoundingRenderable.dispose();
                }
                this._pBoundingRenderable = null;
            };

            BoundingVolumeBase.prototype.fromVertices = function (vertices) {
                var i;
                var len = vertices.length;
                var minX, minY, minZ;
                var maxX, maxY, maxZ;

                if (len == 0) {
                    this.nullify();
                    return;
                }

                var v;

                minX = maxX = vertices[i++];
                minY = maxY = vertices[i++];
                minZ = maxZ = vertices[i++];

                while (i < len) {
                    v = vertices[i++];
                    if (v < minX)
                        minX = v;
else if (v > maxX)
                        maxX = v;
                    v = vertices[i++];
                    if (v < minY)
                        minY = v;
else if (v > maxY)
                        maxY = v;
                    v = vertices[i++];
                    if (v < minZ)
                        minZ = v;
else if (v > maxZ)
                        maxZ = v;
                }

                this.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
            };

            BoundingVolumeBase.prototype.fromGeometry = function (geometry) {
                var subGeoms = geometry.subGeometries;
                var numSubGeoms = subGeoms.length;
                var minX, minY, minZ;
                var maxX, maxY, maxZ;

                if (numSubGeoms > 0) {
                    var j = 0;

                    minX = minY = minZ = Number.POSITIVE_INFINITY;
                    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;

                    while (j < numSubGeoms) {
                        var subGeom = subGeoms[j++];
                        var vertices = subGeom.vertexData;
                        var vertexDataLen = vertices.length;
                        var i = subGeom.vertexOffset;
                        var stride = subGeom.vertexStride;

                        while (i < vertexDataLen) {
                            var v = vertices[i];
                            if (v < minX) {
                                minX = v;
                            } else if (v > maxX) {
                                maxX = v;
                            }

                            v = vertices[i + 1];

                            if (v < minY) {
                                minY = v;
                            } else if (v > maxY) {
                                maxY = v;
                            }

                            v = vertices[i + 2];

                            if (v < minZ) {
                                minZ = v;
                            } else if (v > maxZ) {
                                maxZ = v;
                            }

                            i += stride;
                        }
                    }

                    this.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
                } else {
                    this.fromExtremes(0, 0, 0, 0, 0, 0);
                }
            };

            BoundingVolumeBase.prototype.fromSphere = function (center, radius) {
                this.fromExtremes(center.x - radius, center.y - radius, center.z - radius, center.x + radius, center.y + radius, center.z + radius);
            };

            BoundingVolumeBase.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
                this._pMin.x = minX;
                this._pMin.y = minY;
                this._pMin.z = minZ;
                this._pMax.x = maxX;
                this._pMax.y = maxY;
                this._pMax.z = maxZ;
                this._pAabbPointsDirty = true;

                if (this._pBoundingRenderable) {
                    this.pUpdateBoundingRenderable();
                }
            };

            BoundingVolumeBase.prototype.isInFrustum = function (planes, numPlanes) {
                throw new away.errors.AbstractMethodError();
            };

            BoundingVolumeBase.prototype.overlaps = function (bounds) {
                var min = bounds._pMin;
                var max = bounds._pMax;
                return this._pMax.x > min.x && this._pMin.x < max.x && this._pMax.y > min.y && this._pMin.y < max.y && this._pMax.z > min.z && this._pMin.z < max.z;
            };

            BoundingVolumeBase.prototype.clone = function () {
                throw new away.errors.AbstractMethodError();
            };

            BoundingVolumeBase.prototype.rayIntersection = function (position, direction, targetNormal) {
                position = position;
                direction = direction;
                targetNormal = targetNormal;
                return -1;
            };

            BoundingVolumeBase.prototype.containsPoint = function (position) {
                position = position;
                return false;
            };

            BoundingVolumeBase.prototype.pUpdateAABBPoints = function () {
                var maxX = this._pMax.x;
                var maxY = this._pMax.y;
                var maxZ = this._pMax.z;
                var minX = this._pMin.x;
                var minY = this._pMin.y;
                var minZ = this._pMin.z;

                this._pAabbPoints[0] = minX;
                this._pAabbPoints[1] = minY;
                this._pAabbPoints[2] = minZ;
                this._pAabbPoints[3] = maxX;
                this._pAabbPoints[4] = minY;
                this._pAabbPoints[5] = minZ;
                this._pAabbPoints[6] = minX;
                this._pAabbPoints[7] = maxY;
                this._pAabbPoints[8] = minZ;
                this._pAabbPoints[9] = maxX;
                this._pAabbPoints[10] = maxY;
                this._pAabbPoints[11] = minZ;
                this._pAabbPoints[12] = minX;
                this._pAabbPoints[13] = minY;
                this._pAabbPoints[14] = maxZ;
                this._pAabbPoints[15] = maxX;
                this._pAabbPoints[16] = minY;
                this._pAabbPoints[17] = maxZ;
                this._pAabbPoints[18] = minX;
                this._pAabbPoints[19] = maxY;
                this._pAabbPoints[20] = maxZ;
                this._pAabbPoints[21] = maxX;
                this._pAabbPoints[22] = maxY;
                this._pAabbPoints[23] = maxZ;
                this._pAabbPointsDirty = false;
            };

            BoundingVolumeBase.prototype.pUpdateBoundingRenderable = function () {
                throw new away.errors.AbstractMethodError();
            };

            BoundingVolumeBase.prototype.pCreateBoundingRenderable = function () {
                throw new away.errors.AbstractMethodError();
            };

            BoundingVolumeBase.prototype.classifyToPlane = function (plane) {
                throw new away.errors.AbstractMethodError();
            };

            BoundingVolumeBase.prototype.transformFrom = function (bounds, matrix) {
                throw new away.errors.AbstractMethodError();
            };
            return BoundingVolumeBase;
        })();
        bounds.BoundingVolumeBase = BoundingVolumeBase;
    })(away.bounds || (away.bounds = {}));
    var bounds = away.bounds;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        var LensEvent = (function (_super) {
            __extends(LensEvent, _super);
            function LensEvent(type, lens) {
                _super.call(this, type);
                this._lens = lens;
            }
            Object.defineProperty(LensEvent.prototype, "lens", {
                get: function () {
                    return this._lens;
                },
                enumerable: true,
                configurable: true
            });
            LensEvent.MATRIX_CHANGED = "matrixChanged";
            return LensEvent;
        })(away.events.Event);
        events.LensEvent = LensEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (cameras) {
        var LensBase = (function (_super) {
            __extends(LensBase, _super);
            function LensBase() {
                _super.call(this);
                this._pScissorRect = new away.geom.Rectangle();
                this._pViewPort = new away.geom.Rectangle();
                this._pNear = 20;
                this._pFar = 3000;
                this._pAspectRatio = 1;
                this._pMatrixInvalid = true;
                this._pFrustumCorners = [];
                this._unprojectionInvalid = true;
                this._pMatrix = new away.geom.Matrix3D();
            }
            Object.defineProperty(LensBase.prototype, "frustumCorners", {
                get: function () {
                    return this._pFrustumCorners;
                },
                set: function (frustumCorners) {
                    this._pFrustumCorners = frustumCorners;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LensBase.prototype, "matrix", {
                get: function () {
                    if (this._pMatrixInvalid) {
                        this.pUpdateMatrix();
                        this._pMatrixInvalid = false;
                    }
                    return this._pMatrix;
                },
                set: function (value) {
                    this._pMatrix = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LensBase.prototype, "near", {
                get: function () {
                    return this._pNear;
                },
                set: function (value) {
                    if (value == this._pNear) {
                        return;
                    }
                    this._pNear = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LensBase.prototype, "far", {
                get: function () {
                    return this._pFar;
                },
                set: function (value) {
                    if (value == this._pFar) {
                        return;
                    }
                    this._pFar = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            LensBase.prototype.project = function (point3d) {
                var v = this.matrix.transformVector(point3d);
                v.x = v.x / v.w;
                v.y = -v.y / v.w;

                //z is unaffected by transform
                v.z = point3d.z;

                return v;
            };

            Object.defineProperty(LensBase.prototype, "unprojectionMatrix", {
                get: function () {
                    if (this._unprojectionInvalid) {
                        if (!this._unprojection) {
                            this._unprojection = new away.geom.Matrix3D();
                        }
                        this._unprojection.copyFrom(this.matrix);
                        this._unprojection.invert();
                        this._unprojectionInvalid = false;
                    }
                    return this._unprojection;
                },
                enumerable: true,
                configurable: true
            });

            LensBase.prototype.unproject = function (nX, nY, sZ) {
                throw new away.errors.AbstractMethodError();
            };

            LensBase.prototype.clone = function () {
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(LensBase.prototype, "iAspectRatio", {
                get: function () {
                    return this._pAspectRatio;
                },
                set: function (value) {
                    if (this._pAspectRatio == value) {
                        return;
                    }
                    this._pAspectRatio = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            LensBase.prototype.pInvalidateMatrix = function () {
                this._pMatrixInvalid = true;
                this._unprojectionInvalid = true;
                this.dispatchEvent(new away.events.LensEvent(away.events.LensEvent.MATRIX_CHANGED, this));
            };

            LensBase.prototype.pUpdateMatrix = function () {
                throw new away.errors.AbstractMethodError();
            };

            LensBase.prototype.iUpdateScissorRect = function (x, y, width, height) {
                this._pScissorRect.x = x;
                this._pScissorRect.y = y;
                this._pScissorRect.width = width;
                this._pScissorRect.height = height;
                this.pInvalidateMatrix();
            };

            LensBase.prototype.iUpdateViewport = function (x, y, width, height) {
                this._pViewPort.x = x;
                this._pViewPort.y = y;
                this._pViewPort.width = width;
                this._pViewPort.height = height;
                this.pInvalidateMatrix();
            };
            return LensBase;
        })(away.events.EventDispatcher);
        cameras.LensBase = LensBase;
    })(away.cameras || (away.cameras = {}));
    var cameras = away.cameras;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (cameras) {
        var PerspectiveLens = (function (_super) {
            __extends(PerspectiveLens, _super);
            function PerspectiveLens(fieldOfView) {
                if (typeof fieldOfView === "undefined") { fieldOfView = 60; }
                _super.call(this);
                this.fieldOfView = fieldOfView;
            }
            Object.defineProperty(PerspectiveLens.prototype, "fieldOfView", {
                get: function () {
                    return this._fieldOfView;
                },
                set: function (value) {
                    if (value == this._fieldOfView) {
                        return;
                    }
                    this._fieldOfView = value;

                    this._focalLengthInv = Math.tan(this._fieldOfView * Math.PI / 360);
                    this._focalLength = 1 / this._focalLengthInv;

                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PerspectiveLens.prototype, "focalLength", {
                get: function () {
                    return this._focalLength;
                },
                set: function (value) {
                    if (value == this._focalLength) {
                        return;
                    }
                    this._focalLength = value;

                    this._focalLengthInv = 1 / this._focalLength;
                    this._fieldOfView = Math.atan(this._focalLengthInv) * 360 / Math.PI;

                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            //@override
            PerspectiveLens.prototype.unproject = function (nX, nY, sZ) {
                var v = new away.geom.Vector3D(nX, -nY, sZ, 1.0);

                v.x *= sZ;
                v.y *= sZ;
                v.z = sZ;
                v = this.unprojectionMatrix.transformVector(v);

                return v;
            };

            //@override
            PerspectiveLens.prototype.clone = function () {
                var clone = new PerspectiveLens(this._fieldOfView);
                clone._pNear = this._pNear;
                clone._pFar = this._pFar;
                clone._pAspectRatio = this._pAspectRatio;
                return clone;
            };

            //@override
            PerspectiveLens.prototype.pUpdateMatrix = function () {
                var raw = [];

                this._yMax = this._pNear * this._focalLengthInv;
                this._xMax = this._yMax * this._pAspectRatio;

                var left, right, top, bottom;

                if (this._pScissorRect.x == 0 && this._pScissorRect.y == 0 && this._pScissorRect.width == this._pViewPort.width && this._pScissorRect.height == this._pViewPort.height) {
                    // assume unscissored frustum
                    left = -this._xMax;
                    right = this._xMax;
                    top = -this._yMax;
                    bottom = this._yMax;

                    // assume unscissored frustum
                    raw[0] = this._pNear / this._xMax;
                    raw[5] = this._pNear / this._yMax;
                    raw[10] = this._pFar / (this._pFar - this._pNear);
                    raw[11] = 1;
                    raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[12] = raw[13] = raw[15] = 0;
                    raw[14] = -this._pNear * raw[10];
                } else {
                    // assume scissored frustum
                    var xWidth = this._xMax * (this._pViewPort.width / this._pScissorRect.width);
                    var yHgt = this._yMax * (this._pViewPort.height / this._pScissorRect.height);
                    var center = this._xMax * (this._pScissorRect.x * 2 - this._pViewPort.width) / this._pScissorRect.width + this._xMax;
                    var middle = -this._yMax * (this._pScissorRect.y * 2 - this._pViewPort.height) / this._pScissorRect.height - this._yMax;

                    left = center - xWidth;
                    right = center + xWidth;
                    top = middle - yHgt;
                    bottom = middle + yHgt;

                    raw[0] = 2 * this._pNear / (right - left);
                    raw[5] = 2 * this._pNear / (bottom - top);
                    raw[8] = (right + left) / (right - left);
                    raw[9] = (bottom + top) / (bottom - top);
                    raw[10] = (this._pFar + this._pNear) / (this._pFar - this._pNear);
                    raw[11] = 1;
                    raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[12] = raw[13] = raw[15] = 0;
                    raw[14] = -2 * this._pFar * this._pNear / (this._pFar - this._pNear);
                }

                this._pMatrix.copyRawDataFrom(raw);

                var yMaxFar = this._pFar * this._focalLengthInv;
                var xMaxFar = yMaxFar * this._pAspectRatio;

                this._pFrustumCorners[0] = this._pFrustumCorners[9] = left;
                this._pFrustumCorners[3] = this._pFrustumCorners[6] = right;
                this._pFrustumCorners[1] = this._pFrustumCorners[4] = top;
                this._pFrustumCorners[7] = this._pFrustumCorners[10] = bottom;

                this._pFrustumCorners[12] = this._pFrustumCorners[21] = -xMaxFar;
                this._pFrustumCorners[15] = this._pFrustumCorners[18] = xMaxFar;
                this._pFrustumCorners[13] = this._pFrustumCorners[16] = -yMaxFar;
                this._pFrustumCorners[19] = this._pFrustumCorners[22] = yMaxFar;

                this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
                this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;

                this._pMatrixInvalid = false;
            };
            return PerspectiveLens;
        })(away.cameras.LensBase);
        cameras.PerspectiveLens = PerspectiveLens;
    })(away.cameras || (away.cameras = {}));
    var cameras = away.cameras;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (cameras) {
        var FreeMatrixLens = (function (_super) {
            __extends(FreeMatrixLens, _super);
            function FreeMatrixLens() {
                _super.call(this);
                this._pMatrix.copyFrom(new away.cameras.PerspectiveLens().matrix);
            }
            Object.defineProperty(FreeMatrixLens.prototype, "near", {
                set: //@override
                function (value) {
                    this._pNear = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(FreeMatrixLens.prototype, "far", {
                set: //@override
                function (value) {
                    this._pFar = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(FreeMatrixLens.prototype, "iAspectRatio", {
                set: //@override
                function (value) {
                    this._pAspectRatio = value;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            FreeMatrixLens.prototype.clone = function () {
                var clone = new away.cameras.FreeMatrixLens();
                clone._pMatrix.copyFrom(this._pMatrix);
                clone._pNear = this._pNear;
                clone._pFar = this._pFar;
                clone._pAspectRatio = this._pAspectRatio;
                clone.pInvalidateMatrix();
                return clone;
            };

            //@override
            FreeMatrixLens.prototype.pUpdateMatrix = function () {
                this._pMatrixInvalid = false;
            };
            return FreeMatrixLens;
        })(away.cameras.LensBase);
        cameras.FreeMatrixLens = FreeMatrixLens;
    })(away.cameras || (away.cameras = {}));
    var cameras = away.cameras;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (cameras) {
        var OrthographicLens = (function (_super) {
            __extends(OrthographicLens, _super);
            function OrthographicLens(projectionHeight) {
                if (typeof projectionHeight === "undefined") { projectionHeight = 500; }
                _super.call(this);
                this._projectionHeight = projectionHeight;
            }
            Object.defineProperty(OrthographicLens.prototype, "projectionHeight", {
                get: function () {
                    return this._projectionHeight;
                },
                set: function (value) {
                    if (value == this._projectionHeight) {
                        return;
                    }
                    this._projectionHeight = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            //@override
            OrthographicLens.prototype.unproject = function (nX, nY, sZ) {
                var v = new away.geom.Vector3D(nX + this.matrix.rawData[12], -nY + this.matrix.rawData[13], sZ, 1.0);
                v = this.unprojectionMatrix.transformVector(v);

                //z is unaffected by transform
                v.z = sZ;

                return v;
            };

            //@override
            OrthographicLens.prototype.clone = function () {
                var clone = new away.cameras.OrthographicLens();
                clone._pNear = this._pNear;
                clone._pFar = this._pFar;
                clone._pAspectRatio = this._pAspectRatio;
                clone.projectionHeight = this._projectionHeight;
                return clone;
            };

            //@override
            OrthographicLens.prototype.pUpdateMatrix = function () {
                var raw = [];
                this._yMax = this._projectionHeight * .5;
                this._xMax = this._yMax * this._pAspectRatio;

                var left;
                var right;
                var top;
                var bottom;

                if (this._pScissorRect.x == 0 && this._pScissorRect.y == 0 && this._pScissorRect.width == this._pViewPort.width && this._pScissorRect.height == this._pViewPort.height) {
                    // assume symmetric frustum
                    left = -this._xMax;
                    right = this._xMax;
                    top = -this._yMax;
                    bottom = this._yMax;

                    raw[0] = 2 / (this._projectionHeight * this._pAspectRatio);
                    raw[5] = 2 / this._projectionHeight;
                    raw[10] = 1 / (this._pFar - this._pNear);
                    raw[14] = this._pNear / (this._pNear - this._pFar);
                    raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = raw[12] = raw[13] = 0;
                    raw[15] = 1;
                } else {
                    var xWidth = this._xMax * (this._pViewPort.width / this._pScissorRect.width);
                    var yHgt = this._yMax * (this._pViewPort.height / this._pScissorRect.height);
                    var center = this._xMax * (this._pScissorRect.x * 2 - this._pViewPort.width) / this._pScissorRect.width + this._xMax;
                    var middle = -this._yMax * (this._pScissorRect.y * 2 - this._pViewPort.height) / this._pScissorRect.height - this._yMax;

                    left = center - xWidth;
                    right = center + xWidth;
                    top = middle - yHgt;
                    bottom = middle + yHgt;

                    raw[0] = 2 * 1 / (right - left);
                    raw[5] = -2 * 1 / (top - bottom);
                    raw[10] = 1 / (this._pFar - this._pNear);

                    raw[12] = (right + left) / (right - left);
                    raw[13] = (bottom + top) / (bottom - top);
                    raw[14] = this._pNear / (this.near - this.far);

                    raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
                    raw[15] = 1;
                }

                this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pFrustumCorners[12] = this._pFrustumCorners[21] = left;
                this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pFrustumCorners[15] = this._pFrustumCorners[18] = right;
                this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pFrustumCorners[13] = this._pFrustumCorners[16] = top;
                this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pFrustumCorners[19] = this._pFrustumCorners[22] = bottom;
                this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
                this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;

                this._pMatrix.copyRawDataFrom(raw);

                this._pMatrixInvalid = false;
            };
            return OrthographicLens;
        })(away.cameras.LensBase);
        cameras.OrthographicLens = OrthographicLens;
    })(away.cameras || (away.cameras = {}));
    var cameras = away.cameras;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (cameras) {
        var OrthographicOffCenterLens = (function (_super) {
            __extends(OrthographicOffCenterLens, _super);
            function OrthographicOffCenterLens(minX, maxX, minY, maxY) {
                _super.call(this);
                this._minX = minX;
                this._maxX = maxX;
                this._minY = minY;
                this._maxY = maxY;
            }
            Object.defineProperty(OrthographicOffCenterLens.prototype, "minX", {
                get: function () {
                    return this._minX;
                },
                set: function (value) {
                    this._minX = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(OrthographicOffCenterLens.prototype, "maxX", {
                get: function () {
                    return this._maxX;
                },
                set: function (value) {
                    this._maxX = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(OrthographicOffCenterLens.prototype, "minY", {
                get: function () {
                    return this._minY;
                },
                set: function (value) {
                    this._minY = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(OrthographicOffCenterLens.prototype, "maxY", {
                get: function () {
                    return this._maxY;
                },
                set: function (value) {
                    this._maxY = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            //@override
            OrthographicOffCenterLens.prototype.unproject = function (nX, nY, sZ) {
                var v = new away.geom.Vector3D(nX, -nY, sZ, 1.0);
                v = this.unprojectionMatrix.transformVector(v);

                //z is unaffected by transform
                v.z = sZ;

                return v;
            };

            //@override
            OrthographicOffCenterLens.prototype.clone = function () {
                var clone = new away.cameras.OrthographicOffCenterLens(this._minX, this._maxX, this._minY, this._maxY);
                clone._pNear = this._pNear;
                clone._pFar = this._pFar;
                clone._pAspectRatio = this._pAspectRatio;
                return clone;
            };

            //@override
            OrthographicOffCenterLens.prototype.pUpdateMatrix = function () {
                var raw = [];
                var w = 1 / (this._maxX - this._minX);
                var h = 1 / (this._maxY - this._minY);
                var d = 1 / (this._pFar - this._pNear);

                raw[0] = 2 * w;
                raw[5] = 2 * h;
                raw[10] = d;
                raw[12] = -(this._maxX + this._minX) * w;
                raw[13] = -(this._maxY + this._minY) * h;
                raw[14] = -this._pNear * d;
                raw[15] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
                this._pMatrix.copyRawDataFrom(raw);

                this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pFrustumCorners[12] = this._pFrustumCorners[21] = this._minX;
                this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pFrustumCorners[15] = this._pFrustumCorners[18] = this._maxX;
                this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pFrustumCorners[13] = this._pFrustumCorners[16] = this._minY;
                this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pFrustumCorners[19] = this._pFrustumCorners[22] = this._maxY;
                this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
                this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;

                this._pMatrixInvalid = false;
            };
            return OrthographicOffCenterLens;
        })(away.cameras.LensBase);
        cameras.OrthographicOffCenterLens = OrthographicOffCenterLens;
    })(away.cameras || (away.cameras = {}));
    var cameras = away.cameras;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (cameras) {
        var PerspectiveOffCenterLens = (function (_super) {
            __extends(PerspectiveOffCenterLens, _super);
            function PerspectiveOffCenterLens(minAngleX, maxAngleX, minAngleY, maxAngleY) {
                if (typeof minAngleX === "undefined") { minAngleX = -40; }
                if (typeof maxAngleX === "undefined") { maxAngleX = 40; }
                if (typeof minAngleY === "undefined") { minAngleY = -40; }
                if (typeof maxAngleY === "undefined") { maxAngleY = 40; }
                _super.call(this);

                this.minAngleX = minAngleX;
                this.maxAngleX = maxAngleX;
                this.minAngleY = minAngleY;
                this.maxAngleY = maxAngleY;
            }
            Object.defineProperty(PerspectiveOffCenterLens.prototype, "minAngleX", {
                get: function () {
                    return this._minAngleX;
                },
                set: function (value) {
                    this._minAngleX = value;
                    this._tanMinX = Math.tan(this._minAngleX * Math.PI / 180);
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PerspectiveOffCenterLens.prototype, "maxAngleX", {
                get: function () {
                    return this._maxAngleX;
                },
                set: function (value) {
                    this._maxAngleX = value;
                    this._tanMaxX = Math.tan(this._maxAngleX * Math.PI / 180);
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PerspectiveOffCenterLens.prototype, "minAngleY", {
                get: function () {
                    return this._minAngleY;
                },
                set: function (value) {
                    this._minAngleY = value;
                    this._tanMinY = Math.tan(this._minAngleY * Math.PI / 180);
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PerspectiveOffCenterLens.prototype, "maxAngleY", {
                get: function () {
                    return this._maxAngleY;
                },
                set: function (value) {
                    this._maxAngleY = value;
                    this._tanMaxY = Math.tan(this._maxAngleY * Math.PI / 180);
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            //@override
            PerspectiveOffCenterLens.prototype.unproject = function (nX, nY, sZ) {
                var v = new away.geom.Vector3D(nX, -nY, sZ, 1.0);

                v.x *= sZ;
                v.y *= sZ;
                v = this.unprojectionMatrix.transformVector(v);

                //z is unaffected by transform
                v.z = sZ;

                return v;
            };

            //@override
            PerspectiveOffCenterLens.prototype.clone = function () {
                var clone = new away.cameras.PerspectiveOffCenterLens(this._minAngleX, this._maxAngleX, this._minAngleY, this._maxAngleY);
                clone._pNear = this._pNear;
                clone._pFar = this._pFar;
                clone._pAspectRatio = this._pAspectRatio;
                return clone;
            };

            //@override
            PerspectiveOffCenterLens.prototype.pUpdateMatrix = function () {
                var raw = [];

                this._minLengthX = this._pNear * this._tanMinX;
                this._maxLengthX = this._pNear * this._tanMaxX;
                this._minLengthY = this._pNear * this._tanMinY;
                this._maxLengthY = this._pNear * this._tanMaxY;

                var minLengthFracX = -this._minLengthX / (this._maxLengthX - this._minLengthX);
                var minLengthFracY = -this._minLengthY / (this._maxLengthY - this._minLengthY);

                var left;
                var right;
                var top;
                var bottom;

                // assume scissored frustum
                var center = -this._minLengthX * (this._pScissorRect.x + this._pScissorRect.width * minLengthFracX) / (this._pScissorRect.width * minLengthFracX);
                var middle = this._minLengthY * (this._pScissorRect.y + this._pScissorRect.height * minLengthFracY) / (this._pScissorRect.height * minLengthFracY);

                left = center - (this._maxLengthX - this._minLengthX) * (this._pViewPort.width / this._pScissorRect.width);
                right = center;
                top = middle;
                bottom = middle + (this._maxLengthY - this._minLengthY) * (this._pViewPort.height / this._pScissorRect.height);

                raw[0] = 2 * this._pNear / (right - left);
                raw[5] = 2 * this._pNear / (bottom - top);
                raw[8] = (right + left) / (right - left);
                raw[9] = (bottom + top) / (bottom - top);
                raw[10] = (this._pFar + this._pNear) / (this._pFar - this._pNear);
                raw[11] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[12] = raw[13] = raw[15] = 0;
                raw[14] = -2 * this._pFar * this._pNear / (this._pFar - this._pNear);

                this._pMatrix.copyRawDataFrom(raw);

                this._minLengthX = this._pFar * this._tanMinX;
                this._maxLengthX = this._pFar * this._tanMaxX;
                this._minLengthY = this._pFar * this._tanMinY;
                this._maxLengthY = this._pFar * this._tanMaxY;

                this._pFrustumCorners[0] = this._pFrustumCorners[9] = left;
                this._pFrustumCorners[3] = this._pFrustumCorners[6] = right;
                this._pFrustumCorners[1] = this._pFrustumCorners[4] = top;
                this._pFrustumCorners[7] = this._pFrustumCorners[10] = bottom;

                this._pFrustumCorners[12] = this._pFrustumCorners[21] = this._minLengthX;
                this._pFrustumCorners[15] = this._pFrustumCorners[18] = this._maxLengthX;
                this._pFrustumCorners[13] = this._pFrustumCorners[16] = this._minLengthY;
                this._pFrustumCorners[19] = this._pFrustumCorners[22] = this._maxLengthY;

                this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
                this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;

                this._pMatrixInvalid = false;
            };
            return PerspectiveOffCenterLens;
        })(away.cameras.LensBase);
        cameras.PerspectiveOffCenterLens = PerspectiveOffCenterLens;
    })(away.cameras || (away.cameras = {}));
    var cameras = away.cameras;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (cameras) {
        var ObliqueNearPlaneLens = (function (_super) {
            __extends(ObliqueNearPlaneLens, _super);
            function ObliqueNearPlaneLens(baseLens, plane) {
                _super.call(this);
                this.baseLens = baseLens;
                this.plane = plane;
            }
            Object.defineProperty(ObliqueNearPlaneLens.prototype, "frustumCorners", {
                get: //@override
                function () {
                    return this._baseLens.frustumCorners;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObliqueNearPlaneLens.prototype, "near", {
                get: //@override
                function () {
                    return this._baseLens.near;
                },
                set: //@override
                function (value) {
                    this._baseLens.near = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ObliqueNearPlaneLens.prototype, "far", {
                get: //@override
                function () {
                    return this._baseLens.far;
                },
                set: //@override
                function (value) {
                    this._baseLens.far = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ObliqueNearPlaneLens.prototype, "iAspectRatio", {
                get: //@override
                function () {
                    return this._baseLens.iAspectRatio;
                },
                set: //@override
                function (value) {
                    this._baseLens.iAspectRatio = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ObliqueNearPlaneLens.prototype, "plane", {
                get: function () {
                    return this._plane;
                },
                set: function (value) {
                    this._plane = value;
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ObliqueNearPlaneLens.prototype, "baseLens", {
                set: function (value) {
                    if (this._baseLens) {
                        this._baseLens.removeEventListener(away.events.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged, this);
                    }
                    this._baseLens = value;

                    if (this._baseLens) {
                        this._baseLens.addEventListener(away.events.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged, this);
                    }
                    this.pInvalidateMatrix();
                },
                enumerable: true,
                configurable: true
            });

            ObliqueNearPlaneLens.prototype.onLensMatrixChanged = function (event) {
                this.pInvalidateMatrix();
            };

            //@override
            ObliqueNearPlaneLens.prototype.pUpdateMatrix = function () {
                this._pMatrix.copyFrom(this._baseLens.matrix);

                var cx = this._plane.a;
                var cy = this._plane.b;
                var cz = this._plane.c;
                var cw = -this._plane.d + .05;
                var signX = cx >= 0 ? 1 : -1;
                var signY = cy >= 0 ? 1 : -1;
                var p = new away.geom.Vector3D(signX, signY, 1, 1);
                var inverse = this._pMatrix.clone();
                inverse.invert();
                var q = inverse.transformVector(p);
                this._pMatrix.copyRowTo(3, p);
                var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);
                this._pMatrix.copyRowFrom(2, new away.geom.Vector3D(cx * a, cy * a, cz * a, cw * a));
            };
            return ObliqueNearPlaneLens;
        })(away.cameras.LensBase);
        cameras.ObliqueNearPlaneLens = ObliqueNearPlaneLens;
    })(away.cameras || (away.cameras = {}));
    var cameras = away.cameras;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        /**
        * @class away.events.CameraEvent
        */
        var CameraEvent = (function (_super) {
            __extends(CameraEvent, _super);
            function CameraEvent(type, camera) {
                _super.call(this, type);
                this._camera = camera;
            }
            Object.defineProperty(CameraEvent.prototype, "camera", {
                get: function () {
                    return this._camera;
                },
                enumerable: true,
                configurable: true
            });
            CameraEvent.LENS_CHANGED = "lensChanged";
            return CameraEvent;
        })(away.events.Event);
        events.CameraEvent = CameraEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (bounds) {
        var NullBounds = (function (_super) {
            __extends(NullBounds, _super);
            function NullBounds(alwaysIn, renderable) {
                if (typeof alwaysIn === "undefined") { alwaysIn = true; }
                if (typeof renderable === "undefined") { renderable = null; }
                _super.call(this);
                this._alwaysIn = alwaysIn;
                this._renderable = renderable;
                this._pMax.x = this._pMax.y = this._pMax.z = Number.POSITIVE_INFINITY;
                this._pMin.x = this._pMin.y = this._pMin.z = this._alwaysIn ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
            }
            //@override
            NullBounds.prototype.clone = function () {
                return new away.bounds.NullBounds(this._alwaysIn);
            };

            //@override
            NullBounds.prototype.pCreateBoundingRenderable = function () {
                //return this._renderable || new away.primitives.WireframeSphere( 100, 16, 12, 0xffffff, 0.5 );
                return null;
            };

            //@override
            NullBounds.prototype.isInFrustum = function (planes, numPlanes) {
                planes = planes;
                numPlanes = numPlanes;
                return this._alwaysIn;
            };

            //@override
            NullBounds.prototype.fromGeometry = function (geometry) {
            };

            //@override
            NullBounds.prototype.fromSphere = function (center, radius) {
            };

            //@override
            NullBounds.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
            };

            NullBounds.prototype.classifyToPlane = function (plane) {
                plane = plane;
                return away.math.PlaneClassification.INTERSECT;
            };

            //@override
            NullBounds.prototype.transformFrom = function (bounds, matrix) {
                matrix = matrix;
                var nullBounds = bounds;
                this._alwaysIn = nullBounds._alwaysIn;
            };
            return NullBounds;
        })(away.bounds.BoundingVolumeBase);
        bounds.NullBounds = NullBounds;
    })(away.bounds || (away.bounds = {}));
    var bounds = away.bounds;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (bounds) {
        var BoundingSphere = (function (_super) {
            __extends(BoundingSphere, _super);
            function BoundingSphere() {
                _super.call(this);
                this._radius = 0;
                this._centerX = 0;
                this._centerY = 0;
                this._centerZ = 0;
            }
            Object.defineProperty(BoundingSphere.prototype, "radius", {
                get: function () {
                    return this._radius;
                },
                enumerable: true,
                configurable: true
            });

            BoundingSphere.prototype.nullify = function () {
                _super.prototype.nullify.call(this);
                this._centerX = this._centerY = this._centerZ = 0;
                this._radius = 0;
            };

            BoundingSphere.prototype.isInFrustum = function (planes, numPlanes) {
                for (var i = 0; i < numPlanes; ++i) {
                    var plane = planes[i];
                    var flippedExtentX = plane.a < 0 ? -this._radius : this._radius;
                    var flippedExtentY = plane.b < 0 ? -this._radius : this._radius;
                    var flippedExtentZ = plane.c < 0 ? -this._radius : this._radius;
                    var projDist = plane.a * (this._centerX + flippedExtentX) + plane.b * (this._centerY + flippedExtentY) + plane.c * (this._centerZ + flippedExtentZ) - plane.d;
                    if (projDist < 0) {
                        return false;
                    }
                }
                return true;
            };

            BoundingSphere.prototype.fromSphere = function (center, radius) {
                this._centerX = center.x;
                this._centerY = center.y;
                this._centerZ = center.z;
                this._radius = radius;
                this._pMax.x = this._centerX + radius;
                this._pMax.y = this._centerY + radius;
                this._pMax.z = this._centerZ + radius;
                this._pMin.x = this._centerX - radius;
                this._pMin.y = this._centerY - radius;
                this._pMin.z = this._centerZ - radius;
                this._pAabbPointsDirty = true;
                if (this._pBoundingRenderable) {
                    this.pUpdateBoundingRenderable();
                }
            };

            BoundingSphere.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
                this._centerX = (maxX + minX) * .5;
                this._centerY = (maxY + minY) * .5;
                this._centerZ = (maxZ + minZ) * .5;

                var d = maxX - minX;
                var y = maxY - minY;
                var z = maxZ - minZ;
                if (y > d) {
                    d = y;
                }
                if (z > d) {
                    d = z;
                }
                this._radius = d * Math.sqrt(.5);
                _super.prototype.fromExtremes.call(this, minX, minY, minZ, maxX, maxY, maxZ);
            };

            BoundingSphere.prototype.clone = function () {
                var clone = new BoundingSphere();
                clone.fromSphere(new away.geom.Vector3D(this._centerX, this._centerY, this._centerZ), this._radius);
                return clone;
            };

            BoundingSphere.prototype.rayIntersection = function (position, direction, targetNormal) {
                if (this.containsPoint(position)) {
                    return 0;
                }

                var px = position.x - this._centerX, py = position.y - this._centerY, pz = position.z - this._centerZ;
                var vx = direction.x, vy = direction.y, vz = direction.z;
                var rayEntryDistance;

                var a = vx * vx + vy * vy + vz * vz;
                var b = 2 * (px * vx + py * vy + pz * vz);
                var c = px * px + py * py + pz * pz - this._radius * this._radius;
                var det = b * b - 4 * a * c;

                if (det >= 0) {
                    var sqrtDet = Math.sqrt(det);
                    rayEntryDistance = (-b - sqrtDet) / (2 * a);
                    if (rayEntryDistance >= 0) {
                        targetNormal.x = px + rayEntryDistance * vx;
                        targetNormal.y = py + rayEntryDistance * vy;
                        targetNormal.z = pz + rayEntryDistance * vz;
                        targetNormal.normalize();

                        return rayEntryDistance;
                    }
                }

                // ray misses sphere
                return -1;
            };

            BoundingSphere.prototype.containsPoint = function (position) {
                var px = position.x - this._centerX;
                var py = position.y - this._centerY;
                var pz = position.z - this._centerZ;
                var distance = Math.sqrt(px * px + py * py + pz * pz);
                return distance <= this._radius;
            };

            BoundingSphere.prototype.pUpdateBoundingRenderable = function () {
                var sc = this._radius;
                if (sc == 0) {
                    sc = 0.001;
                }
                this._pBoundingRenderable.scaleX = sc;
                this._pBoundingRenderable.scaleY = sc;
                this._pBoundingRenderable.scaleZ = sc;
                this._pBoundingRenderable.x = this._centerX;
                this._pBoundingRenderable.y = this._centerY;
                this._pBoundingRenderable.z = this._centerZ;
            };

            // TODO pCreateBoundingRenderable():WireframePrimitiveBase
            BoundingSphere.prototype.pCreateBoundingRenderable = function () {
                return new away.primitives.WireframeSphere(1, 16, 12, 0xffffff, 0.5);
            };

            //@override
            BoundingSphere.prototype.classifyToPlane = function (plane) {
                var a = plane.a;
                var b = plane.b;
                var c = plane.c;
                var dd = a * this._centerX + b * this._centerY + c * this._centerZ - plane.d;
                if (a < 0) {
                    a = -a;
                }
                if (b < 0) {
                    b = -b;
                }
                if (c < 0) {
                    c = -c;
                }
                var rr = (a + b + c) * this._radius;

                return dd > rr ? away.math.PlaneClassification.FRONT : dd < -rr ? away.math.PlaneClassification.BACK : away.math.PlaneClassification.INTERSECT;
            };

            BoundingSphere.prototype.transformFrom = function (bounds, matrix) {
                var sphere = bounds;
                var cx = sphere._centerX;
                var cy = sphere._centerY;
                var cz = sphere._centerZ;
                var raw = [];
                matrix.copyRawDataTo(raw);
                var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
                var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
                var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];

                this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
                this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
                this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;

                if (m11 < 0)
                    m11 = -m11;
                if (m12 < 0)
                    m12 = -m12;
                if (m13 < 0)
                    m13 = -m13;
                if (m21 < 0)
                    m21 = -m21;
                if (m22 < 0)
                    m22 = -m22;
                if (m23 < 0)
                    m23 = -m23;
                if (m31 < 0)
                    m31 = -m31;
                if (m32 < 0)
                    m32 = -m32;
                if (m33 < 0)
                    m33 = -m33;
                var r = sphere._radius;
                var rx = m11 + m12 + m13;
                var ry = m21 + m22 + m23;
                var rz = m31 + m32 + m33;
                this._radius = r * Math.sqrt(rx * rx + ry * ry + rz * rz);

                this._pMin.x = this._centerX - this._radius;
                this._pMin.y = this._centerY - this._radius;
                this._pMin.z = this._centerZ - this._radius;

                this._pMax.x = this._centerX + this._radius;
                this._pMax.y = this._centerY + this._radius;
                this._pMax.z = this._centerZ + this._radius;
            };
            return BoundingSphere;
        })(away.bounds.BoundingVolumeBase);
        bounds.BoundingSphere = BoundingSphere;
    })(away.bounds || (away.bounds = {}));
    var bounds = away.bounds;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (bounds) {
        //import away3d.arcane;
        //import away3d.core.math.*;
        //import away3d.primitives.*;
        //import flash.geom.*;
        //use namespace arcane;
        /**
        * AxisAlignedBoundingBox represents a bounding box volume that has its planes aligned to the local coordinate axes of the bounded object.
        * This is useful for most meshes.
        */
        var AxisAlignedBoundingBox = (function (_super) {
            __extends(AxisAlignedBoundingBox, _super);
            /**
            * Creates a new <code>AxisAlignedBoundingBox</code> object.
            */
            function AxisAlignedBoundingBox() {
                _super.call(this);
                this._centerX = 0;
                this._centerY = 0;
                this._centerZ = 0;
                this._halfExtentsX = 0;
                this._halfExtentsY = 0;
                this._halfExtentsZ = 0;
            }
            /**
            * @inheritDoc
            */
            AxisAlignedBoundingBox.prototype.nullify = function () {
                _super.prototype.nullify.call(this);

                this._centerX = this._centerY = this._centerZ = 0;
                this._halfExtentsX = this._halfExtentsY = this._halfExtentsZ = 0;
            };

            /**
            * @inheritDoc
            */
            AxisAlignedBoundingBox.prototype.isInFrustum = function (planes, numPlanes) {
                for (var i = 0; i < numPlanes; ++i) {
                    var plane = planes[i];
                    var a = plane.a;
                    var b = plane.b;
                    var c = plane.c;
                    var flippedExtentX = a < 0 ? -this._halfExtentsX : this._halfExtentsX;
                    var flippedExtentY = b < 0 ? -this._halfExtentsY : this._halfExtentsY;
                    var flippedExtentZ = c < 0 ? -this._halfExtentsZ : this._halfExtentsZ;
                    var projDist = a * (this._centerX + flippedExtentX) + b * (this._centerY + flippedExtentY) + c * (this._centerZ + flippedExtentZ) - plane.d;

                    if (projDist < 0)
                        return false;
                }

                return true;
            };

            AxisAlignedBoundingBox.prototype.rayIntersection = function (position, direction, targetNormal) {
                if (this.containsPoint(position))
                    return 0;

                var px = position.x - this._centerX;
                var py = position.y - this._centerY;
                var pz = position.z - this._centerZ;

                var vx = direction.x;
                var vy = direction.y;
                var vz = direction.z;

                var ix;
                var iy;
                var iz;
                var rayEntryDistance;

                // ray-plane tests
                var intersects;
                if (vx < 0) {
                    rayEntryDistance = (this._halfExtentsX - px) / vx;
                    if (rayEntryDistance > 0) {
                        iy = py + rayEntryDistance * vy;
                        iz = pz + rayEntryDistance * vz;
                        if (iy > -this._halfExtentsY && iy < this._halfExtentsY && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                            targetNormal.x = 1;
                            targetNormal.y = 0;
                            targetNormal.z = 0;

                            intersects = true;
                        }
                    }
                }
                if (!intersects && vx > 0) {
                    rayEntryDistance = (-this._halfExtentsX - px) / vx;
                    if (rayEntryDistance > 0) {
                        iy = py + rayEntryDistance * vy;
                        iz = pz + rayEntryDistance * vz;
                        if (iy > -this._halfExtentsY && iy < this._halfExtentsY && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                            targetNormal.x = -1;
                            targetNormal.y = 0;
                            targetNormal.z = 0;
                            intersects = true;
                        }
                    }
                }
                if (!intersects && vy < 0) {
                    rayEntryDistance = (this._halfExtentsY - py) / vy;
                    if (rayEntryDistance > 0) {
                        ix = px + rayEntryDistance * vx;
                        iz = pz + rayEntryDistance * vz;
                        if (ix > -this._halfExtentsX && ix < this._halfExtentsX && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                            targetNormal.x = 0;
                            targetNormal.y = 1;
                            targetNormal.z = 0;
                            intersects = true;
                        }
                    }
                }
                if (!intersects && vy > 0) {
                    rayEntryDistance = (-this._halfExtentsY - py) / vy;
                    if (rayEntryDistance > 0) {
                        ix = px + rayEntryDistance * vx;
                        iz = pz + rayEntryDistance * vz;
                        if (ix > -this._halfExtentsX && ix < this._halfExtentsX && iz > -this._halfExtentsZ && iz < this._halfExtentsZ) {
                            targetNormal.x = 0;
                            targetNormal.y = -1;
                            targetNormal.z = 0;
                            intersects = true;
                        }
                    }
                }
                if (!intersects && vz < 0) {
                    rayEntryDistance = (this._halfExtentsZ - pz) / vz;
                    if (rayEntryDistance > 0) {
                        ix = px + rayEntryDistance * vx;
                        iy = py + rayEntryDistance * vy;
                        if (iy > -this._halfExtentsY && iy < this._halfExtentsY && ix > -this._halfExtentsX && ix < this._halfExtentsX) {
                            targetNormal.x = 0;
                            targetNormal.y = 0;
                            targetNormal.z = 1;
                            intersects = true;
                        }
                    }
                }
                if (!intersects && vz > 0) {
                    rayEntryDistance = (-this._halfExtentsZ - pz) / vz;
                    if (rayEntryDistance > 0) {
                        ix = px + rayEntryDistance * vx;
                        iy = py + rayEntryDistance * vy;
                        if (iy > -this._halfExtentsY && iy < this._halfExtentsY && ix > -this._halfExtentsX && ix < this._halfExtentsX) {
                            targetNormal.x = 0;
                            targetNormal.y = 0;
                            targetNormal.z = -1;
                            intersects = true;
                        }
                    }
                }

                return intersects ? rayEntryDistance : -1;
            };

            /**
            * @inheritDoc
            */
            AxisAlignedBoundingBox.prototype.containsPoint = function (position) {
                var px = position.x - this._centerX, py = position.y - this._centerY, pz = position.z - this._centerZ;
                return px <= this._halfExtentsX && px >= -this._halfExtentsX && py <= this._halfExtentsY && py >= -this._halfExtentsY && pz <= this._halfExtentsZ && pz >= -this._halfExtentsZ;
            };

            /**
            * @inheritDoc
            */
            AxisAlignedBoundingBox.prototype.fromExtremes = function (minX, minY, minZ, maxX, maxY, maxZ) {
                this._centerX = (maxX + minX) * .5;
                this._centerY = (maxY + minY) * .5;
                this._centerZ = (maxZ + minZ) * .5;
                this._halfExtentsX = (maxX - minX) * .5;
                this._halfExtentsY = (maxY - minY) * .5;
                this._halfExtentsZ = (maxZ - minZ) * .5;

                _super.prototype.fromExtremes.call(this, minX, minY, minZ, maxX, maxY, maxZ);
            };

            /**
            * @inheritDoc
            */
            AxisAlignedBoundingBox.prototype.clone = function () {
                var clone = new AxisAlignedBoundingBox();
                clone.fromExtremes(this._pMin.x, this._pMin.y, this._pMin.z, this._pMax.x, this._pMax.y, this._pMax.z);
                return clone;
            };

            Object.defineProperty(AxisAlignedBoundingBox.prototype, "halfExtentsX", {
                get: function () {
                    return this._halfExtentsX;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AxisAlignedBoundingBox.prototype, "halfExtentsY", {
                get: function () {
                    return this._halfExtentsY;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AxisAlignedBoundingBox.prototype, "halfExtentsZ", {
                get: function () {
                    return this._halfExtentsZ;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Finds the closest point on the bounding volume to another given point. This can be used for maximum error calculations for content within a given bound.
            * @param point The point for which to find the closest point on the bounding volume
            * @param target An optional Vector3D to store the result to prevent creating a new object.
            * @return
            */
            AxisAlignedBoundingBox.prototype.closestPointToPoint = function (point, target) {
                if (typeof target === "undefined") { target = null; }
                var p;

                if (target == null) {
                    target = new away.geom.Vector3D();
                }

                p = point.x;
                if (p < this._pMin.x)
                    p = this._pMin.x;
                if (p > this._pMax.x)
                    p = this._pMax.x;
                target.x = p;

                p = point.y;
                if (p < this._pMin.y)
                    p = this._pMin.y;
                if (p > this._pMax.y)
                    p = this._pMax.y;
                target.y = p;

                p = point.z;
                if (p < this._pMin.z)
                    p = this._pMin.z;
                if (p > this._pMax.z)
                    p = this._pMax.z;
                target.z = p;

                return target;
            };

            AxisAlignedBoundingBox.prototype.pUpdateBoundingRenderable = function () {
                this._pBoundingRenderable.scaleX = Math.max(this._halfExtentsX * 2, 0.001);
                this._pBoundingRenderable.scaleY = Math.max(this._halfExtentsY * 2, 0.001);
                this._pBoundingRenderable.scaleZ = Math.max(this._halfExtentsZ * 2, 0.001);
                this._pBoundingRenderable.x = this._centerX;
                this._pBoundingRenderable.y = this._centerY;
                this._pBoundingRenderable.z = this._centerZ;
            };

            AxisAlignedBoundingBox.prototype.pCreateBoundingRenderable = function () {
                return new away.primitives.WireframeCube(1, 1, 1, 0xffffff, 0.5);
            };

            AxisAlignedBoundingBox.prototype.classifyToPlane = function (plane) {
                var a = plane.a;
                var b = plane.b;
                var c = plane.c;
                var centerDistance = a * this._centerX + b * this._centerY + c * this._centerZ - plane.d;

                if (a < 0)
                    a = -a;

                if (b < 0)
                    b = -b;

                if (c < 0)
                    c = -c;

                var boundOffset = a * this._halfExtentsX + b * this._halfExtentsY + c * this._halfExtentsZ;

                return centerDistance > boundOffset ? away.math.PlaneClassification.FRONT : centerDistance < -boundOffset ? away.math.PlaneClassification.BACK : away.math.PlaneClassification.INTERSECT;
            };

            AxisAlignedBoundingBox.prototype.transformFrom = function (bounds, matrix) {
                var aabb = bounds;
                var cx = aabb._centerX;
                var cy = aabb._centerY;
                var cz = aabb._centerZ;
                var raw = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;

                matrix.copyRawDataTo(raw);

                var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
                var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
                var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];

                this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
                this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
                this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;

                if (m11 < 0)
                    m11 = -m11;
                if (m12 < 0)
                    m12 = -m12;
                if (m13 < 0)
                    m13 = -m13;
                if (m21 < 0)
                    m21 = -m21;
                if (m22 < 0)
                    m22 = -m22;
                if (m23 < 0)
                    m23 = -m23;
                if (m31 < 0)
                    m31 = -m31;
                if (m32 < 0)
                    m32 = -m32;
                if (m33 < 0)
                    m33 = -m33;
                var hx = aabb._halfExtentsX;
                var hy = aabb._halfExtentsY;
                var hz = aabb._halfExtentsZ;
                this._halfExtentsX = hx * m11 + hy * m12 + hz * m13;
                this._halfExtentsY = hx * m21 + hy * m22 + hz * m23;
                this._halfExtentsZ = hx * m31 + hy * m32 + hz * m33;

                this._pMin.x = this._centerX - this._halfExtentsX;
                this._pMin.y = this._centerY - this._halfExtentsY;
                this._pMin.z = this._centerZ - this._halfExtentsZ;
                this._pMax.x = this._centerX + this._halfExtentsX;
                this._pMax.y = this._centerY + this._halfExtentsY;
                this._pMax.z = this._centerZ + this._halfExtentsZ;
            };
            return AxisAlignedBoundingBox;
        })(away.bounds.BoundingVolumeBase);
        bounds.AxisAlignedBoundingBox = AxisAlignedBoundingBox;
    })(away.bounds || (away.bounds = {}));
    var bounds = away.bounds;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (containers) {
        var ObjectContainer3D = (function (_super) {
            __extends(ObjectContainer3D, _super);
            function ObjectContainer3D() {
                _super.call(this);
                this._pSceneTransform = new away.geom.Matrix3D();
                this._pSceneTransformDirty = true;
                this._children = [];
                this._mouseChildren = true;
                this._inverseSceneTransform = new away.geom.Matrix3D();
                this._inverseSceneTransformDirty = true;
                this._scenePosition = new away.geom.Vector3D();
                this._scenePositionDirty = true;
                this._explicitVisibility = true;
                this._implicitVisibility = true;
                this._pIgnoreTransform = false;
            }
            ObjectContainer3D.prototype.getIgnoreTransform = function () {
                return this._pIgnoreTransform;
            };

            ObjectContainer3D.prototype.setIgnoreTransform = function (value) {
                this._pIgnoreTransform = value;
                this._pSceneTransformDirty = !value;
                this._inverseSceneTransformDirty = !value;
                this._scenePositionDirty = !value;

                if (value) {
                    this._pSceneTransform.identity();
                    this._scenePosition.setTo(0, 0, 0);
                }
            };

            /*
            public get iImplicitPartition():away.partition.Partition3D
            {
            return this._pImplicitPartition;
            }
            */
            ObjectContainer3D.prototype.iGetImplicitPartition = function () {
                return this._pImplicitPartition;
            };

            /*
            public set iImplicitPartition( value:away.partition.Partition3D )
            {
            
            this.iSetImplicitPartition( value );
            }
            */
            ObjectContainer3D.prototype.iSetImplicitPartition = function (value) {
                if (value == this._pImplicitPartition)
                    return;

                var i = 0;
                var len = this._children.length;
                var child;

                this._pImplicitPartition = value;

                while (i < len) {
                    child = this._children[i++];

                    if (!child._pExplicitPartition)
                        child._pImplicitPartition = value;
                }
                /*
                if ( value == this._pImplicitPartition )
                {
                return;
                }
                
                console.log( 'ObjectContainer3D','iSetImplicitPartition' , value );
                
                var i:number = 0;
                var len:number = this._children.length;
                var child:away.containers.ObjectContainer3D;
                
                this._pImplicitPartition = value;
                
                while (i < len)
                {
                child = this._children[i++];
                if( !child._pExplicitPartition )
                {
                child._pImplicitPartition = value;
                }
                }
                */
            };

            Object.defineProperty(ObjectContainer3D.prototype, "_iIsVisible", {
                get: function () {
                    return this._implicitVisibility && this._explicitVisibility;
                },
                enumerable: true,
                configurable: true
            });

            ObjectContainer3D.prototype.iSetParent = function (value) {
                this._pParent = value;

                this.pUpdateMouseChildren();

                if (value == null) {
                    this.scene = null;
                    return;
                }

                this.notifySceneTransformChange();
                this.notifySceneChange();
            };

            ObjectContainer3D.prototype.notifySceneTransformChange = function () {
                if (this._pSceneTransformDirty || this._pIgnoreTransform) {
                    return;
                }

                this.pInvalidateSceneTransform();

                var i = 0;
                var len = this._children.length;

                while (i < len) {
                    this._children[i++].notifySceneTransformChange();
                }

                if (this._listenToSceneTransformChanged) {
                    if (!this._sceneTransformChanged) {
                        this._sceneTransformChanged = new away.events.Object3DEvent(away.events.Object3DEvent.SCENETRANSFORM_CHANGED, this);
                    }
                    this.dispatchEvent(this._sceneTransformChanged);
                }
            };

            ObjectContainer3D.prototype.notifySceneChange = function () {
                this.notifySceneTransformChange();

                var i;
                var len = this._children.length;

                while (i < len) {
                    this._children[i++].notifySceneChange();
                }

                if (this._listenToSceneChanged) {
                    if (!this._scenechanged) {
                        this._scenechanged = new away.events.Object3DEvent(away.events.Object3DEvent.SCENE_CHANGED, this);
                    }
                    this.dispatchEvent(this._scenechanged);
                }
            };

            ObjectContainer3D.prototype.pUpdateMouseChildren = function () {
                if (this._pParent && !this._pParent._iIsRoot) {
                    this._iAncestorsAllowMouseEnabled = this._pParent._iAncestorsAllowMouseEnabled && this._pParent.mouseChildren;
                } else {
                    this._iAncestorsAllowMouseEnabled = this.mouseChildren;
                }

                var len = this._children.length;
                for (var i = 0; i < len; ++i) {
                    this._children[i].pUpdateMouseChildren();
                }
            };

            Object.defineProperty(ObjectContainer3D.prototype, "mouseEnabled", {
                get: function () {
                    return this._pMouseEnabled;
                },
                set: function (value) {
                    this._pMouseEnabled = value;
                    this.pUpdateMouseChildren();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ObjectContainer3D.prototype.iInvalidateTransform = function () {
                _super.prototype.iInvalidateTransform.call(this);

                this.notifySceneTransformChange();
            };

            ObjectContainer3D.prototype.pInvalidateSceneTransform = function () {
                this._pSceneTransformDirty = !this._pIgnoreTransform;
                this._inverseSceneTransformDirty = !this._pIgnoreTransform;
                this._scenePositionDirty = !this._pIgnoreTransform;
            };

            ObjectContainer3D.prototype.pUpdateSceneTransform = function () {
                if (this._pParent && !this._pParent._iIsRoot) {
                    this._pSceneTransform.copyFrom(this._pParent.sceneTransform);
                    this._pSceneTransform.prepend(this.transform);
                } else {
                    this._pSceneTransform.copyFrom(this.transform);
                }
                this._pSceneTransformDirty = false;
            };

            Object.defineProperty(ObjectContainer3D.prototype, "mouseChildren", {
                get: function () {
                    return this._mouseChildren;
                },
                set: function (value) {
                    this._mouseChildren = value;
                    this.pUpdateMouseChildren();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ObjectContainer3D.prototype, "visible", {
                get: function () {
                    return this._explicitVisibility;
                },
                set: function (value) {
                    var len = this._children.length;

                    this._explicitVisibility = value;

                    for (var i = 0; i < len; ++i) {
                        this._children[i].updateImplicitVisibility();
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ObjectContainer3D.prototype, "assetType", {
                get: function () {
                    return away.library.AssetType.CONTAINER;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "scenePosition", {
                get: function () {
                    if (this._scenePositionDirty) {
                        this.sceneTransform.copyColumnTo(3, this._scenePosition);
                        this._scenePositionDirty = false;
                    }
                    return this._scenePosition;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "minX", {
                get: function () {
                    var i;
                    var len = this._children.length;
                    var min = Number.POSITIVE_INFINITY;
                    var m;

                    while (i < len) {
                        var child = this._children[i++];
                        m = child.minX + child.x;
                        if (m < min) {
                            min = m;
                        }
                    }
                    return min;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "minY", {
                get: function () {
                    var i;
                    var len = this._children.length;
                    var min = Number.POSITIVE_INFINITY;
                    var m;

                    while (i < len) {
                        var child = this._children[i++];
                        m = child.minY + child.y;
                        if (m < min) {
                            min = m;
                        }
                    }
                    return min;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "minZ", {
                get: function () {
                    var i;
                    var len = this._children.length;
                    var min = Number.POSITIVE_INFINITY;
                    var m;

                    while (i < len) {
                        var child = this._children[i++];
                        m = child.minZ + child.z;
                        if (m < min) {
                            min = m;
                        }
                    }
                    return min;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "maxX", {
                get: function () {
                    var i;
                    var len = this._children.length;
                    var max = Number.NEGATIVE_INFINITY;
                    var m;

                    while (i < len) {
                        var child = this._children[i++];
                        m = child.maxX + child.x;
                        if (m > max) {
                            max = m;
                        }
                    }
                    return max;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "maxY", {
                get: function () {
                    var i;
                    var len = this._children.length;
                    var max = Number.NEGATIVE_INFINITY;
                    var m;

                    while (i < len) {
                        var child = this._children[i++];
                        m = child.maxY + child.y;
                        if (m > max) {
                            max = m;
                        }
                    }
                    return max;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "maxZ", {
                get: function () {
                    var i;
                    var len = this._children.length;
                    var max = Number.NEGATIVE_INFINITY;
                    var m;

                    while (i < len) {
                        var child = this._children[i++];
                        m = child.maxZ + child.z;
                        if (m > max) {
                            max = m;
                        }
                    }
                    return max;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "partition", {
                get: function () {
                    return this._pExplicitPartition;
                },
                set: function (value) {
                    this._pExplicitPartition = value;
                    this.iSetImplicitPartition(value ? value : (this._pParent ? this._pParent.iGetImplicitPartition() : null));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ObjectContainer3D.prototype, "sceneTransform", {
                get: function () {
                    if (this._pSceneTransformDirty) {
                        this.pUpdateSceneTransform();
                    }
                    return this._pSceneTransform;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "scene", {
                get: function () {
                    return this._pScene;
                },
                set: function (value) {
                    this.setScene(value);
                },
                enumerable: true,
                configurable: true
            });


            ObjectContainer3D.prototype.setScene = function (value) {
                //console.log( 'ObjectContainer3D' , 'setScene' , value );
                var i = 0;
                var len = this._children.length;

                while (i < len) {
                    this._children[i++].scene = value;
                }

                if (this._pScene == value)
                    return;

                if (value == null)
                    this._oldScene = this._pScene;

                if (this._pExplicitPartition && this._oldScene && this._oldScene != this._pScene)
                    this.partition = null;

                if (value) {
                    this._oldScene = null;
                }

                // end of stupid partition test code
                this._pScene = value;

                if (this._pScene) {
                    this._pScene.dispatchEvent(new away.events.Scene3DEvent(away.events.Scene3DEvent.ADDED_TO_SCENE, this));
                } else if (this._oldScene) {
                    this._oldScene.dispatchEvent(new away.events.Scene3DEvent(away.events.Scene3DEvent.REMOVED_FROM_SCENE, this));
                }
            };

            Object.defineProperty(ObjectContainer3D.prototype, "inverseSceneTransform", {
                get: function () {
                    if (this._inverseSceneTransformDirty) {
                        this._inverseSceneTransform.copyFrom(this.sceneTransform);
                        this._inverseSceneTransform.invert();
                        this._inverseSceneTransformDirty = false;
                    }
                    return this._inverseSceneTransform;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ObjectContainer3D.prototype, "parent", {
                get: function () {
                    return this._pParent;
                },
                enumerable: true,
                configurable: true
            });

            ObjectContainer3D.prototype.contains = function (child) {
                return this._children.indexOf(child) >= 0;
            };

            ObjectContainer3D.prototype.addChild = function (child) {
                if (child == null) {
                    throw new away.errors.Error("Parameter child cannot be null.");
                }

                if (child._pParent) {
                    child._pParent.removeChild(child);
                }

                if (!child._pExplicitPartition) {
                    //console.log( 'ObjectContainer3D' , 'addChild' , 'set iImplicitPartition' ,  this._pImplicitPartition);
                    child.iSetImplicitPartition(this._pImplicitPartition);
                    //child.iImplicitPartition = this._pImplicitPartition;
                }

                child.iSetParent(this);
                child.scene = this._pScene;
                child.notifySceneTransformChange();
                child.pUpdateMouseChildren();
                child.updateImplicitVisibility();

                this._children.push(child);

                return child;
            };

            ObjectContainer3D.prototype.addChildren = function (childarray) {
                for (var child in childarray) {
                    this.addChild(child);
                }
            };

            ObjectContainer3D.prototype.removeChild = function (child) {
                if (child == null) {
                    throw new away.errors.Error("Parameter child cannot be null");
                }

                var childIndex = this._children.indexOf(child);

                if (childIndex == -1) {
                    throw new away.errors.Error("Parameter is not a child of the caller");
                }

                this.removeChildInternal(childIndex, child);
            };

            ObjectContainer3D.prototype.removeChildAt = function (index) {
                var child = this._children[index];
                this.removeChildInternal(index, child);
            };

            ObjectContainer3D.prototype.removeChildInternal = function (childIndex, child) {
                this._children.splice(childIndex, 1);
                child.iSetParent(null);

                if (!child._pExplicitPartition) {
                    child.iSetImplicitPartition(null);
                }
            };

            ObjectContainer3D.prototype.getChildAt = function (index) {
                return this._children[index];
            };

            Object.defineProperty(ObjectContainer3D.prototype, "numChildren", {
                get: function () {
                    return this._children.length;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            ObjectContainer3D.prototype.lookAt = function (target, upAxis) {
                if (typeof upAxis === "undefined") { upAxis = null; }
                _super.prototype.lookAt.call(this, target, upAxis);
                this.notifySceneTransformChange();
            };

            //@override
            ObjectContainer3D.prototype.translateLocal = function (axis, distance) {
                _super.prototype.translateLocal.call(this, axis, distance);
                this.notifySceneTransformChange();
            };

            //@override
            ObjectContainer3D.prototype.dispose = function () {
                if (this.parent) {
                    this.parent.removeChild(this);
                }
            };

            ObjectContainer3D.prototype.disposeWithChildren = function () {
                this.dispose();
                while (this.numChildren > 0) {
                    this.getChildAt(0).dispose();
                }
            };

            //override
            ObjectContainer3D.prototype.clone = function () {
                var clone = new away.containers.ObjectContainer3D();
                clone.pivotPoint = this.pivotPoint;
                clone.transform = this.transform;
                clone.partition = this.partition;
                clone.name = name;

                var len = this._children.length;

                for (var i = 0; i < len; ++i) {
                    clone.addChild(this._children[i].clone());
                }

                // todo: implement for all subtypes
                return clone;
            };

            //@override
            ObjectContainer3D.prototype.rotate = function (axis, angle) {
                _super.prototype.rotate.call(this, axis, angle);
                this.notifySceneTransformChange();
            };

            //TODO override public function dispatchEvent(event:Event):Boolean
            ObjectContainer3D.prototype.updateImplicitVisibility = function () {
                var len = this._children.length;

                this._implicitVisibility = this._pParent._explicitVisibility && this._pParent._implicitVisibility;

                for (var i = 0; i < len; ++i) {
                    this._children[i].updateImplicitVisibility();
                }
            };
            return ObjectContainer3D;
        })(away.base.Object3D);
        containers.ObjectContainer3D = ObjectContainer3D;
    })(away.containers || (away.containers = {}));
    var containers = away.containers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (entities) {
        var Entity = (function (_super) {
            __extends(Entity, _super);
            function Entity() {
                _super.call(this);
                this._pBoundsInvalid = true;
                this._worldBoundsInvalid = true;
                this._pBounds = this.pGetDefaultBoundingVolume();

                //console.log( "Entity() - Bounds:" , this._pBounds );
                this._worldBounds = this.pGetDefaultBoundingVolume();
            }
            //@override
            Entity.prototype.setIgnoreTransform = function (value) {
                if (this._pScene) {
                    this._pScene.iInvalidateEntityBounds(this);
                }
                _super.prototype.setIgnoreTransform.call(this, value);
            };

            Object.defineProperty(Entity.prototype, "shaderPickingDetails", {
                get: function () {
                    return this._shaderPickingDetails;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Entity.prototype, "staticNode", {
                get: function () {
                    return this._iStaticNode;
                },
                set: function (value) {
                    this._iStaticNode = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Entity.prototype, "pickingCollisionVO", {
                get: function () {
                    if (!this._iPickingCollisionVO) {
                        this._iPickingCollisionVO = new away.pick.PickingCollisionVO(this);
                    }
                    return this._iPickingCollisionVO;
                },
                enumerable: true,
                configurable: true
            });

            Entity.prototype.iCollidesBefore = function (shortestCollisionDistance, findClosest) {
                shortestCollisionDistance = shortestCollisionDistance;
                findClosest = findClosest;
                return true;
            };

            Object.defineProperty(Entity.prototype, "showBounds", {
                get: function () {
                    return this._showBounds;
                },
                set: function (value) {
                    if (value == this._showBounds) {
                        return;
                    }
                    this._showBounds = value;

                    if (this._showBounds) {
                        this.addBounds();
                    } else {
                        this.removeBounds();
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Entity.prototype, "minX", {
                get: //@override
                function () {
                    if (this._pBoundsInvalid) {
                        this.pUpdateBounds();
                    }
                    return this._pBounds.min.x;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Entity.prototype, "minY", {
                get: //@override
                function () {
                    if (this._pBoundsInvalid) {
                        this.pUpdateBounds();
                    }
                    return this._pBounds.min.y;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Entity.prototype, "minZ", {
                get: //@override
                function () {
                    if (this._pBoundsInvalid) {
                        this.pUpdateBounds();
                    }
                    return this._pBounds.min.z;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Entity.prototype, "maxX", {
                get: //@override
                function () {
                    if (this._pBoundsInvalid) {
                        this.pUpdateBounds();
                    }
                    return this._pBounds.max.x;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Entity.prototype, "maxY", {
                get: //@override
                function () {
                    if (this._pBoundsInvalid) {
                        this.pUpdateBounds();
                    }
                    return this._pBounds.max.y;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Entity.prototype, "maxZ", {
                get: //@override
                function () {
                    if (this._pBoundsInvalid) {
                        this.pUpdateBounds();
                    }
                    return this._pBounds.max.z;
                },
                enumerable: true,
                configurable: true
            });

            Entity.prototype.getBounds = function () {
                if (this._pBoundsInvalid) {
                    this.pUpdateBounds();
                }
                return this._pBounds;
            };

            Object.defineProperty(Entity.prototype, "bounds", {
                get: function () {
                    return this.getBounds();
                },
                set: function (value) {
                    this.removeBounds();
                    this._pBounds = value;
                    this._worldBounds = value.clone();
                    this.pInvalidateBounds();
                    if (this._showBounds) {
                        this.addBounds();
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Entity.prototype, "worldBounds", {
                get: function () {
                    if (this._worldBoundsInvalid) {
                        this.updateWorldBounds();
                    }
                    return this._worldBounds;
                },
                enumerable: true,
                configurable: true
            });

            Entity.prototype.updateWorldBounds = function () {
                this._worldBounds.transformFrom(this.getBounds(), this.sceneTransform);
                this._worldBoundsInvalid = false;
            };

            //@override
            /*
            public set iImplicitPartition( value:away.partition.Partition3D )
            {
            */
            /*
            if( value == this._pImplicitPartition )
            {
            return;
            }
            
            if( this._pImplicitPartition )
            {
            this.notifyPartitionUnassigned();
            }
            
            super.iSetImplicitPartition( value );
            this.notifyPartitionAssigned();
            */
            /*
            this.iSetImplicitPartition( value );
            }
            */
            //@override
            Entity.prototype.iSetImplicitPartition = function (value) {
                if (value == this._pImplicitPartition) {
                    return;
                }

                if (this._pImplicitPartition) {
                    this.notifyPartitionUnassigned();
                }

                _super.prototype.iSetImplicitPartition.call(this, value);
                this.notifyPartitionAssigned();
            };

            Object.defineProperty(Entity.prototype, "scene", {
                set: //@override
                function (value) {
                    if (value == this._pScene) {
                        return;
                    }
                    if (this._pScene) {
                        this._pScene.iUnregisterEntity(this);
                    }

                    if (value) {
                        value.iRegisterEntity(this);
                    }

                    _super.prototype.setScene.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Entity.prototype, "assetType", {
                get: //@override
                function () {
                    return away.library.AssetType.ENTITY;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Entity.prototype, "pickingCollider", {
                get: function () {
                    return this._iPickingCollider;
                },
                set: function (value) {
                    this.setPickingCollider(value);
                },
                enumerable: true,
                configurable: true
            });


            Entity.prototype.setPickingCollider = function (value) {
                this._iPickingCollider = value;
            };

            Entity.prototype.getEntityPartitionNode = function () {
                if (!this._partitionNode) {
                    this._partitionNode = this.pCreateEntityPartitionNode();
                }
                return this._partitionNode;
            };

            Entity.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
                var localRayPosition = this.inverseSceneTransform.transformVector(rayPosition);
                var localRayDirection = this.inverseSceneTransform.deltaTransformVector(rayDirection);

                if (!this._iPickingCollisionVO.localNormal) {
                    this._iPickingCollisionVO.localNormal = new away.geom.Vector3D();
                }

                var rayEntryDistance = this._pBounds.rayIntersection(localRayPosition, localRayDirection, this._iPickingCollisionVO.localNormal);

                if (rayEntryDistance < 0) {
                    return false;
                }

                this._iPickingCollisionVO.rayEntryDistance = rayEntryDistance;
                this._iPickingCollisionVO.localRayPosition = localRayPosition;
                this._iPickingCollisionVO.localRayDirection = localRayDirection;
                this._iPickingCollisionVO.rayPosition = rayPosition;
                this._iPickingCollisionVO.rayDirection = rayDirection;
                this._iPickingCollisionVO.rayOriginIsInsideBounds = rayEntryDistance == 0;

                return true;
            };

            Entity.prototype.pCreateEntityPartitionNode = function () {
                throw new away.errors.AbstractMethodError();
            };

            Entity.prototype.pGetDefaultBoundingVolume = function () {
                // point lights should be using sphere bounds
                // directional lights should be using null bounds
                return new away.bounds.AxisAlignedBoundingBox();
            };

            Entity.prototype.pUpdateBounds = function () {
                throw new away.errors.AbstractMethodError();
            };

            Entity.prototype.pInvalidateSceneTransform = function () {
                if (!this._pIgnoreTransform) {
                    _super.prototype.pInvalidateSceneTransform.call(this);
                    this._worldBoundsInvalid = true;
                    this.notifySceneBoundsInvalid();
                }
            };

            Entity.prototype.pInvalidateBounds = function () {
                this._pBoundsInvalid = true;
                this._worldBoundsInvalid = true;
                this.notifySceneBoundsInvalid();
            };

            Entity.prototype.pUpdateMouseChildren = function () {
                if (this._pParent && !this.pickingCollider) {
                    if (this._pParent instanceof away.entities.Entity) {
                        var parentEntity = this._pParent;

                        var collider = parentEntity.pickingCollider;
                        if (collider) {
                            this.pickingCollider = collider;
                        }
                    }
                }

                _super.prototype.pUpdateMouseChildren.call(this);
            };

            Entity.prototype.notifySceneBoundsInvalid = function () {
                if (this._pScene) {
                    this._pScene.iInvalidateEntityBounds(this);
                }
            };

            Entity.prototype.notifyPartitionAssigned = function () {
                if (this._pScene) {
                    this._pScene.iRegisterPartition(this);
                }
            };

            Entity.prototype.notifyPartitionUnassigned = function () {
                if (this._pScene) {
                    this._pScene.iUnregisterPartition(this);
                }
            };

            Entity.prototype.addBounds = function () {
                if (!this._boundsIsShown) {
                    this._boundsIsShown = true;
                    this.addChild(this._pBounds.boundingRenderable);
                }
            };

            Entity.prototype.removeBounds = function () {
                if (this._boundsIsShown) {
                    this._boundsIsShown = false;
                    this.removeChild(this._pBounds.boundingRenderable);
                    this._pBounds.disposeRenderable();
                }
            };

            Entity.prototype.iInternalUpdate = function () {
                if (this._iController) {
                    this._iController.update();
                }
            };
            return Entity;
        })(away.containers.ObjectContainer3D);
        entities.Entity = Entity;
    })(away.entities || (away.entities = {}));
    var entities = away.entities;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (cameras) {
        var Camera3D = (function (_super) {
            __extends(Camera3D, _super);
            function Camera3D(lens) {
                if (typeof lens === "undefined") { lens = null; }
                _super.call(this);
                this._viewProjection = new away.geom.Matrix3D();
                this._viewProjectionDirty = true;
                this._frustumPlanesDirty = true;

                this._lens = lens || new away.cameras.PerspectiveLens();
                this._lens.addEventListener(away.events.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged, this);

                this._frustumPlanes = [];

                for (var i = 0; i < 6; ++i) {
                    this._frustumPlanes[i] = new away.math.Plane3D();
                }

                this.z = -1000;
            }
            Camera3D.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            Object.defineProperty(Camera3D.prototype, "assetType", {
                get: //@override
                function () {
                    return away.library.AssetType.CAMERA;
                },
                enumerable: true,
                configurable: true
            });

            Camera3D.prototype.onLensMatrixChanged = function (event) {
                this._viewProjectionDirty = true;
                this._frustumPlanesDirty = true;
                this.dispatchEvent(event);
            };

            Object.defineProperty(Camera3D.prototype, "frustumPlanes", {
                get: function () {
                    if (this._frustumPlanesDirty) {
                        this.updateFrustum();
                    }
                    return this._frustumPlanes;
                },
                enumerable: true,
                configurable: true
            });

            Camera3D.prototype.updateFrustum = function () {
                var a, b, c;

                //var d : Number;
                var c11, c12, c13, c14;
                var c21, c22, c23, c24;
                var c31, c32, c33, c34;
                var c41, c42, c43, c44;
                var p;
                var raw = new Array(16);
                ;
                var invLen;
                this.viewProjection.copyRawDataTo(raw);

                c11 = raw[0];
                c12 = raw[4];
                c13 = raw[8];
                c14 = raw[12];
                c21 = raw[1];
                c22 = raw[5];
                c23 = raw[9];
                c24 = raw[13];
                c31 = raw[2];
                c32 = raw[6];
                c33 = raw[10];
                c34 = raw[14];
                c41 = raw[3];
                c42 = raw[7];
                c43 = raw[11];
                c44 = raw[15];

                // left plane
                p = this._frustumPlanes[0];
                a = c41 + c11;
                b = c42 + c12;
                c = c43 + c13;
                invLen = 1 / Math.sqrt(a * a + b * b + c * c);
                p.a = a * invLen;
                p.b = b * invLen;
                p.c = c * invLen;
                p.d = -(c44 + c14) * invLen;

                // right plane
                p = this._frustumPlanes[1];
                a = c41 - c11;
                b = c42 - c12;
                c = c43 - c13;
                invLen = 1 / Math.sqrt(a * a + b * b + c * c);
                p.a = a * invLen;
                p.b = b * invLen;
                p.c = c * invLen;
                p.d = (c14 - c44) * invLen;

                // bottom
                p = this._frustumPlanes[2];
                a = c41 + c21;
                b = c42 + c22;
                c = c43 + c23;
                invLen = 1 / Math.sqrt(a * a + b * b + c * c);
                p.a = a * invLen;
                p.b = b * invLen;
                p.c = c * invLen;
                p.d = -(c44 + c24) * invLen;

                // top
                p = this._frustumPlanes[3];
                a = c41 - c21;
                b = c42 - c22;
                c = c43 - c23;
                invLen = 1 / Math.sqrt(a * a + b * b + c * c);
                p.a = a * invLen;
                p.b = b * invLen;
                p.c = c * invLen;
                p.d = (c24 - c44) * invLen;

                // near
                p = this._frustumPlanes[4];
                a = c31;
                b = c32;
                c = c33;
                invLen = 1 / Math.sqrt(a * a + b * b + c * c);
                p.a = a * invLen;
                p.b = b * invLen;
                p.c = c * invLen;
                p.d = -c34 * invLen;

                // far
                p = this._frustumPlanes[5];
                a = c41 - c31;
                b = c42 - c32;
                c = c43 - c33;
                invLen = 1 / Math.sqrt(a * a + b * b + c * c);
                p.a = a * invLen;
                p.b = b * invLen;
                p.c = c * invLen;
                p.d = (c34 - c44) * invLen;

                this._frustumPlanesDirty = false;
            };

            //@override
            Camera3D.prototype.pInvalidateSceneTransform = function () {
                _super.prototype.pInvalidateSceneTransform.call(this);

                this._viewProjectionDirty = true;
                this._frustumPlanesDirty = true;
            };

            //@override
            Camera3D.prototype.pUpdateBounds = function () {
                this._pBounds.nullify();
                this._pBoundsInvalid = false;
            };

            //@override
            Camera3D.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.CameraNode(this);
            };

            Object.defineProperty(Camera3D.prototype, "lens", {
                get: function () {
                    return this._lens;
                },
                set: function (value) {
                    if (this._lens == value) {
                        return;
                    }
                    if (!value) {
                        throw new Error("Lens cannot be null!");
                    }
                    this._lens.removeEventListener(away.events.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged, this);
                    this._lens = value;
                    this._lens.addEventListener(away.events.LensEvent.MATRIX_CHANGED, this.onLensMatrixChanged, this);
                    this.dispatchEvent(new away.events.CameraEvent(away.events.CameraEvent.LENS_CHANGED, this));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Camera3D.prototype, "viewProjection", {
                get: function () {
                    if (this._viewProjectionDirty) {
                        this._viewProjection.copyFrom(this.inverseSceneTransform);
                        this._viewProjection.append(this._lens.matrix);
                        this._viewProjectionDirty = false;
                    }
                    return this._viewProjection;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Calculates the ray in scene space from the camera to the given normalized coordinates in screen space.
            *
            * @param nX The normalised x coordinate in screen space, -1 corresponds to the left edge of the viewport, 1 to the right.
            * @param nY The normalised y coordinate in screen space, -1 corresponds to the top edge of the viewport, 1 to the bottom.
            * @param sZ The z coordinate in screen space, representing the distance into the screen.
            * @return The ray from the camera to the scene space position of the given screen coordinates.
            */
            Camera3D.prototype.getRay = function (nX, nY, sZ) {
                return this.sceneTransform.deltaTransformVector(this._lens.unproject(nX, nY, sZ));
            };

            /**
            * Calculates the normalised position in screen space of the given scene position.
            *
            * @param point3d the position vector of the scene coordinates to be projected.
            * @return The normalised screen position of the given scene coordinates.
            */
            Camera3D.prototype.project = function (point3d) {
                return this._lens.project(this.inverseSceneTransform.transformVector(point3d));
            };

            /**
            * Calculates the scene position of the given normalized coordinates in screen space.
            *
            * @param nX The normalised x coordinate in screen space, -1 corresponds to the left edge of the viewport, 1 to the right.
            * @param nY The normalised y coordinate in screen space, -1 corresponds to the top edge of the viewport, 1 to the bottom.
            * @param sZ The z coordinate in screen space, representing the distance into the screen.
            * @return The scene position of the given screen coordinates.
            */
            Camera3D.prototype.unproject = function (nX, nY, sZ) {
                return this.sceneTransform.transformVector(this._lens.unproject(nX, nY, sZ));
            };
            return Camera3D;
        })(away.entities.Entity);
        cameras.Camera3D = Camera3D;
    })(away.cameras || (away.cameras = {}));
    var cameras = away.cameras;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (entities) {
        var SegmentSet = (function (_super) {
            __extends(SegmentSet, _super);
            function SegmentSet() {
                _super.call(this);
                this.LIMIT = 3 * 0xFFFF;
                this._indexSegments = 0;

                this._subSetCount = 0;
                this._subSets = [];
                this.addSubSet();

                this._pSegments = new Object();

                this.material = new away.materials.SegmentMaterial();
            }
            SegmentSet.prototype.addSegment = function (segment) {
                segment.iSegmentsBase = this;

                this._hasData = true;

                var subSetIndex = this._subSets.length - 1;
                var subSet = this._subSets[subSetIndex];

                if (subSet.vertices.length + 44 > this.LIMIT) {
                    subSet = this.addSubSet();
                    subSetIndex++;
                }

                segment.iIndex = subSet.vertices.length;
                segment.iSubSetIndex = subSetIndex;

                this.iUpdateSegment(segment);

                var index = subSet.lineCount << 2;

                subSet.indices.push(index, index + 1, index + 2, index + 3, index + 2, index + 1);
                subSet.numVertices = subSet.vertices.length / 11;
                subSet.numIndices = subSet.indices.length;
                subSet.lineCount++;

                var segRef = new SegRef();
                segRef.index = index;
                segRef.subSetIndex = subSetIndex;
                segRef.segment = segment;

                this._pSegments[this._indexSegments] = segRef;

                this._indexSegments++;
            };

            SegmentSet.prototype.removeSegmentByIndex = function (index, dispose) {
                if (typeof dispose === "undefined") { dispose = false; }
                var segRef;
                if (index >= this._indexSegments) {
                    return;
                }
                if (this._pSegments[index]) {
                    segRef = this._pSegments[index];
                } else {
                    return;
                }

                var subSet;
                if (!this._subSets[segRef.subSetIndex]) {
                    return;
                }

                var subSetIndex = segRef.subSetIndex;
                subSet = this._subSets[segRef.subSetIndex];

                var segment = segRef.segment;
                var indices = subSet.indices;

                var ind = index * 6;
                for (var i = ind; i < indices.length; ++i) {
                    indices[i] -= 4;
                }
                subSet.indices.splice(index * 6, 6);
                subSet.vertices.splice(index * 44, 44);
                subSet.numVertices = subSet.vertices.length / 11;
                subSet.numIndices = indices.length;
                subSet.vertexBufferDirty = true;
                subSet.indexBufferDirty = true;
                subSet.lineCount--;

                if (dispose) {
                    segment.dispose();
                    segment = null;
                } else {
                    segment.iIndex = -1;
                    segment.iSegmentsBase = null;
                }

                if (subSet.lineCount == 0) {
                    if (subSetIndex == 0) {
                        this._hasData = false;
                    } else {
                        subSet.dispose();
                        this._subSets[subSetIndex] = null;
                        this._subSets.splice(subSetIndex, 1);
                    }
                }

                this.reOrderIndices(subSetIndex, index);

                segRef = null;
                this._pSegments[this._indexSegments] = null;
                this._indexSegments--;
            };

            SegmentSet.prototype.removeSegment = function (segment, dispose) {
                if (typeof dispose === "undefined") { dispose = false; }
                if (segment.iIndex == -1) {
                    return;
                }
                this.removeSegmentByIndex(segment.iIndex / 44);
            };

            SegmentSet.prototype.removeAllSegments = function () {
                var subSet;
                for (var i = 0; i < this._subSetCount; ++i) {
                    subSet = this._subSets[i];
                    subSet.vertices = null;
                    subSet.indices = null;
                    if (subSet.vertexBuffer) {
                        subSet.vertexBuffer.dispose();
                    }
                    if (subSet.indexBuffer) {
                        subSet.indexBuffer.dispose();
                    }
                    subSet = null;
                }

                for (var segRef in this._pSegments) {
                    segRef = null;
                }
                this._pSegments = null;
                this._subSetCount = 0;
                this._activeSubSet = null;
                this._indexSegments = 0;
                this._subSets = [];
                this._pSegments = new Object();

                this.addSubSet();

                this._hasData = false;
            };

            SegmentSet.prototype.getSegment = function (index) {
                if (index > this._indexSegments - 1) {
                    return null;
                }
                return this._pSegments[index].segment;
            };

            Object.defineProperty(SegmentSet.prototype, "segmentCount", {
                get: function () {
                    return this._indexSegments;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "iSubSetCount", {
                get: function () {
                    return this._subSetCount;
                },
                enumerable: true,
                configurable: true
            });

            SegmentSet.prototype.iUpdateSegment = function (segment) {
                var start = segment._pStart;
                var end = segment._pEnd;
                var startX = start.x, startY = start.y, startZ = start.z;
                var endX = end.x, endY = end.y, endZ = end.z;
                var startR = segment._pStartR, startG = segment._pStartG, startB = segment._pStartB;
                var endR = segment._pEndR, endG = segment._pEndG, endB = segment._pEndB;
                var index = segment.iIndex;
                var t = segment.thickness;

                var subSet = this._subSets[segment.iSubSetIndex];
                var vertices = subSet.vertices;

                vertices[index++] = startX;
                vertices[index++] = startY;
                vertices[index++] = startZ;
                vertices[index++] = endX;
                vertices[index++] = endY;
                vertices[index++] = endZ;
                vertices[index++] = t;
                vertices[index++] = startR;
                vertices[index++] = startG;
                vertices[index++] = startB;
                vertices[index++] = 1;

                vertices[index++] = endX;
                vertices[index++] = endY;
                vertices[index++] = endZ;
                vertices[index++] = startX;
                vertices[index++] = startY;
                vertices[index++] = startZ;
                vertices[index++] = -t;
                vertices[index++] = endR;
                vertices[index++] = endG;
                vertices[index++] = endB;
                vertices[index++] = 1;

                vertices[index++] = startX;
                vertices[index++] = startY;
                vertices[index++] = startZ;
                vertices[index++] = endX;
                vertices[index++] = endY;
                vertices[index++] = endZ;
                vertices[index++] = -t;
                vertices[index++] = startR;
                vertices[index++] = startG;
                vertices[index++] = startB;
                vertices[index++] = 1;

                vertices[index++] = endX;
                vertices[index++] = endY;
                vertices[index++] = endZ;
                vertices[index++] = startX;
                vertices[index++] = startY;
                vertices[index++] = startZ;
                vertices[index++] = t;
                vertices[index++] = endR;
                vertices[index++] = endG;
                vertices[index++] = endB;
                vertices[index++] = 1;

                subSet.vertexBufferDirty = true;

                this._pBoundsInvalid = true;
            };

            Object.defineProperty(SegmentSet.prototype, "hasData", {
                get: function () {
                    return this._hasData;
                },
                enumerable: true,
                configurable: true
            });

            SegmentSet.prototype.getIndexBuffer = function (stage3DProxy) {
                if (this._activeSubSet.indexContext3D != stage3DProxy.context3D || this._activeSubSet.indexBufferDirty) {
                    this._activeSubSet.indexBuffer = stage3DProxy._iContext3D.createIndexBuffer(this._activeSubSet.numIndices);
                    this._activeSubSet.indexBuffer.uploadFromArray(this._activeSubSet.indices, 0, this._activeSubSet.numIndices);
                    this._activeSubSet.indexBufferDirty = false;
                    this._activeSubSet.indexContext3D = stage3DProxy.context3D;
                }

                return this._activeSubSet.indexBuffer;
            };

            SegmentSet.prototype.activateVertexBuffer = function (index, stage3DProxy) {
                var subSet = this._subSets[index];

                this._activeSubSet = subSet;
                this._numIndices = subSet.numIndices;

                var vertexBuffer = subSet.vertexBuffer;

                if (subSet.vertexContext3D != stage3DProxy.context3D || subSet.vertexBufferDirty) {
                    subSet.vertexBuffer = stage3DProxy._iContext3D.createVertexBuffer(subSet.numVertices, 11);
                    subSet.vertexBuffer.uploadFromArray(subSet.vertices, 0, subSet.numVertices);
                    subSet.vertexBufferDirty = false;
                    subSet.vertexContext3D = stage3DProxy.context3D;
                }

                var context3d = stage3DProxy._iContext3D;
                context3d.setVertexBufferAt(0, vertexBuffer, 0, away.display3D.Context3DVertexBufferFormat.FLOAT_3);
                context3d.setVertexBufferAt(1, vertexBuffer, 3, away.display3D.Context3DVertexBufferFormat.FLOAT_3);
                context3d.setVertexBufferAt(2, vertexBuffer, 6, away.display3D.Context3DVertexBufferFormat.FLOAT_1);
                context3d.setVertexBufferAt(3, vertexBuffer, 7, away.display3D.Context3DVertexBufferFormat.FLOAT_4);
            };

            SegmentSet.prototype.activateUVBuffer = function (index, stage3DProxy) {
            };

            SegmentSet.prototype.activateVertexNormalBuffer = function (index, stage3DProxy) {
            };

            SegmentSet.prototype.activateVertexTangentBuffer = function (index, stage3DProxy) {
            };

            SegmentSet.prototype.activateSecondaryUVBuffer = function (index, stage3DProxy) {
            };

            SegmentSet.prototype.reOrderIndices = function (subSetIndex, index) {
                var segRef;

                for (var i = index; i < this._indexSegments - 1; ++i) {
                    segRef = this._pSegments[i + 1];
                    segRef.index = i;
                    if (segRef.subSetIndex == subSetIndex) {
                        segRef.segment.iIndex -= 44;
                    }
                    this._pSegments[i] = segRef;
                }
            };

            SegmentSet.prototype.addSubSet = function () {
                var subSet = new SubSet();
                this._subSets.push(subSet);

                subSet.vertices = [];
                subSet.numVertices = 0;
                subSet.indices = [];
                subSet.numIndices = 0;
                subSet.vertexBufferDirty = true;
                subSet.indexBufferDirty = true;
                subSet.lineCount = 0;

                this._subSetCount++;

                return subSet;
            };

            //@override
            SegmentSet.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.removeAllSegments();
                this._pSegments = null;
                this._material = null;
                var subSet = this._subSets[0];
                subSet.vertices = null;
                subSet.indices = null;
                this._subSets = null;
            };

            Object.defineProperty(SegmentSet.prototype, "mouseEnabled", {
                get: //@override
                function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            SegmentSet.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.BoundingSphere();
            };

            //@override
            SegmentSet.prototype.pUpdateBounds = function () {
                var subSet;
                var len;
                var v;
                var index;

                var minX = Infinity;
                var minY = Infinity;
                var minZ = Infinity;
                var maxX = -Infinity;
                var maxY = -Infinity;
                var maxZ = -Infinity;
                var vertices;

                for (var i = 0; i < this._subSetCount; ++i) {
                    subSet = this._subSets[i];
                    index = 0;
                    vertices = subSet.vertices;
                    len = vertices.length;

                    if (len == 0) {
                        continue;
                    }

                    while (index < len) {
                        v = vertices[index++];
                        if (v < minX)
                            minX = v;
else if (v > maxX)
                            maxX = v;

                        v = vertices[index++];
                        if (v < minY)
                            minY = v;
else if (v > maxY)
                            maxY = v;

                        v = vertices[index++];
                        if (v < minZ)
                            minZ = v;
else if (v > maxZ)
                            maxZ = v;

                        index += 8;
                    }
                }

                if (minX != Infinity) {
                    this._pBounds.fromExtremes(minX, minY, minZ, maxX, maxY, maxZ);
                } else {
                    var min = .5;
                    this._pBounds.fromExtremes(-min, -min, -min, min, min, min);
                }

                this._pBoundsInvalid = false;
            };

            //@override
            SegmentSet.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.RenderableNode(this);
            };

            Object.defineProperty(SegmentSet.prototype, "numTriangles", {
                get: function () {
                    return this._numIndices / 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "sourceEntity", {
                get: function () {
                    return this;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "castsShadows", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "material", {
                get: function () {
                    return this._material;
                },
                set: function (value) {
                    if (value == this._material) {
                        return;
                    }
                    if (this._material) {
                        this._material.iRemoveOwner(this);
                    }
                    this._material = value;
                    if (this._material) {
                        this._material.iAddOwner(this);
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "animator", {
                get: function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SegmentSet.prototype, "uvTransform", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "vertexData", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "indexData", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "UVData", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "numVertices", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "vertexStride", {
                get: function () {
                    return 11;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "vertexNormalData", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "vertexTangentData", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "vertexOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "vertexNormalOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "vertexTangentOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SegmentSet.prototype, "assetType", {
                get: //@override
                function () {
                    return away.library.AssetType.SEGMENT_SET;
                },
                enumerable: true,
                configurable: true
            });

            SegmentSet.prototype.getRenderSceneTransform = function (camera) {
                return this._pSceneTransform;
            };
            return SegmentSet;
        })(away.entities.Entity);
        entities.SegmentSet = SegmentSet;

        var SegRef = (function () {
            function SegRef() {
            }
            return SegRef;
        })();

        var SubSet = (function () {
            function SubSet() {
            }
            SubSet.prototype.dispose = function () {
                this.vertices = null;
                if (this.vertexBuffer) {
                    this.vertexBuffer.dispose();
                }
                if (this.indexBuffer) {
                    this.indexBuffer.dispose();
                }
            };
            return SubSet;
        })();
    })(away.entities || (away.entities = {}));
    var entities = away.entities;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (entities) {
        /**
        * Mesh is an instance of a Geometry, augmenting it with a presence in the scene graph, a material, and an animation
        * state. It consists out of SubMeshes, which in turn correspond to SubGeometries. SubMeshes allow different parts
        * of the geometry to be assigned different materials.
        */
        var Mesh = (function (_super) {
            __extends(Mesh, _super);
            /**
            * Create a new Mesh object.
            *
            * @param geometry                    The geometry used by the mesh that provides it with its shape.
            * @param material    [optional]        The material with which to render the Mesh.
            */
            function Mesh(geometry, material) {
                if (typeof material === "undefined") { material = null; }
                _super.call(this);
                this._castsShadows = true;
                this._shareAnimationGeometry = true;

                this._subMeshes = new Array();

                if (geometry == null) {
                    this.geometry = new away.base.Geometry();
                } else {
                    this.geometry = geometry;
                }

                if (material == null) {
                    this.material = away.materials.DefaultMaterialManager.getDefaultMaterial(this);
                } else {
                    this.material = material;
                }
            }
            Mesh.prototype.bakeTransformations = function () {
                this.geometry.applyTransformation(this.transform);
                this.transform.identity();
            };

            Object.defineProperty(Mesh.prototype, "assetType", {
                get: function () {
                    return away.library.AssetType.MESH;
                },
                enumerable: true,
                configurable: true
            });

            Mesh.prototype.onGeometryBoundsInvalid = function (event) {
                this.pInvalidateBounds();
            };

            Object.defineProperty(Mesh.prototype, "castsShadows", {
                get: /**
                * Indicates whether or not the Mesh can cast shadows. Default value is <code>true</code>.
                */
                function () {
                    return this._castsShadows;
                },
                set: function (value) {
                    this._castsShadows = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "animator", {
                get: /**
                * Defines the animator of the mesh. Act on the mesh's geometry.  Default value is <code>null</code>.
                */
                function () {
                    return this._animator;
                },
                set: function (value) {
                    if (this._animator)
                        this._animator.removeOwner(this);

                    this._animator = value;

                    // cause material to be unregistered and registered again to work with the new animation type (if possible)
                    var oldMaterial = this.material;
                    this.material = null;
                    this.material = oldMaterial;

                    var len = this._subMeshes.length;
                    var subMesh;

                    for (var i = 0; i < len; ++i) {
                        subMesh = this._subMeshes[i];
                        oldMaterial = subMesh._iMaterial;
                        if (oldMaterial) {
                            subMesh.material = null;
                            subMesh.material = oldMaterial;
                        }
                    }

                    if (this._animator)
                        this._animator.addOwner(this);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "geometry", {
                get: /**
                * The geometry used by the mesh that provides it with its shape.
                */
                function () {
                    return this._geometry;
                },
                set: function (value) {
                    var i;

                    if (this._geometry) {
                        this._geometry.removeEventListener(away.events.GeometryEvent.BOUNDS_INVALID, this.onGeometryBoundsInvalid, this);
                        this._geometry.removeEventListener(away.events.GeometryEvent.SUB_GEOMETRY_ADDED, this.onSubGeometryAdded, this);
                        this._geometry.removeEventListener(away.events.GeometryEvent.SUB_GEOMETRY_REMOVED, this.onSubGeometryRemoved, this);

                        for (i = 0; i < this._subMeshes.length; ++i) {
                            this._subMeshes[i].dispose();
                        }

                        this._subMeshes.length = 0;
                    }

                    this._geometry = value;

                    if (this._geometry) {
                        this._geometry.addEventListener(away.events.GeometryEvent.BOUNDS_INVALID, this.onGeometryBoundsInvalid, this);
                        this._geometry.addEventListener(away.events.GeometryEvent.SUB_GEOMETRY_ADDED, this.onSubGeometryAdded, this);
                        this._geometry.addEventListener(away.events.GeometryEvent.SUB_GEOMETRY_REMOVED, this.onSubGeometryRemoved, this);

                        //var subGeoms:Vector.<ISubGeometry> = _geometry.subGeometries;
                        var subGeoms = this._geometry.subGeometries;

                        for (i = 0; i < subGeoms.length; ++i) {
                            this.addSubMesh(subGeoms[i]);
                        }
                    }

                    if (this._material) {
                        this._material.iRemoveOwner(this);
                        this._material.iAddOwner(this);
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "material", {
                get: /**
                * The material with which to render the Mesh.
                */
                function () {
                    return this._material;
                },
                set: function (value) {
                    if (value == this._material) {
                        return;
                    }

                    if (this._material) {
                        this._material.iRemoveOwner(this);
                    }

                    this._material = value;

                    if (this._material) {
                        this._material.iAddOwner(this);
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mesh.prototype, "subMeshes", {
                get: /**
                * The SubMeshes out of which the Mesh consists. Every SubMesh can be assigned a material to override the Mesh's
                * material.
                */
                function () {
                    // Since this getter is invoked every iteration of the render loop, and
                    // the geometry construct could affect the sub-meshes, the geometry is
                    // validated here to give it a chance to rebuild.
                    this._geometry.iValidate();

                    return this._subMeshes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mesh.prototype, "shareAnimationGeometry", {
                get: /**
                * Indicates whether or not the mesh share the same animation geometry.
                */
                function () {
                    return this._shareAnimationGeometry;
                },
                set: function (value) {
                    this._shareAnimationGeometry = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Clears the animation geometry of this mesh. It will cause animation to generate a new animation geometry. Work only when shareAnimationGeometry is false.
            */
            Mesh.prototype.clearAnimationGeometry = function () {
                away.Debug.throwPIR("away.entities.Mesh", "away.entities.Mesh", "Missing Dependency: IAnimator");
                /* TODO: Missing Dependency: IAnimator
                var len:number = this._subMeshes.length;
                for (var i:number = 0; i < len; ++i)
                {
                
                this._subMeshes[i].animationSubGeometry = null;
                
                }
                */
            };

            /**
            * @inheritDoc
            */
            Mesh.prototype.dispose = function () {
                _super.prototype.dispose.call(this);

                this.material = null;
                this.geometry = null;
            };

            /**
            * Disposes mesh including the animator and children. This is a merely a convenience method.
            * @return
            */
            Mesh.prototype.disposeWithAnimatorAndChildren = function () {
                this.disposeWithChildren();

                away.Debug.throwPIR("away.entities.Mesh", "away.entities.Mesh", "Missing Dependency: IAnimator");
                /* TODO: Missing Dependency: IAnimator
                if (this._animator)
                {
                
                this._animator.dispose();
                
                }
                */
            };

            /**
            * Clones this Mesh instance along with all it's children, while re-using the same
            * material, geometry and animation set. The returned result will be a copy of this mesh,
            * containing copies of all of it's children.
            *
            * Properties that are re-used (i.e. not cloned) by the new copy include name,
            * geometry, and material. Properties that are cloned or created anew for the copy
            * include subMeshes, children of the mesh, and the animator.
            *
            * If you want to copy just the mesh, reusing it's geometry and material while not
            * cloning it's children, the simplest way is to create a new mesh manually:
            *
            * <code>
            * var clone : Mesh = new Mesh(original.geometry, original.material);
            * </code>
            */
            Mesh.prototype.clone = function () {
                var clone = new away.entities.Mesh(this._geometry, this._material);
                clone.transform = this.transform;
                clone.pivotPoint = this.pivotPoint;
                clone.partition = this.partition;
                clone.bounds = this._pBounds.clone();

                clone.name = this.name;
                clone.castsShadows = this.castsShadows;
                clone.shareAnimationGeometry = this.shareAnimationGeometry;
                clone.mouseEnabled = this.mouseEnabled;
                clone.mouseChildren = this.mouseChildren;

                //this is of course no proper cloning
                //maybe use this instead?: http://blog.another-d-mention.ro/programming/how-to-clone-duplicate-an-object-in-actionscript-3/
                clone.extra = this.extra;

                var len = this._subMeshes.length;
                for (var i = 0; i < len; ++i) {
                    clone._subMeshes[i]._iMaterial = this._subMeshes[i]._iMaterial;
                }

                len = this.numChildren;
                var obj;

                for (i = 0; i < len; ++i) {
                    obj = this.getChildAt(i).clone();
                    clone.addChild(obj);
                }

                if (this._animator) {
                    clone.animator = this._animator.clone();
                }

                return clone;
            };

            /**
            * @inheritDoc
            */
            Mesh.prototype.pUpdateBounds = function () {
                this._pBounds.fromGeometry(this._geometry);
                this._pBoundsInvalid = false;
            };

            /**
            * @inheritDoc
            */
            Mesh.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.MeshNode(this);
            };

            /**
            * Called when a SubGeometry was added to the Geometry.
            */
            Mesh.prototype.onSubGeometryAdded = function (event) {
                this.addSubMesh(event.subGeometry);
            };

            /**
            * Called when a SubGeometry was removed from the Geometry.
            */
            Mesh.prototype.onSubGeometryRemoved = function (event) {
                var subMesh;
                var subGeom = event.subGeometry;
                var len = this._subMeshes.length;
                var i;

                for (i = 0; i < len; ++i) {
                    subMesh = this._subMeshes[i];

                    if (subMesh.subGeometry == subGeom) {
                        subMesh.dispose();

                        this._subMeshes.splice(i, 1);

                        break;
                    }
                }

                --len;
                for (; i < len; ++i) {
                    this._subMeshes[i]._iIndex = i;
                }
            };

            /**
            * Adds a SubMesh wrapping a SubGeometry.
            */
            Mesh.prototype.addSubMesh = function (subGeometry) {
                var subMesh = new away.base.SubMesh(subGeometry, this, null);
                var len = this._subMeshes.length;

                subMesh._iIndex = len;

                this._subMeshes[len] = subMesh;

                this.pInvalidateBounds();
            };

            Mesh.prototype.getSubMeshForSubGeometry = function (subGeometry) {
                return this._subMeshes[this._geometry.subGeometries.indexOf(subGeometry)];
            };

            Mesh.prototype.iCollidesBefore = function (shortestCollisionDistance, findClosest) {
                this._iPickingCollider.setLocalRay(this._iPickingCollisionVO.localRayPosition, this._iPickingCollisionVO.localRayDirection);
                this._iPickingCollisionVO.renderable = null;
                var len = this._subMeshes.length;
                for (var i = 0; i < len; ++i) {
                    var subMesh = this._subMeshes[i];

                    if (this._iPickingCollider.testSubMeshCollision(subMesh, this._iPickingCollisionVO, shortestCollisionDistance)) {
                        shortestCollisionDistance = this._iPickingCollisionVO.rayEntryDistance;

                        this._iPickingCollisionVO.renderable = subMesh;

                        if (!findClosest) {
                            return true;
                        }
                    }
                }

                return this._iPickingCollisionVO.renderable != null;
            };
            return Mesh;
        })(away.entities.Entity);
        entities.Mesh = Mesh;
    })(away.entities || (away.entities = {}));
    var entities = away.entities;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (entities) {
        /**
        * Sprite3D is a 3D billboard, a renderable rectangular area that is always aligned with the projection plane.
        * As a result, no perspective transformation occurs on a Sprite3D object.
        *
        * todo: mvp generation or vertex shader code can be optimized
        */
        var Sprite3D = (function (_super) {
            __extends(Sprite3D, _super);
            function Sprite3D(material, width, height) {
                _super.call(this);
                this._shadowCaster = false;
                this.material = material;
                this._width = width;
                this._height = height;
                this._spriteMatrix = new away.geom.Matrix3D();
                if (!Sprite3D._geometry) {
                    Sprite3D._geometry = new away.base.SubGeometry();
                    Sprite3D._geometry.updateVertexData(Array(-.5, .5, .0, .5, .5, .0, .5, -.5, .0, -.5, -.5, .0));
                    Sprite3D._geometry.updateUVData(Array(.0, .0, 1.0, .0, 1.0, 1.0, .0, 1.0));
                    Sprite3D._geometry.updateIndexData(Array(0, 1, 2, 0, 2, 3));
                    Sprite3D._geometry.updateVertexTangentData(Array(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0));
                    Sprite3D._geometry.updateVertexNormalData(Array(.0, .0, -1.0, .0, .0, -1.0, .0, .0, -1.0, .0, .0, -1.0));
                }
            }
            Object.defineProperty(Sprite3D.prototype, "pickingCollider", {
                set: function (value) {
                    _super.prototype.setPickingCollider.call(this, value);

                    if (value) {
                        this._pickingSubMesh = new away.base.SubMesh(Sprite3D._geometry, null);
                        this._pickingTransform = new away.geom.Matrix3D();
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "width", {
                get: function () {
                    return this._width;
                },
                set: function (value) {
                    if (this._width == value)
                        return;
                    this._width = value;
                    this.iInvalidateTransform();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Sprite3D.prototype, "height", {
                get: function () {
                    return this._height;
                },
                set: function (value) {
                    if (this._height == value)
                        return;
                    this._height = value;
                    this.iInvalidateTransform();
                },
                enumerable: true,
                configurable: true
            });


            Sprite3D.prototype.activateVertexBuffer = function (index, stage3DProxy) {
                Sprite3D._geometry.activateVertexBuffer(index, stage3DProxy);
            };

            Sprite3D.prototype.activateUVBuffer = function (index, stage3DProxy) {
                Sprite3D._geometry.activateUVBuffer(index, stage3DProxy);
            };

            Sprite3D.prototype.activateSecondaryUVBuffer = function (index, stage3DProxy) {
                Sprite3D._geometry.activateSecondaryUVBuffer(index, stage3DProxy);
            };

            Sprite3D.prototype.activateVertexNormalBuffer = function (index, stage3DProxy) {
                Sprite3D._geometry.activateVertexNormalBuffer(index, stage3DProxy);
            };

            Sprite3D.prototype.activateVertexTangentBuffer = function (index, stage3DProxy) {
                Sprite3D._geometry.activateVertexTangentBuffer(index, stage3DProxy);
            };

            Sprite3D.prototype.getIndexBuffer = function (stage3DProxy) {
                return Sprite3D._geometry.getIndexBuffer(stage3DProxy);
            };

            Object.defineProperty(Sprite3D.prototype, "numTriangles", {
                get: function () {
                    return 2;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "sourceEntity", {
                get: function () {
                    return this;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "material", {
                get: function () {
                    return this._material;
                },
                set: function (value) {
                    if (value == this._material)
                        return;
                    if (this._material)
                        this._material.iRemoveOwner(this);
                    this._material = value;
                    if (this._material)
                        this._material.iAddOwner(this);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Sprite3D.prototype, "animator", {
                get: /**
                * Defines the animator of the mesh. Act on the mesh's geometry. Defaults to null
                */
                function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "castsShadows", {
                get: function () {
                    return this._shadowCaster;
                },
                enumerable: true,
                configurable: true
            });

            Sprite3D.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.AxisAlignedBoundingBox();
            };

            Sprite3D.prototype.pUpdateBounds = function () {
                this._pBounds.fromExtremes(-.5 * this._pScaleX, -.5 * this._pScaleY, -.5 * this._pScaleZ, .5 * this._pScaleX, .5 * this._pScaleY, .5 * this._pScaleZ);
                this._pBoundsInvalid = false;
            };

            Sprite3D.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.RenderableNode(this);
            };

            Sprite3D.prototype.pUpdateTransform = function () {
                _super.prototype.pUpdateTransform.call(this);
                this._pTransform.prependScale(this._width, this._height, Math.max(this._width, this._height));
            };

            Object.defineProperty(Sprite3D.prototype, "uvTransform", {
                get: function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "vertexData", {
                get: function () {
                    return Sprite3D._geometry.vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "indexData", {
                get: function () {
                    return Sprite3D._geometry.indexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "UVData", {
                get: function () {
                    return Sprite3D._geometry.UVData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "numVertices", {
                get: function () {
                    return Sprite3D._geometry.numVertices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "vertexStride", {
                get: function () {
                    return Sprite3D._geometry.vertexStride;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "vertexNormalData", {
                get: function () {
                    return Sprite3D._geometry.vertexNormalData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "vertexTangentData", {
                get: function () {
                    return Sprite3D._geometry.vertexTangentData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "vertexOffset", {
                get: function () {
                    return Sprite3D._geometry.vertexOffset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "vertexNormalOffset", {
                get: function () {
                    return Sprite3D._geometry.vertexNormalOffset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Sprite3D.prototype, "vertexTangentOffset", {
                get: function () {
                    return Sprite3D._geometry.vertexTangentOffset;
                },
                enumerable: true,
                configurable: true
            });

            Sprite3D.prototype.iCollidesBefore = function (shortestCollisionDistance, findClosest) {
                findClosest = findClosest;

                var viewTransform = this._camera.inverseSceneTransform.clone();
                viewTransform.transpose();
                var rawViewTransform = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;
                viewTransform.copyRawDataTo(rawViewTransform);
                rawViewTransform[3] = 0;
                rawViewTransform[7] = 0;
                rawViewTransform[11] = 0;
                rawViewTransform[12] = 0;
                rawViewTransform[13] = 0;
                rawViewTransform[14] = 0;

                this._pickingTransform.copyRawDataFrom(rawViewTransform);
                this._pickingTransform.prependScale(this._width, this._height, Math.max(this._width, this._height));
                this._pickingTransform.appendTranslation(this.scenePosition.x, this.scenePosition.y, this.scenePosition.z);
                this._pickingTransform.invert();

                var localRayPosition = this._pickingTransform.transformVector(this._iPickingCollisionVO.rayPosition);
                var localRayDirection = this._pickingTransform.deltaTransformVector(this._iPickingCollisionVO.rayDirection);

                this._iPickingCollider.setLocalRay(localRayPosition, localRayDirection);

                this._iPickingCollisionVO.renderable = null;

                if (this._iPickingCollider.testSubMeshCollision(this._pickingSubMesh, this._iPickingCollisionVO, shortestCollisionDistance))
                    this._iPickingCollisionVO.renderable = this._pickingSubMesh;

                return this._iPickingCollisionVO.renderable != null;
            };

            Sprite3D.prototype.getRenderSceneTransform = function (camera) {
                var comps = camera.sceneTransform.decompose();
                var scale = comps[2];
                comps[0] = this.scenePosition;
                scale.x = this._width * this._pScaleX;
                scale.y = this._height * this._pScaleY;
                this._spriteMatrix.recompose(comps);
                return this._spriteMatrix;
            };
            return Sprite3D;
        })(away.entities.Entity);
        entities.Sprite3D = Sprite3D;
    })(away.entities || (away.entities = {}));
    var entities = away.entities;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * SubMesh wraps a SubGeometry as a scene graph instantiation. A SubMesh is owned by a Mesh object.
        *
        *
        * @see away3d.core.base.SubGeometry
        * @see away3d.scenegraph.Mesh
        *
        * @class away.base.SubGeometryBase
        */
        var SubMesh = (function () {
            //public animationSubGeometry:AnimationSubGeometry;// TODO: implement dependencies AnimationSubGeometry
            //public animatorSubGeometry:AnimationSubGeometry;// TODO: implement dependencies AnimationSubGeometry
            /**
            * Creates a new SubMesh object
            * @param subGeometry The SubGeometry object which provides the geometry data for this SubMesh.
            * @param parentMesh The Mesh object to which this SubMesh belongs.
            * @param material An optional material used to render this SubMesh.
            */
            function SubMesh(subGeometry, parentMesh, material) {
                if (typeof material === "undefined") { material = null; }
                this._iIndex = 0;
                this._uvRotation = 0;
                this._scaleU = 1;
                this._scaleV = 1;
                this._offsetU = 0;
                this._offsetV = 0;
                this._parentMesh = parentMesh;
                this._subGeometry = subGeometry;
                this.material = material;
            }
            Object.defineProperty(SubMesh.prototype, "shaderPickingDetails", {
                get: function () {
                    return this.sourceEntity.shaderPickingDetails;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "offsetU", {
                get: function () {
                    return this._offsetU;
                },
                set: function (value) {
                    if (value == this._offsetU) {
                        return;
                    }

                    this._offsetU = value;
                    this._uvTransformDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "offsetV", {
                get: function () {
                    return this._offsetV;
                },
                set: function (value) {
                    if (value == this._offsetV) {
                        return;
                    }

                    this._offsetV = value;
                    this._uvTransformDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "scaleU", {
                get: function () {
                    return this._scaleU;
                },
                set: function (value) {
                    if (value == this._scaleU) {
                        return;
                    }

                    this._scaleU = value;
                    this._uvTransformDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "scaleV", {
                get: function () {
                    return this._scaleV;
                },
                set: function (value) {
                    if (value == this._scaleV) {
                        return;
                    }

                    this._scaleV = value;
                    this._uvTransformDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "uvRotation", {
                get: function () {
                    return this._uvRotation;
                },
                set: function (value) {
                    if (value == this._uvRotation) {
                        return;
                    }

                    this._uvRotation = value;
                    this._uvTransformDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "sourceEntity", {
                get: /**
                * The entity that that initially provided the IRenderable to the render pipeline (ie: the owning Mesh object).
                */
                function () {
                    return this._parentMesh;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "subGeometry", {
                get: /**
                * The SubGeometry object which provides the geometry data for this SubMesh.
                */
                function () {
                    return this._subGeometry;
                },
                set: function (value) {
                    this._subGeometry = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "material", {
                get: /**
                * The material used to render the current SubMesh. If set to null, its parent Mesh's material will be used instead.
                */
                function () {
                    return this._iMaterial || this._parentMesh.material;
                },
                set: function (value) {
                    if (this._iMaterial) {
                        this._iMaterial.iRemoveOwner(this);
                    }

                    this._iMaterial = value;

                    if (this._iMaterial) {
                        this._iMaterial.iAddOwner(this);
                    }
                    //*/
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "sceneTransform", {
                get: /**
                * The scene transform object that transforms from model to world space.
                */
                function () {
                    return this._parentMesh.sceneTransform;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "inverseSceneTransform", {
                get: /**
                * The inverse scene transform object that transforms from world to model space.
                */
                function () {
                    return this._parentMesh.inverseSceneTransform;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SubMesh.prototype.activateVertexBuffer = function (index, stage3DProxy) {
                this._subGeometry.activateVertexBuffer(index, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            SubMesh.prototype.activateVertexNormalBuffer = function (index, stage3DProxy) {
                this._subGeometry.activateVertexNormalBuffer(index, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            SubMesh.prototype.activateVertexTangentBuffer = function (index, stage3DProxy) {
                this._subGeometry.activateVertexTangentBuffer(index, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            SubMesh.prototype.activateUVBuffer = function (index, stage3DProxy) {
                this._subGeometry.activateUVBuffer(index, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            SubMesh.prototype.activateSecondaryUVBuffer = function (index, stage3DProxy) {
                this._subGeometry.activateSecondaryUVBuffer(index, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            SubMesh.prototype.getIndexBuffer = function (stage3DProxy) {
                return this._subGeometry.getIndexBuffer(stage3DProxy);
            };

            Object.defineProperty(SubMesh.prototype, "numTriangles", {
                get: /**
                * The amount of triangles that make up this SubMesh.
                */
                function () {
                    return this._subGeometry.numTriangles;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "animator", {
                get: /**
                * The animator object that provides the state for the SubMesh's animation.
                */
                function () {
                    return this._parentMesh.animator;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "mouseEnabled", {
                get: /**
                * Indicates whether the SubMesh should trigger mouse events, and hence should be rendered for hit testing.
                */
                function () {
                    return this._parentMesh.mouseEnabled || this._parentMesh._iAncestorsAllowMouseEnabled;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "castsShadows", {
                get: function () {
                    return this._parentMesh.castsShadows;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "iParentMesh", {
                get: /**
                * A reference to the owning Mesh object
                *
                * @private
                */
                function () {
                    return this._parentMesh;
                },
                set: function (value) {
                    this._parentMesh = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubMesh.prototype, "uvTransform", {
                get: function () {
                    if (this._uvTransformDirty) {
                        this.updateUVTransform();
                    }

                    return this._uvTransform;
                },
                enumerable: true,
                configurable: true
            });

            SubMesh.prototype.updateUVTransform = function () {
                if (this._uvTransform == null) {
                    this._uvTransform = new away.geom.Matrix();
                    //_uvTransform ||= new Matrix();
                }

                this._uvTransform.identity();

                if (this._uvRotation != 0) {
                    this._uvTransform.rotate(this._uvRotation);
                }

                if (this._scaleU != 1 || this._scaleV != 1) {
                    this._uvTransform.scale(this._scaleU, this._scaleV);
                }

                this._uvTransform.translate(this._offsetU, this._offsetV);
                this._uvTransformDirty = false;
            };

            SubMesh.prototype.dispose = function () {
                this.material = null;
            };

            Object.defineProperty(SubMesh.prototype, "vertexData", {
                get: function () {
                    return this._subGeometry.vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "indexData", {
                get: function () {
                    return this._subGeometry.indexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "UVData", {
                get: function () {
                    return this._subGeometry.UVData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "bounds", {
                get: function () {
                    return this._parentMesh.getBounds();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "visible", {
                get: function () {
                    return this._parentMesh.visible;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "numVertices", {
                get: function () {
                    return this._subGeometry.numVertices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "vertexStride", {
                get: function () {
                    return this._subGeometry.vertexStride;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "UVStride", {
                get: function () {
                    return this._subGeometry.UVStride;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "vertexNormalData", {
                get: function () {
                    return this._subGeometry.vertexNormalData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "vertexTangentData", {
                get: function () {
                    return this._subGeometry.vertexTangentData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "UVOffset", {
                get: function () {
                    return this._subGeometry.UVOffset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "vertexOffset", {
                get: function () {
                    return this._subGeometry.vertexOffset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "vertexNormalOffset", {
                get: function () {
                    return this._subGeometry.vertexNormalOffset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubMesh.prototype, "vertexTangentOffset", {
                get: function () {
                    return this._subGeometry.vertexTangentOffset;
                },
                enumerable: true,
                configurable: true
            });

            SubMesh.prototype.getRenderSceneTransform = function (camera) {
                return this._parentMesh.sceneTransform;
            };
            return SubMesh;
        })();
        base.SubMesh = SubMesh;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        var WireframePrimitiveBase = (function (_super) {
            __extends(WireframePrimitiveBase, _super);
            function WireframePrimitiveBase(color, thickness) {
                if (typeof color === "undefined") { color = 0xffffff; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this);
                this._geomDirty = true;
                if (thickness <= 0) {
                    thickness = 1;
                }
                this._color = color;
                this._thickness = thickness;
                this.mouseEnabled = this.mouseChildren = false;
            }
            Object.defineProperty(WireframePrimitiveBase.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value;

                    for (var segRef in this._pSegments) {
                        segRef.segment.startColor = segRef.segment.endColor = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframePrimitiveBase.prototype, "thickness", {
                get: function () {
                    return this._thickness;
                },
                set: function (value) {
                    this._thickness = value;

                    for (var segRef in this._pSegments) {
                        segRef.segment.thickness = segRef.segment.thickness = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            //@override
            WireframePrimitiveBase.prototype.removeAllSegments = function () {
                _super.prototype.removeAllSegments.call(this);
            };

            //@override
            WireframePrimitiveBase.prototype.getBounds = function () {
                if (this._geomDirty) {
                    this.updateGeometry();
                }
                return _super.prototype.getBounds.call(this);
            };

            WireframePrimitiveBase.prototype.pBuildGeometry = function () {
                throw new away.errors.AbstractMethodError();
            };

            WireframePrimitiveBase.prototype.pInvalidateGeometry = function () {
                this._geomDirty = true;
                this.pInvalidateBounds();
            };

            WireframePrimitiveBase.prototype.updateGeometry = function () {
                this.pBuildGeometry();
                this._geomDirty = false;
            };

            WireframePrimitiveBase.prototype.pUpdateOrAddSegment = function (index, v0, v1) {
                var segment;
                var s;
                var e;

                if ((segment = this.getSegment(index)) != null) {
                    s = segment.start;
                    e = segment.end;
                    s.x = v0.x;
                    s.y = v0.y;
                    s.z = v0.z;
                    e.x = v1.x;
                    e.y = v1.y;
                    e.z = v1.z;
                    segment.updateSegment(s, e, null, this._color, this._color, this._thickness);
                } else {
                    this.addSegment(new away.primitives.LineSegment(v0.clone(), v1.clone(), this._color, this._color, this._thickness));
                }
            };

            //@override
            WireframePrimitiveBase.prototype.pUpdateMouseChildren = function () {
                this._iAncestorsAllowMouseEnabled = false;
            };
            return WireframePrimitiveBase;
        })(away.entities.SegmentSet);
        primitives.WireframePrimitiveBase = WireframePrimitiveBase;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (primitives) {
        /**
        * A WireframeSphere primitive mesh
        */
        var WireframeSphere = (function (_super) {
            __extends(WireframeSphere, _super);
            /**
            * Creates a new WireframeSphere object.
            * @param radius The radius of the sphere.
            * @param segmentsW Defines the number of horizontal segments that make up the sphere.
            * @param segmentsH Defines the number of vertical segments that make up the sphere.
            * @param color The colour of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            */
            function WireframeSphere(radius, segmentsW, segmentsH, color, thickness) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 12; }
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this, color, thickness);

                this._radius = radius;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
            }
            /**
            * @inheritDoc
            */
            WireframeSphere.prototype.pBuildGeometry = function () {
                var vertices = new Array();
                var v0 = new away.geom.Vector3D();
                var v1 = new away.geom.Vector3D();
                var i, j;
                var numVerts = 0;
                var index = 0;

                for (j = 0; j <= this._segmentsH; ++j) {
                    var horangle = Math.PI * j / this._segmentsH;
                    var z = -this._radius * Math.cos(horangle);
                    var ringradius = this._radius * Math.sin(horangle);

                    for (i = 0; i <= this._segmentsW; ++i) {
                        var verangle = 2 * Math.PI * i / this._segmentsW;
                        var x = ringradius * Math.cos(verangle);
                        var y = ringradius * Math.sin(verangle);
                        vertices[numVerts++] = x;
                        vertices[numVerts++] = -z;
                        vertices[numVerts++] = y;
                    }
                }

                for (j = 1; j <= this._segmentsH; ++j) {
                    for (i = 1; i <= this._segmentsW; ++i) {
                        var a = ((this._segmentsW + 1) * j + i) * 3;
                        var b = ((this._segmentsW + 1) * j + i - 1) * 3;
                        var c = ((this._segmentsW + 1) * (j - 1) + i - 1) * 3;
                        var d = ((this._segmentsW + 1) * (j - 1) + i) * 3;

                        if (j == this._segmentsH) {
                            v0.x = vertices[c];
                            v0.y = vertices[c + 1];
                            v0.z = vertices[c + 2];
                            v1.x = vertices[d];
                            v1.y = vertices[d + 1];
                            v1.z = vertices[d + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                            v0.x = vertices[a];
                            v0.y = vertices[a + 1];
                            v0.z = vertices[a + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                        } else if (j == 1) {
                            v1.x = vertices[b];
                            v1.y = vertices[b + 1];
                            v1.z = vertices[b + 2];
                            v0.x = vertices[c];
                            v0.y = vertices[c + 1];
                            v0.z = vertices[c + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                        } else {
                            v1.x = vertices[b];
                            v1.y = vertices[b + 1];
                            v1.z = vertices[b + 2];
                            v0.x = vertices[c];
                            v0.y = vertices[c + 1];
                            v0.z = vertices[c + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                            v1.x = vertices[d];
                            v1.y = vertices[d + 1];
                            v1.z = vertices[d + 2];
                            this.pUpdateOrAddSegment(index++, v0, v1);
                        }
                    }
                }
            };
            return WireframeSphere;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeSphere = WireframeSphere;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import flash.geom.Vector3D;
        /**
        * A WirefameCube primitive mesh.
        */
        var WireframeCube = (function (_super) {
            __extends(WireframeCube, _super);
            /**
            * Creates a new WireframeCube object.
            * @param width The size of the cube along its X-axis.
            * @param height The size of the cube along its Y-axis.
            * @param depth The size of the cube along its Z-axis.
            * @param color The colour of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            */
            function WireframeCube(width, height, depth, color, thickness) {
                if (typeof width === "undefined") { width = 100; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof depth === "undefined") { depth = 100; }
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this, color, thickness);

                this._width = width;
                this._height = height;
                this._depth = depth;
            }
            Object.defineProperty(WireframeCube.prototype, "width", {
                get: /**
                * The size of the cube along its X-axis.
                */
                function () {
                    return this._width;
                },
                set: function (value) {
                    this._width = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeCube.prototype, "height", {
                get: /**
                * The size of the cube along its Y-axis.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    if (value <= 0)
                        throw new Error("Value needs to be greater than 0");
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeCube.prototype, "depth", {
                get: /**
                * The size of the cube along its Z-axis.
                */
                function () {
                    return this._depth;
                },
                set: function (value) {
                    this._depth = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            WireframeCube.prototype.pBuildGeometry = function () {
                var v0 = new away.geom.Vector3D();
                var v1 = new away.geom.Vector3D();
                var hw = this._width * .5;
                var hh = this._height * .5;
                var hd = this._depth * .5;

                v0.x = -hw;
                v0.y = hh;
                v0.z = -hd;
                v1.x = -hw;
                v1.y = -hh;
                v1.z = -hd;

                this.pUpdateOrAddSegment(0, v0, v1);
                v0.z = hd;
                v1.z = hd;
                this.pUpdateOrAddSegment(1, v0, v1);
                v0.x = hw;
                v1.x = hw;
                this.pUpdateOrAddSegment(2, v0, v1);
                v0.z = -hd;
                v1.z = -hd;
                this.pUpdateOrAddSegment(3, v0, v1);

                v0.x = -hw;
                v0.y = -hh;
                v0.z = -hd;
                v1.x = hw;
                v1.y = -hh;
                v1.z = -hd;
                this.pUpdateOrAddSegment(4, v0, v1);
                v0.y = hh;
                v1.y = hh;
                this.pUpdateOrAddSegment(5, v0, v1);
                v0.z = hd;
                v1.z = hd;
                this.pUpdateOrAddSegment(6, v0, v1);
                v0.y = -hh;
                v1.y = -hh;
                this.pUpdateOrAddSegment(7, v0, v1);

                v0.x = -hw;
                v0.y = -hh;
                v0.z = -hd;
                v1.x = -hw;
                v1.y = -hh;
                v1.z = hd;
                this.pUpdateOrAddSegment(8, v0, v1);
                v0.y = hh;
                v1.y = hh;
                this.pUpdateOrAddSegment(9, v0, v1);
                v0.x = hw;
                v1.x = hw;
                this.pUpdateOrAddSegment(10, v0, v1);
                v0.y = -hh;
                v1.y = -hh;
                this.pUpdateOrAddSegment(11, v0, v1);
            };
            return WireframeCube;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeCube = WireframeCube;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import flash.geom.Vector3D;
        /**
        * Generates a wireframd cylinder primitive.
        */
        var WireframeCylinder = (function (_super) {
            __extends(WireframeCylinder, _super);
            /**
            * Creates a new WireframeCylinder instance
            * @param topRadius Top radius of the cylinder
            * @param bottomRadius Bottom radius of the cylinder
            * @param height The height of the cylinder
            * @param segmentsW Number of radial segments
            * @param segmentsH Number of vertical segments
            * @param color The color of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            */
            function WireframeCylinder(topRadius, bottomRadius, height, segmentsW, segmentsH, color, thickness) {
                if (typeof topRadius === "undefined") { topRadius = 50; }
                if (typeof bottomRadius === "undefined") { bottomRadius = 50; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this, color, thickness);
                this._topRadius = topRadius;
                this._bottomRadius = bottomRadius;
                this._height = height;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
            }
            WireframeCylinder.prototype.pBuildGeometry = function () {
                var i, j;
                var radius = this._topRadius;
                var revolutionAngle;
                var revolutionAngleDelta = WireframeCylinder.TWO_PI / this._segmentsW;
                var nextVertexIndex = 0;
                var x, y, z;

                var lastLayer = new Array(this._segmentsH + 1);

                for (j = 0; j <= this._segmentsH; ++j) {
                    lastLayer[j] = new Array(this._segmentsW + 1);

                    radius = this._topRadius - ((j / this._segmentsH) * (this._topRadius - this._bottomRadius));
                    z = -(this._height / 2) + (j / this._segmentsH * this._height);

                    var previousV = null;

                    for (i = 0; i <= this._segmentsW; ++i) {
                        // revolution vertex
                        revolutionAngle = i * revolutionAngleDelta;
                        x = radius * Math.cos(revolutionAngle);
                        y = radius * Math.sin(revolutionAngle);
                        var vertex;
                        if (previousV) {
                            vertex = new away.geom.Vector3D(x, -z, y);
                            this.pUpdateOrAddSegment(nextVertexIndex++, vertex, previousV);
                            previousV = vertex;
                        } else
                            previousV = new away.geom.Vector3D(x, -z, y);

                        if (j > 0) {
                            this.pUpdateOrAddSegment(nextVertexIndex++, vertex, lastLayer[j - 1][i]);
                        }
                        lastLayer[j][i] = previousV;
                    }
                }
            };

            Object.defineProperty(WireframeCylinder.prototype, "topRadius", {
                get: /**
                * Top radius of the cylinder
                */
                function () {
                    return this._topRadius;
                },
                set: function (value) {
                    this._topRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeCylinder.prototype, "bottomRadius", {
                get: /**
                * Bottom radius of the cylinder
                */
                function () {
                    return this._bottomRadius;
                },
                set: function (value) {
                    this._bottomRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeCylinder.prototype, "height", {
                get: /**
                * The height of the cylinder
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    if (this.height <= 0)
                        throw new Error('Height must be a value greater than zero.');

                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            WireframeCylinder.TWO_PI = 2 * Math.PI;
            return WireframeCylinder;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeCylinder = WireframeCylinder;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import flash.geom.Vector3D;
        /**
        * A WireframePlane primitive mesh.
        */
        var WireframePlane = (function (_super) {
            __extends(WireframePlane, _super);
            /**
            * Creates a new WireframePlane object.
            * @param width The size of the cube along its X-axis.
            * @param height The size of the cube along its Y-axis.
            * @param segmentsW The number of segments that make up the cube along the X-axis.
            * @param segmentsH The number of segments that make up the cube along the Y-axis.
            * @param color The colour of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            * @param orientation The orientaion in which the plane lies.
            */
            function WireframePlane(width, height, segmentsW, segmentsH, color, thickness, orientation) {
                if (typeof segmentsW === "undefined") { segmentsW = 10; }
                if (typeof segmentsH === "undefined") { segmentsH = 10; }
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                if (typeof orientation === "undefined") { orientation = "yz"; }
                _super.call(this, color, thickness);

                this._width = width;
                this._height = height;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
                this._orientation = orientation;
            }
            Object.defineProperty(WireframePlane.prototype, "orientation", {
                get: /**
                * The orientaion in which the plane lies.
                */
                function () {
                    return this._orientation;
                },
                set: function (value) {
                    this._orientation = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframePlane.prototype, "width", {
                get: /**
                * The size of the cube along its X-axis.
                */
                function () {
                    return this._width;
                },
                set: function (value) {
                    this._width = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframePlane.prototype, "height", {
                get: /**
                * The size of the cube along its Y-axis.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    if (value <= 0)
                        throw new Error("Value needs to be greater than 0");
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframePlane.prototype, "segmentsW", {
                get: /**
                * The number of segments that make up the plane along the X-axis.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;
                    this.removeAllSegments();
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframePlane.prototype, "segmentsH", {
                get: /**
                * The number of segments that make up the plane along the Y-axis.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = value;
                    this.removeAllSegments();
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            WireframePlane.prototype.pBuildGeometry = function () {
                var v0 = new away.geom.Vector3D();
                var v1 = new away.geom.Vector3D();
                var hw = this._width * .5;
                var hh = this._height * .5;
                var index = 0;
                var ws, hs;

                if (this._orientation == WireframePlane.ORIENTATION_XY) {
                    v0.y = hh;
                    v0.z = 0;
                    v1.y = -hh;
                    v1.z = 0;

                    for (ws = 0; ws <= this._segmentsW; ++ws) {
                        v0.x = v1.x = (ws / this._segmentsW - .5) * this._width;
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }

                    v0.x = -hw;
                    v1.x = hw;

                    for (hs = 0; hs <= this._segmentsH; ++hs) {
                        v0.y = v1.y = (hs / this._segmentsH - .5) * this._height;
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                } else if (this._orientation == WireframePlane.ORIENTATION_XZ) {
                    v0.z = hh;
                    v0.y = 0;
                    v1.z = -hh;
                    v1.y = 0;

                    for (ws = 0; ws <= this._segmentsW; ++ws) {
                        v0.x = v1.x = (ws / this._segmentsW - .5) * this._width;
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }

                    v0.x = -hw;
                    v1.x = hw;

                    for (hs = 0; hs <= this._segmentsH; ++hs) {
                        v0.z = v1.z = (hs / this._segmentsH - .5) * this._height;
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                } else if (this._orientation == WireframePlane.ORIENTATION_YZ) {
                    v0.y = hh;
                    v0.x = 0;
                    v1.y = -hh;
                    v1.x = 0;

                    for (ws = 0; ws <= this._segmentsW; ++ws) {
                        v0.z = v1.z = (ws / this._segmentsW - .5) * this._width;
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }

                    v0.z = hw;
                    v1.z = -hw;

                    for (hs = 0; hs <= this._segmentsH; ++hs) {
                        v0.y = v1.y = (hs / this._segmentsH - .5) * this._height;
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                }
            };
            WireframePlane.ORIENTATION_YZ = "yz";
            WireframePlane.ORIENTATION_XY = "xy";
            WireframePlane.ORIENTATION_XZ = "xz";
            return WireframePlane;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframePlane = WireframePlane;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import flash.geom.Vector3D;
        /**
        * A WireframeRegularPolygon primitive mesh.
        */
        var WireframeRegularPolygon = (function (_super) {
            __extends(WireframeRegularPolygon, _super);
            /**
            * Creates a new WireframeRegularPolygon object.
            * @param radius The radius of the polygon.
            * @param sides The number of sides on the polygon.
            * @param color The colour of the wireframe lines
            * @param thickness The thickness of the wireframe lines
            * @param orientation The orientaion in which the plane lies.
            */
            function WireframeRegularPolygon(radius, sides, color, thickness, orientation) {
                if (typeof color === "undefined") { color = 0xFFFFFF; }
                if (typeof thickness === "undefined") { thickness = 1; }
                if (typeof orientation === "undefined") { orientation = "yz"; }
                _super.call(this, color, thickness);

                this._radius = radius;
                this._sides = sides;
                this._orientation = orientation;
            }
            Object.defineProperty(WireframeRegularPolygon.prototype, "orientation", {
                get: /**
                * The orientaion in which the polygon lies.
                */
                function () {
                    return this._orientation;
                },
                set: function (value) {
                    this._orientation = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeRegularPolygon.prototype, "radius", {
                get: /**
                * The radius of the regular polygon.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeRegularPolygon.prototype, "sides", {
                get: /**
                * The number of sides to the regular polygon.
                */
                function () {
                    return this._sides;
                },
                set: function (value) {
                    this._sides = value;
                    this.removeAllSegments();
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            WireframeRegularPolygon.prototype.pBuildGeometry = function () {
                var v0 = new away.geom.Vector3D();
                var v1 = new away.geom.Vector3D();
                var index = 0;
                var s;

                if (this._orientation == WireframeRegularPolygon.ORIENTATION_XY) {
                    v0.z = 0;
                    v1.z = 0;

                    for (s = 0; s < this._sides; ++s) {
                        v0.x = this._radius * Math.cos(2 * Math.PI * s / this._sides);
                        v0.y = this._radius * Math.sin(2 * Math.PI * s / this._sides);
                        v1.x = this._radius * Math.cos(2 * Math.PI * (s + 1) / this._sides);
                        v1.y = this._radius * Math.sin(2 * Math.PI * (s + 1) / this._sides);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                } else if (this._orientation == WireframeRegularPolygon.ORIENTATION_XZ) {
                    v0.y = 0;
                    v1.y = 0;

                    for (s = 0; s < this._sides; ++s) {
                        v0.x = this._radius * Math.cos(2 * Math.PI * s / this._sides);
                        v0.z = this._radius * Math.sin(2 * Math.PI * s / this._sides);
                        v1.x = this._radius * Math.cos(2 * Math.PI * (s + 1) / this._sides);
                        v1.z = this._radius * Math.sin(2 * Math.PI * (s + 1) / this._sides);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                } else if (this._orientation == WireframeRegularPolygon.ORIENTATION_YZ) {
                    v0.x = 0;
                    v1.x = 0;

                    for (s = 0; s < this._sides; ++s) {
                        v0.z = this._radius * Math.cos(2 * Math.PI * s / this._sides);
                        v0.y = this._radius * Math.sin(2 * Math.PI * s / this._sides);
                        v1.z = this._radius * Math.cos(2 * Math.PI * (s + 1) / this._sides);
                        v1.y = this._radius * Math.sin(2 * Math.PI * (s + 1) / this._sides);
                        this.pUpdateOrAddSegment(index++, v0, v1);
                    }
                }
            };
            WireframeRegularPolygon.ORIENTATION_YZ = "yz";
            WireframeRegularPolygon.ORIENTATION_XY = "xy";
            WireframeRegularPolygon.ORIENTATION_XZ = "xz";
            return WireframeRegularPolygon;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeRegularPolygon = WireframeRegularPolygon;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (primitives) {
        //import flash.geom.Vector3D;
        //import away3d.primitives.WireframePrimitiveBase;
        /**
        * A WireframeTetrahedron primitive mesh
        */
        var WireframeTetrahedron = (function (_super) {
            __extends(WireframeTetrahedron, _super);
            /**
            * Creates a new WireframeTetrahedron object.
            * @param width The size of the tetrahedron buttom size.
            * @param height The size of the tetranhedron height.
            * @param color The color of the wireframe lines.
            * @param thickness The thickness of the wireframe lines.
            */
            function WireframeTetrahedron(width, height, color, thickness, orientation) {
                if (typeof color === "undefined") { color = 0xffffff; }
                if (typeof thickness === "undefined") { thickness = 1; }
                if (typeof orientation === "undefined") { orientation = "yz"; }
                _super.call(this, color, thickness);

                this._width = width;
                this._height = height;

                this._orientation = orientation;
            }
            Object.defineProperty(WireframeTetrahedron.prototype, "orientation", {
                get: /**
                * The orientation in which the plane lies
                */
                function () {
                    return this._orientation;
                },
                set: function (value) {
                    this._orientation = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeTetrahedron.prototype, "width", {
                get: /**
                * The size of the tetrahedron bottom.
                */
                function () {
                    return this._width;
                },
                set: function (value) {
                    if (value <= 0)
                        throw new Error("Value needs to be greater than 0");
                    this._width = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(WireframeTetrahedron.prototype, "height", {
                get: /**
                * The size of the tetrahedron height.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    if (value <= 0)
                        throw new Error("Value needs to be greater than 0");
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            WireframeTetrahedron.prototype.pBuildGeometry = function () {
                var bv0;
                var bv1;
                var bv2;
                var bv3;
                var top;

                var hw = this._width * 0.5;

                switch (this._orientation) {
                    case WireframeTetrahedron.ORIENTATION_XY:
                        bv0 = new away.geom.Vector3D(-hw, hw, 0);
                        bv1 = new away.geom.Vector3D(hw, hw, 0);
                        bv2 = new away.geom.Vector3D(hw, -hw, 0);
                        bv3 = new away.geom.Vector3D(-hw, -hw, 0);
                        top = new away.geom.Vector3D(0, 0, this._height);
                        break;
                    case WireframeTetrahedron.ORIENTATION_XZ:
                        bv0 = new away.geom.Vector3D(-hw, 0, hw);
                        bv1 = new away.geom.Vector3D(hw, 0, hw);
                        bv2 = new away.geom.Vector3D(hw, 0, -hw);
                        bv3 = new away.geom.Vector3D(-hw, 0, -hw);
                        top = new away.geom.Vector3D(0, this._height, 0);
                        break;
                    case WireframeTetrahedron.ORIENTATION_YZ:
                        bv0 = new away.geom.Vector3D(0, -hw, hw);
                        bv1 = new away.geom.Vector3D(0, hw, hw);
                        bv2 = new away.geom.Vector3D(0, hw, -hw);
                        bv3 = new away.geom.Vector3D(0, -hw, -hw);
                        top = new away.geom.Vector3D(this._height, 0, 0);
                        break;
                }

                //bottom
                this.pUpdateOrAddSegment(0, bv0, bv1);
                this.pUpdateOrAddSegment(1, bv1, bv2);
                this.pUpdateOrAddSegment(2, bv2, bv3);
                this.pUpdateOrAddSegment(3, bv3, bv0);

                //bottom to top
                this.pUpdateOrAddSegment(4, bv0, top);
                this.pUpdateOrAddSegment(5, bv1, top);
                this.pUpdateOrAddSegment(6, bv2, top);
                this.pUpdateOrAddSegment(7, bv3, top);
            };
            WireframeTetrahedron.ORIENTATION_YZ = "yz";
            WireframeTetrahedron.ORIENTATION_XY = "xy";
            WireframeTetrahedron.ORIENTATION_XZ = "xz";
            return WireframeTetrahedron;
        })(away.primitives.WireframePrimitiveBase);
        primitives.WireframeTetrahedron = WireframeTetrahedron;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A SkyBox class is used to render a sky in the scene. It's always considered static and 'at infinity', and as
        * such it's always centered at the camera's position and sized to exactly fit within the camera's frustum, ensuring
        * the sky box is always as large as possible without being clipped.
        */
        var SkyBox = (function (_super) {
            __extends(SkyBox, _super);
            /**
            * Create a new SkyBox object.
            * @param cubeMap The CubeMap to use for the sky box's texture.
            */
            function SkyBox(cubeMap) {
                _super.call(this);
                this._uvTransform = new away.geom.Matrix();
                this._material = new away.materials.SkyBoxMaterial(cubeMap);
                this._material.iAddOwner(this);
                this._geometry = new away.base.SubGeometry();
                this.buildGeometry(this._geometry);
            }
            Object.defineProperty(SkyBox.prototype, "animator", {
                get: function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            SkyBox.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            /**
            * @inheritDoc
            */
            SkyBox.prototype.activateVertexBuffer = function (index, stage3DProxy) {
                this._geometry.activateVertexBuffer(index, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            SkyBox.prototype.activateUVBuffer = function (index, stage3DProxy) {
            };

            /**
            * @inheritDoc
            */
            SkyBox.prototype.activateVertexNormalBuffer = function (index, stage3DProxy) {
            };

            /**
            * @inheritDoc
            */
            SkyBox.prototype.activateVertexTangentBuffer = function (index, stage3DProxy) {
            };

            SkyBox.prototype.activateSecondaryUVBuffer = function (index, stage3DProxy) {
            };

            /**
            * @inheritDoc
            */
            SkyBox.prototype.getIndexBuffer = function (stage3DProxy) {
                return this._geometry.getIndexBuffer(stage3DProxy);
            };

            Object.defineProperty(SkyBox.prototype, "numTriangles", {
                get: /**
                * The amount of triangles that comprise the SkyBox geometry.
                */
                function () {
                    return this._geometry.numTriangles;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "sourceEntity", {
                get: /**
                * The entity that that initially provided the IRenderable to the render pipeline.
                */
                function () {
                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "material", {
                get: /**
                * The material with which to render the object.
                */
                function () {
                    return this._material;
                },
                set: function (value) {
                    throw new away.errors.AbstractMethodError("Unsupported method!");
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SkyBox.prototype, "assetType", {
                get: function () {
                    return away.library.AssetType.SKYBOX;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SkyBox.prototype.pInvalidateBounds = function () {
                // dead end
            };

            /**
            * @inheritDoc
            */
            SkyBox.prototype.pCreateEntityPartitionNode = function () {
                var node = new away.partition.SkyBoxNode(this);
                return node;
            };

            /**
            * @inheritDoc
            */
            SkyBox.prototype.pUpdateBounds = function () {
                this._pBoundsInvalid = false;
            };

            /**
            * Builds the geometry that forms the SkyBox
            */
            SkyBox.prototype.buildGeometry = function (target) {
                var vertices = [
                    -1,
                    1,
                    -1,
                    1,
                    1,
                    -1,
                    1,
                    1,
                    1,
                    -1,
                    1,
                    1,
                    -1,
                    -1,
                    -1,
                    1,
                    -1,
                    -1,
                    1,
                    -1,
                    1,
                    -1,
                    -1,
                    1
                ];

                var indices = [
                    0,
                    1,
                    2,
                    2,
                    3,
                    0,
                    6,
                    5,
                    4,
                    4,
                    7,
                    6,
                    2,
                    6,
                    7,
                    7,
                    3,
                    2,
                    4,
                    5,
                    1,
                    1,
                    0,
                    4,
                    4,
                    0,
                    3,
                    3,
                    7,
                    4,
                    2,
                    1,
                    5,
                    5,
                    6,
                    2
                ];

                target.updateVertexData(vertices);
                target.updateIndexData(indices);
            };

            Object.defineProperty(SkyBox.prototype, "castsShadows", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "uvTransform", {
                get: function () {
                    return this._uvTransform;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "vertexData", {
                get: function () {
                    return this._geometry.vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "indexData", {
                get: function () {
                    return this._geometry.indexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "UVData", {
                get: function () {
                    return this._geometry.UVData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "numVertices", {
                get: function () {
                    return this._geometry.numVertices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "vertexStride", {
                get: function () {
                    return this._geometry.vertexStride;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "vertexNormalData", {
                get: function () {
                    return this._geometry.vertexNormalData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "vertexTangentData", {
                get: function () {
                    return this._geometry.vertexTangentData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "vertexOffset", {
                get: function () {
                    return this._geometry.vertexOffset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "vertexNormalOffset", {
                get: function () {
                    return this._geometry.vertexNormalOffset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkyBox.prototype, "vertexTangentOffset", {
                get: function () {
                    return this._geometry.vertexTangentOffset;
                },
                enumerable: true,
                configurable: true
            });

            SkyBox.prototype.getRenderSceneTransform = function (camera) {
                return this._pSceneTransform;
            };
            return SkyBox;
        })(away.entities.Entity);
        primitives.SkyBox = SkyBox;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var NodeBase = (function () {
            function NodeBase() {
                this._pNumChildNodes = 0;
                this._iNumEntities = 0;
                this._pChildNodes = [];
            }
            Object.defineProperty(NodeBase.prototype, "showDebugBounds", {
                get: function () {
                    return this._pDebugPrimitive != null;
                },
                set: function (value) {
                    if (this._pDebugPrimitive && value == true) {
                        return;
                    }

                    if (!this._pDebugPrimitive && value == false) {
                        return;
                    }

                    if (value) {
                        throw new away.errors.PartialImplementationError();
                        this._pDebugPrimitive = this.pCreateDebugBounds();
                    } else {
                        this._pDebugPrimitive.dispose();
                        this._pDebugPrimitive = null;
                    }

                    for (var i = 0; i < this._pNumChildNodes; ++i) {
                        this._pChildNodes[i].showDebugBounds = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(NodeBase.prototype, "parent", {
                get: function () {
                    return this._iParent;
                },
                enumerable: true,
                configurable: true
            });

            NodeBase.prototype.iAddNode = function (node) {
                node._iParent = this;
                this._iNumEntities += node._pNumEntities;
                this._pChildNodes[this._pNumChildNodes++] = node;
                node.showDebugBounds = this._pDebugPrimitive != null;

                var numEntities = node._pNumEntities;
                node = this;

                do {
                    node._iNumEntities += numEntities;
                } while((node = node._iParent) != null);
            };

            NodeBase.prototype.iRemoveNode = function (node) {
                var index = this._pChildNodes.indexOf(node);
                this._pChildNodes[index] = this._pChildNodes[--this._pNumChildNodes];
                this._pChildNodes.pop();

                var numEntities = node._pNumEntities;
                node = this;

                do {
                    node._pNumEntities -= numEntities;
                } while((node = node._iParent) != null);
            };

            NodeBase.prototype.isInFrustum = function (planes, numPlanes) {
                //console.log( 'NodeBase' , 'isInFrustum - should be true');
                planes = planes;
                numPlanes = numPlanes;
                return true;
            };

            NodeBase.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
                rayPosition = rayPosition;
                rayDirection = rayDirection;
                return true;
            };

            NodeBase.prototype.isCastingShadow = function () {
                return true;
            };

            NodeBase.prototype.findPartitionForEntity = function (entity) {
                entity = entity;
                return this;
            };

            NodeBase.prototype.acceptTraverser = function (traverser) {
                if (this._pNumEntities == 0 && !this._pDebugPrimitive) {
                    return;
                }

                if (traverser.enterNode(this)) {
                    // console.log ( 'NodeBase' , 'acceptTraverser (node entered) : ' , this )
                    var i = 0;

                    while (i < this._pNumChildNodes) {
                        //console.log ( 'NodeBase' , 'loop through childNodes : ' , i );
                        this._pChildNodes[i++].acceptTraverser(traverser);
                    }

                    if (this._pDebugPrimitive) {
                        traverser.applyRenderable(this._pDebugPrimitive);
                    }
                }
            };

            NodeBase.prototype.pCreateDebugBounds = function () {
                return null;
            };

            Object.defineProperty(NodeBase.prototype, "_pNumEntities", {
                get: function () {
                    return this._iNumEntities;
                },
                enumerable: true,
                configurable: true
            });

            NodeBase.prototype._pUpdateNumEntities = function (value) {
                var diff = value - this._pNumEntities;
                var node = this;

                do {
                    node._pNumEntities += diff;
                } while((node = node._iParent) != null);
                //console.log( 'NodeBase' , '_pUpdateNumEntities' , this._pUpdateNumEntities)
            };
            return NodeBase;
        })();
        partition.NodeBase = NodeBase;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var NullNode = (function () {
            function NullNode() {
            }
            return NullNode;
        })();
        partition.NullNode = NullNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var Partition3D = (function () {
            function Partition3D(rootNode) {
                this._updatesMade = false;
                this._rootNode = rootNode || new away.partition.NullNode();
            }
            Object.defineProperty(Partition3D.prototype, "showDebugBounds", {
                get: function () {
                    return this._rootNode.showDebugBounds;
                },
                set: function (value) {
                    this._rootNode.showDebugBounds = value;
                },
                enumerable: true,
                configurable: true
            });


            Partition3D.prototype.traverse = function (traverser) {
                if (this._updatesMade) {
                    this.updateEntities();
                }
                ++away.traverse.PartitionTraverser._iCollectionMark;
                this._rootNode.acceptTraverser(traverser);
            };

            Partition3D.prototype.iMarkForUpdate = function (entity) {
                var node = entity.getEntityPartitionNode();
                var t = this._updateQueue;

                while (t) {
                    if (node == t) {
                        return;
                    }
                    t = t._iUpdateQueueNext;
                }

                node._iUpdateQueueNext = this._updateQueue;

                this._updateQueue = node;
                this._updatesMade = true;
            };

            Partition3D.prototype.iRemoveEntity = function (entity) {
                var node = entity.getEntityPartitionNode();
                var t;

                node.removeFromParent();

                if (node == this._updateQueue) {
                    this._updateQueue = node._iUpdateQueueNext;
                } else {
                    t = this._updateQueue;
                    while (t && t._iUpdateQueueNext != node) {
                        t = t._iUpdateQueueNext;
                    }
                    if (t) {
                        t._iUpdateQueueNext = node._iUpdateQueueNext;
                    }
                }

                node._iUpdateQueueNext = null;

                if (!this._updateQueue) {
                    this._updatesMade = false;
                }
            };

            Partition3D.prototype.updateEntities = function () {
                var node = this._updateQueue;
                var targetNode;
                var t;
                this._updateQueue = null;
                this._updatesMade = false;

                do {
                    targetNode = this._rootNode.findPartitionForEntity(node.entity);

                    if (node.parent != targetNode) {
                        if (node) {
                            node.removeFromParent();
                        }
                        targetNode.iAddNode(node);
                    }

                    t = node._iUpdateQueueNext;
                    node._iUpdateQueueNext = null;
                    node.entity.iInternalUpdate();
                } while((node = t) != null);
            };
            return Partition3D;
        })();
        partition.Partition3D = Partition3D;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (pick) {
        /**
        * Value object for a picking collision returned by a picking collider. Created as unique objects on entities
        *
        * @see away3d.entities.Entity#pickingCollisionVO
        * @see away3d.core.pick.IPickingCollider
        */
        var PickingCollisionVO = (function () {
            /**
            * Creates a new <code>PickingCollisionVO</code> object.
            *
            * @param entity The entity to which this collision object belongs.
            */
            function PickingCollisionVO(entity) {
                this.entity = entity;
            }
            return PickingCollisionVO;
        })();
        pick.PickingCollisionVO = PickingCollisionVO;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var EntityNode = (function (_super) {
            __extends(EntityNode, _super);
            function EntityNode(entity) {
                _super.call(this);
                this._entity = entity;
                this._iNumEntities = 1;
            }
            Object.defineProperty(EntityNode.prototype, "entity", {
                get: function () {
                    return this._entity;
                },
                enumerable: true,
                configurable: true
            });

            EntityNode.prototype.removeFromParent = function () {
                if (this._iParent) {
                    this._iParent.iRemoveNode(this);
                }
                this._iParent = null;
            };

            //@override
            EntityNode.prototype.isInFrustum = function (planes, numPlanes) {
                if (!this._entity._iIsVisible) {
                    return false;
                }
                return this._entity.worldBounds.isInFrustum(planes, numPlanes);
            };

            /**
            * @inheritDoc
            */
            EntityNode.prototype.acceptTraverser = function (traverser) {
                traverser.applyEntity(this._entity);
            };

            /**
            * @inheritDoc
            */
            EntityNode.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
                if (!this._entity._iIsVisible)
                    return false;

                return this._entity.isIntersectingRay(rayPosition, rayDirection);
            };
            return EntityNode;
        })(partition.NodeBase);
        partition.EntityNode = EntityNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var CameraNode = (function (_super) {
            __extends(CameraNode, _super);
            function CameraNode(camera) {
                _super.call(this, camera);
            }
            //@override
            CameraNode.prototype.acceptTraverser = function (traverser) {
                // todo: dead end for now, if it has a debug mesh, then sure accept that
            };
            return CameraNode;
        })(away.partition.EntityNode);
        partition.CameraNode = CameraNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var LightNode = (function (_super) {
            __extends(LightNode, _super);
            function LightNode(light) {
                _super.call(this, light);
                this._light = light;
            }
            Object.defineProperty(LightNode.prototype, "light", {
                get: function () {
                    return this._light;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            LightNode.prototype.acceptTraverser = function (traverser) {
                if (traverser.enterNode(this)) {
                    _super.prototype.acceptTraverser.call(this, traverser);
                    traverser.applyUnknownLight(this._light);
                }
            };
            return LightNode;
        })(away.partition.EntityNode);
        partition.LightNode = LightNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var DirectionalLightNode = (function (_super) {
            __extends(DirectionalLightNode, _super);
            function DirectionalLightNode(light) {
                _super.call(this, light);
                this._light = light;
            }
            Object.defineProperty(DirectionalLightNode.prototype, "light", {
                get: function () {
                    return this._light;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            DirectionalLightNode.prototype.acceptTraverser = function (traverser) {
                if (traverser.enterNode(this)) {
                    _super.prototype.acceptTraverser.call(this, traverser);
                    traverser.applyDirectionalLight(this._light);
                }
            };

            DirectionalLightNode.prototype.isCastingShadow = function () {
                return false;
            };
            return DirectionalLightNode;
        })(away.partition.EntityNode);
        partition.DirectionalLightNode = DirectionalLightNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var PointLightNode = (function (_super) {
            __extends(PointLightNode, _super);
            function PointLightNode(light) {
                _super.call(this, light);
                this._light = light;
            }
            Object.defineProperty(PointLightNode.prototype, "light", {
                get: function () {
                    return this._light;
                },
                enumerable: true,
                configurable: true
            });

            PointLightNode.prototype.acceptTraverser = function (traverser) {
                if (traverser.enterNode(this)) {
                    _super.prototype.acceptTraverser.call(this, traverser);
                    traverser.applyPointLight(this._light);
                }
            };

            PointLightNode.prototype.isCastingShadow = function () {
                return false;
            };
            return PointLightNode;
        })(away.partition.EntityNode);
        partition.PointLightNode = PointLightNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        var LightProbeNode = (function (_super) {
            __extends(LightProbeNode, _super);
            function LightProbeNode(light) {
                _super.call(this, light);
                this._light = light;
            }
            Object.defineProperty(LightProbeNode.prototype, "light", {
                get: function () {
                    return this._light;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            LightProbeNode.prototype.acceptTraverser = function (traverser) {
                if (traverser.enterNode(this)) {
                    _super.prototype.acceptTraverser.call(this, traverser);
                    traverser.applyLightProbe(this._light);
                }
            };
            return LightProbeNode;
        })(away.partition.EntityNode);
        partition.LightProbeNode = LightProbeNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        //import away3d.core.base.SubMesh;
        //import away3d.core.traverse.PartitionTraverser;
        //import away3d.entities.Mesh;
        /**
        * MeshNode is a space partitioning leaf node that contains a Mesh object.
        */
        var MeshNode = (function (_super) {
            __extends(MeshNode, _super);
            /**
            * Creates a new MeshNode object.
            * @param mesh The mesh to be contained in the node.
            */
            function MeshNode(mesh) {
                _super.call(this, mesh);
                this._mesh = mesh;
            }
            Object.defineProperty(MeshNode.prototype, "mesh", {
                get: /**
                * The mesh object contained in the partition node.
                */
                function () {
                    return this._mesh;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            MeshNode.prototype.acceptTraverser = function (traverser) {
                if (traverser.enterNode(this)) {
                    _super.prototype.acceptTraverser.call(this, traverser);

                    var subs = this._mesh.subMeshes;
                    var i = 0;
                    var len = subs.length;
                    while (i < len) {
                        traverser.applyRenderable(subs[i++]);
                    }
                }
            };

            MeshNode.prototype.isCastingShadow = function () {
                return this._mesh.castsShadows;
            };
            return MeshNode;
        })(away.partition.EntityNode);
        partition.MeshNode = MeshNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        /**
        * SkyBoxNode is a space partitioning leaf node that contains a SkyBox object.
        */
        var SkyBoxNode = (function (_super) {
            __extends(SkyBoxNode, _super);
            /**
            * Creates a new SkyBoxNode object.
            * @param skyBox The SkyBox to be contained in the node.
            */
            function SkyBoxNode(skyBox) {
                _super.call(this, skyBox);
                this._skyBox = skyBox;
            }
            /**
            * @inheritDoc
            */
            SkyBoxNode.prototype.acceptTraverser = function (traverser) {
                if (traverser.enterNode(this)) {
                    _super.prototype.acceptTraverser.call(this, traverser);
                    traverser.applySkyBox(this._skyBox);
                }
            };

            SkyBoxNode.prototype.isInFrustum = function (planes, numPlanes) {
                planes = planes;
                numPlanes = numPlanes;

                return true;
            };
            return SkyBoxNode;
        })(away.partition.EntityNode);
        partition.SkyBoxNode = SkyBoxNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (errors) {
        /**
        * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
        * by a concrete subclass.
        */
        var PartialImplementationError = (function (_super) {
            __extends(PartialImplementationError, _super);
            /**
            * Create a new AbstractMethodError.
            * @param message An optional message to override the default error message.
            * @param id The id of the error.
            */
            function PartialImplementationError(dependency, id) {
                if (typeof dependency === "undefined") { dependency = ''; }
                if (typeof id === "undefined") { id = 0; }
                _super.call(this, "PartialImplementationError - this function is in development. Required Dependency: " + dependency, id);
            }
            return PartialImplementationError;
        })(errors.Error);
        errors.PartialImplementationError = PartialImplementationError;
    })(away.errors || (away.errors = {}));
    var errors = away.errors;
})(away || (away = {}));
var away;
(function (away) {
    (function (library) {
        var AssetType = (function () {
            function AssetType() {
            }
            AssetType.ENTITY = 'entity';
            AssetType.SKYBOX = 'skybox';
            AssetType.CAMERA = 'camera';
            AssetType.SEGMENT_SET = 'segmentSet';
            AssetType.MESH = 'mesh';
            AssetType.GEOMETRY = 'geometry';
            AssetType.SKELETON = 'skeleton';
            AssetType.SKELETON_POSE = 'skeletonPose';
            AssetType.CONTAINER = 'container';
            AssetType.TEXTURE = 'texture';
            AssetType.TEXTURE_PROJECTOR = 'textureProjector';
            AssetType.MATERIAL = 'material';
            AssetType.ANIMATION_SET = 'animationSet';
            AssetType.ANIMATION_STATE = 'animationState';
            AssetType.ANIMATION_NODE = 'animationNode';
            AssetType.ANIMATOR = 'animator';
            AssetType.STATE_TRANSITION = 'stateTransition';
            AssetType.LIGHT = 'light';
            AssetType.LIGHT_PICKER = 'lightPicker';
            AssetType.SHADOW_MAP_METHOD = 'shadowMapMethod';
            AssetType.EFFECTS_METHOD = 'effectsMethod';
            return AssetType;
        })();
        library.AssetType = AssetType;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display) {
        var Stage3D = (function (_super) {
            __extends(Stage3D, _super);
            function Stage3D(canvas) {
                _super.call(this);
                this._canvas = canvas;
            }
            Stage3D.prototype.requestContext = function (aglslContext) {
                if (typeof aglslContext === "undefined") { aglslContext = false; }
                try  {
                    if (aglslContext) {
                        this._context3D = new away.display3D.AGLSLContext3D(this._canvas);
                    } else {
                        this._context3D = new away.display3D.Context3D(this._canvas);
                    }
                } catch (e) {
                    this.dispatchEvent(new away.events.Event(away.events.Event.ERROR));
                }

                if (this._context3D) {
                    this.dispatchEvent(new away.events.Event(away.events.Event.CONTEXT3D_CREATE));
                }
            };


            Object.defineProperty(Stage3D.prototype, "width", {
                get: function () {
                    return this._width;
                },
                set: function (v) {
                    this._width = v;
                    away.utils.CSS.setCanvasWidth(this._canvas, v);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Stage3D.prototype, "height", {
                get: function () {
                    return this._height;
                },
                set: function (v) {
                    this._height = v;
                    away.utils.CSS.setCanvasHeight(this._canvas, v);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Stage3D.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (v) {
                    this._x = v;
                    away.utils.CSS.setCanvasX(this._canvas, v);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Stage3D.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (v) {
                    this._y = v;
                    away.utils.CSS.setCanvasY(this._canvas, v);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Stage3D.prototype, "visible", {
                get: function () {
                    return away.utils.CSS.getCanvasVisibility(this._canvas);
                },
                set: function (v) {
                    away.utils.CSS.setCanvasVisibility(this._canvas, v);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3D.prototype, "canvas", {
                get: function () {
                    return this._canvas;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3D.prototype, "context3D", {
                get: function () {
                    return this._context3D;
                },
                enumerable: true,
                configurable: true
            });
            return Stage3D;
        })(away.events.EventDispatcher);
        display.Stage3D = Stage3D;
    })(away.display || (away.display = {}));
    var display = away.display;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var CSS = (function () {
            function CSS() {
            }
            CSS.setCanvasSize = function (canvas, width, height) {
                canvas.style.width = width + "px";
                canvas.style.height = height + "px";
                canvas.width = width;
                canvas.height = height;
            };

            CSS.setCanvasWidth = function (canvas, width) {
                canvas.style.width = width + "px";
                canvas.width = width;
            };

            CSS.setCanvasHeight = function (canvas, height) {
                canvas.style.height = height + "px";
                canvas.height = height;
            };

            CSS.setCanvasX = function (canvas, x) {
                canvas.style.position = 'absolute';
                canvas.style.left = x + "px";
            };

            CSS.setCanvasY = function (canvas, y) {
                canvas.style.position = 'absolute';
                canvas.style.top = y + "px";
            };

            CSS.getCanvasVisibility = function (canvas) {
                return canvas.style.visibility == 'visible';
            };

            CSS.setCanvasVisibility = function (canvas, visible) {
                if (visible) {
                    canvas.style.visibility = 'visible';
                } else {
                    canvas.style.visibility = 'hidden';
                }
            };

            CSS.setCanvasAlpha = function (canvas, alpha) {
                var context = canvas.getContext("2d");
                context.globalAlpha = alpha;
            };

            CSS.setCanvasPosition = function (canvas, x, y, absolute) {
                if (typeof absolute === "undefined") { absolute = false; }
                if (absolute) {
                    canvas.style.position = "absolute";
                } else {
                    canvas.style.position = "relative";
                }

                canvas.style.left = x + "px";
                canvas.style.top = y + "px";
            };
            return CSS;
        })();
        utils.CSS = CSS;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (errors) {
        var DocumentError = (function (_super) {
            __extends(DocumentError, _super);
            function DocumentError(message, id) {
                if (typeof message === "undefined") { message = "DocumentError"; }
                if (typeof id === "undefined") { id = 0; }
                _super.call(this, message, id);
            }
            DocumentError.DOCUMENT_DOES_NOT_EXIST = "documentDoesNotExist";
            return DocumentError;
        })(errors.Error);
        errors.DocumentError = DocumentError;
    })(away.errors || (away.errors = {}));
    var errors = away.errors;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (pick) {
        /**
        * An abstract base class for all picking collider classes. It should not be instantiated directly.
        */
        var PickingColliderBase = (function () {
            function PickingColliderBase() {
            }
            PickingColliderBase.prototype._pPetCollisionNormal = function (indexData/*uint*/ , vertexData, triangleIndex) {
                var normal = new away.geom.Vector3D();
                var i0 = indexData[triangleIndex] * 3;
                var i1 = indexData[triangleIndex + 1] * 3;
                var i2 = indexData[triangleIndex + 2] * 3;
                var p0 = new away.geom.Vector3D(vertexData[i0], vertexData[i0 + 1], vertexData[i0 + 2]);
                var p1 = new away.geom.Vector3D(vertexData[i1], vertexData[i1 + 1], vertexData[i1 + 2]);
                var p2 = new away.geom.Vector3D(vertexData[i2], vertexData[i2 + 1], vertexData[i2 + 2]);
                var side0 = p1.subtract(p0);
                var side1 = p2.subtract(p0);
                normal = side0.crossProduct(side1);
                normal.normalize();
                return normal;
            };

            PickingColliderBase.prototype._pGetCollisionUV = function (indexData/*uint*/ , uvData, triangleIndex, v, w, u, uvOffset, uvStride) {
                var uv = new away.geom.Point();
                var uIndex = indexData[triangleIndex] * uvStride + uvOffset;
                var uv0 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uIndex = indexData[triangleIndex + 1] * uvStride + uvOffset;
                var uv1 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uIndex = indexData[triangleIndex + 2] * uvStride + uvOffset;
                var uv2 = new away.geom.Vector3D(uvData[uIndex], uvData[uIndex + 1]);
                uv.x = u * uv0.x + v * uv1.x + w * uv2.x;
                uv.y = u * uv0.y + v * uv1.y + w * uv2.y;
                return uv;
            };

            //* TODO: implement & integrate GeometryUtils, SubGeometry, SubMesh
            PickingColliderBase.prototype.pGetMeshSubgeometryIndex = function (subGeometry) {
                away.Debug.throwPIR('away.pick.PickingColliderBase', 'pGetMeshSubMeshIndex', 'GeometryUtils.getMeshSubMeshIndex');
                return 0;
                //return GeometryUtils.getMeshSubgeometryIndex(subGeometry);
            };

            //*/
            //* TODO: implement & integrate
            PickingColliderBase.prototype.pGetMeshSubMeshIndex = function (subMesh) {
                away.Debug.throwPIR('away.pick.PickingColliderBase', 'pGetMeshSubMeshIndex', 'GeometryUtils.getMeshSubMeshIndex');

                return 0;
                //return GeometryUtils.getMeshSubMeshIndex(subMesh);
            };

            //*/
            /**
            * @inheritDoc
            */
            PickingColliderBase.prototype.setLocalRay = function (localPosition, localDirection) {
                this.rayPosition = localPosition;
                this.rayDirection = localDirection;
            };
            return PickingColliderBase;
        })();
        pick.PickingColliderBase = PickingColliderBase;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (pick) {
        /**
        * Pure AS3 picking collider for entity objects. Used with the <code>RaycastPicker</code> picking object.
        *
        * @see away3d.entities.Entity#pickingCollider
        * @see away3d.core.pick.RaycastPicker
        */
        var AS3PickingCollider = (function (_super) {
            __extends(AS3PickingCollider, _super);
            /**
            * Creates a new <code>AS3PickingCollider</code> object.
            *
            * @param findClosestCollision Determines whether the picking collider searches for the closest collision along the ray. Defaults to false.
            */
            function AS3PickingCollider(findClosestCollision) {
                if (typeof findClosestCollision === "undefined") { findClosestCollision = false; }
                _super.call(this);
                this._findClosestCollision = findClosestCollision;
            }
            /**
            * @inheritDoc
            */
            //* TODO: Implement & Integrate Dependencies: SubMesh
            AS3PickingCollider.prototype.testSubMeshCollision = function (subMesh, pickingCollisionVO, shortestCollisionDistance) {
                var t;
                var i0, i1, i2;
                var rx, ry, rz;
                var nx, ny, nz;
                var cx, cy, cz;
                var coeff, u, v, w;
                var p0x, p0y, p0z;
                var p1x, p1y, p1z;
                var p2x, p2y, p2z;
                var s0x, s0y, s0z;
                var s1x, s1y, s1z;
                var nl, nDotV, D, disToPlane;
                var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
                var indexData = subMesh.indexData;
                var vertexData = subMesh.vertexData;
                var uvData = subMesh.UVData;
                var collisionTriangleIndex = -1;
                var bothSides = subMesh.material.bothSides;

                var vertexStride = subMesh.vertexStride;
                var vertexOffset = subMesh.vertexOffset;
                var uvStride = subMesh.UVStride;
                var uvOffset = subMesh.UVOffset;
                var numIndices = indexData.length;

                for (var index = 0; index < numIndices; index += 3) {
                    // evaluate triangle indices
                    i0 = vertexOffset + indexData[index] * vertexStride;
                    i1 = vertexOffset + indexData[(index + 1)] * vertexStride;
                    i2 = vertexOffset + indexData[(index + 2)] * vertexStride;

                    // evaluate triangle vertices
                    p0x = vertexData[i0];
                    p0y = vertexData[(i0 + 1)];
                    p0z = vertexData[(i0 + 2)];
                    p1x = vertexData[i1];
                    p1y = vertexData[(i1 + 1)];
                    p1z = vertexData[(i1 + 2)];
                    p2x = vertexData[i2];
                    p2y = vertexData[(i2 + 1)];
                    p2z = vertexData[(i2 + 2)];

                    // evaluate sides and triangle normal
                    s0x = p1x - p0x;
                    s0y = p1y - p0y;
                    s0z = p1z - p0z;
                    s1x = p2x - p0x;
                    s1y = p2y - p0y;
                    s1z = p2z - p0z;
                    nx = s0y * s1z - s0z * s1y;
                    ny = s0z * s1x - s0x * s1z;
                    nz = s0x * s1y - s0y * s1x;
                    nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
                    nx *= nl;
                    ny *= nl;
                    nz *= nl;

                    // -- plane intersection test --
                    nDotV = nx * this.rayDirection.x + ny * +this.rayDirection.y + nz * this.rayDirection.z;
                    if ((!bothSides && nDotV < 0.0) || (bothSides && nDotV != 0.0)) {
                        // find collision t
                        D = -(nx * p0x + ny * p0y + nz * p0z);
                        disToPlane = -(nx * this.rayPosition.x + ny * this.rayPosition.y + nz * this.rayPosition.z + D);
                        t = disToPlane / nDotV;

                        // find collision point
                        cx = this.rayPosition.x + t * this.rayDirection.x;
                        cy = this.rayPosition.y + t * this.rayDirection.y;
                        cz = this.rayPosition.z + t * this.rayDirection.z;

                        // collision point inside triangle? ( using barycentric coordinates )
                        Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                        Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                        Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                        rx = cx - p0x;
                        ry = cy - p0y;
                        rz = cz - p0z;
                        RQ1 = rx * s0x + ry * s0y + rz * s0z;
                        RQ2 = rx * s1x + ry * s1y + rz * s1z;
                        coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                        v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                        w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                        if (v < 0)
                            continue;
                        if (w < 0)
                            continue;
                        u = 1 - v - w;
                        if (!(u < 0) && t > 0 && t < shortestCollisionDistance) {
                            shortestCollisionDistance = t;
                            collisionTriangleIndex = index / 3;
                            pickingCollisionVO.rayEntryDistance = t;
                            pickingCollisionVO.localPosition = new away.geom.Vector3D(cx, cy, cz);
                            pickingCollisionVO.localNormal = new away.geom.Vector3D(nx, ny, nz);
                            pickingCollisionVO.uv = this._pGetCollisionUV(indexData, uvData, index, v, w, u, uvOffset, uvStride);
                            pickingCollisionVO.index = index;
                            pickingCollisionVO.subGeometryIndex = this.pGetMeshSubMeshIndex(subMesh);

                            if (!this._findClosestCollision)
                                return true;
                        }
                    }
                }

                if (collisionTriangleIndex >= 0)
                    return true;

                return false;
            };
            return AS3PickingCollider;
        })(away.pick.PickingColliderBase);
        pick.AS3PickingCollider = AS3PickingCollider;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (pick) {
        /**
        * Options for setting a picking collider for entity objects. Used with the <code>RaycastPicker</code> picking object.
        *
        * @see away3d.entities.Entity#pickingCollider
        * @see away3d.core.pick.RaycastPicker
        */
        var PickingColliderType = (function () {
            function PickingColliderType() {
            }
            PickingColliderType.BOUNDS_ONLY = null;

            PickingColliderType.AS3_FIRST_ENCOUNTERED = new away.pick.AS3PickingCollider(false);

            PickingColliderType.AS3_BEST_HIT = new away.pick.AS3PickingCollider(true);
            return PickingColliderType;
        })();
        pick.PickingColliderType = PickingColliderType;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (containers) {
        var View3D = (function () {
            /*
            ***********************************************************************
            * Disabled / Not yet implemented
            ***********************************************************************
            *
            * private _background:away.textures.Texture2DBase;
            *
            * public _pMouse3DManager:away.managers.Mouse3DManager;
            * public _pTouch3DManager:away.managers.Touch3DManager;
            *
            */
            function View3D(scene, camera, renderer, forceSoftware, profile) {
                if (typeof scene === "undefined") { scene = null; }
                if (typeof camera === "undefined") { camera = null; }
                if (typeof renderer === "undefined") { renderer = null; }
                if (typeof forceSoftware === "undefined") { forceSoftware = false; }
                if (typeof profile === "undefined") { profile = "baseline"; }
                this._pBackBufferInvalid = true;
                this._pShareContext = false;
                this._width = 0;
                this._height = 0;
                this._localPos = new away.geom.Point();
                this._globalPos = new away.geom.Point();
                this._time = 0;
                this._deltaTime = 0;
                this._backgroundColor = 0x000000;
                this._backgroundAlpha = 1;
                this._depthTextureInvalid = true;
                this._antiAlias = 0;
                this._scissorRectDirty = true;
                this._viewportDirty = true;
                this._depthPrepass = false;
                this._layeredView = false;
                if (View3D.sStage == null) {
                    View3D.sStage = new away.display.Stage();
                }

                this._profile = profile;
                this._pScene = scene || new containers.Scene3D();
                this._pScene.addEventListener(away.events.Scene3DEvent.PARTITION_CHANGED, this.onScenePartitionChanged, this);
                this._pCamera = camera || new away.cameras.Camera3D();
                this._pRenderer = renderer || new away.render.DefaultRenderer();
                this._depthRenderer = new away.render.DepthRenderer();
                this._forceSoftware = forceSoftware;
                this._pEntityCollector = this._pRenderer.iCreateEntityCollector();
                this._pEntityCollector.camera = this._pCamera;
                this._pScissorRect = new away.geom.Rectangle();
                this._pCamera.addEventListener(away.events.CameraEvent.LENS_CHANGED, this.onLensChanged, this);
                this._pCamera.partition = this._pScene.partition;
                this.stage = View3D.sStage;

                this.onAddedToStage();
            }
            /**
            *
            * @param e
            */
            View3D.prototype.onScenePartitionChanged = function (e) {
                if (this._pCamera) {
                    this._pCamera.partition = this.scene.partition;
                }
            };

            Object.defineProperty(View3D.prototype, "stage3DProxy", {
                get: /**
                *
                * @returns {away.managers.Stage3DProxy}
                */
                function () {
                    return this._pStage3DProxy;
                },
                set: /**
                *
                * @param stage3DProxy
                */
                function (stage3DProxy) {
                    if (this._pStage3DProxy) {
                        this._pStage3DProxy.removeEventListener(away.events.Stage3DEvent.VIEWPORT_UPDATED, this.onViewportUpdated, this);
                    }

                    this._pStage3DProxy = stage3DProxy;
                    this._pStage3DProxy.addEventListener(away.events.Stage3DEvent.VIEWPORT_UPDATED, this.onViewportUpdated, this);
                    this._pRenderer.iStage3DProxy = this._depthRenderer.iStage3DProxy = this._pStage3DProxy;
                    this._globalPosDirty = true;
                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "layeredView", {
                get: /**
                *
                * @returns {boolean}
                */
                function () {
                    return this._layeredView;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    this._layeredView = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "filters3d", {
                get: /**
                *
                * @returns {*}
                */
                function () {
                    return this._pFilter3DRenderer ? this._pFilter3DRenderer.filters : null;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    if (value && value.length == 0)
                        value = null;

                    if (this._pFilter3DRenderer && !value) {
                        this._pFilter3DRenderer.dispose();
                        this._pFilter3DRenderer = null;
                    } else if (!this._pFilter3DRenderer && value) {
                        this._pFilter3DRenderer = new away.render.Filter3DRenderer(this._pStage3DProxy);
                        this._pFilter3DRenderer.filters = value;
                    }

                    if (this._pFilter3DRenderer) {
                        this._pFilter3DRenderer.filters = value;
                        this._pRequireDepthRender = this._pFilter3DRenderer.requireDepthRender;
                    } else {
                        this._pRequireDepthRender = false;

                        if (this._pDepthRender) {
                            this._pDepthRender.dispose();
                            this._pDepthRender = null;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "renderer", {
                get: /**
                *
                * @returns {away.render.RendererBase}
                */
                function () {
                    return this._pRenderer;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    this._pRenderer.iDispose();
                    this._pRenderer = value;

                    this._pEntityCollector = this._pRenderer.iCreateEntityCollector();
                    this._pEntityCollector.camera = this._pCamera;
                    this._pRenderer.iStage3DProxy = this._pStage3DProxy;
                    this._pRenderer.antiAlias = this._antiAlias;
                    this._pRenderer.iBackgroundR = ((this._backgroundColor >> 16) & 0xff) / 0xff;
                    this._pRenderer.iBackgroundG = ((this._backgroundColor >> 8) & 0xff) / 0xff;
                    this._pRenderer.iBackgroundB = (this._backgroundColor & 0xff) / 0xff;
                    this._pRenderer.iBackgroundAlpha = this._backgroundAlpha;
                    this._pRenderer.iViewWidth = this._width;
                    this._pRenderer.iViewHeight = this._height;

                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "backgroundColor", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._backgroundColor;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    this._backgroundColor = value;
                    this._pRenderer.iBackgroundR = ((value >> 16) & 0xff) / 0xff;
                    this._pRenderer.iBackgroundG = ((value >> 8) & 0xff) / 0xff;
                    this._pRenderer.iBackgroundB = (value & 0xff) / 0xff;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "backgroundAlpha", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._backgroundAlpha;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    if (value > 1) {
                        value = 1;
                    } else if (value < 0) {
                        value = 0;
                    }

                    this._pRenderer.iBackgroundAlpha = value;
                    this._backgroundAlpha = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "camera", {
                get: /**
                *
                * @returns {away.cameras.Camera3D}
                */
                function () {
                    return this._pCamera;
                },
                set: /**
                * Set camera that's used to render the scene for this viewport
                */
                function (camera) {
                    this._pCamera.removeEventListener(away.events.CameraEvent.LENS_CHANGED, this.onLensChanged, this);
                    this._pCamera = camera;

                    this._pEntityCollector.camera = this._pCamera;

                    if (this._pScene) {
                        this._pCamera.partition = this._pScene.partition;
                    }

                    this._pCamera.addEventListener(away.events.CameraEvent.LENS_CHANGED, this.onLensChanged, this);
                    this._scissorRectDirty = true;
                    this._viewportDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "scene", {
                get: /**
                *
                * @returns {away.containers.Scene3D}
                */
                function () {
                    return this._pScene;
                },
                set: /**
                * Set the scene that's used to render for this viewport
                */
                function (scene) {
                    this._pScene.removeEventListener(away.events.Scene3DEvent.PARTITION_CHANGED, this.onScenePartitionChanged, this);
                    this._pScene = scene;
                    this._pScene.addEventListener(away.events.Scene3DEvent.PARTITION_CHANGED, this.onScenePartitionChanged, this);

                    if (this._pCamera) {
                        this._pCamera.partition = this._pScene.partition;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "deltaTime", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._deltaTime;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(View3D.prototype, "width", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._width;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    if (this._width == value) {
                        return;
                    }

                    if (this._pRttBufferManager) {
                        this._pRttBufferManager.viewWidth = value;
                    }

                    this._width = value;
                    this._aspectRatio = this._width / this._height;
                    this._pCamera.lens.iAspectRatio = this._aspectRatio;
                    this._depthTextureInvalid = true;
                    this._pRenderer.iViewWidth = value;
                    this._pScissorRect.width = value;
                    this._pBackBufferInvalid = true;
                    this._scissorRectDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "height", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._height;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    if (this._height == value) {
                        return;
                    }

                    if (this._pRttBufferManager) {
                        this._pRttBufferManager.viewHeight = value;
                    }

                    this._height = value;
                    this._aspectRatio = this._width / this._height;
                    this._pCamera.lens.iAspectRatio = this._aspectRatio;
                    this._depthTextureInvalid = true;
                    this._pRenderer.iViewHeight = value;
                    this._pScissorRect.height = value;
                    this._pBackBufferInvalid = true;
                    this._scissorRectDirty = true;
                },
                enumerable: true,
                configurable: true
            });




            Object.defineProperty(View3D.prototype, "x", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._localPos.x;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    if (this.x == value)
                        return;

                    this._globalPos.x = this._localPos.x = value;
                    this._globalPosDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(View3D.prototype, "y", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._localPos.y;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    if (this.y == value)
                        return;

                    this._globalPos.y = this._localPos.y = value;
                    this._globalPosDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(View3D.prototype, "visible", {
                get: /**
                *
                * @returns {boolean}
                */
                function () {
                    return true;
                },
                set: /**
                *
                * @param v
                */
                function (v) {
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(View3D.prototype, "canvas", {
                get: function () {
                    return this._pStage3DProxy.canvas;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(View3D.prototype, "antiAlias", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._antiAlias;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    this._antiAlias = value;
                    this._pRenderer.antiAlias = value;
                    this._pBackBufferInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(View3D.prototype, "renderedFacesCount", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._pEntityCollector._pNumTriangles;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(View3D.prototype, "shareContext", {
                get: /**
                *
                * @returns {boolean}
                */
                function () {
                    return this._pShareContext;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    if (this._pShareContext == value) {
                        return;
                    }
                    this._pShareContext = value;
                    this._globalPosDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Updates the backbuffer dimensions.
            */
            View3D.prototype.pUpdateBackBuffer = function () {
                if (this._pStage3DProxy._iContext3D && !this._pShareContext) {
                    if (this._width && this._height) {
                        this._pStage3DProxy.configureBackBuffer(this._width, this._height, this._antiAlias, true);
                        this._pBackBufferInvalid = false;
                    }
                }
            };

            /**
            * Renders the view.
            */
            View3D.prototype.render = function () {
                if (!this._pStage3DProxy.recoverFromDisposal()) {
                    this._pBackBufferInvalid = true;
                    return;
                }

                if (this._pBackBufferInvalid) {
                    this.pUpdateBackBuffer();
                }

                if (this._pShareContext && this._layeredView) {
                    this._pStage3DProxy.clearDepthBuffer();
                }

                if (this._globalPosDirty) {
                    this.pUpdateGlobalPos();
                }

                this.pUpdateTime();
                this.pUpdateViewSizeData();
                this._pEntityCollector.clear();
                this._pScene.traversePartitions(this._pEntityCollector);

                if (this._pRequireDepthRender) {
                    this.pRenderSceneDepthToTexture(this._pEntityCollector);
                }

                if (this._depthPrepass) {
                    this.pRenderDepthPrepass(this._pEntityCollector);
                }

                this._pRenderer.iClearOnRender = !this._depthPrepass;

                if (this._pFilter3DRenderer && this._pStage3DProxy._iContext3D) {
                    this._pRenderer.iRender(this._pEntityCollector, this._pFilter3DRenderer.getMainInputTexture(this._pStage3DProxy), this._pRttBufferManager.renderToTextureRect);
                    this._pFilter3DRenderer.render(this._pStage3DProxy, this._pCamera, this._pDepthRender);
                } else {
                    this._pRenderer.iShareContext = this._pShareContext;

                    if (this._pShareContext) {
                        this._pRenderer.iRender(this._pEntityCollector, null, this._pScissorRect);
                    } else {
                        this._pRenderer.iRender(this._pEntityCollector);
                    }
                }

                if (!this._pShareContext) {
                    this._pStage3DProxy.present();
                    // TODO: imeplement mouse3dManager
                    // fire collected mouse events
                    //_mouse3DManager.fireMouseEvents();
                    //_touch3DManager.fireTouchEvents();
                }

                // clean up data for this render
                this._pEntityCollector.cleanUp();

                // register that a view has been rendered
                this._pStage3DProxy.bufferClear = false;
            };

            /**
            *
            */
            View3D.prototype.pUpdateGlobalPos = function () {
                this._globalPosDirty = false;

                if (!this._pStage3DProxy) {
                    return;
                }

                if (this._pShareContext) {
                    this._pScissorRect.x = this._globalPos.x - this._pStage3DProxy.x;
                    this._pScissorRect.y = this._globalPos.y - this._pStage3DProxy.y;
                } else {
                    this._pScissorRect.x = 0;
                    this._pScissorRect.y = 0;
                    this._pStage3DProxy.x = this._globalPos.x;
                    this._pStage3DProxy.y = this._globalPos.y;
                }

                this._scissorRectDirty = true;
            };

            /**
            *
            */
            View3D.prototype.pUpdateTime = function () {
                var time = away.utils.getTimer();

                if (this._time == 0) {
                    this._time = time;
                }

                this._deltaTime = time - this._time;
                this._time = time;
            };

            /**
            *
            */
            View3D.prototype.pUpdateViewSizeData = function () {
                this._pCamera.lens.iAspectRatio = this._aspectRatio;

                if (this._scissorRectDirty) {
                    this._scissorRectDirty = false;
                    this._pCamera.lens.iUpdateScissorRect(this._pScissorRect.x, this._pScissorRect.y, this._pScissorRect.width, this._pScissorRect.height);
                }

                if (this._viewportDirty) {
                    this._viewportDirty = false;
                    this._pCamera.lens.iUpdateViewport(this._pStage3DProxy.viewPort.x, this._pStage3DProxy.viewPort.y, this._pStage3DProxy.viewPort.width, this._pStage3DProxy.viewPort.height);
                }

                if (this._pFilter3DRenderer || this._pRenderer.iRenderToTexture) {
                    this._pRenderer.iTextureRatioX = this._pRttBufferManager.textureRatioX;
                    this._pRenderer.iTextureRatioY = this._pRttBufferManager.textureRatioY;
                } else {
                    this._pRenderer.iTextureRatioX = 1;
                    this._pRenderer.iTextureRatioY = 1;
                }
            };

            /**
            *
            * @param entityCollector
            */
            View3D.prototype.pRenderDepthPrepass = function (entityCollector) {
                this._depthRenderer.disableColor = true;

                if (this._pFilter3DRenderer || this._pRenderer.iRenderToTexture) {
                    this._depthRenderer.iTextureRatioX = this._pRttBufferManager.textureRatioX;
                    this._depthRenderer.iTextureRatioY = this._pRttBufferManager.textureRatioY;
                    this._depthRenderer.iRender(entityCollector, this._pFilter3DRenderer.getMainInputTexture(this._pStage3DProxy), this._pRttBufferManager.renderToTextureRect);
                } else {
                    this._depthRenderer.iTextureRatioX = 1;
                    this._depthRenderer.iTextureRatioY = 1;
                    this._depthRenderer.iRender(entityCollector);
                }

                this._depthRenderer.disableColor = false;
            };

            /**
            *
            * @param entityCollector
            */
            View3D.prototype.pRenderSceneDepthToTexture = function (entityCollector) {
                if (this._depthTextureInvalid || !this._pDepthRender) {
                    this.initDepthTexture(this._pStage3DProxy._iContext3D);
                }
                this._depthRenderer.iTextureRatioX = this._pRttBufferManager.textureRatioX;
                this._depthRenderer.iTextureRatioY = this._pRttBufferManager.textureRatioY;
                this._depthRenderer.iRender(entityCollector, this._pDepthRender);
            };

            /**
            *
            * @param context
            */
            View3D.prototype.initDepthTexture = function (context) {
                this._depthTextureInvalid = false;

                if (this._pDepthRender) {
                    this._pDepthRender.dispose();
                }
                this._pDepthRender = context.createTexture(this._pRttBufferManager.textureWidth, this._pRttBufferManager.textureHeight, away.display3D.Context3DTextureFormat.BGRA, true);
            };

            /**
            *
            */
            View3D.prototype.dispose = function () {
                this._pStage3DProxy.removeEventListener(away.events.Stage3DEvent.VIEWPORT_UPDATED, this.onViewportUpdated, this);

                if (!this.shareContext) {
                    this._pStage3DProxy.dispose();
                }

                this._pRenderer.iDispose();

                if (this._pDepthRender) {
                    this._pDepthRender.dispose();
                }

                if (this._pRttBufferManager) {
                    this._pRttBufferManager.dispose();
                }

                // TODO: imeplement mouse3DManager / touch3DManager
                //this._mouse3DManager.disableMouseListeners(this);
                //this._mouse3DManager.dispose();
                //this._touch3DManager.disableTouchListeners(this);
                //this._touch3DManager.dispose();
                //this._mouse3DManager = null;
                //this._touch3DManager = null;
                this._pRttBufferManager = null;
                this._pDepthRender = null;
                this._depthRenderer = null;
                this._pStage3DProxy = null;
                this._pRenderer = null;
                this._pEntityCollector = null;
            };

            Object.defineProperty(View3D.prototype, "iEntityCollector", {
                get: /**
                *
                * @returns {away.traverse.EntityCollector}
                */
                function () {
                    return this._pEntityCollector;
                },
                enumerable: true,
                configurable: true
            });

            /**
            *
            * @param event
            */
            View3D.prototype.onLensChanged = function (event) {
                this._scissorRectDirty = true;
                this._viewportDirty = true;
            };

            /**
            *
            * @param event
            */
            View3D.prototype.onViewportUpdated = function (event) {
                if (this._pShareContext) {
                    this._pScissorRect.x = this._globalPos.x - this._pStage3DProxy.x;
                    this._pScissorRect.y = this._globalPos.y - this._pStage3DProxy.y;
                    this._scissorRectDirty = true;
                }
                this._viewportDirty = true;
            };

            Object.defineProperty(View3D.prototype, "depthPrepass", {
                get: /**
                *
                * @returns {boolean}
                */
                function () {
                    return this._depthPrepass;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    this._depthPrepass = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            *
            */
            View3D.prototype.onAddedToStage = function () {
                this._addedToStage = true;

                if (this._pStage3DProxy == null) {
                    this._pStage3DProxy = away.managers.Stage3DManager.getInstance(this.stage).getFreeStage3DProxy(this._forceSoftware, this._profile);
                    this._pStage3DProxy.addEventListener(away.events.Stage3DEvent.VIEWPORT_UPDATED, this.onViewportUpdated, this);
                }

                this._globalPosDirty = true;
                this._pRttBufferManager = away.managers.RTTBufferManager.getInstance(this._pStage3DProxy);
                this._pRenderer.iStage3DProxy = this._depthRenderer.iStage3DProxy = this._pStage3DProxy;

                if (this._width == 0) {
                    this.width = this.stage.stageWidth;
                } else {
                    this._pRttBufferManager.viewWidth = this._width;
                }

                if (this._height == 0) {
                    this.height = this.stage.stageHeight;
                } else {
                    this._pRttBufferManager.viewHeight = this._height;
                }
            };

            // TODO private function onAddedToStage(event:Event):void
            // TODO private function onAdded(event:Event):void
            View3D.prototype.project = function (point3d) {
                var v = this._pCamera.project(point3d);
                v.x = (v.x + 1.0) * this._width / 2.0;
                v.y = (v.y + 1.0) * this._height / 2.0;
                return v;
            };

            View3D.prototype.unproject = function (sX, sY, sZ) {
                return this._pCamera.unproject((sX * 2 - this._width) / this._pStage3DProxy.width, (sY * 2 - this._height) / this._pStage3DProxy.height, sZ);
            };

            View3D.prototype.getRay = function (sX, sY, sZ) {
                return this._pCamera.getRay((sX * 2 - this._width) / this._width, (sY * 2 - this._height) / this._height, sZ);
            };
            return View3D;
        })();
        containers.View3D = View3D;
    })(away.containers || (away.containers = {}));
    var containers = away.containers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (library) {
        /**
        * Abstract base class for naming conflict resolution classes. Extend this to create a
        * strategy class which the asset library can use to resolve asset naming conflicts, or
        * use one of the bundled concrete strategy classes:
        *
        * <ul>
        *   <li>IgnoreConflictStrategy (ConflictStrategy.IGNORE)</li>
        *   <li>ErrorConflictStrategy (ConflictStrategy.THROW_ERROR)</li>
        *   <li>NumSuffixConflictStrategy (ConflictStrategy.APPEND_NUM_SUFFIX)</li>
        * </ul>
        *
        * @see away3d.library.AssetLibrary.conflictStrategy
        * @see away3d.library.naming.ConflictStrategy
        * @see away3d.library.naming.IgnoreConflictStrategy
        * @see away3d.library.naming.ErrorConflictStrategy
        * @see away3d.library.naming.NumSuffixConflictStrategy
        */
        var ConflictStrategyBase = (function () {
            function ConflictStrategyBase() {
            }
            /**
            * Resolve a naming conflict between two assets. Must be implemented by concrete strategy
            * classes.
            */
            ConflictStrategyBase.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Create instance of this conflict strategy. Used internally by the AssetLibrary to
            * make sure the same strategy instance is not used in all AssetLibrary instances, which
            * would break any state caching that happens inside the strategy class.
            */
            ConflictStrategyBase.prototype.create = function () {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Provided as a convenience method for all conflict strategy classes, as a way to finalize
            * the conflict resolution by applying the new names and dispatching the correct events.
            */
            ConflictStrategyBase.prototype._pUpdateNames = function (ns, nonConflictingName, oldAsset, newAsset, assetsDictionary, precedence) {
                var loser_prev_name;
                var winner;
                var loser;

                winner = (precedence === away.library.ConflictPrecedence.FAVOR_NEW) ? newAsset : oldAsset;
                loser = (precedence === away.library.ConflictPrecedence.FAVOR_NEW) ? oldAsset : newAsset;

                loser_prev_name = loser.name;

                assetsDictionary[winner.name] = winner;
                assetsDictionary[nonConflictingName] = loser;
                loser.resetAssetPath(nonConflictingName, ns, false);

                loser.dispatchEvent(new away.events.AssetEvent(away.events.AssetEvent.ASSET_CONFLICT_RESOLVED, loser, loser_prev_name));
            };
            return ConflictStrategyBase;
        })();
        library.ConflictStrategyBase = ConflictStrategyBase;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (library) {
        var NumSuffixConflictStrategy = (function (_super) {
            __extends(NumSuffixConflictStrategy, _super);
            function NumSuffixConflictStrategy(separator) {
                if (typeof separator === "undefined") { separator = '.'; }
                _super.call(this);

                this._separator = separator;
                this._next_suffix = {};
            }
            NumSuffixConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
                var orig;
                var new_name;
                var base;
                var suffix;

                orig = changedAsset.name;

                if (orig.indexOf(this._separator) >= 0) {
                    // Name has an ocurrence of the separator, so get base name and suffix,
                    // unless suffix is non-numerical, in which case revert to zero and
                    // use entire name as base
                    base = orig.substring(0, orig.lastIndexOf(this._separator));
                    suffix = parseInt(orig.substring(base.length - 1));

                    if (isNaN(suffix)) {
                        base = orig;
                        suffix = 0;
                    }
                } else {
                    base = orig;
                    suffix = 0;
                }

                if (suffix == 0 && this._next_suffix.hasOwnProperty(base)) {
                    suffix = this._next_suffix[base];
                }

                do {
                    suffix++;

                    new_name = base.concat(this._separator, suffix.toString());
                } while(assetsDictionary.hasOwnProperty(new_name));

                this._next_suffix[base] = suffix;
                this._pUpdateNames(oldAsset.assetNamespace, new_name, oldAsset, changedAsset, assetsDictionary, precedence);
            };

            NumSuffixConflictStrategy.prototype.create = function () {
                return new away.library.NumSuffixConflictStrategy(this._separator);
            };
            return NumSuffixConflictStrategy;
        })(away.library.ConflictStrategyBase);
        library.NumSuffixConflictStrategy = NumSuffixConflictStrategy;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (library) {
        //import away3d.library.assets.IAsset;
        var IgnoreConflictStrategy = (function (_super) {
            __extends(IgnoreConflictStrategy, _super);
            function IgnoreConflictStrategy() {
                _super.call(this);
            }
            IgnoreConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
                // Do nothing, ignore the fact that there is a conflict.
                return;
            };

            IgnoreConflictStrategy.prototype.create = function () {
                return new away.library.IgnoreConflictStrategy();
            };
            return IgnoreConflictStrategy;
        })(away.library.ConflictStrategyBase);
        library.IgnoreConflictStrategy = IgnoreConflictStrategy;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (library) {
        //import away3d.library.assets.IAsset;
        var ErrorConflictStrategy = (function (_super) {
            __extends(ErrorConflictStrategy, _super);
            function ErrorConflictStrategy() {
                _super.call(this);
            }
            ErrorConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
                throw new away.errors.Error('Asset name collision while AssetLibrary.namingStrategy set to AssetLibrary.THROW_ERROR. Asset path: ' + changedAsset.assetFullPath);
            };

            ErrorConflictStrategy.prototype.create = function () {
                return new ErrorConflictStrategy();
            };
            return ErrorConflictStrategy;
        })(away.library.ConflictStrategyBase);
        library.ErrorConflictStrategy = ErrorConflictStrategy;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    (function (library) {
        /**
        * Enumaration class for precedence when resolving naming conflicts in the library.
        *
        * @see away3d.library.AssetLibrary.conflictPrecedence
        * @see away3d.library.AssetLibrary.conflictStrategy
        * @see away3d.library.naming.ConflictStrategy
        */
        var ConflictPrecedence = (function () {
            function ConflictPrecedence() {
            }
            ConflictPrecedence.FAVOR_OLD = 'favorOld';

            ConflictPrecedence.FAVOR_NEW = 'favorNew';
            return ConflictPrecedence;
        })();
        library.ConflictPrecedence = ConflictPrecedence;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (library) {
        /**
        * AssetLibraryBundle enforces a multiton pattern and is not intended to be instanced directly.
        * Its purpose is to create a container for 3D data management, both before and after parsing.
        * If you are interested in creating multiple library bundles, please use the <code>getInstance()</code> method.
        */
        var AssetLibraryBundle = (function (_super) {
            __extends(AssetLibraryBundle, _super);
            /**
            * Creates a new <code>AssetLibraryBundle</code> object.
            *
            * @param me A multiton enforcer for the AssetLibraryBundle ensuring it cannnot be instanced.
            */
            function AssetLibraryBundle(me) {
                _super.call(this);
                this._loadingSessionsGarbage = new Array();

                //me = me;
                this._assets = new Array();
                this._assetDictionary = new Object();
                this._loadingSessions = new Array();

                this.conflictStrategy = away.library.ConflictStrategy.IGNORE.create();
                this.conflictPrecedence = away.library.ConflictPrecedence.FAVOR_NEW;
            }
            AssetLibraryBundle.getInstance = /**
            * Returns an AssetLibraryBundle instance. If no key is given, returns the default bundle instance (which is
            * similar to using the AssetLibraryBundle as a singleton.) To keep several separated library bundles,
            * pass a string key to this method to define which bundle should be returned. This is
            * referred to as using the AssetLibrary as a multiton.
            *
            * @param key Defines which multiton instance should be returned.
            * @return An instance of the asset library
            */
            function (key) {
                if (typeof key === "undefined") { key = 'default'; }
                if (!key) {
                    key = 'default';
                }

                if (!away.library.AssetLibrary._iInstances.hasOwnProperty(key)) {
                    away.library.AssetLibrary._iInstances[key] = new away.library.AssetLibraryBundle(new AssetLibraryBundleSingletonEnforcer());
                }

                return away.library.AssetLibrary._iInstances[key];
            };

            /**
            *
            */
            AssetLibraryBundle.prototype.enableParser = function (parserClass) {
                away.loaders.SingleFileLoader.enableParser(parserClass);
            };

            /**
            *
            */
            AssetLibraryBundle.prototype.enableParsers = function (parserClasses) {
                away.loaders.SingleFileLoader.enableParsers(parserClasses);
            };

            Object.defineProperty(AssetLibraryBundle.prototype, "conflictStrategy", {
                get: /**
                * Defines which strategy should be used for resolving naming conflicts, when two library
                * assets are given the same name. By default, <code>ConflictStrategy.APPEND_NUM_SUFFIX</code>
                * is used which means that a numeric suffix is appended to one of the assets. The
                * <code>conflictPrecedence</code> property defines which of the two conflicting assets will
                * be renamed.
                *
                * @see away3d.library.naming.ConflictStrategy
                * @see away3d.library.AssetLibrary.conflictPrecedence
                */
                function () {
                    return this._strategy;
                },
                set: function (val) {
                    if (!val) {
                        throw new away.errors.Error('namingStrategy must not be null. To ignore naming, use AssetLibrary.IGNORE');
                    }

                    this._strategy = val.create();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AssetLibraryBundle.prototype, "conflictPrecedence", {
                get: /**
                * Defines which asset should have precedence when resolving a naming conflict between
                * two assets of which one has just been renamed by the user or by a parser. By default
                * <code>ConflictPrecedence.FAVOR_NEW</code> is used, meaning that the newly renamed
                * asset will keep it's new name while the older asset gets renamed to not conflict.
                *
                * This property is ignored for conflict strategies that do not actually rename an
                * asset automatically, such as ConflictStrategy.IGNORE and ConflictStrategy.THROW_ERROR.
                *
                * @see away3d.library.naming.ConflictPrecedence
                * @see away3d.library.naming.ConflictStrategy
                */
                function () {
                    return this._strategyPreference;
                },
                set: function (val) {
                    this._strategyPreference = val;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Create an AssetLibraryIterator instance that can be used to iterate over the assets
            * in this asset library instance. The iterator can filter assets on asset type and/or
            * namespace. A "null" filter value means no filter of that type is used.
            *
            * @param assetTypeFilter Asset type to filter on (from the AssetType enum class.) Use
            * null to not filter on asset type.
            * @param namespaceFilter Namespace to filter on. Use null to not filter on namespace.
            * @param filterFunc Callback function to use when deciding whether an asset should be
            * included in the iteration or not. This needs to be a function that takes a single
            * parameter of type IAsset and returns a boolean where true means it should be included.
            *
            * @see away3d.library.assets.AssetType
            */
            AssetLibraryBundle.prototype.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
                if (typeof assetTypeFilter === "undefined") { assetTypeFilter = null; }
                if (typeof namespaceFilter === "undefined") { namespaceFilter = null; }
                if (typeof filterFunc === "undefined") { filterFunc = null; }
                return new away.library.AssetLibraryIterator(this._assets, assetTypeFilter, namespaceFilter, filterFunc);
            };

            /**
            * Loads a file and (optionally) all of its dependencies.
            *
            * @param req The URLRequest object containing the URL of the file to be loaded.
            * @param context An optional context object providing additional parameters for loading
            * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
            * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            AssetLibraryBundle.prototype.load = function (req, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                return this.loadResource(req, context, ns, parser);
            };

            /**
            * Loads a resource from existing data in memory.
            *
            * @param data The data object containing all resource information.
            * @param context An optional context object providing additional parameters for loading
            * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
            * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            AssetLibraryBundle.prototype.loadData = function (data, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                return this.parseResource(data, context, ns, parser);
            };

            /**
            *
            */
            AssetLibraryBundle.prototype.getAsset = function (name, ns) {
                if (typeof ns === "undefined") { ns = null; }
                if (this._assetDictDirty) {
                    this.rehashAssetDict();
                }

                if (ns == null) {
                    ns = away.library.NamedAssetBase.DEFAULT_NAMESPACE;
                }

                if (!this._assetDictionary.hasOwnProperty(ns)) {
                    return null;
                }

                return this._assetDictionary[ns][name];
            };

            /**
            * Adds an asset to the asset library, first making sure that it's name is unique
            * using the method defined by the <code>conflictStrategy</code> and
            * <code>conflictPrecedence</code> properties.
            */
            AssetLibraryBundle.prototype.addAsset = function (asset) {
                var ns;
                var old;

                if (this._assets.indexOf(asset) >= 0) {
                    return;
                }

                old = this.getAsset(asset.name, asset.assetNamespace);
                ns = asset.assetNamespace || library.NamedAssetBase.DEFAULT_NAMESPACE;

                if (old != null) {
                    this._strategy.resolveConflict(asset, old, this._assetDictionary[ns], this._strategyPreference);
                }

                //create unique-id (for now this is used in AwayBuilder only
                asset.id = away.library.IDUtil.createUID();

                // Add it
                this._assets.push(asset);

                if (!this._assetDictionary.hasOwnProperty(ns)) {
                    this._assetDictionary[ns] = new Object();
                }

                this._assetDictionary[ns][asset.name] = asset;

                asset.addEventListener(away.events.AssetEvent.ASSET_RENAME, this.onAssetRename, this);
                asset.addEventListener(away.events.AssetEvent.ASSET_CONFLICT_RESOLVED, this.onAssetConflictResolved, this);
            };

            /**
            * Removes an asset from the library, and optionally disposes that asset by calling
            * it's disposeAsset() method (which for most assets is implemented as a default
            * version of that type's dispose() method.
            *
            * @param asset The asset which should be removed from this library.
            * @param dispose Defines whether the assets should also be disposed.
            */
            AssetLibraryBundle.prototype.removeAsset = function (asset, dispose) {
                if (typeof dispose === "undefined") { dispose = true; }
                var idx;

                this.removeAssetFromDict(asset);

                asset.removeEventListener(away.events.AssetEvent.ASSET_RENAME, this.onAssetRename, this);
                asset.removeEventListener(away.events.AssetEvent.ASSET_CONFLICT_RESOLVED, this.onAssetConflictResolved, this);

                idx = this._assets.indexOf(asset);
                if (idx >= 0) {
                    this._assets.splice(idx, 1);
                }

                if (dispose) {
                    asset.dispose();
                }
            };

            /**
            * Removes an asset which is specified using name and namespace.
            *
            * @param name The name of the asset to be removed.
            * @param ns The namespace to which the desired asset belongs.
            * @param dispose Defines whether the assets should also be disposed.
            *
            * @see away3d.library.AssetLibrary.removeAsset()
            */
            AssetLibraryBundle.prototype.removeAssetByName = function (name, ns, dispose) {
                if (typeof ns === "undefined") { ns = null; }
                if (typeof dispose === "undefined") { dispose = true; }
                var asset = this.getAsset(name, ns);

                if (asset) {
                    this.removeAsset(asset, dispose);
                }

                return asset;
            };

            /**
            * Removes all assets from the asset library, optionally disposing them as they
            * are removed.
            *
            * @param dispose Defines whether the assets should also be disposed.
            */
            AssetLibraryBundle.prototype.removeAllAssets = function (dispose) {
                if (typeof dispose === "undefined") { dispose = true; }
                if (dispose) {
                    var asset;

                    for (var c = 0; c < this._assets.length; c++) {
                        asset = this._assets[c];
                        asset.dispose();
                    }
                    /*
                    for each (asset in _assets)
                    asset.dispose();
                    */
                }

                this._assets.length = 0;
                this.rehashAssetDict();
            };

            /**
            * Removes all assets belonging to a particular namespace (null for default)
            * from the asset library, and optionall disposes them by calling their
            * disposeAsset() method.
            *
            * @param ns The namespace from which all assets should be removed.
            * @param dispose Defines whether the assets should also be disposed.
            *
            * @see away3d.library.AssetLibrary.removeAsset()
            */
            AssetLibraryBundle.prototype.removeNamespaceAssets = function (ns, dispose) {
                if (typeof ns === "undefined") { ns = null; }
                if (typeof dispose === "undefined") { dispose = true; }
                var idx = 0;
                var asset;
                var old_assets;

                // Empty the assets vector after having stored a copy of it.
                // The copy will be filled with all assets which weren't removed.
                old_assets = this._assets.concat();
                this._assets.length = 0;

                if (ns == null) {
                    ns = away.library.NamedAssetBase.DEFAULT_NAMESPACE;
                }

                for (var d = 0; d < old_assets.length; d++) {
                    asset = old_assets[d];

                    if (asset.assetNamespace == ns) {
                        if (dispose) {
                            asset.dispose();
                        }

                        // Remove asset from dictionary, but don't try to auto-remove
                        // the namespace, which will trigger an unnecessarily expensive
                        // test that is not needed since we know that the namespace
                        // will be empty when loop finishes.
                        this.removeAssetFromDict(asset, false);
                    } else {
                        this._assets[idx++] = asset;
                    }
                }

                if (this._assetDictionary.hasOwnProperty(ns)) {
                    delete this._assetDictionary[ns];
                }
            };

            AssetLibraryBundle.prototype.removeAssetFromDict = function (asset, autoRemoveEmptyNamespace) {
                if (typeof autoRemoveEmptyNamespace === "undefined") { autoRemoveEmptyNamespace = true; }
                if (this._assetDictDirty) {
                    this.rehashAssetDict();
                }

                if (this._assetDictionary.hasOwnProperty(asset.assetNamespace)) {
                    if (this._assetDictionary[asset.assetNamespace].hasOwnProperty(asset.name)) {
                        delete this._assetDictionary[asset.assetNamespace][asset.name];
                    }

                    if (autoRemoveEmptyNamespace) {
                        var key;
                        var empty = true;

                        for (key in this._assetDictionary[asset.assetNamespace]) {
                            empty = false;
                            break;
                        }

                        if (empty) {
                            delete this._assetDictionary[asset.assetNamespace];
                        }
                    }
                }
            };

            /**
            * Loads a yet unloaded resource file from the given url.
            */
            AssetLibraryBundle.prototype.loadResource = function (req, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                var loader = new away.loaders.AssetLoader();

                if (!this._loadingSessions) {
                    this._loadingSessions = new Array();
                }

                this._loadingSessions.push(loader);

                loader.addEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this.onResourceRetrieved, this);
                loader.addEventListener(away.events.LoaderEvent.DEPENDENCY_COMPLETE, this.onDependencyRetrieved, this);
                loader.addEventListener(away.events.AssetEvent.TEXTURE_SIZE_ERROR, this.onTextureSizeError, this);
                loader.addEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);

                // Error are handled separately (see documentation for addErrorHandler)
                loader._iAddErrorHandler(this.onDependencyRetrievingError);
                loader._iAddParseErrorHandler(this.onDependencyRetrievingParseError);

                return loader.load(req, context, ns, parser);
            };

            AssetLibraryBundle.prototype.stopAllLoadingSessions = function () {
                var i;

                if (!this._loadingSessions) {
                    this._loadingSessions = new Array();
                }

                var length = this._loadingSessions.length;

                for (i = 0; i < length; i++) {
                    this.killLoadingSession(this._loadingSessions[i]);
                }

                this._loadingSessions = null;
            };

            /**
            * Retrieves an unloaded resource parsed from the given data.
            * @param data The data to be parsed.
            * @param id The id that will be assigned to the resource. This can later also be used by the getResource method.
            * @param ignoreDependencies Indicates whether or not dependencies should be ignored or loaded.
            * @param parser An optional parser object that will translate the data into a usable resource.
            * @return A handle to the retrieved resource.
            */
            AssetLibraryBundle.prototype.parseResource = function (data, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                var loader = new away.loaders.AssetLoader();

                if (!this._loadingSessions) {
                    this._loadingSessions = new Array();
                }

                this._loadingSessions.push(loader);

                loader.addEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this.onResourceRetrieved, this);
                loader.addEventListener(away.events.LoaderEvent.DEPENDENCY_COMPLETE, this.onDependencyRetrieved, this);
                loader.addEventListener(away.events.AssetEvent.TEXTURE_SIZE_ERROR, this.onTextureSizeError, this);
                loader.addEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);

                // Error are handled separately (see documentation for addErrorHandler)
                loader._iAddErrorHandler(this.onDependencyRetrievingError);
                loader._iAddParseErrorHandler(this.onDependencyRetrievingParseError);

                return loader.loadData(data, '', context, ns, parser);
            };

            AssetLibraryBundle.prototype.rehashAssetDict = function () {
                var asset;

                this._assetDictionary = {};

                var l = this._assets.length;

                for (var c = 0; c < l; c++) {
                    asset = this._assets[c];

                    if (!this._assetDictionary.hasOwnProperty(asset.assetNamespace)) {
                        this._assetDictionary[asset.assetNamespace] = {};
                    }

                    this._assetDictionary[asset.assetNamespace][asset.name] = asset;
                }

                this._assetDictDirty = false;
            };

            /**
            * Called when a dependency was retrieved.
            */
            AssetLibraryBundle.prototype.onDependencyRetrieved = function (event) {
                //if (hasEventListener(LoaderEvent.DEPENDENCY_COMPLETE))
                this.dispatchEvent(event);
            };

            /**
            * Called when a an error occurs during dependency retrieving.
            */
            AssetLibraryBundle.prototype.onDependencyRetrievingError = function (event) {
                if (this.hasEventListener(away.events.LoaderEvent.LOAD_ERROR, this.onDependencyRetrievingError, this)) {
                    this.dispatchEvent(event);
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Called when a an error occurs during parsing.
            */
            AssetLibraryBundle.prototype.onDependencyRetrievingParseError = function (event) {
                if (this.hasEventListener(away.events.ParserEvent.PARSE_ERROR, this.onDependencyRetrievingParseError, this)) {
                    this.dispatchEvent(event);
                    return true;
                } else {
                    return false;
                }
            };

            AssetLibraryBundle.prototype.onAssetComplete = function (event) {
                if (event.type == away.events.AssetEvent.ASSET_COMPLETE) {
                    this.addAsset(event.asset);
                }

                this.dispatchEvent(event.clone());
            };

            AssetLibraryBundle.prototype.onTextureSizeError = function (event) {
                this.dispatchEvent(event.clone());
            };

            /**
            * Called when the resource and all of its dependencies was retrieved.
            */
            AssetLibraryBundle.prototype.onResourceRetrieved = function (event) {
                var _this = this;
                var loader = event.target;

                this.dispatchEvent(event.clone());

                var index = this._loadingSessions.indexOf(loader);
                this._loadingSessions.splice(index, 1);

                // Add loader to a garbage array - for a collection sweep and kill
                this._loadingSessionsGarbage.push(loader);
                this._gcTimeoutIID = setTimeout(function () {
                    _this.loadingSessionGC();
                }, 100);
            };

            AssetLibraryBundle.prototype.loadingSessionGC = function () {
                var loader;

                while (this._loadingSessionsGarbage.length > 0) {
                    loader = this._loadingSessionsGarbage.pop();
                    this.killLoadingSession(loader);
                }

                clearTimeout(this._gcTimeoutIID);
                this._gcTimeoutIID = null;
            };

            AssetLibraryBundle.prototype.killLoadingSession = function (loader) {
                loader.removeEventListener(away.events.LoaderEvent.LOAD_ERROR, this.onDependencyRetrievingError, this);
                loader.removeEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this.onResourceRetrieved, this);
                loader.removeEventListener(away.events.LoaderEvent.DEPENDENCY_COMPLETE, this.onDependencyRetrieved, this);
                loader.removeEventListener(away.events.AssetEvent.TEXTURE_SIZE_ERROR, this.onTextureSizeError, this);
                loader.removeEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);
                loader.stop();
            };

            /**
            * Called when unespected error occurs
            */
            /*
            private onResourceError() : void
            {
            var msg:string = "Unexpected parser error";
            if(hasEventListener(LoaderEvent.DEPENDENCY_ERROR)){
            var re:LoaderEvent = new LoaderEvent(LoaderEvent.DEPENDENCY_ERROR, "");
            dispatchEvent(re);
            } else{
            throw new Error(msg);
            }
            }
            */
            AssetLibraryBundle.prototype.onAssetRename = function (ev) {
                var asset = ev.target;
                var old = this.getAsset(asset.assetNamespace, asset.name);

                if (old != null) {
                    this._strategy.resolveConflict(asset, old, this._assetDictionary[asset.assetNamespace], this._strategyPreference);
                } else {
                    var dict = this._assetDictionary[ev.asset.assetNamespace];

                    if (dict == null) {
                        return;
                    }

                    dict[ev.assetPrevName] = null;
                    dict[ev.asset.name] = ev.asset;
                }
            };

            AssetLibraryBundle.prototype.onAssetConflictResolved = function (ev) {
                this.dispatchEvent(ev.clone());
            };
            return AssetLibraryBundle;
        })(away.events.EventDispatcher);
        library.AssetLibraryBundle = AssetLibraryBundle;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));

// singleton enforcer
var AssetLibraryBundleSingletonEnforcer = (function () {
    function AssetLibraryBundleSingletonEnforcer() {
    }
    return AssetLibraryBundleSingletonEnforcer;
})();
var away;
(function (away) {
    (function (loaders) {
        var AssetLoaderContext = (function () {
            /**
            * AssetLoaderContext provides configuration for the AssetLoader load() and parse() operations.
            * Use it to configure how (and if) dependencies are loaded, or to map dependency URLs to
            * embedded data.
            *
            * @see away3d.loading.AssetLoader
            */
            function AssetLoaderContext(includeDependencies, dependencyBaseUrl) {
                if (typeof includeDependencies === "undefined") { includeDependencies = true; }
                if (typeof dependencyBaseUrl === "undefined") { dependencyBaseUrl = null; }
                this._includeDependencies = includeDependencies;
                this._dependencyBaseUrl = dependencyBaseUrl || '';
                this._embeddedDataByUrl = {};
                this._remappedUrls = {};
                this._materialMode = AssetLoaderContext.UNDEFINED;
            }
            Object.defineProperty(AssetLoaderContext.prototype, "includeDependencies", {
                get: /**
                * Defines whether dependencies (all files except the one at the URL given to the load() or
                * parseData() operations) should be automatically loaded. Defaults to true.
                */
                function () {
                    return this._includeDependencies;
                },
                set: function (val) {
                    this._includeDependencies = val;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AssetLoaderContext.prototype, "materialMode", {
                get: /**
                * MaterialMode defines, if the Parser should create SinglePass or MultiPass Materials
                * Options:
                * 0 (Default / undefined) - All Parsers will create SinglePassMaterials, but the AWD2.1parser will create Materials as they are defined in the file
                * 1 (Force SinglePass) - All Parsers create SinglePassMaterials
                * 2 (Force MultiPass) - All Parsers will create MultiPassMaterials
                *
                */
                function () {
                    return this._materialMode;
                },
                set: function (materialMode) {
                    this._materialMode = materialMode;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AssetLoaderContext.prototype, "dependencyBaseUrl", {
                get: /**
                * A base URL that will be prepended to all relative dependency URLs found in a loaded resource.
                * Absolute paths will not be affected by the value of this property.
                */
                function () {
                    return this._dependencyBaseUrl;
                },
                set: function (val) {
                    this._dependencyBaseUrl = val;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AssetLoaderContext.prototype, "overrideAbsolutePaths", {
                get: /**
                * Defines whether absolute paths (defined as paths that begin with a "/") should be overridden
                * with the dependencyBaseUrl defined in this context. If this is true, and the base path is
                * "base", /path/to/asset.jpg will be resolved as base/path/to/asset.jpg.
                */
                function () {
                    return this._overrideAbsPath;
                },
                set: function (val) {
                    this._overrideAbsPath = val;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AssetLoaderContext.prototype, "overrideFullURLs", {
                get: /**
                * Defines whether "full" URLs (defined as a URL that includes a scheme, e.g. http://) should be
                * overridden with the dependencyBaseUrl defined in this context. If this is true, and the base
                * path is "base", http://example.com/path/to/asset.jpg will be resolved as base/path/to/asset.jpg.
                */
                function () {
                    return this._overrideFullUrls;
                },
                set: function (val) {
                    this._overrideFullUrls = val;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Map a URL to another URL, so that files that are referred to by the original URL will instead
            * be loaded from the new URL. Use this when your file structure does not match the one that is
            * expected by the loaded file.
            *
            * @param originalUrl The original URL which is referenced in the loaded resource.
            * @param newUrl The URL from which Away3D should load the resource instead.
            *
            * @see mapUrlToData()
            */
            AssetLoaderContext.prototype.mapUrl = function (originalUrl, newUrl) {
                this._remappedUrls[originalUrl] = newUrl;
            };

            /**
            * Map a URL to embedded data, so that instead of trying to load a dependency from the URL at
            * which it's referenced, the dependency data will be retrieved straight from the memory instead.
            *
            * @param originalUrl The original URL which is referenced in the loaded resource.
            * @param data The embedded data. Can be ByteArray or a class which can be used to create a bytearray.
            */
            AssetLoaderContext.prototype.mapUrlToData = function (originalUrl, data) {
                this._embeddedDataByUrl[originalUrl] = data;
            };

            /**
            * @private
            * Defines whether embedded data has been mapped to a particular URL.
            */
            AssetLoaderContext.prototype._iHasDataForUrl = function (url) {
                return this._embeddedDataByUrl.hasOwnProperty(url);
            };

            /**
            * @private
            * Returns embedded data for a particular URL.
            */
            AssetLoaderContext.prototype._iGetDataForUrl = function (url) {
                return this._embeddedDataByUrl[url];
            };

            /**
            * @private
            * Defines whether a replacement URL has been mapped to a particular URL.
            */
            AssetLoaderContext.prototype._iHasMappingForUrl = function (url) {
                return this._remappedUrls.hasOwnProperty(url);
            };

            /**
            * @private
            * Returns new (replacement) URL for a particular original URL.
            */
            AssetLoaderContext.prototype._iGetRemappedUrl = function (originalUrl) {
                return this._remappedUrls[originalUrl];
            };
            AssetLoaderContext.UNDEFINED = 0;
            AssetLoaderContext.SINGLEPASS_MATERIALS = 1;
            AssetLoaderContext.MULTIPASS_MATERIALS = 2;
            return AssetLoaderContext;
        })();
        loaders.AssetLoaderContext = AssetLoaderContext;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (library) {
        //import away3d.library.assets.IAsset;
        var AssetLibraryIterator = (function () {
            function AssetLibraryIterator(assets, assetTypeFilter, namespaceFilter, filterFunc) {
                this._assets = assets;
                this.filter(assetTypeFilter, namespaceFilter, filterFunc);
            }
            Object.defineProperty(AssetLibraryIterator.prototype, "currentAsset", {
                get: function () {
                    // Return current, or null if no current
                    return (this._idx < this._filtered.length) ? this._filtered[this._idx] : null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AssetLibraryIterator.prototype, "numAssets", {
                get: function () {
                    return this._filtered.length;
                },
                enumerable: true,
                configurable: true
            });

            AssetLibraryIterator.prototype.next = function () {
                var next = null;

                if (this._idx < this._filtered.length)
                    next = this._filtered[this._idx];

                this._idx++;

                return next;
            };

            AssetLibraryIterator.prototype.reset = function () {
                this._idx = 0;
            };

            AssetLibraryIterator.prototype.setIndex = function (index) {
                this._idx = index;
            };

            AssetLibraryIterator.prototype.filter = function (assetTypeFilter, namespaceFilter, filterFunc) {
                if (assetTypeFilter || namespaceFilter) {
                    var idx;
                    var asset;

                    idx = 0;
                    this._filtered = new Array();

                    var l = this._assets.length;

                    for (var c = 0; c < l; c++) {
                        asset = this._assets[c];

                        if (assetTypeFilter && asset.assetType != assetTypeFilter)
                            continue;

                        if (namespaceFilter && asset.assetNamespace != namespaceFilter)
                            continue;

                        if (filterFunc != null && !filterFunc(asset))
                            continue;

                        this._filtered[idx++] = asset;
                    }
                    /*
                    for each (asset in _assets) {
                    // Skip this assets if filtering on type and this is wrong type
                    if (assetTypeFilter && asset.assetType != assetTypeFilter)
                    continue;
                    
                    // Skip this asset if filtering on namespace and this is wrong namespace
                    if (namespaceFilter && asset.assetNamespace != namespaceFilter)
                    continue;
                    
                    // Skip this asset if a filter func has been provided and it returns false
                    if (filterFunc != null && !filterFunc(asset))
                    continue;
                    
                    _filtered[idx++] = asset;
                    }
                    */
                } else {
                    this._filtered = this._assets;
                }
            };
            return AssetLibraryIterator;
        })();
        library.AssetLibraryIterator = AssetLibraryIterator;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (loaders) {
        //import away3d.*;
        //import away3d.events.*;
        //import away3d.loaders.misc.*;
        //import away3d.loaders.parsers.*;
        //import flash.events.*;
        //import flash.net.*;
        //use namespace arcane;
        /**
        * Dispatched when any asset finishes parsing. Also see specific events for each
        * individual asset type (meshes, materials et c.)
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="assetComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a full resource (including dependencies) finishes loading.
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when a single dependency (which may be the main file of a resource)
        * finishes loading.
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when an error occurs during loading. I
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="loadError", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when an error occurs during parsing.
        *
        * @eventType away3d.events.ParserEvent
        */
        //[Event(name="parseError", type="away3d.events.ParserEvent")]
        /**
        * Dispatched when a skybox asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skyboxComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a camera3d asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="cameraComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a mesh asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="meshComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a geometry asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="geometryComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a skeleton asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skeletonComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a skeleton pose asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skeletonPoseComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a container asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="containerComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a texture asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a texture projector asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureProjectorComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a material asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="materialComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a animator asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animatorComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation set has been constructed from a group of animation state resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationSetComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation state has been constructed from a group of animation node resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationStateComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation node has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationNodeComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation state transition has been constructed from a group of animation node resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="stateTransitionComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an light asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="lightComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an light picker asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="lightPickerComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an effect method asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="effectMethodComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an shadow map method asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="shadowMapMethodComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an image asset dimensions are not a power of 2
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureSizeError", type="away3d.events.AssetEvent")]
        /**
        * AssetLoader can load any file format that Away3D supports (or for which a third-party parser
        * has been plugged in) and it's dependencies. Events are dispatched when assets are encountered
        * and for when the resource (or it's dependencies) have been loaded.
        *
        * The AssetLoader will not make assets available in any other way than through the dispatched
        * events. To store assets and make them available at any point from any module in an application,
        * use the AssetLibrary to load and manage assets.
        *
        * @see away3d.loading.Loader3D
        * @see away3d.loading.AssetLibrary
        */
        var AssetLoader = (function (_super) {
            __extends(AssetLoader, _super);
            /**
            * Create a new ResourceLoadSession object.
            */
            function AssetLoader() {
                _super.call(this);

                this._stack = new Array();
                this._errorHandlers = new Array();
                this._parseErrorHandlers = new Array();
            }
            Object.defineProperty(AssetLoader.prototype, "baseDependency", {
                get: /**
                * Returns the base dependency of the loader
                */
                function () {
                    return this._baseDependency;
                },
                enumerable: true,
                configurable: true
            });

            AssetLoader.enableParser = /**
            * Enables a specific parser.
            * When no specific parser is set for a loading/parsing opperation,
            * loader3d can autoselect the correct parser to use.
            * A parser must have been enabled, to be considered when autoselecting the parser.
            *
            * @param parserClass The parser class to enable.
            *
            * @see away3d.loaders.parsers.Parsers
            */
            function (parserClass) {
                away.loaders.SingleFileLoader.enableParser(parserClass);
            };

            AssetLoader.enableParsers = /**
            * Enables a list of parsers.
            * When no specific parser is set for a loading/parsing opperation,
            * AssetLoader can autoselect the correct parser to use.
            * A parser must have been enabled, to be considered when autoselecting the parser.
            *
            * @param parserClasses A Vector of parser classes to enable.
            * @see away3d.loaders.parsers.Parsers
            */
            function (parserClasses) {
                away.loaders.SingleFileLoader.enableParsers(parserClasses);
            };

            /**
            * Loads a file and (optionally) all of its dependencies.
            *
            * @param req The URLRequest object containing the URL of the file to be loaded.
            * @param context An optional context object providing additional parameters for loading
            * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
            * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            AssetLoader.prototype.load = function (req, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                if (!this._token) {
                    this._token = new away.loaders.AssetLoaderToken(this);

                    this._uri = req.url = req.url.replace(/\\/g, "/");
                    this._context = context;
                    this._namespace = ns;

                    this._baseDependency = new away.loaders.ResourceDependency('', req, null, null);
                    this.retrieveDependency(this._baseDependency, parser);

                    return this._token;
                }

                // TODO: Throw error (already loading)
                return null;
            };

            /**
            * Loads a resource from already loaded data.
            *
            * @param data The data object containing all resource information.
            * @param context An optional context object providing additional parameters for loading
            * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
            * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            AssetLoader.prototype.loadData = function (data, id, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                if (!this._token) {
                    this._token = new away.loaders.AssetLoaderToken(this);

                    this._uri = id;
                    this._context = context;
                    this._namespace = ns;

                    this._baseDependency = new loaders.ResourceDependency(id, null, data, null);
                    this.retrieveDependency(this._baseDependency, parser);

                    return this._token;
                }

                // TODO: Throw error (already loading)
                return null;
            };

            /**
            * Recursively retrieves the next to-be-loaded and parsed dependency on the stack, or pops the list off the
            * stack when complete and continues on the top set.
            * @param parser The parser that will translate the data into a usable resource.
            */
            AssetLoader.prototype.retrieveNext = function (parser) {
                if (typeof parser === "undefined") { parser = null; }
                if (this._loadingDependency.dependencies.length) {
                    var dep = this._loadingDependency.dependencies.pop();

                    this._stack.push(this._loadingDependency);
                    this.retrieveDependency(dep);
                } else if (this._loadingDependency._iLoader.parser && this._loadingDependency._iLoader.parser.parsingPaused) {
                    this._loadingDependency._iLoader.parser._iResumeParsingAfterDependencies();
                    this._stack.pop();
                } else if (this._stack.length) {
                    var prev = this._loadingDependency;

                    this._loadingDependency = this._stack.pop();

                    if (prev._iSuccess) {
                        prev.resolve();
                    }

                    this.retrieveNext(parser);
                } else {
                    this.dispatchEvent(new away.events.LoaderEvent(away.events.LoaderEvent.RESOURCE_COMPLETE, this._uri, this._baseDependency.assets));
                }
            };

            /**
            * Retrieves a single dependency.
            * @param parser The parser that will translate the data into a usable resource.
            */
            AssetLoader.prototype.retrieveDependency = function (dependency, parser) {
                if (typeof parser === "undefined") { parser = null; }
                var data;
                var matMode = 0;

                if (this._context && this._context.materialMode != 0) {
                    matMode = this._context.materialMode;
                }

                this._loadingDependency = dependency;
                this._loadingDependency._iLoader = new away.loaders.SingleFileLoader(matMode);

                this.addEventListeners(this._loadingDependency._iLoader);

                // Get already loaded (or mapped) data if available
                data = this._loadingDependency.data;

                if (this._context && this._loadingDependency.request && this._context._iHasDataForUrl(this._loadingDependency.request.url)) {
                    data = this._context._iGetDataForUrl(this._loadingDependency.request.url);
                }

                if (data) {
                    if (this._loadingDependency.retrieveAsRawData) {
                        // No need to parse. The parent parser is expecting this
                        // to be raw data so it can be passed directly.
                        this.dispatchEvent(new away.events.LoaderEvent(away.events.LoaderEvent.DEPENDENCY_COMPLETE, this._loadingDependency.request.url, this._baseDependency.assets, true));
                        this._loadingDependency._iSetData(data);
                        this._loadingDependency.resolve();

                        // Move on to next dependency
                        this.retrieveNext();
                    } else {
                        this._loadingDependency._iLoader.parseData(data, parser, this._loadingDependency.request);
                    }
                } else {
                    // Resolve URL and start loading
                    dependency.request.url = this.resolveDependencyUrl(dependency);
                    this._loadingDependency._iLoader.load(dependency.request, parser, this._loadingDependency.retrieveAsRawData);
                }
            };

            AssetLoader.prototype.joinUrl = function (base, end) {
                if (end.charAt(0) == '/') {
                    end = end.substr(1);
                }

                if (base.length == 0) {
                    return end;
                }

                if (base.charAt(base.length - 1) == '/') {
                    base = base.substr(0, base.length - 1);
                }

                return base.concat('/', end);
            };

            AssetLoader.prototype.resolveDependencyUrl = function (dependency) {
                var scheme_re;
                var base;
                var url = dependency.request.url;

                if (this._context && this._context._iHasMappingForUrl(url))
                    return this._context._iGetRemappedUrl(url);

                if (url == this._uri) {
                    return url;
                }

                // Absolute URL? Check if starts with slash or a URL
                // scheme definition (e.g. ftp://, http://, file://)
                scheme_re = new RegExp('/^[a-zA-Z]{3,4}:\/\//');

                if (url.charAt(0) == '/') {
                    if (this._context && this._context.overrideAbsolutePaths)
                        return this.joinUrl(this._context.dependencyBaseUrl, url);
else
                        return url;
                } else if (scheme_re.test(url)) {
                    if (this._context && this._context.overrideFullURLs) {
                        var noscheme_url;

                        noscheme_url = url['replace'](scheme_re);

                        return this.joinUrl(this._context.dependencyBaseUrl, noscheme_url);
                    }
                }

                if (this._context && this._context.dependencyBaseUrl) {
                    base = this._context.dependencyBaseUrl;
                    return this.joinUrl(base, url);
                } else {
                    base = this._uri.substring(0, this._uri.lastIndexOf('/') + 1);
                    return this.joinUrl(base, url);
                }
            };

            AssetLoader.prototype.retrieveLoaderDependencies = function (loader) {
                if (!this._loadingDependency) {
                    //loader.parser = null;
                    //loader = null;
                    return;
                }
                var i, len = loader.dependencies.length;

                for (i = 0; i < len; i++) {
                    this._loadingDependency.dependencies[i] = loader.dependencies[i];
                }

                // Since more dependencies might be added eventually, empty this
                // list so that the same dependency isn't retrieved more than once.
                loader.dependencies.length = 0;

                this._stack.push(this._loadingDependency);

                this.retrieveNext();
            };

            /**
            * Called when a single dependency loading failed, and pushes further dependencies onto the stack.
            * @param event
            */
            AssetLoader.prototype.onRetrievalFailed = function (event) {
                var handled;
                var isDependency = (this._loadingDependency != this._baseDependency);
                var loader = event.target;

                this.removeEventListeners(loader);

                event = new away.events.LoaderEvent(away.events.LoaderEvent.LOAD_ERROR, this._uri, this._baseDependency.assets, isDependency, event.message);

                // TODO: JS / AS3 Change - debug this code with a fine tooth combe
                //if (this.hasEventListener( away.events.LoaderEvent.LOAD_ERROR , this )) {
                this.dispatchEvent(event);
                handled = true;

                //} else {
                // TO - Away - Consider not doing this even when AssetLoader does
                // have it's own LOAD_ERROR listener
                var i, len = this._errorHandlers.length;
                for (i = 0; i < len; i++) {
                    var handlerFunction = this._errorHandlers[i];

                    handled = handled || handlerFunction(event);
                }

                if (handled) {
                    if (isDependency) {
                        this._loadingDependency.resolveFailure();
                        this.retrieveNext();
                    } else {
                        // Either this was the base file (last left in the stack) or
                        // default behavior was prevented by the handlers, and hence
                        // there is nothing more to do than clean up and bail.
                        this.dispose();
                        return;
                    }
                } else {
                    throw new away.errors.Error(event.message);
                }
            };

            /**
            * Called when a dependency parsing failed, and dispatches a <code>ParserEvent.PARSE_ERROR</code>
            * @param event
            */
            AssetLoader.prototype.onParserError = function (event) {
                var handled;

                var isDependency = (this._loadingDependency != this._baseDependency);

                var loader = event.target;

                this.removeEventListeners(loader);

                event = new away.events.ParserEvent(away.events.ParserEvent.PARSE_ERROR, event.message);

                // TODO: keep on eye on this / debug - JS / AS3 Change
                //if (this.hasEventListener(away.events.ParserEvent.PARSE_ERROR)) {
                this.dispatchEvent(event);
                handled = true;

                //} else {
                // TODO: Consider not doing this even when AssetLoader does
                // have it's own LOAD_ERROR listener
                var i, len = this._parseErrorHandlers.length;

                for (i = 0; i < len; i++) {
                    var handlerFunction = this._parseErrorHandlers[i];

                    handled = handled || handlerFunction(event);
                    //handled ||= Boolean(handlerFunction(event));
                }

                if (handled) {
                    this.dispose();
                    return;
                } else {
                    throw new Error(event.message);
                }
            };

            AssetLoader.prototype.onAssetComplete = function (event) {
                if (event.type == away.events.AssetEvent.ASSET_COMPLETE) {
                    if (this._loadingDependency) {
                        this._loadingDependency.assets.push(event.asset);
                    }

                    event.asset.resetAssetPath(event.asset.name, this._namespace);
                }

                if (!this._loadingDependency.suppresAssetEvents) {
                    this.dispatchEvent(event.clone());
                }
            };

            AssetLoader.prototype.onReadyForDependencies = function (event) {
                var loader = event.target;

                if (this._context && !this._context.includeDependencies) {
                    loader.parser._iResumeParsingAfterDependencies();
                } else {
                    this.retrieveLoaderDependencies(loader);
                }
            };

            /**
            * Called when a single dependency was parsed, and pushes further dependencies onto the stack.
            * @param event
            */
            AssetLoader.prototype.onRetrievalComplete = function (event) {
                var loader = event.target;

                //var loader:SingleFileLoader = SingleFileLoader(event.target);
                // Resolve this dependency
                this._loadingDependency._iSetData(loader.data);
                this._loadingDependency._iSuccess = true;

                this.dispatchEvent(new away.events.LoaderEvent(away.events.LoaderEvent.DEPENDENCY_COMPLETE, event.url, this._baseDependency.assets));
                this.removeEventListeners(loader);

                if (loader.dependencies.length && (!this._context || this._context.includeDependencies)) {
                    this.retrieveLoaderDependencies(loader);
                } else {
                    this.retrieveNext();
                }
            };

            /**
            * Called when an image is too large or it's dimensions are not a power of 2
            * @param event
            */
            AssetLoader.prototype.onTextureSizeError = function (event) {
                event.asset.name = this._loadingDependency.resolveName(event.asset);
                this.dispatchEvent(event);
            };

            AssetLoader.prototype.addEventListeners = function (loader) {
                loader.addEventListener(away.events.LoaderEvent.DEPENDENCY_COMPLETE, this.onRetrievalComplete, this);
                loader.addEventListener(away.events.LoaderEvent.LOAD_ERROR, this.onRetrievalFailed, this);
                loader.addEventListener(away.events.AssetEvent.TEXTURE_SIZE_ERROR, this.onTextureSizeError, this);
                loader.addEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);
                loader.addEventListener(away.events.ParserEvent.READY_FOR_DEPENDENCIES, this.onReadyForDependencies, this);
                loader.addEventListener(away.events.ParserEvent.PARSE_ERROR, this.onParserError, this);
            };

            AssetLoader.prototype.removeEventListeners = function (loader) {
                loader.removeEventListener(away.events.ParserEvent.READY_FOR_DEPENDENCIES, this.onReadyForDependencies, this);
                loader.removeEventListener(away.events.LoaderEvent.DEPENDENCY_COMPLETE, this.onRetrievalComplete, this);
                loader.removeEventListener(away.events.LoaderEvent.LOAD_ERROR, this.onRetrievalFailed, this);
                loader.removeEventListener(away.events.AssetEvent.TEXTURE_SIZE_ERROR, this.onTextureSizeError, this);
                loader.removeEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);
                loader.removeEventListener(away.events.ParserEvent.PARSE_ERROR, this.onParserError, this);
            };

            AssetLoader.prototype.stop = function () {
                this.dispose();
            };

            AssetLoader.prototype.dispose = function () {
                this._errorHandlers = null;
                this._parseErrorHandlers = null;
                this._context = null;
                this._token = null;
                this._stack = null;

                if (this._loadingDependency && this._loadingDependency._iLoader) {
                    this.removeEventListeners(this._loadingDependency._iLoader);
                }

                this._loadingDependency = null;
            };

            /**
            * @private
            * This method is used by other loader classes (e.g. Loader3D and AssetLibraryBundle) to
            * add error event listeners to the AssetLoader instance. This system is used instead of
            * the regular EventDispatcher system so that the AssetLibrary error handler can be sure
            * that if hasEventListener() returns true, it's client code that's listening for the
            * event. Secondly, functions added as error handler through this custom method are
            * expected to return a boolean value indicating whether the event was handled (i.e.
            * whether they in turn had any client code listening for the event.) If no handlers
            * return true, the AssetLoader knows that the event wasn't handled and will throw an RTE.
            */
            AssetLoader.prototype._iAddParseErrorHandler = function (handler) {
                if (this._parseErrorHandlers.indexOf(handler) < 0) {
                    this._parseErrorHandlers.push(handler);
                }
            };

            AssetLoader.prototype._iAddErrorHandler = function (handler) {
                if (this._errorHandlers.indexOf(handler) < 0) {
                    this._errorHandlers.push(handler);
                }
            };
            return AssetLoader;
        })(away.events.EventDispatcher);
        loaders.AssetLoader = AssetLoader;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (library) {
        /**
        * Enumeration class for bundled conflict strategies. Set one of these values (or an
        * instance of a self-defined sub-class of ConflictStrategyBase) to the conflictStrategy
        * property on an AssetLibrary to define how that library resolves naming conflicts.
        *
        * The value of the <code>AssetLibrary.conflictPrecedence</code> property defines which
        * of the conflicting assets will get to keep it's name, and which is renamed (if any.)
        *
        * @see away3d.library.AssetLibrary.conflictStrategy
        * @see away3d.library.naming.ConflictStrategyBase
        */
        var ConflictStrategy = (function () {
            function ConflictStrategy() {
            }
            ConflictStrategy.APPEND_NUM_SUFFIX = new away.library.NumSuffixConflictStrategy();

            ConflictStrategy.IGNORE = new away.library.IgnoreConflictStrategy();

            ConflictStrategy.THROW_ERROR = new away.library.ErrorConflictStrategy();
            return ConflictStrategy;
        })();
        library.ConflictStrategy = ConflictStrategy;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (net) {
        /**
        *
        */
        var URLRequest = (function () {
            /**
            
            * @param url
            */
            function URLRequest(url) {
                if (typeof url === "undefined") { url = null; }
                /**
                *
                * away.net.URLRequestMethod.GET
                * away.net.URLRequestMethod.POST
                *
                * @type {string}
                */
                this.method = away.net.URLRequestMethod.GET;
                /**
                * Use asynchronous XMLHttpRequest
                * @type {boolean}
                */
                this.async = true;
                this._url = url;
            }
            Object.defineProperty(URLRequest.prototype, "url", {
                get: /**
                *
                * @returns {string}
                */
                function () {
                    return this._url;
                },
                set: /**
                *
                * @param value
                */
                function (value) {
                    this._url = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * dispose
            */
            URLRequest.prototype.dispose = function () {
                this.data = null;
                this._url = null;
                this.method = null;
                this.async = null;
            };
            return URLRequest;
        })();
        net.URLRequest = URLRequest;
    })(away.net || (away.net = {}));
    var net = away.net;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        //import away3d.arcane;
        //import away3d.events.AssetEvent;
        //import away3d.events.LoaderEvent;
        //import away3d.loaders.AssetLoader;
        //import flash.events.Event;
        //import flash.events.EventDispatcher;
        //use namespace arcane;
        /**
        * Dispatched when any asset finishes parsing. Also see specific events for each
        * individual asset type (meshes, materials et c.)
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="assetComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a full resource (including dependencies) finishes loading.
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when a single dependency (which may be the main file of a resource)
        * finishes loading.
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when an error occurs during loading. I
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="loadError", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when an error occurs during parsing.
        *
        * @eventType away3d.events.ParserEvent
        */
        //[Event(name="parseError", type="away3d.events.ParserEvent")]
        /**
        * Dispatched when a skybox asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skyboxComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a camera3d asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="cameraComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a mesh asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="meshComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a geometry asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="geometryComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a skeleton asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skeletonComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a skeleton pose asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skeletonPoseComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a container asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="containerComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a texture asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a texture projector asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureProjectorComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a material asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="materialComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a animator asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animatorComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation set has been constructed from a group of animation state resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationSetComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation state has been constructed from a group of animation node resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationStateComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation node has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationNodeComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation state transition has been constructed from a group of animation node resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="stateTransitionComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an light asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="lightComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an light picker asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="lightPickerComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an effect method asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="effectMethodComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an shadow map method asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="shadowMapMethodComplete", type="away3d.events.AssetEvent")]
        /**
        * Instances of this class are returned as tokens by loading operations
        * to provide an object on which events can be listened for in cases where
        * the actual asset loader is not directly available (e.g. when using the
        * AssetLibrary to perform the load.)
        *
        * By listening for events on this class instead of directly on the
        * AssetLibrary, one can distinguish different loads from each other.
        *
        * The token will dispatch all events that the original AssetLoader dispatches,
        * while not providing an interface to obstruct the load and is as such a
        * safer return value for loader wrappers than the loader itself.
        */
        var AssetLoaderToken = (function (_super) {
            __extends(AssetLoaderToken, _super);
            function AssetLoaderToken(loader) {
                _super.call(this);

                this._iLoader = loader;
            }
            AssetLoaderToken.prototype.addEventListener = function (type, listener, target) {
                this._iLoader.addEventListener(type, listener, target);
            };

            AssetLoaderToken.prototype.removeEventListener = function (type, listener, target) {
                this._iLoader.removeEventListener(type, listener, target);
            };

            AssetLoaderToken.prototype.hasEventListener = function (type, listener, target) {
                if (typeof listener === "undefined") { listener = null; }
                if (typeof target === "undefined") { target = null; }
                return this._iLoader.hasEventListener(type, listener, target);
            };
            return AssetLoaderToken;
        })(away.events.EventDispatcher);
        loaders.AssetLoaderToken = AssetLoaderToken;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        /**
        * <code>ParserBase</code> provides an abstract base class for objects that convert blocks of data to data structures
        * supported by Away3D.
        *
        * If used by <code>AssetLoader</code> to automatically determine the parser type, two public static methods should
        * be implemented, with the following signatures:
        *
        * <code>public static supportsType(extension : string) : boolean</code>
        * Indicates whether or not a given file extension is supported by the parser.
        *
        * <code>public static supportsData(data : *) : boolean</code>
        * Tests whether a data block can be parsed by the parser.
        *
        * Furthermore, for any concrete subtype, the method <code>initHandle</code> should be overridden to immediately
        * create the object that will contain the parsed data. This allows <code>ResourceManager</code> to return an object
        * handle regardless of whether the object was loaded or not.
        *
        * @see away3d.loading.parsers.AssetLoader
        * @see away3d.loading.ResourceManager
        */
        var ParserBase = (function (_super) {
            __extends(ParserBase, _super);
            /**
            * Creates a new ParserBase object
            * @param format The data format of the file data to be parsed. Can be either <code>ParserDataFormat.BINARY</code> or <code>ParserDataFormat.PLAIN_TEXT</code>, and should be provided by the concrete subtype.
            * @param loaderType The type of loader required by the parser
            *
            * @see away3d.loading.parsers.ParserDataFormat
            */
            function ParserBase(format, loaderType) {
                if (typeof loaderType === "undefined") { loaderType = null; }
                _super.call(this);
                this._loaderType = away.loaders.ParserLoaderType.URL_LOADER;

                if (loaderType) {
                    this._loaderType = loaderType;
                }

                this._materialMode = 0;
                this._dataFormat = format;
                this._dependencies = new Array();
            }
            ParserBase.supportsType = //----------------------------------------------------------------------------------------------------------------------------------------------------------------
            // TODO: add error checking for the following ( could cause a problem if this function is not implemented )
            //----------------------------------------------------------------------------------------------------------------------------------------------------------------
            // Needs to be implemented in all Parsers (
            //<code>public static supportsType(extension : string) : boolean</code>
            //* Indicates whether or not a given file extension is supported by the parser.
            //----------------------------------------------------------------------------------------------------------------------------------------------------------------
            function (extension) {
                throw new away.errors.AbstractMethodError();
                return false;
            };

            /**
            * Validates a bitmapData loaded before assigning to a default BitmapMaterial
            */
            ParserBase.prototype.isBitmapDataValid = function (bitmapData) {
                var isValid = away.utils.TextureUtils.isBitmapDataValid(bitmapData);

                if (!isValid) {
                    console.log(">> Bitmap loaded is not having power of 2 dimensions or is higher than 2048");
                }

                return isValid;
            };


            Object.defineProperty(ParserBase.prototype, "parsingFailure", {
                get: function () {
                    return this._parsingFailure;
                },
                set: function (b) {
                    this._parsingFailure = b;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParserBase.prototype, "parsingPaused", {
                get: function () {
                    return this._parsingPaused;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParserBase.prototype, "parsingComplete", {
                get: function () {
                    return this._parsingComplete;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParserBase.prototype, "materialMode", {
                get: function () {
                    return this._materialMode;
                },
                set: function (newMaterialMode) {
                    this._materialMode = newMaterialMode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParserBase.prototype, "loaderType", {
                get: function () {
                    return this._loaderType;
                },
                set: function (value) {
                    this._loaderType = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ParserBase.prototype, "data", {
                get: function () {
                    return this._data;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ParserBase.prototype, "dataFormat", {
                get: /**
                * The data format of the file data to be parsed. Can be either <code>ParserDataFormat.BINARY</code> or <code>ParserDataFormat.PLAIN_TEXT</code>.
                */
                function () {
                    return this._dataFormat;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Parse data (possibly containing bytearry, plain text or BitmapAsset) asynchronously, meaning that
            * the parser will periodically stop parsing so that the AVM may proceed to the
            * next frame.
            *
            * @param data The untyped data object in which the loaded data resides.
            * @param frameLimit number of milliseconds of parsing allowed per frame. The
            * actual time spent on a frame can exceed this number since time-checks can
            * only be performed between logical sections of the parsing procedure.
            */
            ParserBase.prototype.parseAsync = function (data, frameLimit) {
                if (typeof frameLimit === "undefined") { frameLimit = 30; }
                this._data = data;
                this.startParsing(frameLimit);
            };

            Object.defineProperty(ParserBase.prototype, "dependencies", {
                get: /**
                * A list of dependencies that need to be loaded and resolved for the object being parsed.
                */
                function () {
                    return this._dependencies;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Resolve a dependency when it's loaded. For example, a dependency containing an ImageResource would be assigned
            * to a Mesh instance as a BitmapMaterial, a scene graph object would be added to its intended parent. The
            * dependency should be a member of the dependencies property.
            *
            * @param resourceDependency The dependency to be resolved.
            */
            ParserBase.prototype._iResolveDependency = function (resourceDependency) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Resolve a dependency loading failure. Used by parser to eventually provide a default map
            *
            * @param resourceDependency The dependency to be resolved.
            */
            ParserBase.prototype._iResolveDependencyFailure = function (resourceDependency) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Resolve a dependency name
            *
            * @param resourceDependency The dependency to be resolved.
            */
            ParserBase.prototype._iResolveDependencyName = function (resourceDependency, asset) {
                return asset.name;
            };

            ParserBase.prototype._iResumeParsingAfterDependencies = function () {
                this._parsingPaused = false;

                if (this._timer) {
                    this._timer.start();
                }
            };

            ParserBase.prototype._pFinalizeAsset = function (asset, name) {
                if (typeof name === "undefined") { name = null; }
                var type_event;
                var type_name;

                if (name != null) {
                    asset.name = name;
                }

                switch (asset.assetType) {
                    case away.library.AssetType.LIGHT_PICKER:
                        type_name = 'lightPicker';
                        type_event = away.events.AssetEvent.LIGHTPICKER_COMPLETE;
                        break;
                    case away.library.AssetType.LIGHT:
                        type_name = 'light';
                        type_event = away.events.AssetEvent.LIGHT_COMPLETE;
                        break;
                    case away.library.AssetType.ANIMATOR:
                        type_name = 'animator';
                        type_event = away.events.AssetEvent.ANIMATOR_COMPLETE;
                        break;
                    case away.library.AssetType.ANIMATION_SET:
                        type_name = 'animationSet';
                        type_event = away.events.AssetEvent.ANIMATION_SET_COMPLETE;
                        break;
                    case away.library.AssetType.ANIMATION_STATE:
                        type_name = 'animationState';
                        type_event = away.events.AssetEvent.ANIMATION_STATE_COMPLETE;
                        break;
                    case away.library.AssetType.ANIMATION_NODE:
                        type_name = 'animationNode';
                        type_event = away.events.AssetEvent.ANIMATION_NODE_COMPLETE;
                        break;
                    case away.library.AssetType.STATE_TRANSITION:
                        type_name = 'stateTransition';
                        type_event = away.events.AssetEvent.STATE_TRANSITION_COMPLETE;
                        break;
                    case away.library.AssetType.TEXTURE:
                        type_name = 'texture';
                        type_event = away.events.AssetEvent.TEXTURE_COMPLETE;
                        break;
                    case away.library.AssetType.TEXTURE_PROJECTOR:
                        type_name = 'textureProjector';
                        type_event = away.events.AssetEvent.TEXTURE_PROJECTOR_COMPLETE;
                        break;
                    case away.library.AssetType.CONTAINER:
                        type_name = 'container';
                        type_event = away.events.AssetEvent.CONTAINER_COMPLETE;
                        break;
                    case away.library.AssetType.GEOMETRY:
                        type_name = 'geometry';
                        type_event = away.events.AssetEvent.GEOMETRY_COMPLETE;
                        break;
                    case away.library.AssetType.MATERIAL:
                        type_name = 'material';
                        type_event = away.events.AssetEvent.MATERIAL_COMPLETE;
                        break;
                    case away.library.AssetType.MESH:
                        type_name = 'mesh';
                        type_event = away.events.AssetEvent.MESH_COMPLETE;
                        break;
                    case away.library.AssetType.SKELETON:
                        type_name = 'skeleton';
                        type_event = away.events.AssetEvent.SKELETON_COMPLETE;
                        break;
                    case away.library.AssetType.SKELETON_POSE:
                        type_name = 'skelpose';
                        type_event = away.events.AssetEvent.SKELETON_POSE_COMPLETE;
                        break;
                    case away.library.AssetType.ENTITY:
                        type_name = 'entity';
                        type_event = away.events.AssetEvent.ENTITY_COMPLETE;
                        break;
                    case away.library.AssetType.SKYBOX:
                        type_name = 'skybox';
                        type_event = away.events.AssetEvent.SKYBOX_COMPLETE;
                        break;
                    case away.library.AssetType.CAMERA:
                        type_name = 'camera';
                        type_event = away.events.AssetEvent.CAMERA_COMPLETE;
                        break;
                    case away.library.AssetType.SEGMENT_SET:
                        type_name = 'segmentSet';
                        type_event = away.events.AssetEvent.SEGMENT_SET_COMPLETE;
                        break;
                    case away.library.AssetType.EFFECTS_METHOD:
                        type_name = 'effectsMethod';
                        type_event = away.events.AssetEvent.EFFECTMETHOD_COMPLETE;
                        break;
                    case away.library.AssetType.SHADOW_MAP_METHOD:
                        type_name = 'effectsMethod';
                        type_event = away.events.AssetEvent.SHADOWMAPMETHOD_COMPLETE;
                        break;
                    default:
                        throw new away.errors.Error('Unhandled asset type ' + asset.assetType + '. Report as bug!');
                        break;
                }
                ;

                if (!asset.name)
                    asset.name = type_name;

                this.dispatchEvent(new away.events.AssetEvent(away.events.AssetEvent.ASSET_COMPLETE, asset));
                this.dispatchEvent(new away.events.AssetEvent(type_event, asset));
            };

            /**
            * Parse the next block of data.
            * @return Whether or not more data needs to be parsed. Can be <code>ParserBase.ParserBase.PARSING_DONE</code> or
            * <code>ParserBase.ParserBase.MORE_TO_PARSE</code>.
            */
            ParserBase.prototype._pProceedParsing = function () {
                throw new away.errors.AbstractMethodError();
                return true;
            };

            ParserBase.prototype._pDieWithError = function (message) {
                if (typeof message === "undefined") { message = 'Unknown parsing error'; }
                if (this._timer) {
                    this._timer.removeEventListener(away.events.TimerEvent.TIMER, this._pOnInterval, this);
                    this._timer.stop();
                    this._timer = null;
                }

                this.dispatchEvent(new away.events.ParserEvent(away.events.ParserEvent.PARSE_ERROR, message));
            };

            ParserBase.prototype._pAddDependency = function (id, req, retrieveAsRawData, data, suppressErrorEvents) {
                if (typeof retrieveAsRawData === "undefined") { retrieveAsRawData = false; }
                if (typeof data === "undefined") { data = null; }
                if (typeof suppressErrorEvents === "undefined") { suppressErrorEvents = false; }
                this._dependencies.push(new away.loaders.ResourceDependency(id, req, data, this, retrieveAsRawData, suppressErrorEvents));
            };

            ParserBase.prototype._pPauseAndRetrieveDependencies = function () {
                if (this._timer) {
                    this._timer.stop();
                }

                this._parsingPaused = true;
                this.dispatchEvent(new away.events.ParserEvent(away.events.ParserEvent.READY_FOR_DEPENDENCIES));
            };

            /**
            * Tests whether or not there is still time left for parsing within the maximum allowed time frame per session.
            * @return True if there is still time left, false if the maximum allotted time was exceeded and parsing should be interrupted.
            */
            ParserBase.prototype._pHasTime = function () {
                return ((away.utils.getTimer() - this._lastFrameTime) < this._frameLimit);
            };

            /**
            * Called when the parsing pause interval has passed and parsing can proceed.
            */
            ParserBase.prototype._pOnInterval = function (event) {
                if (typeof event === "undefined") { event = null; }
                this._lastFrameTime = away.utils.getTimer();

                if (this._pProceedParsing() && !this._parsingFailure) {
                    this._pFinishParsing();
                }
            };

            /**
            * Initializes the parsing of data.
            * @param frameLimit The maximum duration of a parsing session.
            */
            ParserBase.prototype.startParsing = function (frameLimit) {
                this._frameLimit = frameLimit;
                this._timer = new away.utils.Timer(this._frameLimit, 0);
                this._timer.addEventListener(away.events.TimerEvent.TIMER, this._pOnInterval, this);
                this._timer.start();
            };

            /**
            * Finish parsing the data.
            */
            ParserBase.prototype._pFinishParsing = function () {
                if (this._timer) {
                    this._timer.removeEventListener(away.events.TimerEvent.TIMER, this._pOnInterval, this);
                    this._timer.stop();
                }

                this._timer = null;
                this._parsingComplete = true;

                this.dispatchEvent(new away.events.ParserEvent(away.events.ParserEvent.PARSE_COMPLETE));
            };

            /**
            *
            * @returns {string}
            * @private
            */
            ParserBase.prototype._pGetTextData = function () {
                return away.loaders.ParserUtil.toString(this._data);
            };

            /**
            *
            * @returns {string}
            * @private
            */
            ParserBase.prototype._pGetByteData = function () {
                return away.loaders.ParserUtil.toByteArray(this._data);
            };
            ParserBase.PARSING_DONE = true;

            ParserBase.MORE_TO_PARSE = false;
            return ParserBase;
        })(away.events.EventDispatcher);
        loaders.ParserBase = ParserBase;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    (function (library) {
        var IDUtil = (function () {
            function IDUtil() {
            }
            IDUtil.createUID = /**
            *  Generates a UID (unique identifier) based on ActionScript's
            *  pseudo-random number generator and the current time.
            *
            *  <p>The UID has the form
            *  <code>"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"</code>
            *  where X is a hexadecimal digit (0-9, A-F).</p>
            *
            *  <p>This UID will not be truly globally unique; but it is the best
            *  we can do without player support for UID generation.</p>
            *
            *  @return The newly-generated UID.
            *
            *  @langversion 3.0
            *  @playerversion Flash 9
            *  @playerversion AIR 1.1
            *  @productversion Flex 3
            */
            function () {
                var uid = new Array(36);
                var index = 0;

                var i;
                var j;

                for (i = 0; i < 8; i++)
                    uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];

                for (i = 0; i < 3; i++) {
                    uid[index++] = 45;

                    for (j = 0; j < 4; j++)
                        uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];
                }

                uid[index++] = 45;

                var time = new Date().getTime();

                // Note: time is the number of milliseconds since 1970,
                // which is currently more than one trillion.
                // We use the low 8 hex digits of this number in the UID.
                // Just in case the system clock has been reset to
                // Jan 1-4, 1970 (in which case this number could have only
                // 1-7 hex digits), we pad on the left with 7 zeros
                // before taking the low digits.
                var timeString = ("0000000" + time.toString(16).toUpperCase()).substr(-8);

                for (i = 0; i < 8; i++)
                    uid[index++] = timeString.charCodeAt(i);

                for (i = 0; i < 4; i++)
                    uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];

                return String.fromCharCode.apply(null, uid);
            };
            IDUtil.ALPHA_CHAR_CODES = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70];
            return IDUtil;
        })();
        library.IDUtil = IDUtil;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        var LoaderEvent = (function (_super) {
            __extends(LoaderEvent, _super);
            /**
            * Create a new LoaderEvent object.
            * @param type The event type.
            * @param resource The loaded or parsed resource.
            * @param url The url of the loaded resource.
            */
            function LoaderEvent(type, url, assets, isDependency, errmsg) {
                if (typeof url === "undefined") { url = null; }
                if (typeof assets === "undefined") { assets = null; }
                if (typeof isDependency === "undefined") { isDependency = false; }
                if (typeof errmsg === "undefined") { errmsg = null; }
                _super.call(this, type);

                this._url = url;
                this._assets = assets;
                this._message = errmsg;
                this._isDependency = isDependency;
            }
            Object.defineProperty(LoaderEvent.prototype, "url", {
                get: /**
                * The url of the loaded resource.
                */
                function () {
                    return this._url;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LoaderEvent.prototype, "assets", {
                get: /**
                * The error string on loadError.
                */
                function () {
                    return this._assets;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LoaderEvent.prototype, "message", {
                get: /**
                * The error string on loadError.
                */
                function () {
                    return this._message;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LoaderEvent.prototype, "isDependency", {
                get: /**
                * Indicates whether the event occurred while loading a dependency, as opposed
                * to the base file. Dependencies can be textures or other files that are
                * referenced by the base file.
                */
                function () {
                    return this._isDependency;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the current event.
            * @return An exact duplicate of the current event.
            */
            LoaderEvent.prototype.clone = function () {
                return new LoaderEvent(this.type, this._url, this._assets, this._isDependency, this._message);
            };
            LoaderEvent.LOAD_ERROR = "loadError";

            LoaderEvent.RESOURCE_COMPLETE = "resourceComplete";

            LoaderEvent.DEPENDENCY_COMPLETE = "dependencyComplete";
            return LoaderEvent;
        })(away.events.Event);
        events.LoaderEvent = LoaderEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (library) {
        /**
        * AssetLibrary enforces a singleton pattern and is not intended to be instanced.
        * It's purpose is to allow access to the default library bundle through a set of static shortcut methods.
        * If you are interested in creating multiple library bundles, please use the <code>getBundle()</code> method.
        */
        var AssetLibrary = (function () {
            /**
            * Creates a new <code>AssetLibrary</code> object.
            *
            * @param se A singleton enforcer for the AssetLibrary ensuring it cannnot be instanced.
            */
            //*
            function AssetLibrary(se) {
                se = se;
            }
            AssetLibrary.getBundle = //*/
            /**
            * Returns an AssetLibrary bundle instance. If no key is given, returns the default bundle (which is
            * similar to using the AssetLibraryBundle as a singleton). To keep several separated library bundles,
            * pass a string key to this method to define which bundle should be returned. This is
            * referred to as using the AssetLibraryBundle as a multiton.
            *
            * @param key Defines which multiton instance should be returned.
            * @return An instance of the asset library
            */
            function (key) {
                if (typeof key === "undefined") { key = 'default'; }
                return away.library.AssetLibraryBundle.getInstance(key);
            };

            AssetLibrary.enableParser = /**
            *
            */
            function (parserClass) {
                away.loaders.SingleFileLoader.enableParser(parserClass);
            };

            AssetLibrary.enableParsers = /**
            *
            */
            function (parserClasses) {
                away.loaders.SingleFileLoader.enableParsers(parserClasses);
            };

            Object.defineProperty(AssetLibrary, "conflictStrategy", {
                get: /**
                * Short-hand for conflictStrategy property on default asset library bundle.
                *
                * @see away3d.library.AssetLibraryBundle.conflictStrategy
                */
                function () {
                    return away.library.AssetLibrary.getBundle().conflictStrategy;
                },
                set: function (val) {
                    away.library.AssetLibrary.getBundle().conflictStrategy = val;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AssetLibrary, "conflictPrecedence", {
                get: /**
                * Short-hand for conflictPrecedence property on default asset library bundle.
                *
                * @see away3d.library.AssetLibraryBundle.conflictPrecedence
                */
                function () {
                    return away.library.AssetLibrary.getBundle().conflictPrecedence;
                },
                set: function (val) {
                    away.library.AssetLibrary.getBundle().conflictPrecedence = val;
                },
                enumerable: true,
                configurable: true
            });


            AssetLibrary.createIterator = /**
            * Short-hand for createIterator() method on default asset library bundle.
            *
            * @see away3d.library.AssetLibraryBundle.createIterator()
            */
            function (assetTypeFilter, namespaceFilter, filterFunc) {
                if (typeof assetTypeFilter === "undefined") { assetTypeFilter = null; }
                if (typeof namespaceFilter === "undefined") { namespaceFilter = null; }
                if (typeof filterFunc === "undefined") { filterFunc = null; }
                return away.library.AssetLibrary.getBundle().createIterator(assetTypeFilter, namespaceFilter, filterFunc);
            };

            AssetLibrary.load = /**
            * Short-hand for load() method on default asset library bundle.
            *
            * @see away3d.library.AssetLibraryBundle.load()
            */
            function (req, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                return away.library.AssetLibrary.getBundle().load(req, context, ns, parser);
            };

            AssetLibrary.loadData = /**
            * Short-hand for loadData() method on default asset library bundle.
            *
            * @see away3d.library.AssetLibraryBundle.loadData()
            */
            function (data, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                return away.library.AssetLibrary.getBundle().loadData(data, context, ns, parser);
            };

            AssetLibrary.stopLoad = function () {
                away.library.AssetLibrary.getBundle().stopAllLoadingSessions();
            };

            AssetLibrary.getAsset = /**
            * Short-hand for getAsset() method on default asset library bundle.
            *
            * @see away3d.library.AssetLibraryBundle.getAsset()
            */
            function (name, ns) {
                if (typeof ns === "undefined") { ns = null; }
                return away.library.AssetLibrary.getBundle().getAsset(name, ns);
            };

            AssetLibrary.addEventListener = /**
            * Short-hand for addEventListener() method on default asset library bundle.
            */
            function (type, listener, target) {
                away.library.AssetLibrary.getBundle().addEventListener(type, listener, target);
            };

            AssetLibrary.removeEventListener = /**
            * Short-hand for removeEventListener() method on default asset library bundle.
            */
            function (type, listener, target) {
                away.library.AssetLibrary.getBundle().removeEventListener(type, listener, target);
            };

            AssetLibrary.addAsset = /**
            * Short-hand for hasEventListener() method on default asset library bundle.
            
            public static hasEventListener(type:string):boolean
            {
            return away.library.AssetLibrary.getBundle().hasEventListener(type);
            }
            
            public static willTrigger(type:string):boolean
            {
            return getBundle().willTrigger(type);
            }
            */
            /**
            * Short-hand for addAsset() method on default asset library bundle.
            *
            * @see away3d.library.AssetLibraryBundle.addAsset()
            */
            function (asset) {
                away.library.AssetLibrary.getBundle().addAsset(asset);
            };

            AssetLibrary.removeAsset = /**
            * Short-hand for removeAsset() method on default asset library bundle.
            *
            * @param asset The asset which should be removed from the library.
            * @param dispose Defines whether the assets should also be disposed.
            *
            * @see away3d.library.AssetLibraryBundle.removeAsset()
            */
            function (asset, dispose) {
                if (typeof dispose === "undefined") { dispose = true; }
                away.library.AssetLibrary.getBundle().removeAsset(asset, dispose);
            };

            AssetLibrary.removeAssetByName = /**
            * Short-hand for removeAssetByName() method on default asset library bundle.
            *
            * @param name The name of the asset to be removed.
            * @param ns The namespace to which the desired asset belongs.
            * @param dispose Defines whether the assets should also be disposed.
            *
            * @see away3d.library.AssetLibraryBundle.removeAssetByName()
            */
            function (name, ns, dispose) {
                if (typeof ns === "undefined") { ns = null; }
                if (typeof dispose === "undefined") { dispose = true; }
                return away.library.AssetLibrary.getBundle().removeAssetByName(name, ns, dispose);
            };

            AssetLibrary.removeAllAssets = /**
            * Short-hand for removeAllAssets() method on default asset library bundle.
            *
            * @param dispose Defines whether the assets should also be disposed.
            *
            * @see away3d.library.AssetLibraryBundle.removeAllAssets()
            */
            function (dispose) {
                if (typeof dispose === "undefined") { dispose = true; }
                away.library.AssetLibrary.getBundle().removeAllAssets(dispose);
            };

            AssetLibrary.removeNamespaceAssets = /**
            * Short-hand for removeNamespaceAssets() method on default asset library bundle.
            *
            * @see away3d.library.AssetLibraryBundle.removeNamespaceAssets()
            */
            function (ns, dispose) {
                if (typeof ns === "undefined") { ns = null; }
                if (typeof dispose === "undefined") { dispose = true; }
                away.library.AssetLibrary.getBundle().removeNamespaceAssets(ns, dispose);
            };
            AssetLibrary._iInstances = {};
            return AssetLibrary;
        })();
        library.AssetLibrary = AssetLibrary;
    })(away.library || (away.library = {}));
    var library = away.library;
})(away || (away = {}));

// singleton enforcer
var AssetLibrarySingletonEnforcer = (function () {
    function AssetLibrarySingletonEnforcer() {
    }
    return AssetLibrarySingletonEnforcer;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (loaders) {
        /**
        * Dispatched when any asset finishes parsing. Also see specific events for each
        * individual asset type (meshes, materials et c.)
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="assetComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a full resource (including dependencies) finishes loading.
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when a single dependency (which may be the main file of a resource)
        * finishes loading.
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when an error occurs during loading. I
        *
        * @eventType away3d.events.LoaderEvent
        */
        //[Event(name="loadError", type="away3d.events.LoaderEvent")]
        /**
        * Dispatched when an error occurs during parsing.
        *
        * @eventType away3d.events.ParserEvent
        */
        //[Event(name="parseError", type="away3d.events.ParserEvent")]
        /**
        * Dispatched when a skybox asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skyboxComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a camera3d asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="cameraComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a mesh asset has been costructed from a ressource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="meshComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a geometry asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="geometryComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a skeleton asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skeletonComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a skeleton pose asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="skeletonPoseComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a container asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="containerComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a texture asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a texture projector asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureProjectorComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a material asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="materialComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when a animator asset has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animatorComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation set has been constructed from a group of animation state resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationSetComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation state has been constructed from a group of animation node resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationStateComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation node has been constructed from a resource.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="animationNodeComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an animation state transition has been constructed from a group of animation node resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="stateTransitionComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an light asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="lightComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an light picker asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="lightPickerComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an effect method asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="effectMethodComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an shadow map method asset has been constructed from a resources.
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="shadowMapMethodComplete", type="away3d.events.AssetEvent")]
        /**
        * Dispatched when an image asset dimensions are not a power of 2
        *
        * @eventType away3d.events.AssetEvent
        */
        //[Event(name="textureSizeError", type="away3d.events.AssetEvent")]
        /**
        * Loader3D can load any file format that Away3D supports (or for which a third-party parser
        * has been plugged in) and be added directly to the scene. As assets are encountered
        * they are added to the Loader3D container. Assets that can not be displayed in the scene
        * graph (e.g. unused bitmaps/materials/skeletons etc) will be ignored.
        *
        * This provides a fast and easy way to load models (no need for event listeners) but is not
        * very versatile since many types of assets are ignored.
        *
        * Loader3D by default uses the AssetLibrary to load all assets, which means that they also
        * ends up in the library. To circumvent this, Loader3D can be configured to not use the
        * AssetLibrary in which case it will use the AssetLoader directly.
        *
        * @see away3d.loaders.AssetLoader
        * @see away3d.library.AssetLibrary
        */
        var Loader3D = (function (_super) {
            __extends(Loader3D, _super);
            function Loader3D(useAssetLibrary, assetLibraryId) {
                if (typeof useAssetLibrary === "undefined") { useAssetLibrary = true; }
                if (typeof assetLibraryId === "undefined") { assetLibraryId = null; }
                _super.call(this);

                this._loadingSessions = new Array();
                this._useAssetLib = useAssetLibrary;
                this._assetLibId = assetLibraryId;
            }
            /**
            * Loads a file and (optionally) all of its dependencies.
            *
            * @param req The URLRequest object containing the URL of the file to be loaded.
            * @param context An optional context object providing additional parameters for loading
            * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
            * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            Loader3D.prototype.load = function (req, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                var token;

                if (this._useAssetLib) {
                    var lib;
                    lib = away.library.AssetLibraryBundle.getInstance(this._assetLibId);
                    token = lib.load(req, context, ns, parser);
                } else {
                    var loader = new away.loaders.AssetLoader();
                    this._loadingSessions.push(loader);
                    token = loader.load(req, context, ns, parser);
                }

                token.addEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this.onResourceRetrieved, this);
                token.addEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);

                // Error are handled separately (see documentation for addErrorHandler)
                token._iLoader._iAddErrorHandler(this.onDependencyRetrievingError);
                token._iLoader._iAddParseErrorHandler(this.onDependencyRetrievingParseError);

                return token;
            };

            /**
            * Loads a resource from already loaded data.
            *
            * @param data The data object containing all resource information.
            * @param context An optional context object providing additional parameters for loading
            * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
            * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            Loader3D.prototype.loadData = function (data, context, ns, parser) {
                if (typeof context === "undefined") { context = null; }
                if (typeof ns === "undefined") { ns = null; }
                if (typeof parser === "undefined") { parser = null; }
                var token;

                if (this._useAssetLib) {
                    var lib;
                    lib = away.library.AssetLibraryBundle.getInstance(this._assetLibId);
                    token = lib.loadData(data, context, ns, parser);
                } else {
                    var loader = new away.loaders.AssetLoader();
                    this._loadingSessions.push(loader);
                    token = loader.loadData(data, '', context, ns, parser);
                }

                token.addEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this.onResourceRetrieved, this);
                token.addEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                token.addEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);

                // Error are handled separately (see documentation for addErrorHandler)
                token._iLoader._iAddErrorHandler(this.onDependencyRetrievingError);
                token._iLoader._iAddParseErrorHandler(this.onDependencyRetrievingParseError);

                return token;
            };

            /**
            * Stop the current loading/parsing process.
            */
            Loader3D.prototype.stopLoad = function () {
                if (this._useAssetLib) {
                    var lib;
                    lib = away.library.AssetLibraryBundle.getInstance(this._assetLibId);
                    lib.stopAllLoadingSessions();
                    this._loadingSessions = null;
                    return;
                }
                var i/*int*/ ;
                var length = this._loadingSessions.length;
                for (i = 0; i < length; i++) {
                    this.removeListeners(this._loadingSessions[i]);
                    this._loadingSessions[i].stop();
                    this._loadingSessions[i] = null;
                }
                this._loadingSessions = null;
            };

            Loader3D.enableParser = /**
            * Enables a specific parser.
            * When no specific parser is set for a loading/parsing opperation,
            * loader3d can autoselect the correct parser to use.
            * A parser must have been enabled, to be considered when autoselecting the parser.
            *
            * @param parserClass The parser class to enable.
            * @see away3d.loaders.parsers.Parsers
            */
            function (parserClass) {
                away.loaders.SingleFileLoader.enableParser(parserClass);
            };

            Loader3D.enableParsers = /**
            * Enables a list of parsers.
            * When no specific parser is set for a loading/parsing opperation,
            * loader3d can autoselect the correct parser to use.
            * A parser must have been enabled, to be considered when autoselecting the parser.
            *
            * @param parserClasses A Vector of parser classes to enable.
            * @see away3d.loaders.parsers.Parsers
            */
            function (parserClasses) {
                away.loaders.SingleFileLoader.enableParsers(parserClasses);
            };

            Loader3D.prototype.removeListeners = function (dispatcher) {
                dispatcher.removeEventListener(away.events.LoaderEvent.RESOURCE_COMPLETE, this.onResourceRetrieved, this);
                dispatcher.removeEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                dispatcher.removeEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);
            };

            Loader3D.prototype.onAssetComplete = function (ev) {
                if (ev.type == away.events.AssetEvent.ASSET_COMPLETE) {
                    // TODO: not used
                    // var type : string = ev.asset.assetType;
                    var obj;
                    switch (ev.asset.assetType) {
                        case away.library.AssetType.LIGHT:
                            obj = ev.asset;
                            break;
                        case away.library.AssetType.CONTAINER:
                            obj = ev.asset;
                            break;
                        case away.library.AssetType.MESH:
                            obj = ev.asset;
                            break;

                            break;

                            break;
                        case away.library.AssetType.CAMERA:
                            obj = ev.asset;
                            break;
                        case away.library.AssetType.SEGMENT_SET:
                            obj = ev.asset;
                            break;
                    }

                    if (obj && obj.parent == null)
                        this.addChild(obj);
                }

                this.dispatchEvent(ev.clone());
            };

            /**
            * Called when a an error occurs during dependency retrieving.
            */
            Loader3D.prototype.onDependencyRetrievingError = function (event) {
                if (this.hasEventListener(away.events.LoaderEvent.LOAD_ERROR, this.onDependencyRetrievingError, this)) {
                    this.dispatchEvent(event);
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Called when a an error occurs during parsing.
            */
            Loader3D.prototype.onDependencyRetrievingParseError = function (event) {
                if (this.hasEventListener(away.events.ParserEvent.PARSE_ERROR, this.onDependencyRetrievingParseError, this)) {
                    this.dispatchEvent(event);
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Called when the resource and all of its dependencies was retrieved.
            */
            Loader3D.prototype.onResourceRetrieved = function (event) {
                var loader = event.target;

                this.dispatchEvent(event.clone());
            };
            return Loader3D;
        })(away.containers.ObjectContainer3D);
        loaders.Loader3D = Loader3D;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (net) {
        // TODO: implement / test cross domain policy
        var IMGLoader = (function (_super) {
            __extends(IMGLoader, _super);
            function IMGLoader(imageName) {
                if (typeof imageName === "undefined") { imageName = ''; }
                _super.call(this);
                this._name = '';
                this._loaded = false;
                this._name = imageName;
                this.initImage();
            }
            // Public
            /**
            * load an image
            * @param request {away.net.URLRequest}
            */
            IMGLoader.prototype.load = function (request) {
                this._loaded = false;
                this._request = request;

                if (this._crossOrigin) {
                    if (this._image['crossOrigin'] != null) {
                        this._image['crossOrigin'] = this._crossOrigin;
                    }
                }

                this._image.src = this._request.url;
            };

            /**
            *
            */
            IMGLoader.prototype.dispose = function () {
                if (this._image) {
                    this._image.onabort = null;
                    this._image.onerror = null;
                    this._image.onload = null;
                    this._image = null;
                }

                if (this._request) {
                    this._request = null;
                }
            };

            Object.defineProperty(IMGLoader.prototype, "image", {
                get: // Get / Set
                /**
                * Get reference to image if it is loaded
                * @returns {HTMLImageElement}
                */
                function () {
                    return this._image;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(IMGLoader.prototype, "loaded", {
                get: /**
                * Get image width. Returns null is image is not loaded
                * @returns {number}
                */
                function () {
                    return this._loaded;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(IMGLoader.prototype, "crossOrigin", {
                get: function () {
                    return this._crossOrigin;
                },
                set: function (value) {
                    this._crossOrigin = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(IMGLoader.prototype, "width", {
                get: /**
                * Get image width. Returns null is image is not loaded
                * @returns {number}
                */
                function () {
                    if (this._image) {
                        return this._image.width;
                    }

                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(IMGLoader.prototype, "height", {
                get: /**
                * Get image height. Returns null is image is not loaded
                * @returns {number}
                */
                function () {
                    if (this._image) {
                        return this._image.height;
                    }

                    return null;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(IMGLoader.prototype, "request", {
                get: /**
                * return URL request used to load image
                * @returns {away.net.URLRequest}
                */
                function () {
                    return this._request;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(IMGLoader.prototype, "name", {
                get: /**
                * get name of HTMLImageElement
                * @returns {string}
                */
                function () {
                    if (this._image) {
                        return this._image.name;
                    }

                    return this._name;
                },
                set: /**
                * set name of HTMLImageElement
                * @returns {string}
                */
                function (value) {
                    if (this._image) {
                        this._image.name = value;
                    }

                    this._name = value;
                },
                enumerable: true,
                configurable: true
            });


            // Private
            /**
            * intialise the image object
            */
            IMGLoader.prototype.initImage = function () {
                var _this = this;
                if (!this._image) {
                    this._image = new Image();
                    this._image.onabort = function (event) {
                        return _this.onAbort(event);
                    };
                    this._image.onerror = function (event) {
                        return _this.onError(event);
                    };
                    this._image.onload = function (event) {
                        return _this.onLoadComplete(event);
                    };
                    this._image.name = this._name;
                }
            };

            // Image - event handlers
            /**
            * Loading of an image is interrupted
            * @param event
            */
            IMGLoader.prototype.onAbort = function (event) {
                this.dispatchEvent(new away.events.Event(away.events.IOErrorEvent.IO_ERROR));
            };

            /**
            * An error occured when loading the image
            * @param event
            */
            IMGLoader.prototype.onError = function (event) {
                this.dispatchEvent(new away.events.Event(away.events.IOErrorEvent.IO_ERROR));
            };

            /**
            * image is finished loading
            * @param event
            */
            IMGLoader.prototype.onLoadComplete = function (event) {
                this._loaded = true;
                this.dispatchEvent(new away.events.Event(away.events.Event.COMPLETE));
            };
            return IMGLoader;
        })(away.events.EventDispatcher);
        net.IMGLoader = IMGLoader;
    })(away.net || (away.net = {}));
    var net = away.net;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        var IOErrorEvent = (function (_super) {
            __extends(IOErrorEvent, _super);
            function IOErrorEvent(type) {
                _super.call(this, type);
            }
            IOErrorEvent.IO_ERROR = "IOErrorEvent_IO_ERROR";
            return IOErrorEvent;
        })(away.events.Event);
        events.IOErrorEvent = IOErrorEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (events) {
        /**
        * @class away.events.HTTPStatusEvent
        */
        var HTTPStatusEvent = (function (_super) {
            __extends(HTTPStatusEvent, _super);
            function HTTPStatusEvent(type, status) {
                if (typeof status === "undefined") { status = null; }
                _super.call(this, type);

                this.status = status;
            }
            HTTPStatusEvent.HTTP_STATUS = "HTTPStatusEvent_HTTP_STATUS";
            return HTTPStatusEvent;
        })(away.events.Event);
        events.HTTPStatusEvent = HTTPStatusEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        var ProgressEvent = (function (_super) {
            __extends(ProgressEvent, _super);
            function ProgressEvent(type) {
                _super.call(this, type);
            }
            ProgressEvent.PROGRESS = "ProgressEvent_progress";
            return ProgressEvent;
        })(away.events.Event);
        events.ProgressEvent = ProgressEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (net) {
        var URLLoaderDataFormat = (function () {
            function URLLoaderDataFormat() {
            }
            URLLoaderDataFormat.TEXT = 'text';

            URLLoaderDataFormat.VARIABLES = 'variables';

            URLLoaderDataFormat.BLOB = 'blob';

            URLLoaderDataFormat.ARRAY_BUFFER = 'arraybuffer';

            URLLoaderDataFormat.BINARY = 'binary';
            return URLLoaderDataFormat;
        })();
        net.URLLoaderDataFormat = URLLoaderDataFormat;
    })(away.net || (away.net = {}));
    var net = away.net;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (net) {
        var URLRequestMethod = (function () {
            function URLRequestMethod() {
            }
            URLRequestMethod.POST = 'POST';

            URLRequestMethod.GET = 'GET';
            return URLRequestMethod;
        })();
        net.URLRequestMethod = URLRequestMethod;
    })(away.net || (away.net = {}));
    var net = away.net;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (net) {
        // TODO: implement / test cross domain policy
        var URLLoader = (function (_super) {
            __extends(URLLoader, _super);
            function URLLoader() {
                _super.call(this);
                this._bytesLoaded = 0;
                this._bytesTotal = 0;
                this._dataFormat = away.net.URLLoaderDataFormat.TEXT;
                this._loadError = false;
            }
            // Public
            /**
            *
            * @param request {away.net.URLRequest}
            */
            URLLoader.prototype.load = function (request) {
                this.initXHR();
                this._request = request;

                if (request.method === away.net.URLRequestMethod.POST) {
                    this.postRequest(request);
                } else {
                    this.getRequest(request);
                }
            };

            /**
            *
            */
            URLLoader.prototype.close = function () {
                this._XHR.abort();
                this.disposeXHR();
            };

            /**
            *
            */
            URLLoader.prototype.dispose = function () {
                if (this._XHR) {
                    this._XHR.abort();
                }

                this.disposeXHR();

                this._data = null;
                this._dataFormat = null;
                this._bytesLoaded = null;
                this._bytesTotal = null;

                /*
                if( this._request )
                {
                
                this._request.dispose();
                
                }
                */
                this._request = null;
            };


            Object.defineProperty(URLLoader.prototype, "dataFormat", {
                get: /**
                *
                * @returns {string}
                *      away.net.URLLoaderDataFormat
                */
                function () {
                    return this._dataFormat;
                },
                set: // Get / Set
                /**
                *
                * away.net.URLLoaderDataFormat.BINARY
                * away.net.URLLoaderDataFormat.TEXT
                * away.net.URLLoaderDataFormat.VARIABLES
                *
                * @param format
                */
                function (format) {
                    if (format === away.net.URLLoaderDataFormat.BLOB || format === away.net.URLLoaderDataFormat.ARRAY_BUFFER || format === away.net.URLLoaderDataFormat.BINARY || format === away.net.URLLoaderDataFormat.TEXT || format === away.net.URLLoaderDataFormat.VARIABLES) {
                        this._dataFormat = format;
                    } else {
                        throw new away.errors.Error('URLLoader error: incompatible dataFormat');
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URLLoader.prototype, "data", {
                get: /**
                *
                * @returns {*}
                */
                function () {
                    return this._data;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URLLoader.prototype, "bytesLoaded", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._bytesLoaded;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URLLoader.prototype, "bytesTotal", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._bytesTotal;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URLLoader.prototype, "request", {
                get: /**
                *
                * @returns {away.net.URLRequest}
                */
                function () {
                    return this._request;
                },
                enumerable: true,
                configurable: true
            });

            // Private
            /**
            *
            * @param xhr
            * @param responseType
            */
            URLLoader.prototype.setResponseType = function (xhr, responseType) {
                switch (responseType) {
                    case away.net.URLLoaderDataFormat.ARRAY_BUFFER:
                    case away.net.URLLoaderDataFormat.BLOB:
                    case away.net.URLLoaderDataFormat.TEXT:
                        xhr.responseType = responseType;

                        break;

                    case away.net.URLLoaderDataFormat.VARIABLES:
                        xhr.responseType = away.net.URLLoaderDataFormat.TEXT;

                        break;

                    case away.net.URLLoaderDataFormat.BINARY:
                        xhr.responseType = '';

                        break;
                }
            };

            /**
            *
            * @param request {away.net.URLRequest}
            */
            URLLoader.prototype.getRequest = function (request) {
                try  {
                    this._XHR.open(request.method, request.url, request.async);
                    this.setResponseType(this._XHR, this._dataFormat);
                    this._XHR.send();
                } catch (e) {
                    this.handleXmlHttpRequestException(e);
                }
            };

            /**
            *
            * @param request {away.net.URLRequest}
            */
            URLLoader.prototype.postRequest = function (request) {
                this._loadError = false;

                this._XHR.open(request.method, request.url, request.async);

                if (request.data != null) {
                    if (request.data instanceof away.net.URLVariables) {
                        var urlVars = request.data;

                        try  {
                            this._XHR.responseType = 'text';
                            this._XHR.send(urlVars.formData);
                        } catch (e) {
                            this.handleXmlHttpRequestException(e);
                        }
                    } else {
                        this.setResponseType(this._XHR, this._dataFormat);

                        if (request.data) {
                            this._XHR.send(request.data);
                        } else {
                            this._XHR.send();
                        }
                    }
                } else {
                    this._XHR.send();
                }
            };

            /**
            *
            * @param error {XMLHttpRequestException}
            */
            URLLoader.prototype.handleXmlHttpRequestException = function (error/* <XMLHttpRequestException> */ ) {
                switch (error.code) {
                    case 101:
                        break;
                }
            };

            /**
            *
            */
            URLLoader.prototype.initXHR = function () {
                var _this = this;
                if (!this._XHR) {
                    this._XHR = new XMLHttpRequest();

                    this._XHR.onloadstart = function (event) {
                        return _this.onLoadStart(event);
                    };
                    this._XHR.onprogress = function (event) {
                        return _this.onProgress(event);
                    };
                    this._XHR.onabort = function (event) {
                        return _this.onAbort(event);
                    };
                    this._XHR.onerror = function (event) {
                        return _this.onLoadError(event);
                    };
                    this._XHR.onload = function (event) {
                        return _this.onLoadComplete(event);
                    };
                    this._XHR.ontimeout = function (event) {
                        return _this.onTimeOut(event);
                    };
                    this._XHR.onloadend = function (event) {
                        return _this.onLoadEnd(event);
                    };
                    this._XHR.onreadystatechange = function (event) {
                        return _this.onReadyStateChange(event);
                    };
                }
            };

            /**
            *
            */
            URLLoader.prototype.disposeXHR = function () {
                if (this._XHR !== null) {
                    this._XHR.onloadstart = null;
                    this._XHR.onprogress = null;
                    this._XHR.onabort = null;
                    this._XHR.onerror = null;
                    this._XHR.onload = null;
                    this._XHR.ontimeout = null;
                    this._XHR.onloadend = null;
                    this._XHR = null;
                }
            };

            /**
            *
            * @param source
            */
            URLLoader.prototype.decodeURLVariables = function (source) {
                var result = new Object();

                source = source.split("+").join(" ");

                var tokens, re = /[?&]?([^=]+)=([^&]*)/g;

                while (tokens = re.exec(source)) {
                    result[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
                }

                return result;
            };

            // XMLHttpRequest - Event Handlers
            /**
            * When XHR state changes
            * @param event
            */
            URLLoader.prototype.onReadyStateChange = function (event) {
                if (this._XHR.readyState == 4) {
                    if (this._XHR.status == 404) {
                        this._loadError = true;
                        this.dispatchEvent(new away.events.IOErrorEvent(away.events.IOErrorEvent.IO_ERROR));
                    }

                    this.dispatchEvent(new away.events.HTTPStatusEvent(away.events.HTTPStatusEvent.HTTP_STATUS, this._XHR.status));
                }
            };

            /**
            * When the request has completed, regardless of whether or not it was successful.
            * @param event
            */
            URLLoader.prototype.onLoadEnd = function (event) {
                if (this._loadError === true)
                    return;
            };

            /**
            * When the author specified timeout has passed before the request could complete.
            * @param event
            */
            URLLoader.prototype.onTimeOut = function (event) {
                //TODO: Timeout not currently implemented ( also not part of AS3 API )
            };

            /**
            * When the request has been aborted, either by invoking the abort() method or navigating away from the page.
            * @param event
            */
            URLLoader.prototype.onAbort = function (event) {
                // TODO: investigate whether this needs to be an IOError
            };

            /**
            * While loading and sending data.
            * @param event
            */
            URLLoader.prototype.onProgress = function (event) {
                this._bytesTotal = event.total;
                this._bytesLoaded = event.loaded;

                var progressEvent = new away.events.ProgressEvent(away.events.ProgressEvent.PROGRESS);
                progressEvent.bytesLoaded = this._bytesLoaded;
                progressEvent.bytesTotal = this._bytesTotal;
                this.dispatchEvent(progressEvent);
            };

            /**
            * When the request starts.
            * @param event
            */
            URLLoader.prototype.onLoadStart = function (event) {
                this.dispatchEvent(new away.events.Event(away.events.Event.OPEN));
            };

            /**
            * When the request has successfully completed.
            * @param event
            */
            URLLoader.prototype.onLoadComplete = function (event) {
                if (this._loadError === true)
                    return;

                switch (this._dataFormat) {
                    case away.net.URLLoaderDataFormat.TEXT:
                        this._data = this._XHR.responseText;

                        break;

                    case away.net.URLLoaderDataFormat.VARIABLES:
                        this._data = this.decodeURLVariables(this._XHR.responseText);

                        break;

                    case away.net.URLLoaderDataFormat.BLOB:
                    case away.net.URLLoaderDataFormat.ARRAY_BUFFER:
                    case away.net.URLLoaderDataFormat.BINARY:
                        this._data = this._XHR.response;

                        break;

                    default:
                        this._data = this._XHR.responseText;

                        break;
                }

                this.dispatchEvent(new away.events.Event(away.events.Event.COMPLETE));
            };

            /**
            * When the request has failed. ( due to network issues ).
            * @param event
            */
            URLLoader.prototype.onLoadError = function (event) {
                this._loadError = true;
                this.dispatchEvent(new away.events.IOErrorEvent(away.events.IOErrorEvent.IO_ERROR));
            };
            return URLLoader;
        })(away.events.EventDispatcher);
        net.URLLoader = URLLoader;
    })(away.net || (away.net = {}));
    var net = away.net;
})(away || (away = {}));
var away;
(function (away) {
    (function (loaders) {
        /**
        * An enumeration providing values to describe the data format of parsed data.
        */
        var ParserDataFormat = (function () {
            function ParserDataFormat() {
            }
            ParserDataFormat.BINARY = "binary";

            ParserDataFormat.PLAIN_TEXT = "plainText";

            ParserDataFormat.IMAGE = "image";
            return ParserDataFormat;
        })();
        loaders.ParserDataFormat = ParserDataFormat;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        /**
        * ImageParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
        * a loader object, it wraps it in a BitmapDataResource so resource management can happen consistently without
        * exception cases.
        */
        var ImageParser = (function (_super) {
            __extends(ImageParser, _super);
            //private var _loader           : Loader;
            /**
            * Creates a new ImageParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function ImageParser() {
                _super.call(this, away.loaders.ParserDataFormat.IMAGE, away.loaders.ParserLoaderType.IMG_LOADER);
            }
            ImageParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "jpg" || extension == "jpeg" || extension == "png" || extension == "gif";
            };

            ImageParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                if (data instanceof HTMLImageElement)
                    return true;

                if (!(data instanceof away.utils.ByteArray))
                    return false;

                var ba = data;
                ba.position = 0;

                if (ba.readUnsignedShort() == 0xffd8)
                    return true;

                ba.position = 0;
                if (ba.readShort() == 0x424D)
                    return true;

                ba.position = 1;
                if (ba.readUTFBytes(3) == 'PNG')
                    return true;

                ba.position = 0;
                if (ba.readUTFBytes(3) == 'GIF' && ba.readShort() == 0x3839 && ba.readByte() == 0x61)
                    return true;

                ba.position = 0;
                if (ba.readUTFBytes(3) == 'ATF')
                    return true;

                return false;
            };

            /**
            * @inheritDoc
            */
            ImageParser.prototype._pProceedParsing = function () {
                var asset;
                var sizeError = false;

                if (this.data instanceof HTMLImageElement) {
                    if (away.utils.TextureUtils.isHTMLImageElementValid(this.data)) {
                        asset = new away.textures.HTMLImageElementTexture(this.data, false);
                        this._pFinalizeAsset(asset, this._iFileName);
                    } else {
                        sizeError = true;
                    }
                } else if (this.data instanceof away.utils.ByteArray) {
                    var ba = this.data;
                    ba.position = 0;
                    var htmlImageElement = away.loaders.ParserUtil.byteArrayToImage(this.data);

                    if (away.utils.TextureUtils.isHTMLImageElementValid(htmlImageElement)) {
                        asset = new away.textures.HTMLImageElementTexture(htmlImageElement, false);
                        this._pFinalizeAsset(asset, this._iFileName);
                    } else {
                        sizeError = true;
                    }
                }

                if (sizeError == true) {
                    asset = new away.textures.BitmapTexture(away.materials.DefaultMaterialManager.createCheckeredBitmapData(), false);
                    this._pFinalizeAsset(asset, this._iFileName);
                    this.dispatchEvent(new away.events.AssetEvent(away.events.AssetEvent.TEXTURE_SIZE_ERROR, asset));
                }

                return away.loaders.ParserBase.PARSING_DONE;
            };
            return ImageParser;
        })(away.loaders.ParserBase);
        loaders.ImageParser = ImageParser;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        /**
        * The SingleFileLoader is used to load a single file, as part of a resource.
        *
        * While SingleFileLoader can be used directly, e.g. to create a third-party asset
        * management system, it's recommended to use any of the classes Loader3D, AssetLoader
        * and AssetLibrary instead in most cases.
        *
        * @see away3d.loading.Loader3D
        * @see away3d.loading.AssetLoader
        * @see away3d.loading.AssetLibrary
        */
        var SingleFileLoader = (function (_super) {
            __extends(SingleFileLoader, _super);
            // Constructor
            /**
            * Creates a new SingleFileLoader object.
            */
            function SingleFileLoader(materialMode) {
                if (typeof materialMode === "undefined") { materialMode = 0; }
                _super.call(this);
                this._materialMode = materialMode;
                this._assets = new Array();
            }
            SingleFileLoader.enableParser = function (parser) {
                if (SingleFileLoader._parsers.indexOf(parser) < 0) {
                    SingleFileLoader._parsers.push(parser);
                }
            };

            SingleFileLoader.enableParsers = function (parsers) {
                var pc;

                for (var c = 0; c < parsers.length; c++) {
                    SingleFileLoader.enableParser(parsers[c]);
                }
            };

            Object.defineProperty(SingleFileLoader.prototype, "url", {
                get: // Get / Set
                function () {
                    return this._req ? this._req.url : '';
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SingleFileLoader.prototype, "data", {
                get: function () {
                    return this._data;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SingleFileLoader.prototype, "loadAsRawData", {
                get: function () {
                    return this._loadAsRawData;
                },
                enumerable: true,
                configurable: true
            });

            // Public
            /**
            * Load a resource from a file.
            *
            * @param urlRequest The URLRequest object containing the URL of the object to be loaded.
            * @param parser An optional parser object that will translate the loaded data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            SingleFileLoader.prototype.load = function (urlRequest, parser, loadAsRawData) {
                if (typeof parser === "undefined") { parser = null; }
                if (typeof loadAsRawData === "undefined") { loadAsRawData = false; }
                //var urlLoader   : away.net.URLLoader;
                var dataFormat;
                var loaderType = away.loaders.ParserLoaderType.URL_LOADER;

                this._loadAsRawData = loadAsRawData;
                this._req = urlRequest;

                this.decomposeFilename(this._req.url);

                if (this._loadAsRawData) {
                    // Always use binary for raw data loading
                    dataFormat = away.net.URLLoaderDataFormat.BINARY;
                } else {
                    if (parser) {
                        this._parser = parser;
                    }

                    if (!this._parser) {
                        this._parser = this.getParserFromSuffix();
                    }

                    if (this._parser) {
                        switch (this._parser.dataFormat) {
                            case away.loaders.ParserDataFormat.BINARY:
                                dataFormat = away.net.URLLoaderDataFormat.ARRAY_BUFFER;

                                break;

                            case away.loaders.ParserDataFormat.PLAIN_TEXT:
                                dataFormat = away.net.URLLoaderDataFormat.TEXT;
                                break;
                        }

                        switch (this._parser.loaderType) {
                            case away.loaders.ParserLoaderType.IMG_LOADER:
                                loaderType = away.loaders.ParserLoaderType.IMG_LOADER;
                                break;

                            case away.loaders.ParserLoaderType.URL_LOADER:
                                loaderType = away.loaders.ParserLoaderType.URL_LOADER;
                                break;
                        }
                    } else {
                        // Always use BINARY for unknown file formats. The thorough
                        // file type check will determine format after load, and if
                        // binary, a text load will have broken the file data.
                        dataFormat = away.net.URLLoaderDataFormat.BINARY;
                    }
                }

                var loader = this.getLoader(loaderType);
                loader.dataFormat = dataFormat;
                loader.addEventListener(away.events.Event.COMPLETE, this.handleUrlLoaderComplete, this);
                loader.addEventListener(away.events.IOErrorEvent.IO_ERROR, this.handleUrlLoaderError, this);
                loader.load(urlRequest);
            };

            /**
            * Loads a resource from already loaded data.
            * @param data The data to be parsed. Depending on the parser type, this can be a ByteArray, String or XML.
            * @param uri The identifier (url or id) of the object to be loaded, mainly used for resource management.
            * @param parser An optional parser object that will translate the data into a usable resource. If not provided, AssetLoader will attempt to auto-detect the file type.
            */
            SingleFileLoader.prototype.parseData = function (data, parser, req) {
                if (typeof parser === "undefined") { parser = null; }
                if (typeof req === "undefined") { req = null; }
                if (data.constructor === Function) {
                    data = new data();
                }

                if (parser) {
                    this._parser = parser;
                }

                this._req = req;
                this.parse(data);
            };

            Object.defineProperty(SingleFileLoader.prototype, "parser", {
                get: /**
                * A reference to the parser that will translate the loaded data into a usable resource.
                */
                function () {
                    return this._parser;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SingleFileLoader.prototype, "dependencies", {
                get: /**
                * A list of dependencies that need to be loaded and resolved for the loaded object.
                */
                function () {
                    return this._parser ? this._parser.dependencies : new Array();
                },
                enumerable: true,
                configurable: true
            });

            // Private
            /**
            *
            * @param loaderType
            */
            SingleFileLoader.prototype.getLoader = function (loaderType) {
                var loader;

                switch (loaderType) {
                    case away.loaders.ParserLoaderType.IMG_LOADER:
                        loader = new away.loaders.SingleFileImageLoader();
                        break;

                    case away.loaders.ParserLoaderType.URL_LOADER:
                        loader = new away.loaders.SingleFileURLLoader();
                        break;
                }

                return loader;
            };

            /**
            * Splits a url string into base and extension.
            * @param url The url to be decomposed.
            */
            SingleFileLoader.prototype.decomposeFilename = function (url) {
                // Get rid of query string if any and extract suffix
                var base = (url.indexOf('?') > 0) ? url.split('?')[0] : url;
                var i = base.lastIndexOf('.');
                this._fileExtension = base.substr(i + 1).toLowerCase();
                this._fileName = base.substr(0, i);
            };

            /**
            * Guesses the parser to be used based on the file extension.
            * @return An instance of the guessed parser.
            */
            SingleFileLoader.prototype.getParserFromSuffix = function () {
                var len = SingleFileLoader._parsers.length;

                for (var i = len - 1; i >= 0; i--) {
                    var currentParser = SingleFileLoader._parsers[i];
                    var supportstype = SingleFileLoader._parsers[i].supportsType(this._fileExtension);

                    if (SingleFileLoader._parsers[i]['supportsType'](this._fileExtension)) {
                        return new SingleFileLoader._parsers[i]();
                    }
                }

                return null;
            };

            /**
            * Guesses the parser to be used based on the file contents.
            * @param data The data to be parsed.
            * @param uri The url or id of the object to be parsed.
            * @return An instance of the guessed parser.
            */
            SingleFileLoader.prototype.getParserFromData = function (data) {
                var len = SingleFileLoader._parsers.length;

                for (var i = len - 1; i >= 0; i--)
                    if (SingleFileLoader._parsers[i].supportsData(data))
                        return new SingleFileLoader._parsers[i]();

                return null;
            };

            /**
            * Cleanups
            */
            SingleFileLoader.prototype.removeListeners = function (urlLoader) {
                urlLoader.removeEventListener(away.events.Event.COMPLETE, this.handleUrlLoaderComplete, this);
                urlLoader.removeEventListener(away.events.IOErrorEvent.IO_ERROR, this.handleUrlLoaderError, this);
            };

            // Events
            /**
            * Called when loading of a file has failed
            */
            SingleFileLoader.prototype.handleUrlLoaderError = function (event) {
                var urlLoader = event.target;
                this.removeListeners(urlLoader);

                //if(this.hasEventListener(away.events.LoaderEvent.LOAD_ERROR , this.handleUrlLoaderError , this ))
                this.dispatchEvent(new away.events.LoaderEvent(away.events.LoaderEvent.LOAD_ERROR, this.url, this._assets));
            };

            /**
            * Called when loading of a file is complete
            */
            SingleFileLoader.prototype.handleUrlLoaderComplete = function (event) {
                var urlLoader = event.target;
                this.removeListeners(urlLoader);

                this._data = urlLoader.data;

                if (this._loadAsRawData) {
                    // No need to parse this data, which should be returned as is
                    this.dispatchEvent(new away.events.LoaderEvent(away.events.LoaderEvent.DEPENDENCY_COMPLETE, this.url, this._assets));
                } else {
                    this.parse(this._data);
                }
            };

            /**
            * Initiates parsing of the loaded data.
            * @param data The data to be parsed.
            */
            SingleFileLoader.prototype.parse = function (data) {
                if (!this._parser) {
                    this._parser = this.getParserFromData(data);
                }

                if (this._parser) {
                    this._parser.addEventListener(away.events.ParserEvent.READY_FOR_DEPENDENCIES, this.onReadyForDependencies, this);
                    this._parser.addEventListener(away.events.ParserEvent.PARSE_ERROR, this.onParseError, this);
                    this._parser.addEventListener(away.events.ParserEvent.PARSE_COMPLETE, this.onParseComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.TEXTURE_SIZE_ERROR, this.onTextureSizeError, this);
                    this._parser.addEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                    this._parser.addEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);

                    if (this._req && this._req.url) {
                        this._parser._iFileName = this._req.url;
                    }

                    this._parser.materialMode = this._materialMode;
                    this._parser.parseAsync(data);
                } else {
                    var msg = "No parser defined. To enable all parsers for auto-detection, use Parsers.enableAllBundled()";

                    //if(hasEventListener(LoaderEvent.LOAD_ERROR)){
                    this.dispatchEvent(new away.events.LoaderEvent(away.events.LoaderEvent.LOAD_ERROR, this.url, this._assets, true, msg));
                    //} else{
                    //	throw new Error(msg);
                    //}
                }
            };

            SingleFileLoader.prototype.onParseError = function (event) {
                this.dispatchEvent(event.clone());
            };

            SingleFileLoader.prototype.onReadyForDependencies = function (event) {
                this.dispatchEvent(event.clone());
            };

            SingleFileLoader.prototype.onAssetComplete = function (event) {
                if (event.type == away.events.AssetEvent.ASSET_COMPLETE)
                    this._assets.push(event.asset);

                this.dispatchEvent(event.clone());
            };

            SingleFileLoader.prototype.onTextureSizeError = function (event) {
                this.dispatchEvent(event.clone());
            };

            /**
            * Called when parsing is complete.
            */
            SingleFileLoader.prototype.onParseComplete = function (event) {
                this.dispatchEvent(new away.events.LoaderEvent(away.events.LoaderEvent.DEPENDENCY_COMPLETE, this.url, this._assets));

                this._parser.removeEventListener(away.events.ParserEvent.READY_FOR_DEPENDENCIES, this.onReadyForDependencies, this);
                this._parser.removeEventListener(away.events.ParserEvent.PARSE_COMPLETE, this.onParseComplete, this);
                this._parser.removeEventListener(away.events.ParserEvent.PARSE_ERROR, this.onParseError, this);
                this._parser.removeEventListener(away.events.AssetEvent.TEXTURE_SIZE_ERROR, this.onTextureSizeError, this);
                this._parser.removeEventListener(away.events.AssetEvent.ASSET_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.ANIMATION_SET_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.ANIMATION_STATE_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.ANIMATION_NODE_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.STATE_TRANSITION_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.TEXTURE_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.CONTAINER_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.GEOMETRY_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.MATERIAL_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.MESH_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.ENTITY_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.SKELETON_COMPLETE, this.onAssetComplete, this);
                this._parser.removeEventListener(away.events.AssetEvent.SKELETON_POSE_COMPLETE, this.onAssetComplete, this);
            };
            SingleFileLoader._parsers = new Array(away.loaders.ImageParser);
            return SingleFileLoader;
        })(away.events.EventDispatcher);
        loaders.SingleFileLoader = SingleFileLoader;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        var SingleFileImageLoader = (function (_super) {
            __extends(SingleFileImageLoader, _super);
            function SingleFileImageLoader() {
                _super.call(this);
                this.initLoader();
            }
            // Public
            /**
            *
            * @param req
            */
            SingleFileImageLoader.prototype.load = function (req) {
                this._loader.load(req);
            };

            /**
            *
            */
            SingleFileImageLoader.prototype.dispose = function () {
                this.disposeLoader();
                this._data = null;
            };

            Object.defineProperty(SingleFileImageLoader.prototype, "data", {
                get: // Get / Set
                /**
                *
                * @returns {*}
                */
                function () {
                    return this._loader.image;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SingleFileImageLoader.prototype, "dataFormat", {
                get: /**
                *
                * @returns {*}
                */
                function () {
                    return this._dataFormat;
                },
                set: function (value) {
                    this._dataFormat = value;
                },
                enumerable: true,
                configurable: true
            });

            // Private
            /**
            *
            */
            SingleFileImageLoader.prototype.initLoader = function () {
                if (!this._loader) {
                    this._loader = new away.net.IMGLoader();
                    this._loader.addEventListener(away.events.Event.COMPLETE, this.onLoadComplete, this);
                    this._loader.addEventListener(away.events.IOErrorEvent.IO_ERROR, this.onLoadError, this);
                }
            };

            /**
            *
            */
            SingleFileImageLoader.prototype.disposeLoader = function () {
                if (this._loader) {
                    this._loader.dispose();
                    this._loader.removeEventListener(away.events.Event.COMPLETE, this.onLoadComplete, this);
                    this._loader.removeEventListener(away.events.IOErrorEvent.IO_ERROR, this.onLoadError, this);
                    this._loader = null;
                }
            };

            // Events
            /**
            *
            * @param event
            */
            SingleFileImageLoader.prototype.onLoadComplete = function (event) {
                this.dispatchEvent(event);
            };

            /**
            *
            * @param event
            */
            SingleFileImageLoader.prototype.onLoadError = function (event) {
                this.dispatchEvent(event);
            };
            return SingleFileImageLoader;
        })(away.events.EventDispatcher);
        loaders.SingleFileImageLoader = SingleFileImageLoader;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        var SingleFileURLLoader = (function (_super) {
            __extends(SingleFileURLLoader, _super);
            function SingleFileURLLoader() {
                _super.call(this);
                this.initLoader();
            }
            // Public
            /**
            *
            * @param req
            */
            SingleFileURLLoader.prototype.load = function (req) {
                this._loader.load(req);
            };

            /**
            *
            */
            SingleFileURLLoader.prototype.dispose = function () {
                this.disposeLoader();
                this._data = null;
            };

            Object.defineProperty(SingleFileURLLoader.prototype, "data", {
                get: // Get / Set
                /**
                *
                * @returns {*}
                */
                function () {
                    return this._loader.data;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SingleFileURLLoader.prototype, "dataFormat", {
                get: /**
                *
                * @returns {*}
                */
                function () {
                    return this._loader.dataFormat;
                },
                set: function (value) {
                    this._loader.dataFormat = value;
                },
                enumerable: true,
                configurable: true
            });

            // Private
            /**
            *
            */
            SingleFileURLLoader.prototype.initLoader = function () {
                if (!this._loader) {
                    this._loader = new away.net.URLLoader();
                    this._loader.addEventListener(away.events.Event.COMPLETE, this.onLoadComplete, this);
                    this._loader.addEventListener(away.events.IOErrorEvent.IO_ERROR, this.onLoadError, this);
                }
            };

            /**
            *
            */
            SingleFileURLLoader.prototype.disposeLoader = function () {
                if (this._loader) {
                    this._loader.dispose();
                    this._loader.removeEventListener(away.events.Event.COMPLETE, this.onLoadComplete, this);
                    this._loader.removeEventListener(away.events.IOErrorEvent.IO_ERROR, this.onLoadError, this);
                    this._loader = null;
                }
            };

            // Events
            /**
            *
            * @param event
            */
            SingleFileURLLoader.prototype.onLoadComplete = function (event) {
                this.dispatchEvent(event);
            };

            /**
            *
            * @param event
            */
            SingleFileURLLoader.prototype.onLoadError = function (event) {
                this.dispatchEvent(event);
            };
            return SingleFileURLLoader;
        })(away.events.EventDispatcher);
        loaders.SingleFileURLLoader = SingleFileURLLoader;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    (function (loaders) {
        var ParserLoaderType = (function () {
            function ParserLoaderType() {
            }
            ParserLoaderType.URL_LOADER = 'ParserLoaderType_URLLoader';
            ParserLoaderType.IMG_LOADER = 'ParserLoaderType_IMGLoader';
            return ParserLoaderType;
        })();
        loaders.ParserLoaderType = ParserLoaderType;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../../_definitions.ts"/>
    (function (loaders) {
        var ParserUtil = (function () {
            function ParserUtil() {
            }
            ParserUtil.byteArrayToImage = /**
            * Converts an ByteArray to an Image - returns an HTMLImageElement
            *
            * @param image data as a ByteArray
            *
            * @return HTMLImageElement
            *
            */
            function (data) {
                var byteStr = '';
                var bytes = new Uint8Array(data.arraybytes);
                var len = bytes.byteLength;

                for (var i = 0; i < len; i++) {
                    byteStr += String.fromCharCode(bytes[i]);
                }

                var base64Image = window.btoa(byteStr);
                var str = 'data:image/png;base64,' + base64Image;
                var img = new Image();
                img.src = str;

                return img;
            };

            ParserUtil.toByteArray = /**
            * Returns a object as ByteArray, if possible.
            *
            * @param data The object to return as ByteArray
            *
            * @return The ByteArray or null
            *
            */
            function (data) {
                var b = new away.utils.ByteArray();
                b.setArrayBuffer(data);
                return b;
            };

            ParserUtil.toString = /**
            * Returns a object as String, if possible.
            *
            * @param data The object to return as String
            * @param length The length of the returned String
            *
            * @return The String or null
            *
            */
            function (data, length) {
                if (typeof length === "undefined") { length = 0; }
                if (typeof data === 'string')
                    ;
                 {
                    var s = data;

                    if (s['substr'] != null) {
                        return s.substr(0, s.length);
                    }
                }

                if (data instanceof away.utils.ByteArray) {
                    var ba = data;
                    ba.position = 0;
                    return ba.readUTFBytes(Math.min(ba.getBytesAvailable(), length));
                }

                return null;
                /*
                var ba:ByteArray;
                
                length ||= uint.MAX_VALUE;
                
                if (data is String)
                return String(data).substr(0, length);
                
                ba = toByteArray(data);
                if (ba) {
                ba.position = 0;
                return ba.readUTFBytes(Math.min(ba.bytesAvailable, length));
                }
                
                return null;
                
                */
            };
            return ParserUtil;
        })();
        loaders.ParserUtil = ParserUtil;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        /**
        * OBJParser provides a parser for the OBJ data type.
        */
        var OBJParser = (function (_super) {
            __extends(OBJParser, _super);
            /**
            * Creates a new OBJParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function OBJParser(scale) {
                if (typeof scale === "undefined") { scale = 1; }
                _super.call(this, loaders.ParserDataFormat.PLAIN_TEXT);
                this._mtlLibLoaded = true;
                this._activeMaterialID = "";
                this._scale = scale;
            }
            Object.defineProperty(OBJParser.prototype, "scale", {
                set: /**
                * Scaling factor applied directly to vertices data
                * @param value The scaling factor.
                */
                function (value) {
                    this._scale = value;
                },
                enumerable: true,
                configurable: true
            });

            OBJParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "obj";
            };

            OBJParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                var content = away.loaders.ParserUtil.toString(data);
                var hasV = false;
                var hasF = false;

                if (content) {
                    hasV = content.indexOf("\nv ") != -1;
                    hasF = content.indexOf("\nf ") != -1;
                }

                return hasV && hasF;
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.id == 'mtl') {
                    var str = away.loaders.ParserUtil.toString(resourceDependency.data);
                    this.parseMtl(str);
                } else {
                    var asset;

                    if (resourceDependency.assets.length != 1) {
                        return;
                    }

                    asset = resourceDependency.assets[0];

                    if (asset.assetType == away.library.AssetType.TEXTURE) {
                        var lm = new LoadedMaterial();
                        lm.materialID = resourceDependency.id;
                        lm.texture = asset;

                        this._materialLoaded.push(lm);

                        if (this._meshes.length > 0) {
                            this.applyMaterial(lm);
                        }
                    }
                }
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                if (resourceDependency.id == "mtl") {
                    this._mtlLib = false;
                    this._mtlLibLoaded = false;
                } else {
                    var lm = new LoadedMaterial();
                    lm.materialID = resourceDependency.id;
                    this._materialLoaded.push(lm);
                }

                if (this._meshes.length > 0)
                    this.applyMaterial(lm);
            };

            /**
            * @inheritDoc
            */
            OBJParser.prototype._pProceedParsing = function () {
                var line;
                var creturn = String.fromCharCode(10);
                var trunk;

                if (!this._startedParsing) {
                    this._textData = this._pGetTextData();

                    // Merge linebreaks that are immediately preceeded by
                    // the "escape" backward slash into single lines.
                    this._textData = this._textData.replace(/\\[\r\n]+\s*/gm, ' ');
                }

                if (this._textData.indexOf(creturn) == -1)
                    creturn = String.fromCharCode(13);

                if (!this._startedParsing) {
                    this._startedParsing = true;
                    this._vertices = new Array();
                    this._vertexNormals = new Array();
                    this._materialIDs = new Array();
                    this._materialLoaded = new Array();
                    this._meshes = new Array();
                    this._uvs = new Array();
                    this._stringLength = this._textData.length;
                    this._charIndex = this._textData.indexOf(creturn, 0);
                    this._oldIndex = 0;
                    this._objects = new Array();
                    this._objectIndex = 0;
                }

                while (this._charIndex < this._stringLength && this._pHasTime()) {
                    this._charIndex = this._textData.indexOf(creturn, this._oldIndex);

                    if (this._charIndex == -1)
                        this._charIndex = this._stringLength;

                    line = this._textData.substring(this._oldIndex, this._charIndex);
                    line = line.split('\r').join("");
                    line = line.replace("  ", " ");
                    trunk = line.split(" ");
                    this._oldIndex = this._charIndex + 1;
                    this.parseLine(trunk);

                    if (this.parsingPaused) {
                        return away.loaders.ParserBase.MORE_TO_PARSE;
                    }
                }

                if (this._charIndex >= this._stringLength) {
                    if (this._mtlLib && !this._mtlLibLoaded) {
                        return away.loaders.ParserBase.MORE_TO_PARSE;
                    }

                    this.translate();
                    this.applyMaterials();

                    return away.loaders.ParserBase.PARSING_DONE;
                }

                return away.loaders.ParserBase.MORE_TO_PARSE;
            };

            /**
            * Parses a single line in the OBJ file.
            */
            OBJParser.prototype.parseLine = function (trunk) {
                switch (trunk[0]) {
                    case "mtllib":
                        this._mtlLib = true;
                        this._mtlLibLoaded = false;
                        this.loadMtl(trunk[1]);

                        break;

                    case "g":
                        this.createGroup(trunk);

                        break;

                    case "o":
                        this.createObject(trunk);

                        break;

                    case "usemtl":
                        if (this._mtlLib) {
                            if (!trunk[1])
                                trunk[1] = "def000";

                            this._materialIDs.push(trunk[1]);
                            this._activeMaterialID = trunk[1];

                            if (this._currentGroup)
                                this._currentGroup.materialID = this._activeMaterialID;
                        }

                        break;

                    case "v":
                        this.parseVertex(trunk);

                        break;

                    case "vt":
                        this.parseUV(trunk);

                        break;

                    case "vn":
                        this.parseVertexNormal(trunk);

                        break;

                    case "f":
                        this.parseFace(trunk);
                }
            };

            /**
            * Converts the parsed data into an Away3D scenegraph structure
            */
            OBJParser.prototype.translate = function () {
                for (var objIndex = 0; objIndex < this._objects.length; ++objIndex) {
                    var groups = this._objects[objIndex].groups;
                    var numGroups = groups.length;
                    var materialGroups;
                    var numMaterialGroups;
                    var geometry;
                    var mesh;

                    var m;
                    var sm;
                    var bmMaterial;

                    for (var g = 0; g < numGroups; ++g) {
                        geometry = new away.base.Geometry();
                        materialGroups = groups[g].materialGroups;
                        numMaterialGroups = materialGroups.length;

                        for (m = 0; m < numMaterialGroups; ++m)
                            this.translateMaterialGroup(materialGroups[m], geometry);

                        if (geometry.subGeometries.length == 0)
                            continue;

                        // Finalize and force type-based name
                        this._pFinalizeAsset(geometry);

                        if (this.materialMode < 2)
                            bmMaterial = new away.materials.TextureMaterial(away.materials.DefaultMaterialManager.getDefaultTexture());
else
                            bmMaterial = new away.materials.TextureMultiPassMaterial(away.materials.DefaultMaterialManager.getDefaultTexture());

                        //bmMaterial = new TextureMaterial(DefaultMaterialManager.getDefaultTexture());
                        mesh = new away.entities.Mesh(geometry, bmMaterial);

                        if (this._objects[objIndex].name) {
                            // this is a full independent object ('o' tag in OBJ file)
                            mesh.name = this._objects[objIndex].name;
                        } else if (groups[g].name) {
                            // this is a group so the sub groups contain the actual mesh object names ('g' tag in OBJ file)
                            mesh.name = groups[g].name;
                        } else {
                            // No name stored. Use empty string which will force it
                            // to be overridden by finalizeAsset() to type default.
                            mesh.name = "";
                        }

                        this._meshes.push(mesh);

                        if (groups[g].materialID != "")
                            bmMaterial.name = groups[g].materialID + "~" + mesh.name;
else
                            bmMaterial.name = this._lastMtlID + "~" + mesh.name;

                        if (mesh.subMeshes.length > 1) {
                            for (sm = 1; sm < mesh.subMeshes.length; ++sm)
                                mesh.subMeshes[sm].material = bmMaterial;
                        }

                        this._pFinalizeAsset(mesh);
                    }
                }
            };

            /**
            * Translates an obj's material group to a subgeometry.
            * @param materialGroup The material group data to convert.
            * @param geometry The Geometry to contain the converted SubGeometry.
            */
            OBJParser.prototype.translateMaterialGroup = function (materialGroup, geometry) {
                var faces = materialGroup.faces;
                var face;
                var numFaces = faces.length;
                var numVerts;
                var subs;

                var vertices = new Array();
                var uvs = new Array();
                var normals = new Array();
                var indices = new Array();

                this._realIndices = [];
                this._vertexIndex = 0;

                var j;
                for (var i = 0; i < numFaces; ++i) {
                    face = faces[i];
                    numVerts = face.indexIds.length - 1;

                    for (j = 1; j < numVerts; ++j) {
                        this.translateVertexData(face, j, vertices, uvs, indices, normals);
                        this.translateVertexData(face, 0, vertices, uvs, indices, normals);
                        this.translateVertexData(face, j + 1, vertices, uvs, indices, normals);
                    }
                }
                if (vertices.length > 0) {
                    subs = away.utils.GeometryUtils.fromVectors(vertices, indices, uvs, normals, null, null, null);
                    for (i = 0; i < subs.length; i++) {
                        geometry.addSubGeometry(subs[i]);
                    }
                }
            };

            OBJParser.prototype.translateVertexData = function (face, vertexIndex, vertices, uvs, indices/*uint*/ , normals) {
                var index;
                var vertex;
                var vertexNormal;
                var uv;

                if (!this._realIndices[face.indexIds[vertexIndex]]) {
                    index = this._vertexIndex;
                    this._realIndices[face.indexIds[vertexIndex]] = ++this._vertexIndex;
                    vertex = this._vertices[face.vertexIndices[vertexIndex] - 1];
                    vertices.push(vertex.x * this._scale, vertex.y * this._scale, vertex.z * this._scale);

                    if (face.normalIndices.length > 0) {
                        vertexNormal = this._vertexNormals[face.normalIndices[vertexIndex] - 1];
                        normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
                    }

                    if (face.uvIndices.length > 0) {
                        try  {
                            uv = this._uvs[face.uvIndices[vertexIndex] - 1];
                            uvs.push(uv.u, uv.v);
                        } catch (e) {
                            switch (vertexIndex) {
                                case 0:
                                    uvs.push(0, 1);
                                    break;
                                case 1:
                                    uvs.push(.5, 0);
                                    break;
                                case 2:
                                    uvs.push(1, 1);
                            }
                        }
                    }
                } else {
                    index = this._realIndices[face.indexIds[vertexIndex]] - 1;
                }

                indices.push(index);
            };

            /**
            * Creates a new object group.
            * @param trunk The data block containing the object tag and its parameters
            */
            OBJParser.prototype.createObject = function (trunk) {
                this._currentGroup = null;
                this._currentMaterialGroup = null;
                this._objects.push(this._currentObject = new ObjectGroup());

                if (trunk)
                    this._currentObject.name = trunk[1];
            };

            /**
            * Creates a new group.
            * @param trunk The data block containing the group tag and its parameters
            */
            OBJParser.prototype.createGroup = function (trunk) {
                if (!this._currentObject)
                    this.createObject(null);
                this._currentGroup = new Group();

                this._currentGroup.materialID = this._activeMaterialID;

                if (trunk)
                    this._currentGroup.name = trunk[1];
                this._currentObject.groups.push(this._currentGroup);

                this.createMaterialGroup(null);
            };

            /**
            * Creates a new material group.
            * @param trunk The data block containing the material tag and its parameters
            */
            OBJParser.prototype.createMaterialGroup = function (trunk) {
                this._currentMaterialGroup = new MaterialGroup();
                if (trunk)
                    this._currentMaterialGroup.url = trunk[1];
                this._currentGroup.materialGroups.push(this._currentMaterialGroup);
            };

            /**
            * Reads the next vertex coordinates.
            * @param trunk The data block containing the vertex tag and its parameters
            */
            OBJParser.prototype.parseVertex = function (trunk) {
                //for the very rare cases of other delimiters/charcodes seen in some obj files
                var v1, v2, v3;
                if (trunk.length > 4) {
                    var nTrunk = [];
                    var val;

                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }

                    v1 = nTrunk[0];
                    v2 = nTrunk[1];
                    v3 = -nTrunk[2];
                    this._vertices.push(new Vertex(v1, v2, v3));
                } else {
                    v1 = parseFloat(trunk[1]);
                    v2 = parseFloat(trunk[2]);
                    v3 = -parseFloat(trunk[3]);

                    this._vertices.push(new Vertex(v1, v2, v3));
                }
            };

            /**
            * Reads the next uv coordinates.
            * @param trunk The data block containing the uv tag and its parameters
            */
            OBJParser.prototype.parseUV = function (trunk) {
                if (trunk.length > 3) {
                    var nTrunk = [];
                    var val;
                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }
                    this._uvs.push(new UV(nTrunk[0], 1 - nTrunk[1]));
                } else {
                    this._uvs.push(new UV(parseFloat(trunk[1]), 1 - parseFloat(trunk[2])));
                }
            };

            /**
            * Reads the next vertex normal coordinates.
            * @param trunk The data block containing the vertex normal tag and its parameters
            */
            OBJParser.prototype.parseVertexNormal = function (trunk) {
                if (trunk.length > 4) {
                    var nTrunk = [];
                    var val;
                    for (var i = 1; i < trunk.length; ++i) {
                        val = parseFloat(trunk[i]);
                        if (!isNaN(val))
                            nTrunk.push(val);
                    }
                    this._vertexNormals.push(new Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
                } else {
                    this._vertexNormals.push(new Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
                }
            };

            /**
            * Reads the next face's indices.
            * @param trunk The data block containing the face tag and its parameters
            */
            OBJParser.prototype.parseFace = function (trunk) {
                var len = trunk.length;
                var face = new FaceData();

                if (!this._currentGroup) {
                    this.createGroup(null);
                }

                var indices;
                for (var i = 1; i < len; ++i) {
                    if (trunk[i] == "") {
                        continue;
                    }

                    indices = trunk[i].split("/");
                    face.vertexIndices.push(this.parseIndex(parseInt(indices[0]), this._vertices.length));

                    if (indices[1] && String(indices[1]).length > 0)
                        face.uvIndices.push(this.parseIndex(parseInt(indices[1]), this._uvs.length));

                    if (indices[2] && String(indices[2]).length > 0)
                        face.normalIndices.push(this.parseIndex(parseInt(indices[2]), this._vertexNormals.length));

                    face.indexIds.push(trunk[i]);
                }

                this._currentMaterialGroup.faces.push(face);
            };

            /**
            * This is a hack around negative face coords
            */
            OBJParser.prototype.parseIndex = function (index, length) {
                if (index < 0)
                    return index + length + 1;
else
                    return index;
            };

            OBJParser.prototype.parseMtl = function (data) {
                var materialDefinitions = data.split('newmtl');
                var lines;
                var trunk;
                var j;

                var basicSpecularMethod;
                var useSpecular;
                var useColor;
                var diffuseColor;
                var ambientColor;
                var specularColor;
                var specular;
                var alpha;
                var mapkd;

                for (var i = 0; i < materialDefinitions.length; ++i) {
                    lines = (materialDefinitions[i].split('\r')).join("").split('\n');

                    if (lines.length == 1)
                        lines = materialDefinitions[i].split(String.fromCharCode(13));

                    diffuseColor = ambientColor = specularColor = 0xFFFFFF;
                    specular = 0;
                    useSpecular = false;
                    useColor = false;
                    alpha = 1;
                    mapkd = "";

                    for (j = 0; j < lines.length; ++j) {
                        lines[j] = lines[j].replace(/\s+$/, "");

                        if (lines[j].substring(0, 1) != "#" && (j == 0 || lines[j] != "")) {
                            trunk = lines[j].split(" ");

                            if (String(trunk[0]).charCodeAt(0) == 9 || String(trunk[0]).charCodeAt(0) == 32)
                                trunk[0] = trunk[0].substring(1, trunk[0].length);

                            if (j == 0) {
                                this._lastMtlID = trunk.join("");
                                this._lastMtlID = (this._lastMtlID == "") ? "def000" : this._lastMtlID;
                            } else {
                                switch (trunk[0]) {
                                    case "Ka":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3])))
                                            ambientColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                        break;

                                    case "Ks":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                            specularColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                            useSpecular = true;
                                        }
                                        break;

                                    case "Ns":
                                        if (trunk[1] && !isNaN(Number(trunk[1])))
                                            specular = Number(trunk[1]) * 0.001;
                                        if (specular == 0)
                                            useSpecular = false;
                                        break;

                                    case "Kd":
                                        if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                            diffuseColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                            useColor = true;
                                        }
                                        break;

                                    case "tr":
                                    case "d":
                                        if (trunk[1] && !isNaN(Number(trunk[1])))
                                            alpha = Number(trunk[1]);
                                        break;

                                    case "map_Kd":
                                        mapkd = this.parseMapKdString(trunk);
                                        mapkd = mapkd.replace(/\\/g, "/");
                                }
                            }
                        }
                    }

                    if (mapkd != "") {
                        if (useSpecular) {
                            basicSpecularMethod = new away.materials.BasicSpecularMethod();
                            basicSpecularMethod.specularColor = specularColor;
                            basicSpecularMethod.specular = specular;

                            var specularData = new SpecularData();
                            specularData.alpha = alpha;
                            specularData.basicSpecularMethod = basicSpecularMethod;
                            specularData.materialID = this._lastMtlID;

                            if (!this._materialSpecularData)
                                this._materialSpecularData = new Array();

                            this._materialSpecularData.push(specularData);
                        }

                        this._pAddDependency(this._lastMtlID, new away.net.URLRequest(mapkd));
                    } else if (useColor && !isNaN(diffuseColor)) {
                        var lm = new LoadedMaterial();
                        lm.materialID = this._lastMtlID;

                        if (alpha == 0)
                            console.log("Warning: an alpha value of 0 was found in mtl color tag (Tr or d) ref:" + this._lastMtlID + ", mesh(es) using it will be invisible!");

                        var cm;

                        if (this.materialMode < 2) {
                            cm = new away.materials.ColorMaterial(diffuseColor);

                            var colorMat = cm;

                            colorMat.alpha = alpha;
                            colorMat.ambientColor = ambientColor;
                            colorMat.repeat = true;

                            if (useSpecular) {
                                colorMat.specularColor = specularColor;
                                colorMat.specular = specular;
                            }
                        } else {
                            cm = new away.materials.ColorMultiPassMaterial(diffuseColor);

                            var colorMultiMat = cm;

                            colorMultiMat.ambientColor = ambientColor;
                            colorMultiMat.repeat = true;

                            if (useSpecular) {
                                colorMultiMat.specularColor = specularColor;
                                colorMultiMat.specular = specular;
                            }
                        }

                        lm.cm = cm;

                        this._materialLoaded.push(lm);

                        if (this._meshes.length > 0)
                            this.applyMaterial(lm);
                    }
                }

                this._mtlLibLoaded = true;
            };

            OBJParser.prototype.parseMapKdString = function (trunk) {
                var url = "";
                var i;
                var breakflag;

                for (i = 1; i < trunk.length;) {
                    switch (trunk[i]) {
                        case "-blendu":
                        case "-blendv":
                        case "-cc":
                        case "-clamp":
                        case "-texres":
                            i += 2;
                            break;
                        case "-mm":
                            i += 3;
                            break;
                        case "-o":
                        case "-s":
                        case "-t":
                            i += 4;
                            continue;
                        default:
                            breakflag = true;
                            break;
                    }

                    if (breakflag)
                        break;
                }

                for (i; i < trunk.length; i++) {
                    url += trunk[i];
                    url += " ";
                }

                //Remove the extraneous space and/or newline from the right side
                url = url.replace(/\s+$/, "");

                return url;
            };

            OBJParser.prototype.loadMtl = function (mtlurl) {
                // Add raw-data dependency to queue and load dependencies now,
                // which will pause the parsing in the meantime.
                this._pAddDependency('mtl', new away.net.URLRequest(mtlurl), true);
                this._pPauseAndRetrieveDependencies();
            };

            OBJParser.prototype.applyMaterial = function (lm) {
                var decomposeID;
                var mesh;
                var mat;
                var j;
                var specularData;

                for (var i = 0; i < this._meshes.length; ++i) {
                    mesh = this._meshes[i];
                    decomposeID = mesh.material.name.split("~");

                    if (decomposeID[0] == lm.materialID) {
                        if (lm.cm) {
                            if (mesh.material)
                                mesh.material = null;
                            mesh.material = lm.cm;
                        } else if (lm.texture) {
                            if (this.materialMode < 2) {
                                mat = mesh.material;

                                var tm = mat;

                                tm.texture = lm.texture;
                                tm.ambientColor = lm.ambientColor;
                                tm.alpha = lm.alpha;
                                tm.repeat = true;

                                if (lm.specularMethod) {
                                    // By setting the specularMethod property to null before assigning
                                    // the actual method instance, we avoid having the properties of
                                    // the new method being overridden with the settings from the old
                                    // one, which is default behavior of the setter.
                                    tm.specularMethod = null;
                                    tm.specularMethod = lm.specularMethod;
                                } else if (this._materialSpecularData) {
                                    for (j = 0; j < this._materialSpecularData.length; ++j) {
                                        specularData = this._materialSpecularData[j];

                                        if (specularData.materialID == lm.materialID) {
                                            tm.specularMethod = null;
                                            tm.specularMethod = specularData.basicSpecularMethod;
                                            tm.ambientColor = specularData.ambientColor;
                                            tm.alpha = specularData.alpha;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                mat = mesh.material;

                                var tmMult = mat;

                                tmMult.texture = lm.texture;
                                tmMult.ambientColor = lm.ambientColor;
                                tmMult.repeat = true;

                                if (lm.specularMethod) {
                                    // By setting the specularMethod property to null before assigning
                                    // the actual method instance, we avoid having the properties of
                                    // the new method being overridden with the settings from the old
                                    // one, which is default behavior of the setter.
                                    tmMult.specularMethod = null;
                                    tmMult.specularMethod = lm.specularMethod;
                                } else if (this._materialSpecularData) {
                                    for (j = 0; j < this._materialSpecularData.length; ++j) {
                                        specularData = this._materialSpecularData[j];

                                        if (specularData.materialID == lm.materialID) {
                                            tmMult.specularMethod = null;
                                            tmMult.specularMethod = specularData.basicSpecularMethod;
                                            tmMult.ambientColor = specularData.ambientColor;

                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        mesh.material.name = decomposeID[1] ? decomposeID[1] : decomposeID[0];
                        this._meshes.splice(i, 1);
                        --i;
                    }
                }

                if (lm.cm || mat)
                    this._pFinalizeAsset(lm.cm || mat);
            };

            OBJParser.prototype.applyMaterials = function () {
                if (this._materialLoaded.length == 0)
                    return;

                for (var i = 0; i < this._materialLoaded.length; ++i)
                    this.applyMaterial(this._materialLoaded[i]);
            };
            return OBJParser;
        })(away.loaders.ParserBase);
        loaders.OBJParser = OBJParser;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));

var ObjectGroup = (function () {
    function ObjectGroup() {
        this.groups = new Array();
    }
    return ObjectGroup;
})();

var Group = (function () {
    function Group() {
        this.materialGroups = new Array();
    }
    return Group;
})();

var MaterialGroup = (function () {
    function MaterialGroup() {
        this.faces = new Array();
    }
    return MaterialGroup;
})();

var SpecularData = (function () {
    function SpecularData() {
        this.ambientColor = 0xFFFFFF;
        this.alpha = 1;
    }
    return SpecularData;
})();

var LoadedMaterial = (function () {
    function LoadedMaterial() {
        this.ambientColor = 0xFFFFFF;
        this.alpha = 1;
    }
    return LoadedMaterial;
})();

var FaceData = (function () {
    function FaceData() {
        this.vertexIndices = new Array();
        this.uvIndices = new Array();
        this.normalIndices = new Array();
        this.indexIds = new Array();
    }
    return FaceData;
})();

/**
* Texture coordinates value object.
*/
var UV = (function () {
    /**
    * Creates a new <code>UV</code> object.
    *
    * @param	u		[optional]	The horizontal coordinate of the texture value. Defaults to 0.
    * @param	v		[optional]	The vertical coordinate of the texture value. Defaults to 0.
    */
    function UV(u, v) {
        if (typeof u === "undefined") { u = 0; }
        if (typeof v === "undefined") { v = 0; }
        this._u = u;
        this._v = v;
    }
    Object.defineProperty(UV.prototype, "v", {
        get: /**
        * Defines the vertical coordinate of the texture value.
        */
        function () {
            return this._v;
        },
        set: function (value) {
            this._v = value;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(UV.prototype, "u", {
        get: /**
        * Defines the horizontal coordinate of the texture value.
        */
        function () {
            return this._u;
        },
        set: function (value) {
            this._u = value;
        },
        enumerable: true,
        configurable: true
    });


    /**
    * returns a new UV value Object
    */
    UV.prototype.clone = function () {
        return new UV(this._u, this._v);
    };

    /**
    * returns the value object as a string for trace/debug purpose
    */
    UV.prototype.toString = function () {
        return this._u + "," + this._v;
    };
    return UV;
})();

var Vertex = (function () {
    /**
    * Creates a new <code>Vertex</code> value object.
    *
    * @param	x			[optional]	The x value. Defaults to 0.
    * @param	y			[optional]	The y value. Defaults to 0.
    * @param	z			[optional]	The z value. Defaults to 0.
    * @param	index		[optional]	The index value. Defaults is NaN.
    */
    function Vertex(x, y, z, index) {
        if (typeof x === "undefined") { x = 0; }
        if (typeof y === "undefined") { y = 0; }
        if (typeof z === "undefined") { z = 0; }
        if (typeof index === "undefined") { index = 0; }
        this._x = x;
        this._y = y;
        this._z = z;
        this._index = index;
    }
    Object.defineProperty(Vertex.prototype, "index", {
        get: function () {
            return this._index;
        },
        set: /**
        * To define/store the index of value object
        * @param	ind		The index
        */
        function (ind) {
            this._index = ind;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(Vertex.prototype, "x", {
        get: /**
        * To define/store the x value of the value object
        * @param	value		The x value
        */
        function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(Vertex.prototype, "y", {
        get: /**
        * To define/store the y value of the value object
        * @param	value		The y value
        */
        function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(Vertex.prototype, "z", {
        get: /**
        * To define/store the z value of the value object
        * @param	value		The z value
        */
        function () {
            return this._z;
        },
        set: function (value) {
            this._z = value;
        },
        enumerable: true,
        configurable: true
    });


    /**
    * returns a new Vertex value Object
    */
    Vertex.prototype.clone = function () {
        return new Vertex(this._x, this._y, this._z);
    };

    Vertex.prototype.FaceData = function () {
    };
    return Vertex;
})();
var away;
(function (away) {
    ///<reference path="../../../../src/away/_definitions.ts" />
    (function (loaders) {
        /**
        * ImageParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
        * a loader object, it wraps it in a BitmapDataResource so resource management can happen consistently without
        * exception cases.
        */
        var CubeTextureParser = (function (_super) {
            __extends(CubeTextureParser, _super);
            /**
            * Creates a new ImageParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function CubeTextureParser() {
                _super.call(this, away.loaders.ParserDataFormat.PLAIN_TEXT, away.loaders.ParserLoaderType.URL_LOADER);
                this.STATE_PARSE_DATA = 0;
                this.STATE_LOAD_IMAGES = 1;
                this.STATE_COMPLETE = 2;
                this._state = -1;
                this._dependencyCount = 0;
                this._totalImages = 0;
                this._loadedImageCounter = 0;

                this._loadedTextures = new Array();
                this._state = this.STATE_PARSE_DATA;
            }
            CubeTextureParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "cube";
            };

            CubeTextureParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                try  {
                    var obj = JSON.parse(data);

                    if (obj) {
                        return true;
                    }
                    return false;
                } catch (e) {
                    return false;
                }

                return false;
            };

            /**
            * @inheritDoc
            */
            CubeTextureParser.prototype._iResolveDependency = function (resourceDependency) {
            };

            /**
            * @inheritDoc
            */
            CubeTextureParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
            };

            CubeTextureParser.prototype.parseJson = function () {
                if (CubeTextureParser.supportsData(this.data)) {
                    try  {
                        this._imgLoaderDictionary = new Object();

                        var json = JSON.parse(this.data);
                        var data = json.data;
                        var rec;
                        var rq;

                        for (var c = 0; c < data.length; c++) {
                            rec = data[c];

                            var uri = rec.image;
                            var id = rec.id;

                            rq = new away.net.URLRequest(uri);

                            // Note: Not loading dependencies as we want these to be CubeTexture ( loader will automatically convert to Texture2d ) ;
                            var imgLoader = new away.net.IMGLoader();

                            imgLoader.name = rec.id;
                            imgLoader.load(rq);
                            imgLoader.addEventListener(away.events.Event.COMPLETE, this.onIMGLoadComplete, this);

                            this._imgLoaderDictionary[imgLoader.name] = imgLoader;
                        }

                        if (data.length != 6) {
                            this._pDieWithError('CubeTextureParser: Error - cube texture should have exactly 6 images');
                            this._state = this.STATE_COMPLETE;

                            return;
                        }

                        if (!this.validateCubeData()) {
                            this._pDieWithError("CubeTextureParser: JSON data error - cubes require id of:   \n" + CubeTextureParser.posX + ', ' + CubeTextureParser.negX + ',  \n' + CubeTextureParser.posY + ', ' + CubeTextureParser.negY + ',  \n' + CubeTextureParser.posZ + ', ' + CubeTextureParser.negZ);

                            this._state = this.STATE_COMPLETE;

                            return;
                        }

                        this._state = this.STATE_LOAD_IMAGES;
                    } catch (e) {
                        this._pDieWithError('CubeTexturePaser Error parsing JSON');
                        this._state = this.STATE_COMPLETE;
                    }
                }
            };

            CubeTextureParser.prototype.createCubeTexture = function () {
                var asset = new away.textures.HTMLImageElementCubeTexture(this.getHTMLImageElement(CubeTextureParser.posX), this.getHTMLImageElement(CubeTextureParser.negX), this.getHTMLImageElement(CubeTextureParser.posY), this.getHTMLImageElement(CubeTextureParser.negY), this.getHTMLImageElement(CubeTextureParser.posZ), this.getHTMLImageElement(CubeTextureParser.negZ));

                asset.name = this._iFileName;

                this._pFinalizeAsset(asset, this._iFileName);

                this._state = this.STATE_COMPLETE;
            };

            CubeTextureParser.prototype.validateCubeData = function () {
                return (this.getHTMLImageElement(CubeTextureParser.posX) != null && this.getHTMLImageElement(CubeTextureParser.negX) != null && this.getHTMLImageElement(CubeTextureParser.posY) != null && this.getHTMLImageElement(CubeTextureParser.negY) != null && this.getHTMLImageElement(CubeTextureParser.posZ) != null && this.getHTMLImageElement(CubeTextureParser.negZ) != null);
            };

            CubeTextureParser.prototype.getHTMLImageElement = function (name) {
                var imgLoader = this._imgLoaderDictionary[name];

                if (imgLoader) {
                    return imgLoader.image;
                }

                return null;
            };

            CubeTextureParser.prototype.onIMGLoadComplete = function (e) {
                this._loadedImageCounter++;

                if (this._loadedImageCounter == 6) {
                    this.createCubeTexture();
                }
            };

            /**
            * @inheritDoc
            */
            CubeTextureParser.prototype._pProceedParsing = function () {
                switch (this._state) {
                    case this.STATE_PARSE_DATA:
                        this.parseJson();
                        return away.loaders.ParserBase.MORE_TO_PARSE;

                        break;

                    case this.STATE_LOAD_IMAGES:
                        break;

                    case this.STATE_COMPLETE:
                        return away.loaders.ParserBase.PARSING_DONE;

                        break;
                }
            };
            CubeTextureParser.posX = 'posX';
            CubeTextureParser.negX = 'negX';
            CubeTextureParser.posY = 'posY';
            CubeTextureParser.negY = 'negY';
            CubeTextureParser.posZ = 'posZ';
            CubeTextureParser.negZ = 'negZ';
            return CubeTextureParser;
        })(away.loaders.ParserBase);
        loaders.CubeTextureParser = CubeTextureParser;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        /**
        * AWDParser provides a parser for the AWD data type.
        */
        var AWDParser = (function (_super) {
            __extends(AWDParser, _super);
            /**
            * Creates a new AWDParser object.
            * @param uri The url or id of the data or file to be parsed.
            * @param extra The holder for extra contextual data that the parser might need.
            */
            function AWDParser() {
                _super.call(this, away.loaders.ParserDataFormat.BINARY);
                //set to "true" to have some traces in the Console
                this._debug = true;
                this._startedParsing = false;
                this._texture_users = {};
                this._parsed_header = false;

                this._blocks = new Array();
                this._blocks[0] = new AWDBlock();
                this._blocks[0].data = null;

                this.blendModeDic = new Array();
                this.blendModeDic.push(away.display.BlendMode.NORMAL);
                this.blendModeDic.push(away.display.BlendMode.ADD);
                this.blendModeDic.push(away.display.BlendMode.ALPHA);
                this.blendModeDic.push(away.display.BlendMode.DARKEN);
                this.blendModeDic.push(away.display.BlendMode.DIFFERENCE);
                this.blendModeDic.push(away.display.BlendMode.ERASE);
                this.blendModeDic.push(away.display.BlendMode.HARDLIGHT);
                this.blendModeDic.push(away.display.BlendMode.INVERT);
                this.blendModeDic.push(away.display.BlendMode.LAYER);
                this.blendModeDic.push(away.display.BlendMode.LIGHTEN);
                this.blendModeDic.push(away.display.BlendMode.MULTIPLY);
                this.blendModeDic.push(away.display.BlendMode.NORMAL);
                this.blendModeDic.push(away.display.BlendMode.OVERLAY);
                this.blendModeDic.push(away.display.BlendMode.SCREEN);
                this.blendModeDic.push(away.display.BlendMode.SHADER);
                this.blendModeDic.push(away.display.BlendMode.OVERLAY);

                this._depthSizeDic = new Array();
                this._depthSizeDic.push(256);
                this._depthSizeDic.push(512);
                this._depthSizeDic.push(2048);
                this._depthSizeDic.push(1024);
                this._version = Array();
            }
            AWDParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "awd";
            };

            AWDParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                return (away.loaders.ParserUtil.toString(data, 3) == 'AWD');
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.assets.length == 1) {
                    var isCubeTextureArray = resourceDependency.id.split("#");
                    var ressourceID = isCubeTextureArray[0];
                    var asset;
                    var thisBitmapTexture;
                    var block;

                    if (isCubeTextureArray.length == 1) {
                        asset = resourceDependency.assets[0];
                        if (asset) {
                            var mat;
                            var users;

                            block = this._blocks[resourceDependency.id];
                            block.data = asset;

                            // Reset name of texture to the one defined in the AWD file,
                            // as opposed to whatever the image parser came up with.
                            asset.resetAssetPath(block.name, null, true);
                            block.name = asset.name;

                            // Finalize texture asset to dispatch texture event, which was
                            // previously suppressed while the dependency was loaded.
                            this._pFinalizeAsset(asset);

                            if (this._debug) {
                                console.log("Successfully loaded Bitmap for texture");
                                console.log("Parsed texture: Name = " + block.name);
                            }
                        }
                    }

                    if (isCubeTextureArray.length > 1) {
                        thisBitmapTexture = resourceDependency.assets[0];

                        var tx = thisBitmapTexture;

                        this._cubeTextures[isCubeTextureArray[1]] = tx.htmlImageElement;
                        this._texture_users[ressourceID].push(1);

                        if (this._debug) {
                            console.log("Successfully loaded Bitmap " + this._texture_users[ressourceID].length + " / 6 for Cubetexture");
                        }
                        if (this._texture_users[ressourceID].length == this._cubeTextures.length) {
                            var posX = this._cubeTextures[0];
                            var negX = this._cubeTextures[1];
                            var posY = this._cubeTextures[2];
                            var negY = this._cubeTextures[3];
                            var posZ = this._cubeTextures[4];
                            var negZ = this._cubeTextures[5];

                            asset = new away.textures.HTMLImageElementCubeTexture(posX, negX, posY, negY, posZ, negZ);
                            block = this._blocks[ressourceID];
                            block.data = asset;

                            // Reset name of texture to the one defined in the AWD file,
                            // as opposed to whatever the image parser came up with.
                            asset.resetAssetPath(block.name, null, true);
                            block.name = asset.name;

                            // Finalize texture asset to dispatch texture event, which was
                            // previously suppressed while the dependency was loaded.
                            this._pFinalizeAsset(asset);
                            if (this._debug) {
                                console.log("Parsed CubeTexture: Name = " + block.name);
                            }
                        }
                    }
                }
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                //not used - if a dependcy fails, the awaiting Texture or CubeTexture will never be finalized, and the default-bitmaps will be used.
                // this means, that if one Bitmap of a CubeTexture fails, the CubeTexture will have the DefaultTexture applied for all six Bitmaps.
            };

            /**
            * Resolve a dependency name
            *
            * @param resourceDependency The dependency to be resolved.
            */
            AWDParser.prototype._iResolveDependencyName = function (resourceDependency, asset) {
                var oldName = asset.name;

                if (asset) {
                    var block = this._blocks[parseInt(resourceDependency.id)];

                    // Reset name of texture to the one defined in the AWD file,
                    // as opposed to whatever the image parser came up with.
                    asset.resetAssetPath(block.name, null, true);
                }

                var newName = asset.name;

                asset.name = oldName;

                return newName;
            };

            /**
            * @inheritDoc
            */
            AWDParser.prototype._pProceedParsing = function () {
                if (!this._startedParsing) {
                    this._byteData = this._pGetByteData();
                    this._startedParsing = true;
                }

                if (!this._parsed_header) {
                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._byteData.endian = Endian.LITTLE_ENDIAN;
                    //----------------------------------------------------------------------------
                    //----------------------------------------------------------------------------
                    // Parse header and decompress body if needed
                    this.parseHeader();

                    switch (this._compression) {
                        case AWDParser.DEFLATE:
                        case AWDParser.LZMA:
                            this._pDieWithError('Compressed AWD formats not yet supported');
                            break;

                        case AWDParser.UNCOMPRESSED:
                            this._body = this._byteData;
                            break;
                    }

                    this._parsed_header = true;
                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._body.endian = Endian.LITTLE_ENDIAN;// Should be default
                    //----------------------------------------------------------------------------
                }

                if (this._body) {
                    while (this._body.getBytesAvailable() > 0 && !this.parsingPaused) {
                        this.parseNextBlock();
                    }

                    if (this._body.getBytesAvailable() == 0) {
                        this.dispose();
                        return away.loaders.ParserBase.PARSING_DONE;
                    } else {
                        return away.loaders.ParserBase.MORE_TO_PARSE;
                    }
                } else {
                    switch (this._compression) {
                        case AWDParser.DEFLATE:
                        case AWDParser.LZMA:
                            if (this._debug) {
                                console.log("(!) AWDParser Error: Compressed AWD formats not yet supported (!)");
                            }

                            break;
                    }

                    // Error - most likely _body not set because we do not support compression.
                    return away.loaders.ParserBase.PARSING_DONE;
                }
            };

            AWDParser.prototype.dispose = function () {
                for (var c in this._blocks) {
                    var b = this._blocks[c];
                    b.dispose();
                }
            };

            AWDParser.prototype.parseNextBlock = function () {
                var block;
                var assetData;
                var isParsed = false;
                var ns;
                var type;
                var flags;
                var len;

                this._cur_block_id = this._body.readUnsignedInt();

                ns = this._body.readUnsignedByte();
                type = this._body.readUnsignedByte();
                flags = this._body.readUnsignedByte();
                len = this._body.readUnsignedInt();

                var blockCompression = bitFlags.test(flags, bitFlags.FLAG4);
                var blockCompressionLZMA = bitFlags.test(flags, bitFlags.FLAG5);

                if (this._accuracyOnBlocks) {
                    this._accuracyMatrix = bitFlags.test(flags, bitFlags.FLAG1);
                    this._accuracyGeo = bitFlags.test(flags, bitFlags.FLAG2);
                    this._accuracyProps = bitFlags.test(flags, bitFlags.FLAG3);
                    this._geoNrType = AWDParser.FLOAT32;

                    if (this._accuracyGeo) {
                        this._geoNrType = AWDParser.FLOAT64;
                    }

                    this._matrixNrType = AWDParser.FLOAT32;

                    if (this._accuracyMatrix) {
                        this._matrixNrType = AWDParser.FLOAT64;
                    }

                    this._propsNrType = AWDParser.FLOAT32;

                    if (this._accuracyProps) {
                        this._propsNrType = AWDParser.FLOAT64;
                    }
                }

                var blockEndAll = this._body.position + len;

                if (len > this._body.getBytesAvailable()) {
                    this._pDieWithError('AWD2 block length is bigger than the bytes that are available!');
                    this._body.position += this._body.getBytesAvailable();
                    return;
                }
                this._newBlockBytes = new away.utils.ByteArray();

                this._body.readBytes(this._newBlockBytes, 0, len);

                if (blockCompression) {
                    this._pDieWithError('Compressed AWD formats not yet supported');
                    /*
                    if (blockCompressionLZMA)
                    {
                    this._newBlockBytes.uncompress(AWDParser.COMPRESSIONMODE_LZMA);
                    }
                    else
                    {
                    this._newBlockBytes.uncompress();
                    }
                    */
                }

                //----------------------------------------------------------------------------
                // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                //----------------------------------------------------------------------------
                //this._newBlockBytes.endian = Endian.LITTLE_ENDIAN;
                //----------------------------------------------------------------------------
                this._newBlockBytes.position = 0;
                block = new AWDBlock();
                block.len = this._newBlockBytes.position + len;
                block.id = this._cur_block_id;

                var blockEndBlock = this._newBlockBytes.position + len;

                if (blockCompression) {
                    this._pDieWithError('Compressed AWD formats not yet supported');
                    //blockEndBlock   = this._newBlockBytes.position + this._newBlockBytes.length;
                    //block.len       = blockEndBlock;
                }

                if (this._debug) {
                    console.log("AWDBlock:  ID = " + this._cur_block_id + " | TypeID = " + type + " | Compression = " + blockCompression + " | Matrix-Precision = " + this._accuracyMatrix + " | Geometry-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
                }

                this._blocks[this._cur_block_id] = block;

                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    switch (type) {
                        case 11:
                            this.parsePrimitves(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 31:
                            break;
                        case 41:
                            this.parseLight(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 42:
                            this.parseCamera(this._cur_block_id);
                            isParsed = true;
                            break;

                        case 51:
                            this.parseLightPicker(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 81:
                            this.parseMaterial_v1(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 83:
                            this.parseCubeTexture(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 91:
                            this.parseSharedMethodBlock(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 92:
                            this.parseShadowMethodBlock(this._cur_block_id);
                            isParsed = true;
                            break;
                        case 111:
                            break;
                        case 112:
                            break;
                        case 113:
                            break;
                        case 122:
                            break;
                        case 253:
                            this.parseCommand(this._cur_block_id);
                            isParsed = true;
                            break;
                    }
                    //*/
                }

                if (isParsed == false) {
                    switch (type) {
                        case 1:
                            this.parseTriangleGeometrieBlock(this._cur_block_id);
                            break;
                        case 22:
                            this.parseContainer(this._cur_block_id);
                            break;
                        case 23:
                            this.parseMeshInstance(this._cur_block_id);
                            break;
                        case 81:
                            this.parseMaterial(this._cur_block_id);
                            break;
                        case 82:
                            this.parseTexture(this._cur_block_id);
                            break;
                        case 101:
                            break;
                        case 102:
                            break;
                        case 103:
                            break;
                        case 121:
                            break;
                        case 254:
                            this.parseNameSpace(this._cur_block_id);
                            break;
                        case 255:
                            this.parseMetaData(this._cur_block_id);
                            break;
                        default:
                            if (this._debug) {
                                console.log("AWDBlock:   Unknown BlockType  (BlockID = " + this._cur_block_id + ") - Skip " + len + " bytes");
                            }
                            this._newBlockBytes.position += len;
                            break;
                    }
                }

                //*/
                var msgCnt = 0;
                if (this._newBlockBytes.position == blockEndBlock) {
                    if (this._debug) {
                        if (block.errorMessages) {
                            while (msgCnt < block.errorMessages.length) {
                                console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
                                msgCnt++;
                            }
                        }
                    }
                    if (this._debug) {
                        console.log("\n");
                    }
                } else {
                    if (this._debug) {
                        console.log("  (!)(!)(!) Error while reading AWDBlock ID " + this._cur_block_id + " = skip to next block");

                        if (block.errorMessages) {
                            while (msgCnt < block.errorMessages.length) {
                                console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
                                msgCnt++;
                            }
                        }
                    }
                }

                this._body.position = blockEndAll;
                this._newBlockBytes = null;
            };

            //--Parser Blocks---------------------------------------------------------------------------
            //Block ID = 1
            AWDParser.prototype.parseTriangleGeometrieBlock = function (blockID) {
                var geom = new away.base.Geometry();

                // Read name and sub count
                var name = this.parseVarStr();
                var num_subs = this._newBlockBytes.readUnsignedShort();

                // Read optional properties
                var props = this.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });
                var geoScaleU = props.get(1, 1);
                var geoScaleV = props.get(2, 1);

                // Loop through sub meshes
                var subs_parsed = 0;
                while (subs_parsed < num_subs) {
                    var i;
                    var sm_len, sm_end;
                    var sub_geoms;
                    var w_indices;
                    var weights;

                    sm_len = this._newBlockBytes.readUnsignedInt();
                    sm_end = this._newBlockBytes.position + sm_len;

                    // Ignore for now
                    var subProps = this.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });

                    while (this._newBlockBytes.position < sm_end) {
                        var idx = 0;
                        var str_ftype, str_type, str_len, str_end;

                        // Type, field type, length
                        str_type = this._newBlockBytes.readUnsignedByte();
                        str_ftype = this._newBlockBytes.readUnsignedByte();
                        str_len = this._newBlockBytes.readUnsignedInt();
                        str_end = this._newBlockBytes.position + str_len;

                        var x, y, z;

                        if (str_type == 1) {
                            var verts = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                // TODO: Respect stream field type
                                x = this.readNumber(this._accuracyGeo);
                                y = this.readNumber(this._accuracyGeo);
                                z = this.readNumber(this._accuracyGeo);

                                verts[idx++] = x;
                                verts[idx++] = y;
                                verts[idx++] = z;
                            }
                        } else if (str_type == 2) {
                            var indices = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                // TODO: Respect stream field type
                                indices[idx++] = this._newBlockBytes.readUnsignedShort();
                            }
                        } else if (str_type == 3) {
                            var uvs = new Array();
                            while (this._newBlockBytes.position < str_end) {
                                uvs[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else if (str_type == 4) {
                            var normals = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                normals[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else if (str_type == 6) {
                            w_indices = Array();

                            while (this._newBlockBytes.position < str_end) {
                                w_indices[idx++] = this._newBlockBytes.readUnsignedShort() * 3;
                            }
                        } else if (str_type == 7) {
                            weights = new Array();

                            while (this._newBlockBytes.position < str_end) {
                                weights[idx++] = this.readNumber(this._accuracyGeo);
                            }
                        } else {
                            this._newBlockBytes.position = str_end;
                        }
                    }

                    this.parseUserAttributes();

                    sub_geoms = away.utils.GeometryUtils.fromVectors(verts, indices, uvs, normals, null, weights, w_indices);

                    var scaleU = subProps.get(1, 1);
                    var scaleV = subProps.get(2, 1);
                    var setSubUVs = false;

                    if ((geoScaleU != scaleU) || (geoScaleV != scaleV)) {
                        setSubUVs = true;
                        scaleU = geoScaleU / scaleU;
                        scaleV = geoScaleV / scaleV;
                    }

                    for (i = 0; i < sub_geoms.length; i++) {
                        if (setSubUVs)
                            sub_geoms[i].scaleUV(scaleU, scaleV);
                        geom.addSubGeometry(sub_geoms[i]);
                        // TODO: Somehow map in-sub to out-sub indices to enable look-up
                        // when creating meshes (and their material assignments.)
                    }
                    subs_parsed++;
                }
                if ((geoScaleU != 1) || (geoScaleV != 1))
                    geom.scaleUV(geoScaleU, geoScaleV);
                this.parseUserAttributes();
                this._pFinalizeAsset(geom, name);
                this._blocks[blockID].data = geom;

                if (this._debug) {
                    console.log("Parsed a TriangleGeometry: Name = " + name + "| SubGeometries = " + sub_geoms.length);
                }
            };

            //Block ID = 11
            AWDParser.prototype.parsePrimitves = function (blockID) {
                var name;
                var geom;
                var primType;
                var subs_parsed;
                var props;
                var bsm;

                // Read name and sub count
                name = this.parseVarStr();
                primType = this._newBlockBytes.readUnsignedByte();
                props = this.parseProperties({ 101: this._geoNrType, 102: this._geoNrType, 103: this._geoNrType, 110: this._geoNrType, 111: this._geoNrType, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 303: AWDParser.UINT16, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 703: AWDParser.BOOL, 704: AWDParser.BOOL });

                var primitveTypes = ["Unsupported Type-ID", "PlaneGeometry", "CubeGeometry", "SphereGeometry", "CylinderGeometry", "ConeGeometry", "CapsuleGeometry", "TorusGeometry"];

                switch (primType) {
                    case 1:
                        geom = new away.primitives.PlaneGeometry(props.get(101, 100), props.get(102, 100), props.get(301, 1), props.get(302, 1), props.get(701, true), props.get(702, false));
                        break;

                    case 2:
                        geom = new away.primitives.CubeGeometry(props.get(101, 100), props.get(102, 100), props.get(103, 100), props.get(301, 1), props.get(302, 1), props.get(303, 1), props.get(701, true));
                        break;

                    case 3:
                        geom = new away.primitives.SphereGeometry(props.get(101, 50), props.get(301, 16), props.get(302, 12), props.get(701, true));
                        break;

                    case 4:
                        geom = new away.primitives.CylinderGeometry(props.get(101, 50), props.get(102, 50), props.get(103, 100), props.get(301, 16), props.get(302, 1), true, true, true);
                        if (!props.get(701, true))
                            (geom).topClosed = false;
                        if (!props.get(702, true))
                            (geom).bottomClosed = false;
                        if (!props.get(703, true))
                            (geom).yUp = false;

                        break;

                    case 5:
                        geom = new away.primitives.ConeGeometry(props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 1), props.get(701, true), props.get(702, true));
                        break;

                    case 6:
                        geom = new away.primitives.CapsuleGeometry(props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 15), props.get(701, true));
                        break;

                    case 7:
                        geom = new away.primitives.TorusGeometry(props.get(101, 50), props.get(102, 50), props.get(301, 16), props.get(302, 8), props.get(701, true));
                        break;

                    default:
                        geom = new away.base.Geometry();
                        console.log("ERROR: UNSUPPORTED PRIMITIVE_TYPE");
                        break;
                }

                if ((props.get(110, 1) != 1) || (props.get(111, 1) != 1)) {
                    geom.subGeometries;
                    geom.scaleUV(props.get(110, 1), props.get(111, 1));
                }

                this.parseUserAttributes();
                geom.name = name;
                this._pFinalizeAsset(geom, name);
                this._blocks[blockID].data = geom;

                if (this._debug) {
                    if ((primType < 0) || (primType > 7)) {
                        primType = 0;
                    }
                    console.log("Parsed a Primivite: Name = " + name + "| type = " + primitveTypes[primType]);
                }
            };

            // Block ID = 22
            AWDParser.prototype.parseContainer = function (blockID) {
                var name;
                var par_id;
                var mtx;
                var ctr;
                var parent;

                par_id = this._newBlockBytes.readUnsignedInt();
                mtx = this.parseMatrix3D();
                name = this.parseVarStr();

                var parentName = "Root (TopLevel)";
                ctr = new away.containers.ObjectContainer3D();
                ctr.transform = mtx;

                var returnedArray = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET]);

                if (returnedArray[0]) {
                    var obj = (returnedArray[1]).addChild(ctr);
                    parentName = (returnedArray[1]).name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this ObjectContainer3D");
                }

                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    var props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });
                    ctr.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                } else {
                    this.parseProperties(null);
                }

                // the extraProperties should only be set for AWD2.1-Files, but is read for both versions
                ctr.extra = this.parseUserAttributes();

                this._pFinalizeAsset(ctr, name);
                this._blocks[blockID].data = ctr;

                if (this._debug) {
                    console.log("Parsed a Container: Name = '" + name + "' | Parent-Name = " + parentName);
                }
            };

            // Block ID = 23
            AWDParser.prototype.parseMeshInstance = function (blockID) {
                var num_materials;
                var materials_parsed;
                var parent;
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var parentName = "Root (TopLevel)";
                var data_id = this._newBlockBytes.readUnsignedInt();
                var geom;
                var returnedArrayGeometry = this.getAssetByID(data_id, [away.library.AssetType.GEOMETRY]);

                if (returnedArrayGeometry[0]) {
                    geom = returnedArrayGeometry[1];
                } else {
                    this._blocks[blockID].addError("Could not find a Geometry for this Mesh. A empty Geometry is created!");
                    geom = new away.base.Geometry();
                }

                this._blocks[blockID].geoID = data_id;
                var materials = new Array();
                num_materials = this._newBlockBytes.readUnsignedShort();

                var materialNames = new Array();
                materials_parsed = 0;

                var returnedArrayMaterial;

                while (materials_parsed < num_materials) {
                    var mat_id;
                    mat_id = this._newBlockBytes.readUnsignedInt();
                    returnedArrayMaterial = this.getAssetByID(mat_id, [away.library.AssetType.MATERIAL]);
                    if ((!returnedArrayMaterial[0]) && (mat_id > 0)) {
                        this._blocks[blockID].addError("Could not find Material Nr " + materials_parsed + " (ID = " + mat_id + " ) for this Mesh");
                    }

                    var m = returnedArrayMaterial[1];

                    materials.push(m);
                    materialNames.push(m.name);

                    materials_parsed++;
                }

                var mesh = new away.entities.Mesh(geom, null);
                mesh.transform = mtx;

                var returnedArrayParent = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET]);

                if (returnedArrayParent[0]) {
                    var objC = returnedArrayParent[1];
                    objC.addChild(mesh);
                    parentName = objC.name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this Mesh");
                }

                if (materials.length >= 1 && mesh.subMeshes.length == 1) {
                    mesh.material = materials[0];
                } else if (materials.length > 1) {
                    var i;

                    for (i = 0; i < mesh.subMeshes.length; i++) {
                        mesh.subMeshes[i].material = materials[Math.min(materials.length - 1, i)];
                    }
                }
                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    var props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8, 5: AWDParser.BOOL });
                    mesh.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                    mesh.castsShadows = props.get(5, true);
                } else {
                    this.parseProperties(null);
                }

                mesh.extra = this.parseUserAttributes();

                this._pFinalizeAsset(mesh, name);
                this._blocks[blockID].data = mesh;

                if (this._debug) {
                    console.log("Parsed a Mesh: Name = '" + name + "' | Parent-Name = " + parentName + "| Geometry-Name = " + geom.name + " | SubMeshes = " + mesh.subMeshes.length + " | Mat-Names = " + materialNames.toString());
                }
            };

            //Block ID = 41
            AWDParser.prototype.parseLight = function (blockID) {
                var light;
                var newShadowMapper;

                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var lightType = this._newBlockBytes.readUnsignedByte();
                var props = this.parseProperties({ 1: this._propsNrType, 2: this._propsNrType, 3: AWDParser.COLOR, 4: this._propsNrType, 5: this._propsNrType, 6: AWDParser.BOOL, 7: AWDParser.COLOR, 8: this._propsNrType, 9: AWDParser.UINT8, 10: AWDParser.UINT8, 11: this._propsNrType, 12: AWDParser.UINT16, 21: this._matrixNrType, 22: this._matrixNrType, 23: this._matrixNrType });
                var shadowMapperType = props.get(9, 0);
                var parentName = "Root (TopLevel)";
                var lightTypes = ["Unsupported LightType", "PointLight", "DirectionalLight"];
                var shadowMapperTypes = ["No ShadowMapper", "DirectionalShadowMapper", "NearDirectionalShadowMapper", "CascadeShadowMapper", "CubeMapShadowMapper"];

                if (lightType == 1) {
                    light = new away.lights.PointLight();

                    (light).radius = props.get(1, 90000);
                    (light).fallOff = props.get(2, 100000);

                    if (shadowMapperType > 0) {
                        if (shadowMapperType == 4) {
                            newShadowMapper = new away.lights.CubeMapShadowMapper();
                        }
                    }

                    light.transform = mtx;
                }

                if (lightType == 2) {
                    light = new away.lights.DirectionalLight(props.get(21, 0), props.get(22, -1), props.get(23, 1));

                    if (shadowMapperType > 0) {
                        if (shadowMapperType == 1) {
                            newShadowMapper = new away.lights.DirectionalShadowMapper();
                        }
                        //if (shadowMapperType == 2)
                        //  newShadowMapper = new NearDirectionalShadowMapper(props.get(11, 0.5));
                        //if (shadowMapperType == 3)
                        //   newShadowMapper = new CascadeShadowMapper(props.get(12, 3));
                    }
                }
                light.color = props.get(3, 0xffffff);
                light.specular = props.get(4, 1.0);
                light.diffuse = props.get(5, 1.0);
                light.ambientColor = props.get(7, 0xffffff);
                light.ambient = props.get(8, 0.0);

                if (newShadowMapper) {
                    if (newShadowMapper instanceof away.lights.CubeMapShadowMapper) {
                        if (props.get(10, 1) != 1) {
                            newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 1)];
                        }
                    } else {
                        if (props.get(10, 2) != 2) {
                            newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 2)];
                        }
                    }

                    light.shadowMapper = newShadowMapper;
                    light.castsShadows = true;
                }

                if (par_id != 0) {
                    var returnedArrayParent = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET]);

                    if (returnedArrayParent[0]) {
                        (returnedArrayParent[1]).addChild(light);
                        parentName = (returnedArrayParent[1]).name;
                    } else {
                        this._blocks[blockID].addError("Could not find a parent for this Light");
                    }
                }

                this.parseUserAttributes();

                this._pFinalizeAsset(light, name);

                this._blocks[blockID].data = light;

                if (this._debug)
                    console.log("Parsed a Light: Name = '" + name + "' | Type = " + lightTypes[lightType] + " | Parent-Name = " + parentName + " | ShadowMapper-Type = " + shadowMapperTypes[shadowMapperType]);
            };

            //Block ID = 43
            AWDParser.prototype.parseCamera = function (blockID) {
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();
                var parentName = "Root (TopLevel)";
                var lens;

                this._newBlockBytes.readUnsignedByte();
                this._newBlockBytes.readShort();

                var lenstype = this._newBlockBytes.readShort();
                var props = this.parseProperties({ 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 104: this._propsNrType });

                switch (lenstype) {
                    case 5001:
                        lens = new away.cameras.PerspectiveLens(props.get(101, 60));
                        break;
                    case 5002:
                        lens = new away.cameras.OrthographicLens(props.get(101, 500));
                        break;
                    case 5003:
                        lens = new away.cameras.OrthographicOffCenterLens(props.get(101, -400), props.get(102, 400), props.get(103, -300), props.get(104, 300));
                        break;
                    default:
                        console.log("unsupportedLenstype");
                        return;
                }

                var camera = new away.cameras.Camera3D(lens);
                camera.transform = mtx;

                var returnedArrayParent = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET]);

                if (returnedArrayParent[0]) {
                    var objC = returnedArrayParent[1];
                    objC.addChild(camera);

                    parentName = objC.name;
                } else if (par_id > 0) {
                    this._blocks[blockID].addError("Could not find a parent for this Camera");
                }

                camera.name = name;
                props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });
                camera.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                camera.extra = this.parseUserAttributes();

                this._pFinalizeAsset(camera, name);

                this._blocks[blockID].data = camera;

                if (this._debug) {
                    console.log("Parsed a Camera: Name = '" + name + "' | Lenstype = " + lens + " | Parent-Name = " + parentName);
                }
            };

            //Block ID = 51
            AWDParser.prototype.parseLightPicker = function (blockID) {
                var name = this.parseVarStr();
                var numLights = this._newBlockBytes.readUnsignedShort();
                var lightsArray = new Array();
                var k = 0;
                var lightID = 0;

                var returnedArrayLight;
                var lightsArrayNames = new Array();

                for (k = 0; k < numLights; k++) {
                    lightID = this._newBlockBytes.readUnsignedInt();
                    returnedArrayLight = this.getAssetByID(lightID, [away.library.AssetType.LIGHT]);

                    if (returnedArrayLight[0]) {
                        lightsArray.push(returnedArrayLight[1]);
                        lightsArrayNames.push((returnedArrayLight[1]).name);
                    } else {
                        this._blocks[blockID].addError("Could not find a Light Nr " + k + " (ID = " + lightID + " ) for this LightPicker");
                    }
                }

                if (lightsArray.length == 0) {
                    this._blocks[blockID].addError("Could not create this LightPicker, cause no Light was found.");
                    this.parseUserAttributes();
                    return;
                }

                var lightPick = new away.materials.StaticLightPicker(lightsArray);
                lightPick.name = name;

                this.parseUserAttributes();
                this._pFinalizeAsset(lightPick, name);

                this._blocks[blockID].data = lightPick;
                if (this._debug) {
                    console.log("Parsed a StaticLightPicker: Name = '" + name + "' | Texture-Name = " + lightsArrayNames.toString());
                }
            };

            //Block ID = 81
            AWDParser.prototype.parseMaterial = function (blockID) {
                // TODO: not used
                ////blockLength = block.len;
                var name;
                var type;
                var props;
                var mat;
                var attributes;
                var finalize;
                var num_methods;
                var methods_parsed;
                var returnedArray;

                name = this.parseVarStr();
                type = this._newBlockBytes.readUnsignedByte();
                num_methods = this._newBlockBytes.readUnsignedByte();

                // Read material numerical properties
                // (1=color, 2=bitmap url, 10=alpha, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
                props = this.parseProperties({ 1: AWDParser.INT32, 2: AWDParser.BADDR, 10: this._propsNrType, 11: AWDParser.BOOL, 12: this._propsNrType, 13: AWDParser.BOOL });

                methods_parsed = 0;
                while (methods_parsed < num_methods) {
                    var method_type;

                    method_type = this._newBlockBytes.readUnsignedShort();
                    this.parseProperties(null);
                    this.parseUserAttributes();
                    methods_parsed += 1;
                }
                var debugString = "";
                attributes = this.parseUserAttributes();
                if (type === 1) {
                    debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
                    var color;
                    color = props.get(1, 0xcccccc);
                    if (this.materialMode < 2)
                        mat = new away.materials.ColorMaterial(color, props.get(10, 1.0));
else
                        mat = new away.materials.ColorMultiPassMaterial(color);
                } else if (type === 2) {
                    var tex_addr = props.get(2, 0);

                    returnedArray = this.getAssetByID(tex_addr, [away.library.AssetType.TEXTURE]);
                    if ((!returnedArray[0]) && (tex_addr > 0)) {
                        this._blocks[blockID].addError("Could not find the DiffsueTexture (ID = " + tex_addr + " ) for this Material");
                    }

                    if (this.materialMode < 2) {
                        mat = new away.materials.TextureMaterial(returnedArray[1]);

                        var txMaterial = mat;

                        txMaterial.alphaBlending = props.get(11, false);
                        txMaterial.alpha = props.get(10, 1.0);
                        debugString += "Parsed a TextureMaterial(SinglePass): Name = '" + name + "' | Texture-Name = " + mat.name;
                    } else {
                        mat = new away.materials.TextureMultiPassMaterial(returnedArray[1]);
                        debugString += "Parsed a TextureMaterial(MultipAss): Name = '" + name + "' | Texture-Name = " + mat.name;
                    }
                }

                mat.extra = attributes;
                if (this.materialMode < 2) {
                    var spmb = mat;
                    spmb.alphaThreshold = props.get(12, 0.0);
                } else {
                    var mpmb = mat;
                    mpmb.alphaThreshold = props.get(12, 0.0);
                }

                mat.repeat = props.get(13, false);
                this._pFinalizeAsset(mat, name);
                this._blocks[blockID].data = mat;

                if (this._debug) {
                    console.log(debugString);
                }
            };

            // Block ID = 81 AWD2.1
            AWDParser.prototype.parseMaterial_v1 = function (blockID) {
                var mat;
                var normalTexture;
                var specTexture;
                var returnedArray;

                var name = this.parseVarStr();
                var type = this._newBlockBytes.readUnsignedByte();
                var num_methods = this._newBlockBytes.readUnsignedByte();
                var props = this.parseProperties({ 1: AWDParser.UINT32, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 4: AWDParser.UINT8, 5: AWDParser.BOOL, 6: AWDParser.BOOL, 7: AWDParser.BOOL, 8: AWDParser.BOOL, 9: AWDParser.UINT8, 10: this._propsNrType, 11: AWDParser.BOOL, 12: this._propsNrType, 13: AWDParser.BOOL, 15: this._propsNrType, 16: AWDParser.UINT32, 17: AWDParser.BADDR, 18: this._propsNrType, 19: this._propsNrType, 20: AWDParser.UINT32, 21: AWDParser.BADDR, 22: AWDParser.BADDR });
                var spezialType = props.get(4, 0);
                var debugString = "";

                if (spezialType >= 2) {
                    this._blocks[blockID].addError("Material-spezialType '" + spezialType + "' is not supported, can only be 0:singlePass, 1:MultiPass !");
                    return;
                }

                if (this.materialMode == 1) {
                    spezialType = 0;
                } else if (this.materialMode == 2) {
                    spezialType = 1;
                }

                if (spezialType < 2) {
                    if (type == 1) {
                        var color = props.get(1, 0xcccccc);

                        if (spezialType == 1) {
                            mat = new away.materials.ColorMultiPassMaterial(color);
                            debugString += "Parsed a ColorMaterial(MultiPass): Name = '" + name + "' | ";
                        } else {
                            mat = new away.materials.ColorMaterial(color, props.get(10, 1.0));
                            (mat).alphaBlending = props.get(11, false);
                            debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
                        }
                    } else if (type == 2) {
                        var tex_addr = props.get(2, 0);
                        returnedArray = this.getAssetByID(tex_addr, [away.library.AssetType.TEXTURE]);

                        if ((!returnedArray[0]) && (tex_addr > 0)) {
                            this._blocks[blockID].addError("Could not find the DiffuseTexture (ID = " + tex_addr + " ) for this TextureMaterial");
                        }
                        var texture = returnedArray[1];
                        var ambientTexture;
                        var ambientTex_addr = props.get(17, 0);

                        returnedArray = this.getAssetByID(ambientTex_addr, [away.library.AssetType.TEXTURE]);

                        if ((!returnedArray[0]) && (ambientTex_addr != 0)) {
                            this._blocks[blockID].addError("Could not find the AmbientTexture (ID = " + ambientTex_addr + " ) for this TextureMaterial");
                        }

                        if (returnedArray[0]) {
                            ambientTexture = returnedArray[1];
                        }

                        if (spezialType == 1) {
                            mat = new away.materials.TextureMultiPassMaterial(texture);
                            debugString += "Parsed a TextureMaterial(MultiPass): Name = '" + name + "' | Texture-Name = " + texture.name;

                            if (ambientTexture) {
                                (mat).ambientTexture = ambientTexture;
                                debugString += " | AmbientTexture-Name = " + ambientTexture.name;
                            }
                        } else {
                            mat = new away.materials.TextureMaterial(texture);
                            debugString += "Parsed a TextureMaterial(SinglePass): Name = '" + name + "' | Texture-Name = " + texture.name;

                            if (ambientTexture) {
                                (mat).ambientTexture = ambientTexture;
                                debugString += " | AmbientTexture-Name = " + ambientTexture.name;
                            }

                            (mat).alpha = props.get(10, 1.0);
                            (mat).alphaBlending = props.get(11, false);
                        }
                    }

                    var normalTex_addr = props.get(3, 0);

                    returnedArray = this.getAssetByID(normalTex_addr, [away.library.AssetType.TEXTURE]);

                    if ((!returnedArray[0]) && (normalTex_addr != 0)) {
                        this._blocks[blockID].addError("Could not find the NormalTexture (ID = " + normalTex_addr + " ) for this TextureMaterial");
                    }

                    if (returnedArray[0]) {
                        normalTexture = returnedArray[1];
                        debugString += " | NormalTexture-Name = " + normalTexture.name;
                    }

                    var specTex_addr = props.get(21, 0);
                    returnedArray = this.getAssetByID(specTex_addr, [away.library.AssetType.TEXTURE]);

                    if ((!returnedArray[0]) && (specTex_addr != 0)) {
                        this._blocks[blockID].addError("Could not find the SpecularTexture (ID = " + specTex_addr + " ) for this TextureMaterial");
                    }
                    if (returnedArray[0]) {
                        specTexture = returnedArray[1];
                        debugString += " | SpecularTexture-Name = " + specTexture.name;
                    }

                    var lightPickerAddr = props.get(22, 0);
                    returnedArray = this.getAssetByID(lightPickerAddr, [away.library.AssetType.LIGHT_PICKER]);

                    if ((!returnedArray[0]) && (lightPickerAddr)) {
                        this._blocks[blockID].addError("Could not find the LightPicker (ID = " + lightPickerAddr + " ) for this TextureMaterial");
                    } else {
                        (mat).lightPicker = returnedArray[1];
                        //debugString+=" | Lightpicker-Name = "+LightPickerBase(returnedArray[1]).name;
                    }

                    (mat).smooth = props.get(5, true);
                    (mat).mipmap = props.get(6, true);
                    (mat).bothSides = props.get(7, false);
                    (mat).alphaPremultiplied = props.get(8, false);
                    (mat).blendMode = this.blendModeDic[props.get(9, 0)];
                    (mat).repeat = props.get(13, false);

                    if (spezialType == 0) {
                        if (normalTexture) {
                            (mat).normalMap = normalTexture;
                        }
                        if (specTexture) {
                            (mat).specularMap = specTexture;
                        }

                        (mat).alphaThreshold = props.get(12, 0.0);
                        (mat).ambient = props.get(15, 1.0);
                        (mat).ambientColor = props.get(16, 0xffffff);
                        (mat).specular = props.get(18, 1.0);
                        (mat).gloss = props.get(19, 50);
                        (mat).specularColor = props.get(20, 0xffffff);
                    } else {
                        if (normalTexture) {
                            (mat).normalMap = normalTexture;
                        }
                        if (specTexture) {
                            (mat).specularMap = specTexture;
                        }

                        (mat).alphaThreshold = props.get(12, 0.0);
                        (mat).ambient = props.get(15, 1.0);
                        (mat).ambientColor = props.get(16, 0xffffff);
                        (mat).specular = props.get(18, 1.0);
                        (mat).gloss = props.get(19, 50);
                        (mat).specularColor = props.get(20, 0xffffff);
                    }

                    var methods_parsed = 0;
                    var targetID;

                    while (methods_parsed < num_methods) {
                        var method_type;
                        method_type = this._newBlockBytes.readUnsignedShort();

                        props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 801: AWDParser.MTX4x4 });

                        switch (method_type) {
                            case 999:
                                targetID = props.get(1, 0);
                                returnedArray = this.getAssetByID(targetID, [away.library.AssetType.EFFECTS_METHOD]);

                                if (!returnedArray[0]) {
                                    this._blocks[blockID].addError("Could not find the EffectMethod (ID = " + targetID + " ) for this Material");
                                } else {
                                    if (spezialType == 0) {
                                        (mat).addMethod(returnedArray[1]);
                                    }
                                    if (spezialType == 1) {
                                        (mat).addMethod(returnedArray[1]);
                                    }

                                    debugString += " | EffectMethod-Name = " + (returnedArray[1]).name;
                                }

                                break;

                            case 998:
                                targetID = props.get(1, 0);
                                returnedArray = this.getAssetByID(targetID, [away.library.AssetType.SHADOW_MAP_METHOD]);

                                if (!returnedArray[0]) {
                                    this._blocks[blockID].addError("Could not find the ShadowMethod (ID = " + targetID + " ) for this Material");
                                } else {
                                    if (spezialType == 0) {
                                        (mat).shadowMethod = returnedArray[1];
                                    }

                                    if (spezialType == 1) {
                                        (mat).shadowMethod = returnedArray[1];
                                    }

                                    debugString += " | ShadowMethod-Name = " + (returnedArray[1]).name;
                                }

                                break;
                        }
                        this.parseUserAttributes();
                        methods_parsed += 1;
                    }
                }
                (mat).extra = this.parseUserAttributes();
                this._pFinalizeAsset(mat, name);

                this._blocks[blockID].data = mat;
                if (this._debug) {
                    console.log(debugString);
                }
            };

            //Block ID = 82
            AWDParser.prototype.parseTexture = function (blockID) {
                var asset;

                this._blocks[blockID].name = this.parseVarStr();

                var type = this._newBlockBytes.readUnsignedByte();
                var data_len;

                this._texture_users[this._cur_block_id.toString()] = [];

                if (type == 0) {
                    data_len = this._newBlockBytes.readUnsignedInt();
                    var url;
                    url = this._newBlockBytes.readUTFBytes(data_len);
                    this._pAddDependency(this._cur_block_id.toString(), new away.net.URLRequest(url), false, null, true);
                } else {
                    data_len = this._newBlockBytes.readUnsignedInt();

                    var data;
                    data = new away.utils.ByteArray();
                    this._newBlockBytes.readBytes(data, 0, data_len);

                    //
                    // AWDParser - Fix for FireFox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=715075 .
                    //
                    // Converting data to image here instead of parser - fix FireFox bug where image width / height is 0 when created from data
                    // This gives the browser time to initialise image width / height.
                    this._pAddDependency(this._cur_block_id.toString(), null, false, away.loaders.ParserUtil.byteArrayToImage(data), true);
                    //this._pAddDependency(this._cur_block_id.toString(), null, false, data, true);
                }

                // Ignore for now
                this.parseProperties(null);
                this._blocks[blockID].extras = this.parseUserAttributes();
                this._pPauseAndRetrieveDependencies();
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    var textureStylesNames = ["external", "embed"];
                    console.log("Start parsing a " + textureStylesNames[type] + " Bitmap for Texture");
                }
            };

            //Block ID = 83
            AWDParser.prototype.parseCubeTexture = function (blockID) {
                //blockLength = block.len;
                var data_len;
                var asset;
                var i;

                this._cubeTextures = new Array();
                this._texture_users[this._cur_block_id.toString()] = [];

                var type = this._newBlockBytes.readUnsignedByte();

                this._blocks[blockID].name = this.parseVarStr();

                for (i = 0; i < 6; i++) {
                    this._texture_users[this._cur_block_id.toString()] = [];
                    this._cubeTextures.push(null);

                    if (type == 0) {
                        data_len = this._newBlockBytes.readUnsignedInt();
                        var url;
                        url = this._newBlockBytes.readUTFBytes(data_len);

                        this._pAddDependency(this._cur_block_id.toString() + "#" + i, new away.net.URLRequest(url), false, null, true);
                    } else {
                        data_len = this._newBlockBytes.readUnsignedInt();
                        var data;
                        data = new away.utils.ByteArray();

                        this._newBlockBytes.readBytes(data, 0, data_len);
                        this._pAddDependency(this._cur_block_id.toString() + "#" + i, null, false, data, true);
                    }
                }

                // Ignore for now
                this.parseProperties(null);
                this._blocks[blockID].extras = this.parseUserAttributes();
                this._pPauseAndRetrieveDependencies();
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    var textureStylesNames = ["external", "embed"];
                    console.log("Start parsing 6 " + textureStylesNames[type] + " Bitmaps for CubeTexture");
                }
            };

            //Block ID = 91
            AWDParser.prototype.parseSharedMethodBlock = function (blockID) {
                var asset;

                this._blocks[blockID].name = this.parseVarStr();
                asset = this.parseSharedMethodList(blockID);
                this.parseUserAttributes();
                this._blocks[blockID].data = asset;
                this._pFinalizeAsset(asset, this._blocks[blockID].name);
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    console.log("Parsed a EffectMethod: Name = " + asset.name + " Type = " + asset);
                }
            };

            //Block ID = 92
            AWDParser.prototype.parseShadowMethodBlock = function (blockID) {
                var type;
                var data_len;
                var asset;
                var shadowLightID;
                this._blocks[blockID].name = this.parseVarStr();

                shadowLightID = this._newBlockBytes.readUnsignedInt();
                var returnedArray = this.getAssetByID(shadowLightID, [away.library.AssetType.LIGHT]);

                if (!returnedArray[0]) {
                    this._blocks[blockID].addError("Could not find the TargetLight (ID = " + shadowLightID + " ) for this ShadowMethod - ShadowMethod not created");
                    return;
                }

                asset = this.parseShadowMethodList(returnedArray[1], blockID);

                if (!asset)
                    return;

                this.parseUserAttributes();
                this._pFinalizeAsset(asset, this._blocks[blockID].name);
                this._blocks[blockID].data = asset;

                if (this._debug) {
                    console.log("Parsed a ShadowMapMethodMethod: Name = " + asset.name + " | Type = " + asset + " | Light-Name = ", (returnedArray[1]).name);
                }
            };

            //Block ID = 253
            AWDParser.prototype.parseCommand = function (blockID) {
                var hasBlocks = (this._newBlockBytes.readUnsignedByte() == 1);
                var par_id = this._newBlockBytes.readUnsignedInt();
                var mtx = this.parseMatrix3D();
                var name = this.parseVarStr();

                var parentObject;
                var targetObject;

                var returnedArray = this.getAssetByID(par_id, [away.library.AssetType.CONTAINER, away.library.AssetType.LIGHT, away.library.AssetType.MESH, away.library.AssetType.ENTITY, away.library.AssetType.SEGMENT_SET]);

                if (returnedArray[0]) {
                    parentObject = returnedArray[1];
                }

                var numCommands = this._newBlockBytes.readShort();
                var typeCommand = this._newBlockBytes.readShort();

                var props = this.parseProperties({ 1: AWDParser.BADDR });

                switch (typeCommand) {
                    case 1:
                        var targetID = props.get(1, 0);
                        var returnedArrayTarget = this.getAssetByID(targetID, [away.library.AssetType.LIGHT, away.library.AssetType.TEXTURE_PROJECTOR]);

                        if ((!returnedArrayTarget[0]) && (targetID != 0)) {
                            this._blocks[blockID].addError("Could not find the light (ID = " + targetID + " ( for this CommandBock!");
                            return;
                        }

                        targetObject = returnedArrayTarget[1];

                        if (parentObject) {
                            parentObject.addChild(targetObject);
                        }

                        targetObject.transform = mtx;

                        break;
                }

                if (targetObject) {
                    props = this.parseProperties({ 1: this._matrixNrType, 2: this._matrixNrType, 3: this._matrixNrType, 4: AWDParser.UINT8 });

                    targetObject.pivotPoint = new away.geom.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
                    targetObject.extra = this.parseUserAttributes();
                }
                this._blocks[blockID].data = targetObject;

                if (this._debug) {
                    console.log("Parsed a CommandBlock: Name = '" + name);
                }
            };

            //blockID 255
            AWDParser.prototype.parseMetaData = function (blockID) {
                var props = this.parseProperties({ 1: AWDParser.UINT32, 2: AWDParser.AWDSTRING, 3: AWDParser.AWDSTRING, 4: AWDParser.AWDSTRING, 5: AWDParser.AWDSTRING });

                if (this._debug) {
                    console.log("Parsed a MetaDataBlock: TimeStamp         = " + props.get(1, 0));
                    console.log("                        EncoderName       = " + props.get(2, "unknown"));
                    console.log("                        EncoderVersion    = " + props.get(3, "unknown"));
                    console.log("                        GeneratorName     = " + props.get(4, "unknown"));
                    console.log("                        GeneratorVersion  = " + props.get(5, "unknown"));
                }
            };

            //blockID 254
            AWDParser.prototype.parseNameSpace = function (blockID) {
                var id = this._newBlockBytes.readUnsignedByte();
                var nameSpaceString = this.parseVarStr();
                if (this._debug)
                    console.log("Parsed a NameSpaceBlock: ID = " + id + " | String = " + nameSpaceString);
            };

            //--Parser UTILS---------------------------------------------------------------------------
            // this functions reads and creates a ShadowMethodMethod
            AWDParser.prototype.parseShadowMethodList = function (light, blockID) {
                var methodType = this._newBlockBytes.readUnsignedShort();
                var shadowMethod;
                var props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL, 801: AWDParser.MTX4x4 });

                var targetID;
                var returnedArray;
                switch (methodType) {
                    case 1101:
                        shadowMethod = new away.materials.FilteredShadowMapMethod(light);
                        (shadowMethod).alpha = props.get(101, 1);
                        (shadowMethod).epsilon = props.get(102, 0.002);
                        break;

                    case 1102:
                        shadowMethod = new away.materials.DitheredShadowMapMethod(light, props.get(201, 5));
                        (shadowMethod).alpha = props.get(101, 1);
                        (shadowMethod).epsilon = props.get(102, 0.002);
                        (shadowMethod).range = props.get(103, 1);

                        break;
                    case 1103:
                        shadowMethod = new away.materials.SoftShadowMapMethod(light, props.get(201, 5));
                        (shadowMethod).alpha = props.get(101, 1);
                        (shadowMethod).epsilon = props.get(102, 0.002);
                        (shadowMethod).range = props.get(103, 1);

                        break;
                }
                this.parseUserAttributes();
                return shadowMethod;
            };

            // this functions reads and creates a EffectMethod
            AWDParser.prototype.parseSharedMethodList = function (blockID) {
                var methodType = this._newBlockBytes.readUnsignedShort();
                var effectMethodReturn;

                var props = this.parseProperties({ 1: AWDParser.BADDR, 2: AWDParser.BADDR, 3: AWDParser.BADDR, 101: this._propsNrType, 102: this._propsNrType, 103: this._propsNrType, 104: this._propsNrType, 105: this._propsNrType, 106: this._propsNrType, 107: this._propsNrType, 201: AWDParser.UINT32, 202: AWDParser.UINT32, 301: AWDParser.UINT16, 302: AWDParser.UINT16, 401: AWDParser.UINT8, 402: AWDParser.UINT8, 601: AWDParser.COLOR, 602: AWDParser.COLOR, 701: AWDParser.BOOL, 702: AWDParser.BOOL });
                var targetID;
                var returnedArray;
                switch (methodType) {
                }
                this.parseUserAttributes();
                return effectMethodReturn;
            };

            AWDParser.prototype.parseUserAttributes = function () {
                var attributes;
                var list_len;
                var attibuteCnt;

                list_len = this._newBlockBytes.readUnsignedInt();

                if (list_len > 0) {
                    var list_end;

                    attributes = {};

                    list_end = this._newBlockBytes.position + list_len;

                    while (this._newBlockBytes.position < list_end) {
                        var ns_id;
                        var attr_key;
                        var attr_type;
                        var attr_len;
                        var attr_val;

                        // TODO: Properly tend to namespaces in attributes
                        ns_id = this._newBlockBytes.readUnsignedByte();
                        attr_key = this.parseVarStr();
                        attr_type = this._newBlockBytes.readUnsignedByte();
                        attr_len = this._newBlockBytes.readUnsignedInt();

                        if ((this._newBlockBytes.position + attr_len) > list_end) {
                            console.log("           Error in reading attribute # " + attibuteCnt + " = skipped to end of attribute-list");
                            this._newBlockBytes.position = list_end;
                            return attributes;
                        }

                        switch (attr_type) {
                            case AWDParser.AWDSTRING:
                                attr_val = this._newBlockBytes.readUTFBytes(attr_len);
                                break;
                            case AWDParser.INT8:
                                attr_val = this._newBlockBytes.readByte();
                                break;
                            case AWDParser.INT16:
                                attr_val = this._newBlockBytes.readShort();
                                break;
                            case AWDParser.INT32:
                                attr_val = this._newBlockBytes.readInt();
                                break;
                            case AWDParser.BOOL:
                            case AWDParser.UINT8:
                                attr_val = this._newBlockBytes.readUnsignedByte();
                                break;
                            case AWDParser.UINT16:
                                attr_val = this._newBlockBytes.readUnsignedShort();
                                break;
                            case AWDParser.UINT32:
                            case AWDParser.BADDR:
                                attr_val = this._newBlockBytes.readUnsignedInt();
                                break;
                            case AWDParser.FLOAT32:
                                attr_val = this._newBlockBytes.readFloat();
                                break;
                            case AWDParser.FLOAT64:
                                attr_val = this._newBlockBytes.readDouble();
                                break;
                            default:
                                attr_val = 'unimplemented attribute type ' + attr_type;
                                this._newBlockBytes.position += attr_len;
                                break;
                        }

                        if (this._debug) {
                            console.log("attribute = name: " + attr_key + "  / value = " + attr_val);
                        }

                        attributes[attr_key] = attr_val;
                        attibuteCnt += 1;
                    }
                }

                return attributes;
            };

            AWDParser.prototype.parseProperties = function (expected) {
                var list_end;
                var list_len;
                var propertyCnt = 0;
                var props = new AWDProperties();

                list_len = this._newBlockBytes.readUnsignedInt();
                list_end = this._newBlockBytes.position + list_len;

                if (expected) {
                    while (this._newBlockBytes.position < list_end) {
                        var len;
                        var key;
                        var type;

                        key = this._newBlockBytes.readUnsignedShort();
                        len = this._newBlockBytes.readUnsignedInt();

                        if ((this._newBlockBytes.position + len) > list_end) {
                            console.log("           Error in reading property # " + propertyCnt + " = skipped to end of propertie-list");
                            this._newBlockBytes.position = list_end;
                            return props;
                        }

                        if (expected.hasOwnProperty(key.toString())) {
                            type = expected[key];
                            props.set(key, this.parseAttrValue(type, len));
                        } else {
                            this._newBlockBytes.position += len;
                        }

                        propertyCnt += 1;
                    }
                } else {
                    this._newBlockBytes.position = list_end;
                }

                return props;
            };

            AWDParser.prototype.parseAttrValue = function (type, len) {
                var elem_len;
                var read_func;

                switch (type) {
                    case AWDParser.BOOL:
                    case AWDParser.INT8:
                        elem_len = 1;
                        read_func = this._newBlockBytes.readByte;
                        break;

                    case AWDParser.INT16:
                        elem_len = 2;
                        read_func = this._newBlockBytes.readShort;
                        break;

                    case AWDParser.INT32:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readInt;
                        break;

                    case AWDParser.UINT8:
                        elem_len = 1;
                        read_func = this._newBlockBytes.readUnsignedByte;
                        break;

                    case AWDParser.UINT16:
                        elem_len = 2;
                        read_func = this._newBlockBytes.readUnsignedShort;
                        break;

                    case AWDParser.UINT32:
                    case AWDParser.COLOR:
                    case AWDParser.BADDR:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readUnsignedInt;
                        break;

                    case AWDParser.FLOAT32:
                        elem_len = 4;
                        read_func = this._newBlockBytes.readFloat;
                        break;

                    case AWDParser.FLOAT64:
                        elem_len = 8;
                        read_func = this._newBlockBytes.readDouble;
                        break;

                    case AWDParser.AWDSTRING:
                        return this._newBlockBytes.readUTFBytes(len);

                    case AWDParser.VECTOR2x1:
                    case AWDParser.VECTOR3x1:
                    case AWDParser.VECTOR4x1:
                    case AWDParser.MTX3x2:
                    case AWDParser.MTX3x3:
                    case AWDParser.MTX4x3:
                    case AWDParser.MTX4x4:
                        elem_len = 8;
                        read_func = this._newBlockBytes.readDouble;
                        break;
                }

                if (elem_len < len) {
                    var list = [];
                    var num_read = 0;
                    var num_elems = len / elem_len;

                    while (num_read < num_elems) {
                        list.push(read_func.apply(this._newBlockBytes));
                        num_read++;
                    }

                    return list;
                } else {
                    var val = read_func.apply(this._newBlockBytes);
                    return val;
                }
            };

            AWDParser.prototype.parseHeader = function () {
                var flags;
                var body_len;

                this._byteData.position = 3;

                this._version[0] = this._byteData.readUnsignedByte();
                this._version[1] = this._byteData.readUnsignedByte();

                flags = this._byteData.readUnsignedShort();

                this._streaming = bitFlags.test(flags, bitFlags.FLAG1);

                if ((this._version[0] == 2) && (this._version[1] == 1)) {
                    this._accuracyMatrix = bitFlags.test(flags, bitFlags.FLAG2);
                    this._accuracyGeo = bitFlags.test(flags, bitFlags.FLAG3);
                    this._accuracyProps = bitFlags.test(flags, bitFlags.FLAG4);
                }

                // if we set _accuracyOnBlocks, the precision-values are read from each block-header.
                // set storagePrecision types
                this._geoNrType = AWDParser.FLOAT32;

                if (this._accuracyGeo) {
                    this._geoNrType = AWDParser.FLOAT64;
                }

                this._matrixNrType = AWDParser.FLOAT32;

                if (this._accuracyMatrix) {
                    this._matrixNrType = AWDParser.FLOAT64;
                }

                this._propsNrType = AWDParser.FLOAT32;

                if (this._accuracyProps) {
                    this._propsNrType = AWDParser.FLOAT64;
                }

                this._compression = this._byteData.readUnsignedByte();

                if (this._debug) {
                    console.log("Import AWDFile of version = " + this._version[0] + " - " + this._version[1]);
                    console.log("Global Settings = Compression = " + this._compression + " | Streaming = " + this._streaming + " | Matrix-Precision = " + this._accuracyMatrix + " | Geometry-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
                }

                // Check file integrity
                body_len = this._byteData.readUnsignedInt();
                if (!this._streaming && body_len != this._byteData.getBytesAvailable()) {
                    this._pDieWithError('AWD2 body length does not match header integrity field');
                }
            };

            AWDParser.prototype.parseVarStr = function () {
                var len = this._newBlockBytes.readUnsignedShort();
                return this._newBlockBytes.readUTFBytes(len);
            };

            AWDParser.prototype.getAssetByID = function (assetID, assetTypesToGet, extraTypeInfo) {
                if (typeof extraTypeInfo === "undefined") { extraTypeInfo = "SingleTexture"; }
                var returnArray = new Array();
                var typeCnt = 0;
                if (assetID > 0) {
                    if (this._blocks[assetID]) {
                        if (this._blocks[assetID].data) {
                            while (typeCnt < assetTypesToGet.length) {
                                var iasset = this._blocks[assetID].data;

                                if (iasset.assetType == assetTypesToGet[typeCnt]) {
                                    if ((assetTypesToGet[typeCnt] == away.library.AssetType.TEXTURE) && (extraTypeInfo == "CubeTexture")) {
                                        if (this._blocks[assetID].data instanceof away.textures.HTMLImageElementCubeTexture) {
                                            returnArray.push(true);
                                            returnArray.push(this._blocks[assetID].data);
                                            return returnArray;
                                        }
                                    }
                                    if ((assetTypesToGet[typeCnt] == away.library.AssetType.TEXTURE) && (extraTypeInfo == "SingleTexture")) {
                                        if (this._blocks[assetID].data instanceof away.textures.HTMLImageElementTexture) {
                                            returnArray.push(true);
                                            returnArray.push(this._blocks[assetID].data);
                                            return returnArray;
                                        }
                                    } else {
                                        returnArray.push(true);
                                        returnArray.push(this._blocks[assetID].data);
                                        return returnArray;
                                    }
                                }

                                if ((assetTypesToGet[typeCnt] == away.library.AssetType.GEOMETRY) && (iasset.assetType == away.library.AssetType.MESH)) {
                                    var mesh = this._blocks[assetID].data;

                                    returnArray.push(true);
                                    returnArray.push(mesh.geometry);
                                    return returnArray;
                                }

                                typeCnt++;
                            }
                        }
                    }
                }

                // if the function has not returned anything yet, the asset is not found, or the found asset is not the right type.
                returnArray.push(false);
                returnArray.push(this.getDefaultAsset(assetTypesToGet[0], extraTypeInfo));
                return returnArray;
            };

            AWDParser.prototype.getDefaultAsset = function (assetType, extraTypeInfo) {
                switch (true) {
                    case (assetType == away.library.AssetType.TEXTURE):
                        if (extraTypeInfo == "CubeTexture")
                            return this.getDefaultCubeTexture();
                        if (extraTypeInfo == "SingleTexture")
                            return this.getDefaultTexture();
                        break;

                    case (assetType == away.library.AssetType.MATERIAL):
                        return this.getDefaultMaterial();
                        break;

                    default:
                        break;
                }

                return null;
            };

            AWDParser.prototype.getDefaultMaterial = function () {
                if (!this._defaultBitmapMaterial)
                    this._defaultBitmapMaterial = away.materials.DefaultMaterialManager.getDefaultMaterial();
                return this._defaultBitmapMaterial;
            };

            AWDParser.prototype.getDefaultTexture = function () {
                if (!this._defaultTexture) {
                    this._defaultTexture = away.materials.DefaultMaterialManager.getDefaultTexture();
                }

                return this._defaultTexture;
            };

            AWDParser.prototype.getDefaultCubeTexture = function () {
                if (!this._defaultCubeTexture) {
                    var defaultBitmap = away.materials.DefaultMaterialManager.createCheckeredBitmapData();

                    this._defaultCubeTexture = new away.textures.BitmapCubeTexture(defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap, defaultBitmap);
                    this._defaultCubeTexture.name = "defaultTexture";
                }

                return this._defaultCubeTexture;
            };

            AWDParser.prototype.readNumber = function (precision) {
                if (typeof precision === "undefined") { precision = false; }
                if (precision)
                    return this._newBlockBytes.readDouble();
                return this._newBlockBytes.readFloat();
            };

            AWDParser.prototype.parseMatrix3D = function () {
                return new away.geom.Matrix3D(this.parseMatrix43RawData());
            };

            AWDParser.prototype.parseMatrix32RawData = function () {
                var i;
                var mtx_raw = new Array(6);
                for (i = 0; i < 6; i++) {
                    mtx_raw[i] = this._newBlockBytes.readFloat();
                }

                return mtx_raw;
            };

            AWDParser.prototype.parseMatrix43RawData = function () {
                var mtx_raw = new Array(16);

                mtx_raw[0] = this.readNumber(this._accuracyMatrix);
                mtx_raw[1] = this.readNumber(this._accuracyMatrix);
                mtx_raw[2] = this.readNumber(this._accuracyMatrix);
                mtx_raw[3] = 0.0;
                mtx_raw[4] = this.readNumber(this._accuracyMatrix);
                mtx_raw[5] = this.readNumber(this._accuracyMatrix);
                mtx_raw[6] = this.readNumber(this._accuracyMatrix);
                mtx_raw[7] = 0.0;
                mtx_raw[8] = this.readNumber(this._accuracyMatrix);
                mtx_raw[9] = this.readNumber(this._accuracyMatrix);
                mtx_raw[10] = this.readNumber(this._accuracyMatrix);
                mtx_raw[11] = 0.0;
                mtx_raw[12] = this.readNumber(this._accuracyMatrix);
                mtx_raw[13] = this.readNumber(this._accuracyMatrix);
                mtx_raw[14] = this.readNumber(this._accuracyMatrix);
                mtx_raw[15] = 1.0;

                if (isNaN(mtx_raw[0])) {
                    mtx_raw[0] = 1;
                    mtx_raw[1] = 0;
                    mtx_raw[2] = 0;
                    mtx_raw[4] = 0;
                    mtx_raw[5] = 1;
                    mtx_raw[6] = 0;
                    mtx_raw[8] = 0;
                    mtx_raw[9] = 0;
                    mtx_raw[10] = 1;
                    mtx_raw[12] = 0;
                    mtx_raw[13] = 0;
                    mtx_raw[14] = 0;
                }

                return mtx_raw;
            };
            AWDParser.COMPRESSIONMODE_LZMA = "lzma";
            AWDParser.UNCOMPRESSED = 0;
            AWDParser.DEFLATE = 1;
            AWDParser.LZMA = 2;
            AWDParser.INT8 = 1;
            AWDParser.INT16 = 2;
            AWDParser.INT32 = 3;
            AWDParser.UINT8 = 4;
            AWDParser.UINT16 = 5;
            AWDParser.UINT32 = 6;
            AWDParser.FLOAT32 = 7;
            AWDParser.FLOAT64 = 8;
            AWDParser.BOOL = 21;
            AWDParser.COLOR = 22;
            AWDParser.BADDR = 23;
            AWDParser.AWDSTRING = 31;
            AWDParser.AWDBYTEARRAY = 32;
            AWDParser.VECTOR2x1 = 41;
            AWDParser.VECTOR3x1 = 42;
            AWDParser.VECTOR4x1 = 43;
            AWDParser.MTX3x2 = 44;
            AWDParser.MTX3x3 = 45;
            AWDParser.MTX4x3 = 46;
            AWDParser.MTX4x4 = 47;
            return AWDParser;
        })(away.loaders.ParserBase);
        loaders.AWDParser = AWDParser;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));

var AWDBlock = (function () {
    function AWDBlock() {
    }
    AWDBlock.prototype.dispose = function () {
        this.id = null;
        this.bytes = null;
        this.errorMessages = null;
        this.uvsForVertexAnimation = null;
    };

    AWDBlock.prototype.addError = function (errorMsg) {
        if (!this.errorMessages)
            this.errorMessages = new Array();
        this.errorMessages.push(errorMsg);
    };
    return AWDBlock;
})();

var bitFlags = (function () {
    function bitFlags() {
    }
    bitFlags.test = function (flags, testFlag) {
        return (flags & testFlag) == testFlag;
    };
    bitFlags.FLAG1 = 1;
    bitFlags.FLAG2 = 2;
    bitFlags.FLAG3 = 4;
    bitFlags.FLAG4 = 8;
    bitFlags.FLAG5 = 16;
    bitFlags.FLAG6 = 32;
    bitFlags.FLAG7 = 64;
    bitFlags.FLAG8 = 128;
    bitFlags.FLAG9 = 256;
    bitFlags.FLAG10 = 512;
    bitFlags.FLAG11 = 1024;
    bitFlags.FLAG12 = 2048;
    bitFlags.FLAG13 = 4096;
    bitFlags.FLAG14 = 8192;
    bitFlags.FLAG15 = 16384;
    bitFlags.FLAG16 = 32768;
    return bitFlags;
})();

var AWDProperties = (function () {
    function AWDProperties() {
    }
    AWDProperties.prototype.set = function (key, value) {
        this[key.toString()] = value;
    };

    AWDProperties.prototype.get = function (key, fallback) {
        console.log('this.hasOwnProperty(key.toString());', key, fallback, this.hasOwnProperty(key.toString()));

        if (this.hasOwnProperty(key.toString())) {
            return this[key.toString()];
        } else {
            return fallback;
        }
    };
    return AWDProperties;
})();
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        /**
        * Max3DSParser provides a parser for the 3ds data type.
        */
        var Max3DSParser = (function (_super) {
            __extends(Max3DSParser, _super);
            function Max3DSParser() {
                _super.call(this, loaders.ParserDataFormat.BINARY);
            }
            Max3DSParser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "3ds";
            };

            Max3DSParser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                var ba;

                ba = away.loaders.ParserUtil.toByteArray(data);
                if (ba) {
                    ba.position = 0;
                    if (ba.readShort() == 0x4d4d)
                        return true;
                }

                return false;
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.assets.length == 1) {
                    var asset;

                    asset = resourceDependency.assets[0];
                    if (asset.assetType == away.library.AssetType.TEXTURE) {
                        var tex;

                        tex = this._textures[resourceDependency.id];
                        tex.texture = asset;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                // TODO: Implement
            };

            /**
            * @inheritDoc
            */
            Max3DSParser.prototype._pProceedParsing = function () {
                if (!this._byteData) {
                    this._byteData = this._pGetByteData();
                    this._byteData.position = 0;

                    //----------------------------------------------------------------------------
                    // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                    //----------------------------------------------------------------------------
                    //this._byteData.endian = Endian.LITTLE_ENDIAN;// Should be default
                    //----------------------------------------------------------------------------
                    this._textures = {};
                    this._materials = {};
                    this._unfinalized_objects = {};
                }

                while (this._pHasTime()) {
                    if (this._cur_mat && this._byteData.position >= this._cur_mat_end)
                        this.finalizeCurrentMaterial();
else if (this._cur_obj && this._byteData.position >= this._cur_obj_end) {
                        // Can't finalize at this point, because we have to wait until the full
                        // animation section has been parsed for any potential pivot definitions
                        this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
                        this._cur_obj_end = Number.MAX_VALUE;
                        ;
                        this._cur_obj = null;
                    }

                    if (this._byteData.getBytesAvailable() > 0) {
                        var cid/*uint*/ ;
                        var len/*uint*/ ;
                        var end/*uint*/ ;

                        cid = this._byteData.readUnsignedShort();
                        len = this._byteData.readUnsignedInt();
                        end = this._byteData.position + (len - 6);

                        switch (cid) {
                            case 0x4D4D:
                            case 0x3D3D:
                            case 0xB000:
                                continue;
                                break;

                            case 0xAFFF:
                                this._cur_mat_end = end;
                                this._cur_mat = this.parseMaterial();
                                break;

                            case 0x4000:
                                this._cur_obj_end = end;
                                this._cur_obj = new ObjectVO();
                                this._cur_obj.name = this.readNulTermstring();
                                this._cur_obj.materials = new Array();
                                this._cur_obj.materialFaces = {};
                                break;

                            case 0x4100:
                                this._cur_obj.type = away.library.AssetType.MESH;
                                break;

                            case 0x4110:
                                this.parseVertexList();
                                break;

                            case 0x4120:
                                this.parseFaceList();
                                break;

                            case 0x4140:
                                this.parseUVList();
                                break;

                            case 0x4130:
                                this.parseFaceMaterialList();
                                break;

                            case 0x4160:
                                this._cur_obj.transform = this.readTransform();
                                break;

                            case 0xB002:
                                this.parseObjectAnimation(end);
                                break;

                            case 0x4150:
                                this.parseSmoothingGroups();
                                break;

                            default:
                                // Skip this (unknown) chunk
                                this._byteData.position += (len - 6);
                                break;
                        }

                        if (this.dependencies.length) {
                            this._pPauseAndRetrieveDependencies();
                            break;
                        }
                    }
                }

                if (this._byteData.getBytesAvailable() || this._cur_obj || this._cur_mat)
                    return away.loaders.ParserBase.MORE_TO_PARSE;
else {
                    var name;

                    for (name in this._unfinalized_objects) {
                        var obj;
                        obj = this.constructObject(this._unfinalized_objects[name]);
                        if (obj)
                            this._pFinalizeAsset(obj, name);
                    }

                    return away.loaders.ParserBase.PARSING_DONE;
                }
            };

            Max3DSParser.prototype.parseMaterial = function () {
                var mat;

                mat = new MaterialVO();

                while (this._byteData.position < this._cur_mat_end) {
                    var cid/*uint*/ ;
                    var len/*uint*/ ;
                    var end/*uint*/ ;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();
                    end = this._byteData.position + (len - 6);

                    switch (cid) {
                        case 0xA000:
                            mat.name = this.readNulTermstring();
                            break;

                        case 0xA010:
                            mat.ambientColor = this.readColor();
                            break;

                        case 0xA020:
                            mat.diffuseColor = this.readColor();
                            break;

                        case 0xA030:
                            mat.specularColor = this.readColor();
                            break;

                        case 0xA081:
                            mat.twoSided = true;
                            break;

                        case 0xA200:
                            mat.colorMap = this.parseTexture(end);
                            break;

                        case 0xA204:
                            mat.specularMap = this.parseTexture(end);
                            break;

                        default:
                            this._byteData.position = end;
                            break;
                    }
                }

                return mat;
            };

            Max3DSParser.prototype.parseTexture = function (end/*uint*/ ) {
                var tex;

                tex = new TextureVO();

                while (this._byteData.position < end) {
                    var cid/*uint*/ ;
                    var len/*uint*/ ;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();

                    switch (cid) {
                        case 0xA300:
                            tex.url = this.readNulTermstring();
                            break;

                        default:
                            // Skip this unknown texture sub-chunk
                            this._byteData.position += (len - 6);
                            break;
                    }
                }

                this._textures[tex.url] = tex;
                this._pAddDependency(tex.url, new away.net.URLRequest(tex.url));

                return tex;
            };

            Max3DSParser.prototype.parseVertexList = function () {
                var i/*uint*/ ;
                var len/*uint*/ ;
                var count/*uint*/ ;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.verts = new Array(count * 3);

                i = 0;
                len = this._cur_obj.verts.length;
                while (i < len) {
                    var x, y, z;

                    x = this._byteData.readFloat();
                    y = this._byteData.readFloat();
                    z = this._byteData.readFloat();

                    this._cur_obj.verts[i++] = x;
                    this._cur_obj.verts[i++] = z;
                    this._cur_obj.verts[i++] = y;
                }
            };

            Max3DSParser.prototype.parseFaceList = function () {
                var i/*uint*/ ;
                var len/*uint*/ ;
                var count/*uint*/ ;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.indices = new Array(count * 3);

                i = 0;
                len = this._cur_obj.indices.length;
                while (i < len) {
                    var i0/*uint*/ , i1, i2;

                    i0 = this._byteData.readUnsignedShort();
                    i1 = this._byteData.readUnsignedShort();
                    i2 = this._byteData.readUnsignedShort();

                    this._cur_obj.indices[i++] = i0;
                    this._cur_obj.indices[i++] = i2;
                    this._cur_obj.indices[i++] = i1;

                    // Skip "face info", irrelevant in Away3D
                    this._byteData.position += 2;
                }

                this._cur_obj.smoothingGroups = new Array(count);
            };

            Max3DSParser.prototype.parseSmoothingGroups = function () {
                var len = this._cur_obj.indices.length / 3;
                var i = 0;
                while (i < len) {
                    this._cur_obj.smoothingGroups[i] = this._byteData.readUnsignedInt();
                    i++;
                }
            };

            Max3DSParser.prototype.parseUVList = function () {
                var i/*uint*/ ;
                var len/*uint*/ ;
                var count/*uint*/ ;

                count = this._byteData.readUnsignedShort();
                this._cur_obj.uvs = new Array(count * 2);

                i = 0;
                len = this._cur_obj.uvs.length;
                while (i < len) {
                    this._cur_obj.uvs[i++] = this._byteData.readFloat();
                    this._cur_obj.uvs[i++] = 1.0 - this._byteData.readFloat();
                }
            };

            Max3DSParser.prototype.parseFaceMaterialList = function () {
                var mat;
                var count/*uint*/ ;
                var i/*uint*/ ;
                var faces/*uint*/ ;

                mat = this.readNulTermstring();
                count = this._byteData.readUnsignedShort();

                faces = new Array(count);
                i = 0;
                while (i < faces.length)
                    faces[i++] = this._byteData.readUnsignedShort();

                this._cur_obj.materials.push(mat);
                this._cur_obj.materialFaces[mat] = faces;
            };

            Max3DSParser.prototype.parseObjectAnimation = function (end) {
                var vo;
                var obj;
                var pivot;
                var name;
                var hier/*uint*/ ;

                // Pivot defaults to origin
                pivot = new away.geom.Vector3D();

                while (this._byteData.position < end) {
                    var cid/*uint*/ ;
                    var len/*uint*/ ;

                    cid = this._byteData.readUnsignedShort();
                    len = this._byteData.readUnsignedInt();

                    switch (cid) {
                        case 0xb010:
                            name = this.readNulTermstring();
                            this._byteData.position += 4;
                            hier = this._byteData.readShort();
                            break;

                        case 0xb013:
                            pivot.x = this._byteData.readFloat();
                            pivot.z = this._byteData.readFloat();
                            pivot.y = this._byteData.readFloat();
                            break;

                        default:
                            this._byteData.position += (len - 6);
                            break;
                    }
                }

                if (name != '$$$DUMMY' && this._unfinalized_objects.hasOwnProperty(name)) {
                    vo = this._unfinalized_objects[name];
                    obj = this.constructObject(vo, pivot);

                    if (obj)
                        this._pFinalizeAsset(obj, vo.name);

                    delete this._unfinalized_objects[name];
                }
            };

            Max3DSParser.prototype.constructObject = function (obj, pivot) {
                if (typeof pivot === "undefined") { pivot = null; }
                if (obj.type == away.library.AssetType.MESH) {
                    var i/*uint*/ ;
                    var subs;
                    var geom;
                    var mat;
                    var mesh;
                    var mtx;
                    var vertices;
                    var faces;

                    if (obj.materials.length > 1)
                        console.log("The Away3D 3DS parser does not support multiple materials per mesh at this point.");

                    if (!obj.indices || obj.indices.length == 0)
                        return null;

                    vertices = new Array(obj.verts.length / 3);
                    faces = new Array(obj.indices.length / 3);

                    this.prepareData(vertices, faces, obj);
                    this.applySmoothGroups(vertices, faces);

                    obj.verts = new Array(vertices.length * 3);
                    for (i = 0; i < vertices.length; i++) {
                        obj.verts[i * 3] = vertices[i].x;
                        obj.verts[i * 3 + 1] = vertices[i].y;
                        obj.verts[i * 3 + 2] = vertices[i].z;
                    }
                    obj.indices = new Array(faces.length * 3);
                    ;
                    for (i = 0; i < faces.length; i++) {
                        obj.indices[i * 3] = faces[i].a;
                        obj.indices[i * 3 + 1] = faces[i].b;
                        obj.indices[i * 3 + 2] = faces[i].c;
                    }

                    if (obj.uvs) {
                        // If the object had UVs to start with, use UVs generated by
                        // smoothing group splitting algorithm. Otherwise those UVs
                        // will be nonsense and should be skipped.
                        obj.uvs = new Array(vertices.length * 2);
                        for (i = 0; i < vertices.length; i++) {
                            obj.uvs[i * 2] = vertices[i].u;
                            obj.uvs[i * 2 + 1] = vertices[i].v;
                        }
                    }

                    geom = new away.base.Geometry();

                    // Construct sub-geometries (potentially splitting buffers)
                    // and add them to geometry.
                    subs = away.utils.GeometryUtils.fromVectors(obj.verts, obj.indices, obj.uvs, null, null, null, null);
                    for (i = 0; i < subs.length; i++)
                        geom.subGeometries.push(subs[i]);

                    if (obj.materials.length > 0) {
                        var mname;
                        mname = obj.materials[0];
                        mat = this._materials[mname].material;
                    }

                    if (pivot) {
                        if (obj.transform) {
                            // If a transform was found while parsing the
                            // object chunk, use it to find the local pivot vector
                            var dat = obj.transform.concat();
                            dat[12] = 0;
                            dat[13] = 0;
                            dat[14] = 0;
                            mtx = new away.geom.Matrix3D(dat);
                            pivot = mtx.transformVector(pivot);
                        }

                        pivot.scaleBy(-1);

                        mtx = new away.geom.Matrix3D();
                        mtx.appendTranslation(pivot.x, pivot.y, pivot.z);
                        geom.applyTransformation(mtx);
                    }

                    if (obj.transform) {
                        mtx = new away.geom.Matrix3D(obj.transform);
                        mtx.invert();
                        geom.applyTransformation(mtx);
                    }

                    // Final transform applied to geometry. Finalize the geometry,
                    // which will no longer be modified after this point.
                    this._pFinalizeAsset(geom, obj.name.concat('_geom'));

                    // Build mesh and return it
                    mesh = new away.entities.Mesh(geom, mat);
                    mesh.transform = new away.geom.Matrix3D(obj.transform);
                    return mesh;
                }

                // If reached, unknown
                return null;
            };

            Max3DSParser.prototype.prepareData = function (vertices, faces, obj) {
                // convert raw ObjectVO's data to structured VertexVO and FaceVO
                var i/*int*/ ;
                var j/*int*/ ;
                var k/*int*/ ;
                var len = obj.verts.length;
                for (i = 0, j = 0, k = 0; i < len;) {
                    var v = new VertexVO();
                    v.x = obj.verts[i++];
                    v.y = obj.verts[i++];
                    v.z = obj.verts[i++];
                    if (obj.uvs) {
                        v.u = obj.uvs[j++];
                        v.v = obj.uvs[j++];
                    }
                    vertices[k++] = v;
                }
                len = obj.indices.length;
                for (i = 0, k = 0; i < len;) {
                    var f = new FaceVO();
                    f.a = obj.indices[i++];
                    f.b = obj.indices[i++];
                    f.c = obj.indices[i++];
                    f.smoothGroup = obj.smoothingGroups[k];
                    faces[k++] = f;
                }
            };

            Max3DSParser.prototype.applySmoothGroups = function (vertices, faces) {
                // clone vertices according to following rule:
                // clone if vertex's in faces from groups 1+2 and 3
                // don't clone if vertex's in faces from groups 1+2, 3 and 1+3
                var i/*int*/ ;
                var j/*int*/ ;
                var k/*int*/ ;
                var l/*int*/ ;
                var len/*int*/ ;
                var numVerts = vertices.length;
                var numFaces = faces.length;

                // extract groups data for vertices
                var vGroups = new Array(numVerts)/*uint*/ ;
                for (i = 0; i < numVerts; i++)
                    vGroups[i] = new Array();
                for (i = 0; i < numFaces; i++) {
                    var face = faces[i];
                    for (j = 0; j < 3; j++) {
                        var groups = vGroups[(j == 0) ? face.a : ((j == 1) ? face.b : face.c)];
                        var group = face.smoothGroup;
                        for (k = groups.length - 1; k >= 0; k--) {
                            if ((group & groups[k]) > 0) {
                                group |= groups[k];
                                groups.splice(k, 1);
                                k = groups.length - 1;
                            }
                        }
                        groups.push(group);
                    }
                }

                // clone vertices
                var vClones = new Array(numVerts)/*uint*/ ;
                for (i = 0; i < numVerts; i++) {
                    if ((len = vGroups[i].length) < 1)
                        continue;
                    var clones = new Array(len)/*uint*/ ;
                    vClones[i] = clones;
                    clones[0] = i;
                    var v0 = vertices[i];
                    for (j = 1; j < len; j++) {
                        var v1 = new VertexVO();
                        v1.x = v0.x;
                        v1.y = v0.y;
                        v1.z = v0.z;
                        v1.u = v0.u;
                        v1.v = v0.v;
                        clones[j] = vertices.length;
                        vertices.push(v1);
                    }
                }
                numVerts = vertices.length;

                for (i = 0; i < numFaces; i++) {
                    face = faces[i];
                    group = face.smoothGroup;
                    for (j = 0; j < 3; j++) {
                        k = (j == 0) ? face.a : ((j == 1) ? face.b : face.c);
                        groups = vGroups[k];
                        len = groups.length;
                        clones = vClones[k];
                        for (l = 0; l < len; l++) {
                            if (((group == 0) && (groups[l] == 0)) || ((group & groups[l]) > 0)) {
                                var index = clones[l];
                                if (group == 0) {
                                    // vertex is unique if no smoothGroup found
                                    groups.splice(l, 1);
                                    clones.splice(l, 1);
                                }
                                if (j == 0)
                                    face.a = index;
else if (j == 1)
                                    face.b = index;
else
                                    face.c = index;
                                l = len;
                            }
                        }
                    }
                }
            };

            Max3DSParser.prototype.finalizeCurrentMaterial = function () {
                var mat;
                if (this.materialMode < 2) {
                    if (this._cur_mat.colorMap)
                        mat = new away.materials.TextureMaterial(this._cur_mat.colorMap.texture || away.materials.DefaultMaterialManager.getDefaultTexture());
else
                        mat = new away.materials.ColorMaterial(this._cur_mat.diffuseColor);
                    (mat).ambientColor = this._cur_mat.ambientColor;
                    (mat).specularColor = this._cur_mat.specularColor;
                } else {
                    if (this._cur_mat.colorMap)
                        mat = new away.materials.TextureMultiPassMaterial(this._cur_mat.colorMap.texture || away.materials.DefaultMaterialManager.getDefaultTexture());
else
                        mat = new away.materials.ColorMultiPassMaterial(this._cur_mat.diffuseColor);
                    (mat).ambientColor = this._cur_mat.ambientColor;
                    (mat).specularColor = this._cur_mat.specularColor;
                }

                mat.bothSides = this._cur_mat.twoSided;

                this._pFinalizeAsset(mat, this._cur_mat.name);

                this._materials[this._cur_mat.name] = this._cur_mat;
                this._cur_mat.material = mat;

                this._cur_mat = null;
            };

            Max3DSParser.prototype.readNulTermstring = function () {
                var chr/*int*/ ;
                var str = "";

                while ((chr = this._byteData.readUnsignedByte()) > 0)
                    str += String.fromCharCode(chr);

                return str;
            };

            Max3DSParser.prototype.readTransform = function () {
                var data;

                data = new Array(16);

                // X axis
                data[0] = this._byteData.readFloat();
                data[2] = this._byteData.readFloat();
                data[1] = this._byteData.readFloat();
                data[3] = 0;

                // Z axis
                data[8] = this._byteData.readFloat();
                data[10] = this._byteData.readFloat();
                data[9] = this._byteData.readFloat();
                data[11] = 0;

                // Y Axis
                data[4] = this._byteData.readFloat();
                data[6] = this._byteData.readFloat();
                data[5] = this._byteData.readFloat();
                data[7] = 0;

                // Translation
                data[12] = this._byteData.readFloat();
                data[14] = this._byteData.readFloat();
                data[13] = this._byteData.readFloat();
                data[15] = 1;

                return data;
            };

            Max3DSParser.prototype.readColor = function () {
                var cid/*int*/ ;
                var len/*int*/ ;
                var r/*int*/ , g, b;

                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();

                switch (cid) {
                    case 0x0010:
                        r = this._byteData.readFloat() * 255;
                        g = this._byteData.readFloat() * 255;
                        b = this._byteData.readFloat() * 255;
                        break;
                    case 0x0011:
                        r = this._byteData.readUnsignedByte();
                        g = this._byteData.readUnsignedByte();
                        b = this._byteData.readUnsignedByte();
                        break;
                    default:
                        this._byteData.position += (len - 6);
                        break;
                }

                return (r << 16) | (g << 8) | b;
            };
            return Max3DSParser;
        })(away.loaders.ParserBase);
        loaders.Max3DSParser = Max3DSParser;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));

var TextureVO = (function () {
    function TextureVO() {
    }
    TextureVO.prototype.TextureVO = function () {
    };
    return TextureVO;
})();

var MaterialVO = (function () {
    function MaterialVO() {
    }
    MaterialVO.prototype.MaterialVO = function () {
    };
    return MaterialVO;
})();

var ObjectVO = (function () {
    function ObjectVO() {
    }
    ObjectVO.prototype.ObjectVO = function () {
    };
    return ObjectVO;
})();

var VertexVO = (function () {
    function VertexVO() {
    }
    VertexVO.prototype.VertexVO = function () {
    };
    return VertexVO;
})();

var FaceVO = (function () {
    function FaceVO() {
    }
    FaceVO.prototype.FaceVO = function () {
    };
    return FaceVO;
})();
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        /**
        * MD2Parser provides a parser for the MD2 data type.
        */
        var MD2Parser = (function (_super) {
            __extends(MD2Parser, _super);
            /**
            * Creates a new MD2Parser object.
            * @param textureType The extension of the texture (e.g. jpg/png/...)
            * @param ignoreTexturePath If true, the path of the texture is ignored
            */
            function MD2Parser(textureType, ignoreTexturePath) {
                if (typeof textureType === "undefined") { textureType = "jpg"; }
                if (typeof ignoreTexturePath === "undefined") { ignoreTexturePath = true; }
                _super.call(this, loaders.ParserDataFormat.BINARY);
                this._clipNodes = new Object();
                // the current subgeom being built
                this._animationSet = new away.animators.VertexAnimationSet();
                this.materialFinal = false;
                this.geoCreated = false;
                this._textureType = textureType;
                this._ignoreTexturePath = ignoreTexturePath;
            }
            MD2Parser.supportsType = /**
            * Indicates whether or not a given file extension is supported by the parser.
            * @param extension The file extension of a potential file to be parsed.
            * @return Whether or not the given file type is supported.
            */
            function (extension) {
                extension = extension.toLowerCase();
                return extension == "md2";
            };

            MD2Parser.supportsData = /**
            * Tests whether a data block can be parsed by the parser.
            * @param data The data block to potentially be parsed.
            * @return Whether or not the given data is supported.
            */
            function (data) {
                return (loaders.ParserUtil.toString(data, 4) == 'IDP2');
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._iResolveDependency = function (resourceDependency) {
                if (resourceDependency.assets.length != 1)
                    return;

                var asset = resourceDependency.assets[0];
                if (asset) {
                    var material;
                    if (this.materialMode < 2)
                        material = new away.materials.TextureMaterial(asset);
else
                        material = new away.materials.TextureMultiPassMaterial(asset);

                    material.name = this._mesh.material.name;
                    this._mesh.material = material;
                    this._pFinalizeAsset(material);
                    this._pFinalizeAsset(this._mesh.geometry);
                    this._pFinalizeAsset(this._mesh);
                }
                this.materialFinal = true;
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._iResolveDependencyFailure = function (resourceDependency) {
                if (this.materialMode < 2)
                    this._mesh.material = away.materials.DefaultMaterialManager.getDefaultMaterial();
else
                    this._mesh.material = new away.materials.TextureMultiPassMaterial(away.materials.DefaultMaterialManager.getDefaultTexture());

                this._pFinalizeAsset(this._mesh.geometry);
                this._pFinalizeAsset(this._mesh);
                this.materialFinal = true;
            };

            /**
            * @inheritDoc
            */
            MD2Parser.prototype._pProceedParsing = function () {
                if (!this._startedParsing) {
                    this._byteData = this._pGetByteData();
                    this._startedParsing = true;

                    // Reset bytearray read position (which may have been
                    // moved forward by the supportsData() function.)
                    this._byteData.position = 0;
                }

                while (this._pHasTime()) {
                    if (!this._parsedHeader) {
                        //----------------------------------------------------------------------------
                        // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                        //----------------------------------------------------------------------------
                        //this._byteData.endian = Endian.LITTLE_ENDIAN;
                        // TODO: Create a mesh only when encountered (if it makes sense
                        // for this file format) and return it using this._pFinalizeAsset()
                        this._geometry = new away.base.Geometry();
                        this._mesh = new away.entities.Mesh(this._geometry, null);
                        if (this.materialMode < 2)
                            this._mesh.material = away.materials.DefaultMaterialManager.getDefaultMaterial();
else
                            this._mesh.material = new away.materials.TextureMultiPassMaterial(away.materials.DefaultMaterialManager.getDefaultTexture());

                        //_geometry.animation = new VertexAnimation(2, VertexAnimationMode.ABSOLUTE);
                        //_animator = new VertexAnimator(VertexAnimationState(_mesh.animationState));
                        // Parse header and decompress body
                        this.parseHeader();
                        this.parseMaterialNames();
                    } else if (!this._parsedUV)
                        this.parseUV();
else if (!this._parsedFaces)
                        this.parseFaces();
else if (!this._parsedFrames)
                        this.parseFrames();
else if ((this.geoCreated) && (this.materialFinal))
                        return away.loaders.ParserBase.PARSING_DONE;
else if (!this.geoCreated) {
                        this.geoCreated = true;
                        this.createDefaultSubGeometry();

                        // Force name to be chosen by this._pFinalizeAsset()
                        this._mesh.name = "";
                        if (this.materialFinal) {
                            this._pFinalizeAsset(this._mesh.geometry);
                            this._pFinalizeAsset(this._mesh);
                        }

                        this._pPauseAndRetrieveDependencies();
                    }
                }

                return away.loaders.ParserBase.MORE_TO_PARSE;
            };

            /**
            * Reads in all that MD2 Header data that is declared as private variables.
            * I know its a lot, and it looks ugly, but only way to do it in Flash
            */
            MD2Parser.prototype.parseHeader = function () {
                this._ident = this._byteData.readInt();
                this._version = this._byteData.readInt();
                this._skinWidth = this._byteData.readInt();
                this._skinHeight = this._byteData.readInt();

                //skip this._frameSize
                this._byteData.readInt();
                this._numSkins = this._byteData.readInt();
                this._numVertices = this._byteData.readInt();
                this._numST = this._byteData.readInt();
                this._numTris = this._byteData.readInt();

                //skip this._numGlCmds
                this._byteData.readInt();
                this._numFrames = this._byteData.readInt();
                this._offsetSkins = this._byteData.readInt();
                this._offsetST = this._byteData.readInt();
                this._offsetTris = this._byteData.readInt();
                this._offsetFrames = this._byteData.readInt();

                //skip this._offsetGlCmds
                this._byteData.readInt();
                this._offsetEnd = this._byteData.readInt();

                this._parsedHeader = true;
            };

            /**
            * Parses the file names for the materials.
            */
            MD2Parser.prototype.parseMaterialNames = function () {
                var url;
                var name;
                var extIndex/*int*/ ;
                var slashIndex/*int*/ ;
                this._materialNames = new Array();
                this._byteData.position = this._offsetSkins;

                var regExp = new RegExp("[^a-zA-Z0-9\\_\/.]", "g");
                for (var i = 0; i < this._numSkins; ++i) {
                    name = this._byteData.readUTFBytes(64);
                    name = name.replace(regExp, "");
                    extIndex = name.lastIndexOf(".");
                    if (this._ignoreTexturePath)
                        slashIndex = name.lastIndexOf("/");
                    if (name.toLowerCase().indexOf(".jpg") == -1 && name.toLowerCase().indexOf(".png") == -1) {
                        name = name.substring(slashIndex + 1, extIndex);
                        url = name + "." + this._textureType;
                    } else
                        url = name;

                    this._materialNames[i] = name;

                    if (this.dependencies.length == 0)
                        this._pAddDependency(name, new away.net.URLRequest(url));
                }

                if (this._materialNames.length > 0)
                    this._mesh.material.name = this._materialNames[0];
else
                    this.materialFinal = true;
            };

            /**
            * Parses the uv data for the mesh.
            */
            MD2Parser.prototype.parseUV = function () {
                var j = 0;

                this._uvs = new Array(this._numST * 2);
                this._byteData.position = this._offsetST;
                for (var i = 0; i < this._numST; i++) {
                    this._uvs[j++] = this._byteData.readShort() / this._skinWidth;
                    this._uvs[j++] = this._byteData.readShort() / this._skinHeight;
                }

                this._parsedUV = true;
            };

            /**
            * Parses unique indices for the faces.
            */
            MD2Parser.prototype.parseFaces = function () {
                var a/*uint*/ , b, c, ta, tb, tc;
                var i/*uint*/ ;

                this._vertIndices = new Array();
                this._uvIndices = new Array();
                this._indices = new Array();

                this._byteData.position = this._offsetTris;

                for (i = 0; i < this._numTris; i++) {
                    //collect vertex indices
                    a = this._byteData.readUnsignedShort();
                    b = this._byteData.readUnsignedShort();
                    c = this._byteData.readUnsignedShort();

                    //collect uv indices
                    ta = this._byteData.readUnsignedShort();
                    tb = this._byteData.readUnsignedShort();
                    tc = this._byteData.readUnsignedShort();

                    this.addIndex(a, ta);
                    this.addIndex(b, tb);
                    this.addIndex(c, tc);
                }

                var len = this._uvIndices.length;
                this._finalUV = new Array(len * 2);

                for (i = 0; i < len; ++i) {
                    this._finalUV[i << 1] = this._uvs[this._uvIndices[i] << 1];
                    this._finalUV[(i << 1) + 1] = this._uvs[(this._uvIndices[i] << 1) + 1];
                }

                this._parsedFaces = true;
            };

            /**
            * Adds a face index to the list if it doesn't exist yet, based on vertexIndex and uvIndex, and adds the
            * corresponding vertex and uv data in the correct location.
            * @param vertexIndex The original index in the vertex list.
            * @param uvIndex The original index in the uv list.
            */
            MD2Parser.prototype.addIndex = function (vertexIndex/*uint*/ , uvIndex/*uint*/ ) {
                var index = this.findIndex(vertexIndex, uvIndex);

                if (index == -1) {
                    this._indices.push(this._vertIndices.length);
                    this._vertIndices.push(vertexIndex);
                    this._uvIndices.push(uvIndex);
                } else
                    this._indices.push(index);
            };

            /**
            * Finds the final index corresponding to the original MD2's vertex and uv indices. Returns -1 if it wasn't added yet.
            * @param vertexIndex The original index in the vertex list.
            * @param uvIndex The original index in the uv list.
            * @return The index of the final mesh corresponding to the original vertex and uv index. -1 if it doesn't exist yet.
            */
            MD2Parser.prototype.findIndex = function (vertexIndex/*uint*/ , uvIndex/*uint*/ ) {
                var len = this._vertIndices.length;

                for (var i = 0; i < len; ++i) {
                    if (this._vertIndices[i] == vertexIndex && this._uvIndices[i] == uvIndex)
                        return i;
                }

                return -1;
            };

            /**
            * Parses all the frame geometries.
            */
            MD2Parser.prototype.parseFrames = function () {
                var sx, sy, sz;
                var tx, ty, tz;
                var geometry;
                var subGeom;
                var vertLen = this._vertIndices.length;
                var fvertices;
                var tvertices;
                var i/*uint*/ , j, k;

                //var ch : number /*uint*/;
                var name = "";
                var prevClip = null;

                this._byteData.position = this._offsetFrames;

                for (i = 0; i < this._numFrames; i++) {
                    subGeom = new away.base.CompactSubGeometry();

                    if (this._firstSubGeom == null)
                        this._firstSubGeom = subGeom;

                    geometry = new away.base.Geometry();
                    geometry.addSubGeometry(subGeom);
                    tvertices = new Array();
                    fvertices = new Array(vertLen * 3);

                    sx = this._byteData.readFloat();
                    sy = this._byteData.readFloat();
                    sz = this._byteData.readFloat();

                    tx = this._byteData.readFloat();
                    ty = this._byteData.readFloat();
                    tz = this._byteData.readFloat();

                    name = this.readFrameName();

                    for (j = 0; j < this._numVertices; j++, this._byteData.position++)
                        tvertices.push(sx * this._byteData.readUnsignedByte() + tx, sy * this._byteData.readUnsignedByte() + ty, sz * this._byteData.readUnsignedByte() + tz);

                    k = 0;
                    for (j = 0; j < vertLen; j++) {
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3];
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 2];
                        fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 1];
                    }

                    subGeom.fromVectors(fvertices, this._finalUV, null, null);
                    subGeom.updateIndexData(this._indices);
                    subGeom.vertexNormalData;
                    subGeom.vertexTangentData;
                    subGeom.autoDeriveVertexNormals = false;
                    subGeom.autoDeriveVertexTangents = false;

                    var clip = this._clipNodes[name];

                    if (!clip) {
                        if (prevClip) {
                            this._pFinalizeAsset(prevClip);
                            this._animationSet.addAnimation(prevClip);
                        }

                        clip = new away.animators.VertexClipNode();
                        clip.name = name;
                        clip.stitchFinalFrame = true;

                        this._clipNodes[name] = clip;

                        prevClip = clip;
                    }
                    clip.addFrame(geometry, 1000 / away.loaders.MD2Parser.FPS);
                }

                if (prevClip) {
                    this._pFinalizeAsset(prevClip);
                    this._animationSet.addAnimation(prevClip);
                }

                // Force this._pFinalizeAsset() to decide name
                this._pFinalizeAsset(this._animationSet);

                this._parsedFrames = true;
            };

            MD2Parser.prototype.readFrameName = function () {
                var name = "";
                var k = 0;
                for (var j = 0; j < 16; j++) {
                    var ch = this._byteData.readUnsignedByte();

                    if (Math.floor(ch) > 0x39 && Math.floor(ch) <= 0x7A && k == 0)
                        name += String.fromCharCode(ch);

                    if (Math.floor(ch) >= 0x30 && Math.floor(ch) <= 0x39)
                        k++;
                }
                return name;
            };

            MD2Parser.prototype.createDefaultSubGeometry = function () {
                var sub = new away.base.CompactSubGeometry();
                sub.updateData(this._firstSubGeom.vertexData);
                sub.updateIndexData(this._indices);
                this._geometry.addSubGeometry(sub);
            };
            MD2Parser.FPS = 6;
            return MD2Parser;
        })(loaders.ParserBase);
        loaders.MD2Parser = MD2Parser;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        var Parsers = (function () {
            function Parsers() {
            }
            Parsers.enableAllBundled = /**
            * Short-hand function to enable all bundled parsers for auto-detection. In practice,
            * this is the same as invoking enableParsers(Parsers.ALL_BUNDLED) on any of the
            * loader classes SingleFileLoader, AssetLoader, AssetLibrary or Loader3D.
            *
            * See notes about file size in the documentation for the ALL_BUNDLED constant.
            *
            * @see away3d.loaders.parsers.Parsers.ALL_BUNDLED
            */
            function () {
                away.loaders.SingleFileLoader.enableParsers(this.ALL_BUNDLED);
            };
            Parsers.ALL_BUNDLED = Array(away.loaders.AWDParser, away.loaders.Max3DSParser, away.loaders.MD2Parser, away.loaders.OBJParser);
            return Parsers;
        })();
        loaders.Parsers = Parsers;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (textures) {
        var TextureProxyBase = (function (_super) {
            __extends(TextureProxyBase, _super);
            function TextureProxyBase() {
                _super.call(this);
                this._format = away.display3D.Context3DTextureFormat.BGRA;
                this._hasMipmaps = true;

                this._textures = new Array(8);
                this._dirty = new Array(8);
            }
            Object.defineProperty(TextureProxyBase.prototype, "hasMipMaps", {
                get: /**
                *
                * @returns {boolean}
                */
                function () {
                    return this._hasMipmaps;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(TextureProxyBase.prototype, "format", {
                get: /**
                *
                * @returns {string}
                */
                function () {
                    return this._format;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(TextureProxyBase.prototype, "assetType", {
                get: /**
                *
                * @returns {string}
                */
                function () {
                    return away.library.AssetType.TEXTURE;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(TextureProxyBase.prototype, "width", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._pWidth;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(TextureProxyBase.prototype, "height", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._pHeight;
                },
                enumerable: true,
                configurable: true
            });

            TextureProxyBase.prototype.getTextureForStage3D = function (stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;

                var tex = this._textures[contextIndex];

                var context = stage3DProxy._iContext3D;

                if (!tex || this._dirty[contextIndex] != context) {
                    this._textures[contextIndex] = tex = this.pCreateTexture(context);
                    this._dirty[contextIndex] = context;
                    this.pUploadContent(tex);
                }

                return tex;
            };

            /**
            *
            * @param texture
            * @private
            */
            TextureProxyBase.prototype.pUploadContent = function (texture) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            *
            * @param width
            * @param height
            * @private
            */
            TextureProxyBase.prototype.pSetSize = function (width, height) {
                if (this._pWidth != width || this._pHeight != height) {
                    this.pInvalidateSize();
                }

                this._pWidth = width;
                this._pHeight = height;
            };

            /**
            *
            */
            TextureProxyBase.prototype.invalidateContent = function () {
                for (var i = 0; i < 8; ++i) {
                    this._dirty[i] = null;
                }
            };

            /**
            *
            * @private
            */
            TextureProxyBase.prototype.pInvalidateSize = function () {
                var tex;
                for (var i = 0; i < 8; ++i) {
                    tex = this._textures[i];

                    if (tex) {
                        tex.dispose();

                        this._textures[i] = null;
                        this._dirty[i] = null;
                    }
                }
            };

            /**
            *
            * @param context
            * @private
            */
            TextureProxyBase.prototype.pCreateTexture = function (context) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * @inheritDoc
            */
            TextureProxyBase.prototype.dispose = function () {
                for (var i = 0; i < 8; ++i) {
                    if (this._textures[i]) {
                        this._textures[i].dispose();
                    }
                }
            };
            return TextureProxyBase;
        })(away.library.NamedAssetBase);
        textures.TextureProxyBase = TextureProxyBase;
    })(away.textures || (away.textures = {}));
    var textures = away.textures;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (textures) {
        //use namespace arcane;
        var Texture2DBase = (function (_super) {
            __extends(Texture2DBase, _super);
            function Texture2DBase() {
                _super.call(this);
            }
            Texture2DBase.prototype.pCreateTexture = function (context) {
                return context.createTexture(this.width, this.height, away.display3D.Context3DTextureFormat.BGRA, false);
            };
            return Texture2DBase;
        })(away.textures.TextureProxyBase);
        textures.Texture2DBase = Texture2DBase;
    })(away.textures || (away.textures = {}));
    var textures = away.textures;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (textures) {
        var HTMLImageElementTexture = (function (_super) {
            __extends(HTMLImageElementTexture, _super);
            function HTMLImageElementTexture(htmlImageElement, generateMipmaps) {
                if (typeof generateMipmaps === "undefined") { generateMipmaps = true; }
                _super.call(this);

                this._htmlImageElement = htmlImageElement;
                this._generateMipmaps = generateMipmaps;
            }
            Object.defineProperty(HTMLImageElementTexture.prototype, "htmlImageElement", {
                get: function () {
                    return this._htmlImageElement;
                },
                set: function (value) {
                    if (value == this._htmlImageElement) {
                        return;
                    }

                    if (!away.utils.TextureUtils.isHTMLImageElementValid(value)) {
                        throw new away.errors.Error("Invalid bitmapData: Width and height must be power of 2 and cannot exceed 2048");
                    }

                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._htmlImageElement = value;

                    if (this._generateMipmaps) {
                        this.getMipMapHolder();
                    }
                },
                enumerable: true,
                configurable: true
            });


            HTMLImageElementTexture.prototype.pUploadContent = function (texture) {
                if (this._generateMipmaps) {
                    away.materials.MipmapGenerator.generateHTMLImageElementMipMaps(this._htmlImageElement, texture, this._mipMapHolder, true);
                } else {
                    var tx = texture;
                    tx.uploadFromHTMLImageElement(this._htmlImageElement, 0);
                }
            };

            HTMLImageElementTexture.prototype.getMipMapHolder = function () {
                var newW = this._htmlImageElement.width;
                var newH = this._htmlImageElement.height;

                if (this._mipMapHolder) {
                    if (this._mipMapHolder.width == newW && this._htmlImageElement.height == newH) {
                        return;
                    }

                    this.freeMipMapHolder();
                }

                if (!HTMLImageElementTexture._mipMaps[newW]) {
                    HTMLImageElementTexture._mipMaps[newW] = [];
                    HTMLImageElementTexture._mipMapUses[newW] = [];
                }

                if (!HTMLImageElementTexture._mipMaps[newW][newH]) {
                    this._mipMapHolder = HTMLImageElementTexture._mipMaps[newW][newH] = new away.display.BitmapData(newW, newH, true);
                    HTMLImageElementTexture._mipMapUses[newW][newH] = 1;
                } else {
                    HTMLImageElementTexture._mipMapUses[newW][newH] = HTMLImageElementTexture._mipMapUses[newW][newH] + 1;
                    this._mipMapHolder = HTMLImageElementTexture._mipMaps[newW][newH];
                }
            };

            HTMLImageElementTexture.prototype.freeMipMapHolder = function () {
                var holderWidth = this._mipMapHolder.width;
                var holderHeight = this._mipMapHolder.height;

                if (--HTMLImageElementTexture._mipMapUses[holderWidth][holderHeight] == 0) {
                    HTMLImageElementTexture._mipMaps[holderWidth][holderHeight].dispose();
                    HTMLImageElementTexture._mipMaps[holderWidth][holderHeight] = null;
                }
            };

            HTMLImageElementTexture.prototype.dispose = function () {
                _super.prototype.dispose.call(this);

                if (this._mipMapHolder) {
                    this.freeMipMapHolder();
                }
            };
            HTMLImageElementTexture._mipMaps = [];
            HTMLImageElementTexture._mipMapUses = [];
            return HTMLImageElementTexture;
        })(away.textures.Texture2DBase);
        textures.HTMLImageElementTexture = HTMLImageElementTexture;
    })(away.textures || (away.textures = {}));
    var textures = away.textures;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (textures) {
        var BitmapTexture = (function (_super) {
            __extends(BitmapTexture, _super);
            function BitmapTexture(bitmapData, generateMipmaps) {
                if (typeof generateMipmaps === "undefined") { generateMipmaps = true; }
                _super.call(this);

                this.bitmapData = bitmapData;
                this._generateMipmaps = generateMipmaps;
            }
            Object.defineProperty(BitmapTexture.prototype, "bitmapData", {
                get: function () {
                    return this._bitmapData;
                },
                set: function (value) {
                    if (value == this._bitmapData) {
                        return;
                    }

                    if (!away.utils.TextureUtils.isBitmapDataValid(value)) {
                        throw new Error("Invalid bitmapData: Width and height must be power of 2 and cannot exceed 2048");
                    }

                    this.invalidateContent();

                    this.pSetSize(value.width, value.height);

                    this._bitmapData = value;

                    if (this._generateMipmaps) {
                        this.getMipMapHolder();
                    }
                },
                enumerable: true,
                configurable: true
            });


            BitmapTexture.prototype.pUploadContent = function (texture) {
                if (this._generateMipmaps) {
                    away.materials.MipmapGenerator.generateMipMaps(this._bitmapData, texture, this._mipMapHolder, true);
                } else {
                    var tx = texture;
                    tx.uploadFromBitmapData(this._bitmapData, 0);
                }
            };

            BitmapTexture.prototype.getMipMapHolder = function () {
                var newW, newH;

                newW = this._bitmapData.width;
                newH = this._bitmapData.height;

                if (this._mipMapHolder) {
                    if (this._mipMapHolder.width == newW && this._bitmapData.height == newH) {
                        return;
                    }

                    this.freeMipMapHolder();
                }

                if (!BitmapTexture._mipMaps[newW]) {
                    BitmapTexture._mipMaps[newW] = [];
                    BitmapTexture._mipMapUses[newW] = [];
                }

                if (!BitmapTexture._mipMaps[newW][newH]) {
                    this._mipMapHolder = BitmapTexture._mipMaps[newW][newH] = new away.display.BitmapData(newW, newH, true);
                    BitmapTexture._mipMapUses[newW][newH] = 1;
                } else {
                    BitmapTexture._mipMapUses[newW][newH] = BitmapTexture._mipMapUses[newW][newH] + 1;
                    this._mipMapHolder = BitmapTexture._mipMaps[newW][newH];
                }
            };

            BitmapTexture.prototype.freeMipMapHolder = function () {
                var holderWidth = this._mipMapHolder.width;
                var holderHeight = this._mipMapHolder.height;

                if (--BitmapTexture._mipMapUses[holderWidth][holderHeight] == 0) {
                    BitmapTexture._mipMaps[holderWidth][holderHeight].dispose();
                    BitmapTexture._mipMaps[holderWidth][holderHeight] = null;
                }
            };

            BitmapTexture.prototype.dispose = function () {
                _super.prototype.dispose.call(this);

                if (this._mipMapHolder) {
                    this.freeMipMapHolder();
                }
            };
            BitmapTexture._mipMaps = [];
            BitmapTexture._mipMapUses = [];
            return BitmapTexture;
        })(away.textures.Texture2DBase);
        textures.BitmapTexture = BitmapTexture;
    })(away.textures || (away.textures = {}));
    var textures = away.textures;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (textures) {
        var CubeTextureBase = (function (_super) {
            __extends(CubeTextureBase, _super);
            function CubeTextureBase() {
                _super.call(this);
            }
            Object.defineProperty(CubeTextureBase.prototype, "size", {
                get: function () {
                    //TODO replace this with this._pWidth (requires change in super class to reflect the protected declaration)
                    return this.width;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            CubeTextureBase.prototype.pCreateTexture = function (context) {
                return context.createCubeTexture(this.width, away.display3D.Context3DTextureFormat.BGRA, false);
            };
            return CubeTextureBase;
        })(away.textures.TextureProxyBase);
        textures.CubeTextureBase = CubeTextureBase;
    })(away.textures || (away.textures = {}));
    var textures = away.textures;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (textures) {
        var RenderTexture = (function (_super) {
            __extends(RenderTexture, _super);
            function RenderTexture(width, height) {
                _super.call(this);
                this.pSetSize(width, height);
            }
            Object.defineProperty(RenderTexture.prototype, "width", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._pWidth;
                },
                set: function (value) {
                    if (value == this._pWidth) {
                        return;
                    }

                    if (!away.utils.TextureUtils.isDimensionValid(value))
                        throw new Error("Invalid size: Width and height must be power of 2 and cannot exceed 2048");

                    this.invalidateContent();
                    this.pSetSize(value, this._pHeight);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RenderTexture.prototype, "height", {
                get: /**
                *
                * @returns {number}
                */
                function () {
                    return this._pHeight;
                },
                set: function (value) {
                    if (value == this._pHeight) {
                        return;
                    }

                    if (!away.utils.TextureUtils.isDimensionValid(value)) {
                        throw new Error("Invalid size: Width and height must be power of 2 and cannot exceed 2048");
                    }

                    this.invalidateContent();
                    this.pSetSize(this._pWidth, value);
                },
                enumerable: true,
                configurable: true
            });


            RenderTexture.prototype.pUploadContent = function (texture) {
                // fake data, to complete texture for sampling
                var bmp = new away.display.BitmapData(this.width, this.height, false, 0xff0000);

                //(<away.display3D.Texture> texture).uploadFromBitmapData(bmp, 0);
                //away.materials.MipmapGenerator.generateMipMaps(bmp, texture);
                (texture).generateFromRenderBuffer(bmp);
                bmp.dispose();
            };

            RenderTexture.prototype.pCreateTexture = function (context) {
                return context.createTexture(this.width, this.height, away.display3D.Context3DTextureFormat.BGRA, true);
            };
            return RenderTexture;
        })(away.textures.Texture2DBase);
        textures.RenderTexture = RenderTexture;
    })(away.textures || (away.textures = {}));
    var textures = away.textures;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (textures) {
        var HTMLImageElementCubeTexture = (function (_super) {
            __extends(HTMLImageElementCubeTexture, _super);
            function HTMLImageElementCubeTexture(posX, negX, posY, negY, posZ, negZ) {
                _super.call(this);
                this._useMipMaps = false;

                this._bitmapDatas = new Array(6);
                this.testSize(this._bitmapDatas[0] = posX);
                this.testSize(this._bitmapDatas[1] = negX);
                this.testSize(this._bitmapDatas[2] = posY);
                this.testSize(this._bitmapDatas[3] = negY);
                this.testSize(this._bitmapDatas[4] = posZ);
                this.testSize(this._bitmapDatas[5] = negZ);

                this.pSetSize(posX.width, posX.height);
            }
            Object.defineProperty(HTMLImageElementCubeTexture.prototype, "positiveX", {
                get: /**
                * The texture on the cube's right face.
                */
                function () {
                    return this._bitmapDatas[0];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[0] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HTMLImageElementCubeTexture.prototype, "negativeX", {
                get: /**
                * The texture on the cube's left face.
                */
                function () {
                    return this._bitmapDatas[1];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[1] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HTMLImageElementCubeTexture.prototype, "positiveY", {
                get: /**
                * The texture on the cube's top face.
                */
                function () {
                    return this._bitmapDatas[2];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[2] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HTMLImageElementCubeTexture.prototype, "negativeY", {
                get: /**
                * The texture on the cube's bottom face.
                */
                function () {
                    return this._bitmapDatas[3];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[3] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HTMLImageElementCubeTexture.prototype, "positiveZ", {
                get: /**
                * The texture on the cube's far face.
                */
                function () {
                    return this._bitmapDatas[4];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[4] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HTMLImageElementCubeTexture.prototype, "negativeZ", {
                get: /**
                * The texture on the cube's near face.
                */
                function () {
                    return this._bitmapDatas[5];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[5] = value;
                },
                enumerable: true,
                configurable: true
            });


            HTMLImageElementCubeTexture.prototype.testSize = function (value) {
                if (value.width != value.height)
                    throw new Error("BitmapData should have equal width and height!");
                if (!away.utils.TextureUtils.isHTMLImageElementValid(value))
                    throw new Error("Invalid bitmapData: Width and height must be power of 2 and cannot exceed 2048");
            };

            HTMLImageElementCubeTexture.prototype.pUploadContent = function (texture) {
                for (var i = 0; i < 6; ++i) {
                    if (this._useMipMaps) {
                        //away.materials.MipmapGenerator.generateMipMaps(this._bitmapDatas[i], texture, null, false, i);
                    } else {
                        var tx = texture;
                        tx.uploadFromHTMLImageElement(this._bitmapDatas[i], i, 0);
                    }
                }
            };
            return HTMLImageElementCubeTexture;
        })(textures.CubeTextureBase);
        textures.HTMLImageElementCubeTexture = HTMLImageElementCubeTexture;
    })(away.textures || (away.textures = {}));
    var textures = away.textures;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (textures) {
        var BitmapCubeTexture = (function (_super) {
            __extends(BitmapCubeTexture, _super);
            function BitmapCubeTexture(posX, negX, posY, negY, posZ, negZ) {
                _super.call(this);
                this._useMipMaps = false;

                this._bitmapDatas = new Array(6);
                this.testSize(this._bitmapDatas[0] = posX);
                this.testSize(this._bitmapDatas[1] = negX);
                this.testSize(this._bitmapDatas[2] = posY);
                this.testSize(this._bitmapDatas[3] = negY);
                this.testSize(this._bitmapDatas[4] = posZ);
                this.testSize(this._bitmapDatas[5] = negZ);

                this.pSetSize(posX.width, posX.height);
            }
            Object.defineProperty(BitmapCubeTexture.prototype, "positiveX", {
                get: /**
                * The texture on the cube's right face.
                */
                function () {
                    return this._bitmapDatas[0];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[0] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BitmapCubeTexture.prototype, "negativeX", {
                get: /**
                * The texture on the cube's left face.
                */
                function () {
                    return this._bitmapDatas[1];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[1] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BitmapCubeTexture.prototype, "positiveY", {
                get: /**
                * The texture on the cube's top face.
                */
                function () {
                    return this._bitmapDatas[2];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[2] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BitmapCubeTexture.prototype, "negativeY", {
                get: /**
                * The texture on the cube's bottom face.
                */
                function () {
                    return this._bitmapDatas[3];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[3] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BitmapCubeTexture.prototype, "positiveZ", {
                get: /**
                * The texture on the cube's far face.
                */
                function () {
                    return this._bitmapDatas[4];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[4] = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BitmapCubeTexture.prototype, "negativeZ", {
                get: /**
                * The texture on the cube's near face.
                */
                function () {
                    return this._bitmapDatas[5];
                },
                set: function (value) {
                    this.testSize(value);
                    this.invalidateContent();
                    this.pSetSize(value.width, value.height);
                    this._bitmapDatas[5] = value;
                },
                enumerable: true,
                configurable: true
            });


            BitmapCubeTexture.prototype.testSize = function (value) {
                if (value.width != value.height)
                    throw new Error("BitmapData should have equal width and height!");
                if (!away.utils.TextureUtils.isBitmapDataValid(value))
                    throw new Error("Invalid bitmapData: Width and height must be power of 2 and cannot exceed 2048");
            };

            BitmapCubeTexture.prototype.pUploadContent = function (texture) {
                for (var i = 0; i < 6; ++i) {
                    if (this._useMipMaps) {
                        //away.materials.MipmapGenerator.generateMipMaps(this._bitmapDatas[i], texture, null, false, i);
                    } else {
                        var tx = texture;
                        tx.uploadFromBitmapData(this._bitmapDatas[i], i, 0);
                    }
                }
            };
            return BitmapCubeTexture;
        })(textures.CubeTextureBase);
        textures.BitmapCubeTexture = BitmapCubeTexture;
    })(away.textures || (away.textures = {}));
    var textures = away.textures;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        //import flash.display.BitmapData;
        var TextureUtils = (function () {
            function TextureUtils() {
            }
            TextureUtils.isBitmapDataValid = function (bitmapData) {
                if (bitmapData == null) {
                    return true;
                }

                return TextureUtils.isDimensionValid(bitmapData.width) && TextureUtils.isDimensionValid(bitmapData.height);
            };

            TextureUtils.isHTMLImageElementValid = function (image) {
                if (image == null) {
                    return true;
                }

                return TextureUtils.isDimensionValid(image.width) && TextureUtils.isDimensionValid(image.height);
            };

            TextureUtils.isDimensionValid = function (d) {
                return d >= 1 && d <= TextureUtils.MAX_SIZE && TextureUtils.isPowerOfTwo(d);
            };

            TextureUtils.isPowerOfTwo = function (value) {
                return value ? ((value & -value) == value) : false;
            };

            TextureUtils.getBestPowerOf2 = function (value) {
                var p = 1;

                while (p < value)
                    p <<= 1;

                if (p > TextureUtils.MAX_SIZE)
                    p = TextureUtils.MAX_SIZE;

                return p;
            };
            TextureUtils.MAX_SIZE = 2048;
            return TextureUtils;
        })();
        utils.TextureUtils = TextureUtils;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        var TimerEvent = (function (_super) {
            __extends(TimerEvent, _super);
            function TimerEvent(type) {
                _super.call(this, type);
            }
            TimerEvent.TIMER = "timer";
            TimerEvent.TIMER_COMPLETE = "timerComplete";
            return TimerEvent;
        })(away.events.Event);
        events.TimerEvent = TimerEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        //import flash.events.Event;
        var ParserEvent = (function (_super) {
            __extends(ParserEvent, _super);
            function ParserEvent(type, message) {
                if (typeof message === "undefined") { message = ''; }
                _super.call(this, type);

                this._message = message;
            }
            Object.defineProperty(ParserEvent.prototype, "message", {
                get: /**
                * Additional human-readable message. Usually supplied for ParserEvent.PARSE_ERROR events.
                */
                function () {
                    return this._message;
                },
                enumerable: true,
                configurable: true
            });

            ParserEvent.prototype.clone = function () {
                return new away.events.ParserEvent(this.type, this.message);
            };
            ParserEvent.PARSE_COMPLETE = 'parseComplete';

            ParserEvent.PARSE_ERROR = 'parseError';

            ParserEvent.READY_FOR_DEPENDENCIES = 'readyForDependencies';
            return ParserEvent;
        })(away.events.Event);
        events.ParserEvent = ParserEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (loaders) {
        //import away3d.arcane;
        //import away3d.library.assets.IAsset;
        //import away3d.loaders.parsers.ParserBase;
        //import flash.net.URLRequest;
        //use namespace arcane;
        /**
        * ResourceDependency represents the data required to load, parse and resolve additional files ("dependencies")
        * required by a parser, used by ResourceLoadSession.
        *
        */
        var ResourceDependency = (function () {
            function ResourceDependency(id, req, data, parentParser, retrieveAsRawData, suppressAssetEvents) {
                if (typeof retrieveAsRawData === "undefined") { retrieveAsRawData = false; }
                if (typeof suppressAssetEvents === "undefined") { suppressAssetEvents = false; }
                this._id = id;
                this._req = req;
                this._parentParser = parentParser;
                this._data = data;
                this._retrieveAsRawData = retrieveAsRawData;
                this._suppressAssetEvents = suppressAssetEvents;

                this._assets = new Array();
                this._dependencies = new Array();
            }
            Object.defineProperty(ResourceDependency.prototype, "id", {
                get: function () {
                    return this._id;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ResourceDependency.prototype, "assets", {
                get: function () {
                    return this._assets;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ResourceDependency.prototype, "dependencies", {
                get: function () {
                    return this._dependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ResourceDependency.prototype, "request", {
                get: function () {
                    return this._req;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ResourceDependency.prototype, "retrieveAsRawData", {
                get: function () {
                    return this._retrieveAsRawData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ResourceDependency.prototype, "suppresAssetEvents", {
                get: function () {
                    return this._suppressAssetEvents;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ResourceDependency.prototype, "data", {
                get: /**
                * The data containing the dependency to be parsed, if the resource was already loaded.
                */
                function () {
                    return this._data;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @private
            * Method to set data after having already created the dependency object, e.g. after load.
            */
            ResourceDependency.prototype._iSetData = function (data) {
                this._data = data;
            };

            Object.defineProperty(ResourceDependency.prototype, "parentParser", {
                get: /**
                * The parser which is dependent on this ResourceDependency object.
                */
                function () {
                    return this._parentParser;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Resolve the dependency when it's loaded with the parent parser. For example, a dependency containing an
            * ImageResource would be assigned to a Mesh instance as a BitmapMaterial, a scene graph object would be added
            * to its intended parent. The dependency should be a member of the dependencies property.
            */
            ResourceDependency.prototype.resolve = function () {
                if (this._parentParser)
                    this._parentParser._iResolveDependency(this);
            };

            /**
            * Resolve a dependency failure. For example, map loading failure from a 3d file
            */
            ResourceDependency.prototype.resolveFailure = function () {
                if (this._parentParser)
                    this._parentParser._iResolveDependencyFailure(this);
            };

            /**
            * Resolve the dependencies name
            */
            ResourceDependency.prototype.resolveName = function (asset) {
                if (this._parentParser)
                    return this._parentParser._iResolveDependencyName(this, asset);
                return asset.name;
            };
            return ResourceDependency;
        })();
        loaders.ResourceDependency = ResourceDependency;
    })(away.loaders || (away.loaders = {}));
    var loaders = away.loaders;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        //[native(cls="TimerClass", gc="exact", instance="TimerObject", methods="auto")]
        //[Event(name="timerComplete", type="flash.events.TimerEvent")]
        //[Event(name="timer", type="flash.events.TimerEvent")]
        var Timer = (function (_super) {
            __extends(Timer, _super);
            function Timer(delay, repeatCount) {
                if (typeof repeatCount === "undefined") { repeatCount = 0; }
                _super.call(this);
                this._repeatCount = 0;
                this._currentCount = 0;
                this._running = false;

                this._delay = delay;
                this._repeatCount = repeatCount;

                if (isNaN(delay) || delay < 0) {
                    throw new away.errors.Error("Delay is negative or not a number");
                }
            }
            Object.defineProperty(Timer.prototype, "currentCount", {
                get: function () {
                    return this._currentCount;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Timer.prototype, "delay", {
                get: function () {
                    return this._delay;
                },
                set: function (value) {
                    this._delay = value;

                    if (this._running) {
                        this.stop();
                        this.start();
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Timer.prototype, "repeatCount", {
                get: function () {
                    return this._repeatCount;
                },
                set: function (value) {
                    this._repeatCount = value;
                },
                enumerable: true,
                configurable: true
            });


            Timer.prototype.reset = function () {
                if (this._running) {
                    this.stop();
                }

                this._currentCount = 0;
            };

            Object.defineProperty(Timer.prototype, "running", {
                get: function () {
                    return this._running;
                },
                enumerable: true,
                configurable: true
            });

            Timer.prototype.start = function () {
                var _this = this;
                this._running = true;
                clearInterval(this._iid);
                this._iid = setInterval(function () {
                    return _this.tick();
                }, this._delay);
            };

            Timer.prototype.stop = function () {
                this._running = false;
                clearInterval(this._iid);
            };

            Timer.prototype.tick = function () {
                this._currentCount++;

                if ((this._repeatCount > 0) && this._currentCount >= this._repeatCount) {
                    this.stop();
                    this.dispatchEvent(new away.events.TimerEvent(away.events.TimerEvent.TIMER));
                    this.dispatchEvent(new away.events.TimerEvent(away.events.TimerEvent.TIMER_COMPLETE));
                } else {
                    this.dispatchEvent(new away.events.TimerEvent(away.events.TimerEvent.TIMER));
                }
            };
            return Timer;
        })(away.events.EventDispatcher);
        utils.Timer = Timer;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        //[native(cls="TimerClass", gc="exact", instance="TimerObject", methods="auto")]
        //[Event(name="timerComplete", type="flash.events.TimerEvent")]
        //[Event(name="timer", type="flash.events.TimerEvent")]
        function getTimer() {
            // number milliseconds of 1970/01/01
            // this different to AS3 implementation which gets the number of milliseconds
            // since instance of Flash player was initialised
            return Date.now();
        }
        utils.getTimer = getTimer;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        //import away3d.arcane;
        //import away3d.containers.ObjectContainer3D;
        //import away3d.containers.View3D;
        //import away3d.core.base.IRenderable;
        //import away3d.materials.MaterialBase;
        //import flash.events.Event;
        //import flash.geom.Point;
        //import flash.geom.Vector3D;
        //use namespace arcane;
        /**
        * A MouseEvent3D is dispatched when a mouse event occurs over a mouseEnabled object in View3D.
        * todo: we don't have screenZ data, tho this should be easy to implement
        */
        var MouseEvent3D = (function (_super) {
            __extends(MouseEvent3D, _super);
            /**
            * Create a new MouseEvent3D object.
            * @param type The type of the MouseEvent3D.
            */
            function MouseEvent3D(type) {
                _super.call(this, type);
                // Private.
                this._iAllowedToPropagate = true;
            }
            Object.defineProperty(MouseEvent3D.prototype, "bubbles", {
                get: /**
                * @inheritDoc
                */
                function () {
                    var doesBubble = this._iAllowedToPropagate;
                    this._iAllowedToPropagate = true;

                    // Don't bubble if propagation has been stopped.
                    return doesBubble;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            MouseEvent3D.prototype.stopPropagation = function () {
                this._iAllowedToPropagate = false;

                if (this._iParentEvent) {
                    this._iParentEvent.stopPropagation();
                }
            };

            /**
            * @inheritDoc
            */
            MouseEvent3D.prototype.stopImmediatePropagation = function () {
                this._iAllowedToPropagate = false;

                if (this._iParentEvent) {
                    this._iParentEvent.stopImmediatePropagation();
                }
            };

            /**
            * Creates a copy of the MouseEvent3D object and sets the value of each property to match that of the original.
            */
            MouseEvent3D.prototype.clone = function () {
                var result = new away.events.MouseEvent3D(this.type);

                /* TODO: Debug / test - look into isDefaultPrevented
                if (isDefaultPrevented())
                result.preventDefault();
                */
                result.screenX = this.screenX;
                result.screenY = this.screenY;

                result.view = this.view;
                result.object = this.object;
                result.renderable = this.renderable;
                result.material = this.material;
                result.uv = this.uv;
                result.localPosition = this.localPosition;
                result.localNormal = this.localNormal;
                result.index = this.index;
                result.subGeometryIndex = this.subGeometryIndex;
                result.delta = this.delta;

                result.ctrlKey = this.ctrlKey;
                result.shiftKey = this.shiftKey;

                result._iParentEvent = this;
                result._iAllowedToPropagate = this._iAllowedToPropagate;

                return result;
            };

            Object.defineProperty(MouseEvent3D.prototype, "scenePosition", {
                get: /**
                * The position in scene space where the event took place
                */
                function () {
                    if (this.object instanceof away.containers.ObjectContainer3D) {
                        var objContainer = this.object;
                        return objContainer.sceneTransform.transformVector(this.localPosition);
                    } else {
                        return this.localPosition;
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MouseEvent3D.prototype, "sceneNormal", {
                get: /**
                * The normal in scene space where the event took place
                */
                function () {
                    if (this.object instanceof away.containers.ObjectContainer3D) {
                        var objContainer = this.object;
                        var sceneNormal = objContainer.sceneTransform.deltaTransformVector(this.localNormal);

                        sceneNormal.normalize();

                        return sceneNormal;
                    } else {
                        return this.localNormal;
                    }
                    /*
                    if (object is ObjectContainer3D) {
                    var sceneNormal:Vector3D = ObjectContainer3D(object)
                    sceneNormal.normalize();
                    return sceneNormal;
                    } else
                    return localNormal;
                    */
                },
                enumerable: true,
                configurable: true
            });
            MouseEvent3D.MOUSE_OVER = "mouseOver3d";

            MouseEvent3D.MOUSE_OUT = "mouseOut3d";

            MouseEvent3D.MOUSE_UP = "mouseUp3d";

            MouseEvent3D.MOUSE_DOWN = "mouseDown3d";

            MouseEvent3D.MOUSE_MOVE = "mouseMove3d";

            MouseEvent3D.CLICK = "click3d";

            MouseEvent3D.DOUBLE_CLICK = "doubleClick3d";

            MouseEvent3D.MOUSE_WHEEL = "mouseWheel3d";
            return MouseEvent3D;
        })(events.Event);
        events.MouseEvent3D = MouseEvent3D;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (managers) {
        //import away3d.arcane;
        //import away3d.debug.Debug;
        //import away3d.events.Stage3DEvent;
        //import flash.display.Shape;
        //import flash.display.Stage3D;
        //import flash.display3D.Context3D;
        //import flash.display3D.Context3DClearMask;
        //import flash.display3D.Context3DRenderMode;
        //import flash.display3D.Program3D;
        //import flash.display3D.textures.TextureBase;
        //import flash.events.Event;
        //import flash.events.EventDispatcher;
        //import flash.geom.Rectangle;
        //use namespace arcane;
        //[Event(name="enterFrame", type="flash.events.Event")]
        //[Event(name="exitFrame", type="flash.events.Event")]
        /**
        * Stage3DProxy provides a proxy class to manage a single Stage3D instance as well as handling the creation and
        * attachment of the Context3D (and in turn the back buffer) is uses. Stage3DProxy should never be created directly,
        * but requested through Stage3DManager.
        *
        * @see away3d.core.managers.Stage3DProxy
        *
        * todo: consider moving all creation methods (createVertexBuffer etc) in here, so that disposal can occur here
        * along with the context, instead of scattered throughout the framework
        */
        var Stage3DProxy = (function (_super) {
            __extends(Stage3DProxy, _super);
            /**
            * Creates a Stage3DProxy object. This method should not be called directly. Creation of Stage3DProxy objects should
            * be handled by Stage3DManager.
            * @param stage3DIndex The index of the Stage3D to be proxied.
            * @param stage3D The Stage3D to be proxied.
            * @param stage3DManager
            * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
            */
            function Stage3DProxy(stage3DIndex, stage3D, stage3DManager, forceSoftware, profile) {
                if (typeof forceSoftware === "undefined") { forceSoftware = false; }
                if (typeof profile === "undefined") { profile = "baseline"; }
                _super.call(this);
                this._iStage3DIndex = -1;
                this._antiAlias = 0;
                //private var _activeVertexBuffers : Vector.<VertexBuffer3D> = new Vector.<VertexBuffer3D>(8, true);
                //private var _activeTextures : Vector.<TextureBase> = new Vector.<TextureBase>(8, true);
                this._renderTarget = null;
                this._renderSurfaceSelector = 0;

                this._iStage3DIndex = stage3DIndex;
                this._stage3D = stage3D;

                this._stage3D.x = 0;
                this._stage3D.y = 0;
                this._stage3D.visible = true;
                this._stage3DManager = stage3DManager;
                this._viewPort = new away.geom.Rectangle();
                this._enableDepthAndStencil = true;

                // whatever happens, be sure this has highest priority
                this._stage3D.addEventListener(away.events.Event.CONTEXT3D_CREATE, this.onContext3DUpdate, this);
                this.requestContext(forceSoftware, this.profile);
            }
            //private _touch3DManager:Touch3DManager; //TODO: imeplement dependency Touch3DManager
            Stage3DProxy.prototype.notifyViewportUpdated = function () {
                if (this._viewportDirty) {
                    return;
                }

                this._viewportDirty = true;

                //if (!this.hasEventListener(away.events.Stage3DEvent.VIEWPORT_UPDATED))
                //return;
                //if (!_viewportUpdated)
                this._viewportUpdated = new away.events.Stage3DEvent(away.events.Stage3DEvent.VIEWPORT_UPDATED);
                this.dispatchEvent(this._viewportUpdated);
            };

            Stage3DProxy.prototype.notifyEnterFrame = function () {
                if (!this._enterFrame) {
                    this._enterFrame = new away.events.Event(away.events.Event.ENTER_FRAME);
                }

                this.dispatchEvent(this._enterFrame);
            };

            Stage3DProxy.prototype.notifyExitFrame = function () {
                if (!this._exitFrame)
                    this._exitFrame = new away.events.Event(away.events.Event.EXIT_FRAME);

                this.dispatchEvent(this._exitFrame);
            };

            Object.defineProperty(Stage3DProxy.prototype, "profile", {
                get: function () {
                    return this._profile;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Disposes the Stage3DProxy object, freeing the Context3D attached to the Stage3D.
            */
            Stage3DProxy.prototype.dispose = function () {
                this._stage3DManager.iRemoveStage3DProxy(this);
                this._stage3D.removeEventListener(away.events.Event.CONTEXT3D_CREATE, this.onContext3DUpdate, this);
                this.freeContext3D();
                this._stage3D = null;
                this._stage3DManager = null;
                this._iStage3DIndex = -1;
            };

            /**
            * Configures the back buffer associated with the Stage3D object.
            * @param backBufferWidth The width of the backbuffer.
            * @param backBufferHeight The height of the backbuffer.
            * @param antiAlias The amount of anti-aliasing to use.
            * @param enableDepthAndStencil Indicates whether the back buffer contains a depth and stencil buffer.
            */
            Stage3DProxy.prototype.configureBackBuffer = function (backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil) {
                var oldWidth = this._backBufferWidth;
                var oldHeight = this._backBufferHeight;

                this._backBufferWidth = this._viewPort.width = backBufferWidth;
                this._backBufferHeight = this._viewPort.height = backBufferHeight;

                if (oldWidth != this._backBufferWidth || oldHeight != this._backBufferHeight)
                    this.notifyViewportUpdated();

                this._antiAlias = antiAlias;
                this._enableDepthAndStencil = enableDepthAndStencil;

                if (this._iContext3D)
                    this._iContext3D.configureBackBuffer(backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil);

                this._stage3D.width = backBufferWidth;
                this._stage3D.height = backBufferHeight;
            };

            Object.defineProperty(Stage3DProxy.prototype, "enableDepthAndStencil", {
                get: /*
                * Indicates whether the depth and stencil buffer is used
                */
                function () {
                    return this._enableDepthAndStencil;
                },
                set: function (enableDepthAndStencil) {
                    this._enableDepthAndStencil = enableDepthAndStencil;
                    this._backBufferDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Stage3DProxy.prototype, "renderTarget", {
                get: function () {
                    return this._renderTarget;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "renderSurfaceSelector", {
                get: function () {
                    return this._renderSurfaceSelector;
                },
                enumerable: true,
                configurable: true
            });

            Stage3DProxy.prototype.setRenderTarget = function (target, enableDepthAndStencil, surfaceSelector) {
                if (typeof enableDepthAndStencil === "undefined") { enableDepthAndStencil = false; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                if (this._renderTarget === target && surfaceSelector == this._renderSurfaceSelector && this._enableDepthAndStencil == enableDepthAndStencil) {
                    return;
                }

                this._renderTarget = target;
                this._renderSurfaceSelector = surfaceSelector;
                this._enableDepthAndStencil = enableDepthAndStencil;

                if (target) {
                    this._iContext3D.setRenderToTexture(target, enableDepthAndStencil, this._antiAlias, surfaceSelector);
                } else {
                    this._iContext3D.setRenderToBackBuffer();
                    this.configureBackBuffer(this._backBufferWidth, this._backBufferHeight, this._antiAlias, this._enableDepthAndStencil);
                }
            };

            /*
            * Clear and reset the back buffer when using a shared context
            */
            Stage3DProxy.prototype.clear = function () {
                if (!this._iContext3D)
                    return;

                if (this._backBufferDirty) {
                    this.configureBackBuffer(this._backBufferWidth, this._backBufferHeight, this._antiAlias, this._enableDepthAndStencil);
                    this._backBufferDirty = false;
                }

                this._iContext3D.clear((this._color & 0xff000000) >>> 24, (this._color & 0xff0000) >>> 16, (this._color & 0xff00) >>> 8, this._color & 0xff);

                this._bufferClear = true;
            };

            /*
            * Display the back rendering buffer
            */
            Stage3DProxy.prototype.present = function () {
                if (!this._iContext3D)
                    return;

                this._iContext3D.present();

                this._activeProgram3D = null;

                if (this._mouse3DManager)
                    this._mouse3DManager.fireMouseEvents();
            };

            /**
            * Registers an event listener object with an EventDispatcher object so that the listener receives notification of an event. Special case for enterframe and exitframe events - will switch Stage3DProxy into automatic render mode.
            * You can register event listeners on all nodes in the display list for a specific type of event, phase, and priority.
            *
            * @param type The type of event.
            * @param listener The listener function that processes the event.
            * @param useCapture Determines whether the listener works in the capture phase or the target and bubbling phases. If useCapture is set to true, the listener processes the event only during the capture phase and not in the target or bubbling phase. If useCapture is false, the listener processes the event only during the target or bubbling phase. To listen for the event in all three phases, call addEventListener twice, once with useCapture set to true, then again with useCapture set to false.
            * @param priority The priority level of the event listener. The priority is designated by a signed 32-bit integer. The higher the number, the higher the priority. All listeners with priority n are processed before listeners of priority n-1. If two or more listeners share the same priority, they are processed in the order in which they were added. The default priority is 0.
            * @param useWeakReference Determines whether the reference to the listener is strong or weak. A strong reference (the default) prevents your listener from being garbage-collected. A weak reference does not.
            */
            //public override function addEventListener(type:string, listener, useCapture:boolean = false, priority:number = 0, useWeakReference:boolean = false)
            Stage3DProxy.prototype.addEventListener = function (type, listener, target) {
                _super.prototype.addEventListener.call(this, type, listener, target);
                //away.Debug.throwPIR( 'Stage3DProxy' , 'addEventListener' ,  'EnterFrame, ExitFrame');
                //if ((type == away.events.Event.ENTER_FRAME || type == away.events.Event.EXIT_FRAME) ){//&& ! this._frameEventDriver.hasEventListener(Event.ENTER_FRAME)){
                //_frameEventDriver.addEventListener(Event.ENTER_FRAME, onEnterFrame, useCapture, priority, useWeakReference);
                //}
                /* Original code
                if ((type == Event.ENTER_FRAME || type == Event.EXIT_FRAME) && ! _frameEventDriver.hasEventListener(Event.ENTER_FRAME)){
                
                _frameEventDriver.addEventListener(Event.ENTER_FRAME, onEnterFrame, useCapture, priority, useWeakReference);
                
                
                }
                */
            };

            /**
            * Removes a listener from the EventDispatcher object. Special case for enterframe and exitframe events - will switch Stage3DProxy out of automatic render mode.
            * If there is no matching listener registered with the EventDispatcher object, a call to this method has no effect.
            *
            * @param type The type of event.
            * @param listener The listener object to remove.
            * @param useCapture Specifies whether the listener was registered for the capture phase or the target and bubbling phases. If the listener was registered for both the capture phase and the target and bubbling phases, two calls to removeEventListener() are required to remove both, one call with useCapture() set to true, and another call with useCapture() set to false.
            */
            Stage3DProxy.prototype.removeEventListener = function (type, listener, target) {
                _super.prototype.removeEventListener.call(this, type, listener, target);
                //away.Debug.throwPIR( 'Stage3DProxy' , 'removeEventListener' ,  'EnterFrame, ExitFrame');
                /*
                // Remove the main rendering listener if no EnterFrame listeners remain
                if (    ! this.hasEventListener(away.events.Event.ENTER_FRAME , this.onEnterFrame , this )
                &&  ! this.hasEventListener(away.events.Event.EXIT_FRAME , this.onEnterFrame , this) ) //&& _frameEventDriver.hasEventListener(Event.ENTER_FRAME))
                {
                
                //_frameEventDriver.removeEventListener(Event.ENTER_FRAME, this.onEnterFrame, this );
                
                }
                */
            };

            Object.defineProperty(Stage3DProxy.prototype, "scissorRect", {
                get: function () {
                    return this._scissorRect;
                },
                set: function (value) {
                    this._scissorRect = value;
                    this._iContext3D.setScissorRectangle(this._scissorRect);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "stage3DIndex", {
                get: /**
                * The index of the Stage3D which is managed by this instance of Stage3DProxy.
                */
                function () {
                    return this._iStage3DIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "stage3D", {
                get: /**
                * The base Stage3D object associated with this proxy.
                */
                function () {
                    return this._stage3D;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "context3D", {
                get: /**
                * The Context3D object associated with the given Stage3D object.
                */
                function () {
                    return this._iContext3D;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "usesSoftwareRendering", {
                get: /**
                * Indicates whether the Stage3D managed by this proxy is running in software mode.
                * Remember to wait for the CONTEXT3D_CREATED event before checking this property,
                * as only then will it be guaranteed to be accurate.
                */
                function () {
                    return this._usesSoftwareRendering;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "x", {
                get: /**
                * The x position of the Stage3D.
                */
                function () {
                    return this._stage3D.x;
                },
                set: function (value) {
                    if (this._viewPort.x == value)
                        return;

                    this._stage3D.x = this._viewPort.x = value;

                    this.notifyViewportUpdated();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "y", {
                get: /**
                * The y position of the Stage3D.
                */
                function () {
                    return this._stage3D.y;
                },
                set: function (value) {
                    if (this._viewPort.y == value)
                        return;

                    this._stage3D.y = this._viewPort.y = value;

                    this.notifyViewportUpdated();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "canvas", {
                get: /**
                *
                * @returns {HTMLCanvasElement}
                */
                function () {
                    return this._stage3D.canvas;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "width", {
                get: /**
                * The width of the Stage3D.
                */
                function () {
                    return this._backBufferWidth;
                },
                set: function (width) {
                    if (this._viewPort.width == width)
                        return;

                    this._stage3D.width = this._backBufferWidth = this._viewPort.width = width;
                    this._backBufferDirty = true;

                    this.notifyViewportUpdated();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "height", {
                get: /**
                * The height of the Stage3D.
                */
                function () {
                    return this._backBufferHeight;
                },
                set: function (height) {
                    if (this._viewPort.height == height)
                        return;

                    this._stage3D.height = this._backBufferHeight = this._viewPort.height = height;
                    this._backBufferDirty = true;

                    this.notifyViewportUpdated();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "antiAlias", {
                get: /**
                * The antiAliasing of the Stage3D.
                */
                function () {
                    return this._antiAlias;
                },
                set: function (antiAlias) {
                    this._antiAlias = antiAlias;
                    this._backBufferDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "viewPort", {
                get: /**
                * A viewPort rectangle equivalent of the Stage3D size and position.
                */
                function () {
                    this._viewportDirty = false;

                    return this._viewPort;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "color", {
                get: /**
                * The background color of the Stage3D.
                */
                function () {
                    return this._color;
                },
                set: function (color) {
                    this._color = color;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Stage3DProxy.prototype, "visible", {
                get: /**
                * The visibility of the Stage3D.
                */
                function () {
                    return this._stage3D.visible;
                },
                set: function (value) {
                    this._stage3D.visible = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "bufferClear", {
                get: /**
                * The freshly cleared state of the backbuffer before any rendering
                */
                function () {
                    return this._bufferClear;
                },
                set: function (newBufferClear) {
                    this._bufferClear = newBufferClear;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DProxy.prototype, "mouse3DManager", {
                get: /*
                * Access to fire mouseevents across multiple layered view3D instances
                */
                function () {
                    return this._mouse3DManager;
                },
                set: function (value) {
                    this._mouse3DManager = value;
                },
                enumerable: true,
                configurable: true
            });


            /* TODO: implement dependency Touch3DManager
            public get touch3DManager():Touch3DManager
            {
            return _touch3DManager;
            }
            
            public set touch3DManager(value:Touch3DManager)
            {
            _touch3DManager = value;
            }
            */
            /**
            * Frees the Context3D associated with this Stage3DProxy.
            */
            Stage3DProxy.prototype.freeContext3D = function () {
                if (this._iContext3D) {
                    this._iContext3D.dispose();
                    this.dispatchEvent(new away.events.Stage3DEvent(away.events.Stage3DEvent.CONTEXT3D_DISPOSED));
                }

                this._iContext3D = null;
            };

            /*
            * Called whenever the Context3D is retrieved or lost.
            * @param event The event dispatched.
            */
            Stage3DProxy.prototype.onContext3DUpdate = function (event) {
                if (this._stage3D.context3D) {
                    var hadContext = (this._iContext3D != null);
                    this._iContext3D = this._stage3D.context3D;

                    if (this._backBufferWidth && this._backBufferHeight) {
                        this._iContext3D.configureBackBuffer(this._backBufferWidth, this._backBufferHeight, this._antiAlias, this._enableDepthAndStencil);
                    }

                    // Dispatch the appropriate event depending on whether context was
                    // created for the first time or recreated after a device loss.
                    this.dispatchEvent(new away.events.Stage3DEvent(hadContext ? away.events.Stage3DEvent.CONTEXT3D_RECREATED : away.events.Stage3DEvent.CONTEXT3D_CREATED));
                } else {
                    throw new Error("Rendering context lost!");
                }
            };

            /**
            * Requests a Context3D object to attach to the managed Stage3D.
            */
            Stage3DProxy.prototype.requestContext = function (forceSoftware, profile) {
                if (typeof forceSoftware === "undefined") { forceSoftware = false; }
                if (typeof profile === "undefined") { profile = "baseline"; }
                if (this._usesSoftwareRendering != null) {
                    this._usesSoftwareRendering = forceSoftware;
                }

                this._profile = profile;

                // Updated to work with current JS <> AS3 Display3D System
                this._stage3D.requestContext(true);
            };

            /**
            * The Enter_Frame handler for processing the proxy.ENTER_FRAME and proxy.EXIT_FRAME event handlers.
            * Typically the proxy.ENTER_FRAME listener would render the layers for this Stage3D instance.
            */
            Stage3DProxy.prototype.onEnterFrame = function (event) {
                if (!this._iContext3D) {
                    return;
                }

                // Clear the stage3D instance
                this.clear();

                //notify the enterframe listeners
                this.notifyEnterFrame();

                // Call the present() to render the frame
                this.present();

                //notify the exitframe listeners
                this.notifyExitFrame();
            };

            Stage3DProxy.prototype.recoverFromDisposal = function () {
                if (!this._iContext3D) {
                    return false;
                }

                //away.Debug.throwPIR( 'Stage3DProxy' , 'recoverFromDisposal' , '' );
                /*
                if (this._iContext3D.driverInfo == "Disposed")
                {
                this._iContext3D = null;
                this.dispatchEvent(new away.events.Stage3DEvent(away.events.Stage3DEvent.CONTEXT3D_DISPOSED));
                return false;
                
                }
                */
                return true;
            };

            Stage3DProxy.prototype.clearDepthBuffer = function () {
                if (!this._iContext3D) {
                    return;
                }

                this._iContext3D.clear(0, 0, 0, 1, 1, 0, away.display3D.Context3DClearMask.DEPTH);
            };
            return Stage3DProxy;
        })(away.events.EventDispatcher);
        managers.Stage3DProxy = Stage3DProxy;
    })(away.managers || (away.managers = {}));
    var managers = away.managers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (display) {
        var Stage = (function (_super) {
            __extends(Stage, _super);
            function Stage(width, height) {
                if (typeof width === "undefined") { width = 640; }
                if (typeof height === "undefined") { height = 480; }
                _super.call(this);

                if (!document) {
                    throw new away.errors.DocumentError("A root document object does not exist.");
                }

                this.initStage3DObjects();
                this.resize(width, height);
            }
            Stage.prototype.resize = function (width, height) {
                this._stageHeight = height;
                this._stageWidth = width;

                var s3d;

                for (var i = 0; i < Stage.STAGE3D_MAX_QUANTITY; ++i) {
                    s3d = this.stage3Ds[i];
                    s3d.width = width;
                    s3d.height = height;
                    s3d.x = 0;
                    s3d.y = 0;
                    //away.utils.CSS.setCanvasSize( this.stage3Ds[ i ].canvas, width, height );
                    //away.utils.CSS.setCanvasPosition( this.stage3Ds[ i ].canvas, 0, 0, true );
                }
                this.dispatchEvent(new away.events.Event(away.events.Event.RESIZE));
            };

            Stage.prototype.getStage3DAt = function (index) {
                if (0 <= index && index < Stage.STAGE3D_MAX_QUANTITY) {
                    return this.stage3Ds[index];
                }
                throw new away.errors.ArgumentError("Index is out of bounds [0.." + Stage.STAGE3D_MAX_QUANTITY + "]");
            };

            Stage.prototype.initStage3DObjects = function () {
                this.stage3Ds = [];

                for (var i = 0; i < Stage.STAGE3D_MAX_QUANTITY; ++i) {
                    var canvas = this.createHTMLCanvasElement();
                    var stage3D = new away.display.Stage3D(canvas);
                    stage3D.addEventListener(away.events.Event.CONTEXT3D_CREATE, this.onContextCreated, this);

                    this.stage3Ds.push(stage3D);
                }
            };

            Stage.prototype.onContextCreated = function (e) {
                var stage3D = e.target;
                this.addChildHTMLElement(stage3D.canvas);
            };

            Stage.prototype.createHTMLCanvasElement = function () {
                return document.createElement("canvas");
            };

            Stage.prototype.addChildHTMLElement = function (canvas) {
                document.body.appendChild(canvas);
            };

            Object.defineProperty(Stage.prototype, "stageWidth", {
                get: function () {
                    return this._stageWidth;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage.prototype, "stageHeight", {
                get: function () {
                    return this._stageHeight;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage.prototype, "rect", {
                get: function () {
                    return new away.geom.Rectangle(0, 0, this._stageWidth, this._stageHeight);
                },
                enumerable: true,
                configurable: true
            });
            Stage.STAGE3D_MAX_QUANTITY = 8;
            return Stage;
        })(away.events.EventDispatcher);
        display.Stage = Stage;
    })(away.display || (away.display = {}));
    var display = away.display;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    // Reference note: http://www.w3schools.com/jsref/dom_obj_event.asp
    (function (managers) {
        //import away3d.arcane;
        //import away3d.containers.ObjectContainer3D;
        //import away3d.containers.View3D;
        //import away3d.core.pick.IPicker;
        //import away3d.core.pick.PickingCollisionVO;
        //import away3d.core.pick.PickingType;
        //import away3d.events.MouseEvent3D;
        //import flash.display.DisplayObject;
        //import flash.display.DisplayObjectContainer;
        //import flash.display.Stage;
        //import flash.events.MouseEvent;
        //import flash.geom.Vector3D;
        //import flash.utils.Dictionary;
        //use namespace arcane;
        /**
        * Mouse3DManager enforces a singleton pattern and is not intended to be instanced.
        * it provides a manager class for detecting 3D mouse hits on View3D objects and sending out 3D mouse events.
        */
        var Mouse3DManager = (function () {
            /**
            * Creates a new <code>Mouse3DManager</code> object.
            */
            function Mouse3DManager() {
                this._updateDirty = true;
                this._nullVector = new away.geom.Vector3D();
                this._mousePicker = away.pick.PickingType.RAYCAST_FIRST_ENCOUNTERED;
                this._childDepth = 0;
                if (!Mouse3DManager._view3Ds) {
                    Mouse3DManager._view3Ds = new Object();
                    Mouse3DManager._view3DLookup = new Array();
                }
            }
            // ---------------------------------------------------------------------
            // Interface.
            // ---------------------------------------------------------------------
            // TODO: required dependency stage3DProxy
            Mouse3DManager.prototype.updateCollider = function (view) {
                throw new away.errors.PartialImplementationError('stage3DProxy');
                /*
                this._previousCollidingView = this._collidingView;
                
                if (view) {
                // Clear the current colliding objects for multiple views if backBuffer just cleared
                if (view.stage3DProxy.bufferClear)
                _collidingViewObjects = new Vector.<PickingCollisionVO>(_viewCount);
                
                if (!view.shareContext) {
                if (view == _activeView && (_forceMouseMove || _updateDirty)) { // If forceMouseMove is off, and no 2D mouse events dirtied the update, don't update either.
                _collidingObject = _mousePicker.getViewCollision(view.mouseX, view.mouseY, view);
                }
                } else {
                if (view.getBounds(view.parent).contains(view.mouseX + view.x, view.mouseY + view.y)) {
                if (!_collidingViewObjects)
                _collidingViewObjects = new Vector.<PickingCollisionVO>(_viewCount);
                _collidingObject = _collidingViewObjects[_view3Ds[view]] = _mousePicker.getViewCollision(view.mouseX, view.mouseY, view);
                }
                }
                }
                */
            };

            Mouse3DManager.prototype.fireMouseEvents = function () {
                throw new away.errors.PartialImplementationError('View3D().layeredView');
                /*
                
                var i:number;
                var len:number;
                var event:away.events.MouseEvent3D;
                var dispatcher:away.containers.ObjectContainer3D;
                
                
                
                // If multiple view are used, determine the best hit based on the depth intersection.
                if ( Mouse3DManager._collidingViewObjects )
                {
                Mouse3DManager._pCollidingObject = null;//_collidingObject = null;
                
                // Get the top-most view colliding object
                var distance:number = Infinity;
                var view:away.containers.View3D;
                
                for (var v:number = Mouse3DManager._viewCount - 1; v >= 0; v--)
                {
                view = _view3DLookup[v];
                
                if ( Mouse3DManager._collidingViewObjects[v] && (view.layeredView || Mouse3DManager._collidingViewObjects[v].rayEntryDistance < distance))
                {
                
                distance = Mouse3DManager._collidingViewObjects[v].rayEntryDistance;
                
                Mouse3DManager._pCollidingObject = Mouse3DManager._collidingViewObjects[v];//_collidingObject = Mouse3DManager._collidingViewObjects[v];
                
                if (view.layeredView)
                {
                
                break;
                
                }
                
                }
                }
                }
                
                // If colliding object has changed, queue over/out events.
                if (Mouse3DManager._pCollidingObject  != Mouse3DManager._previousCollidingObject)
                {
                
                if (Mouse3DManager._previousCollidingObject)
                {
                
                this.queueDispatch(Mouse3DManager._mouseOut, this._mouseMoveEvent, Mouse3DManager._previousCollidingObject);
                
                }
                
                if (Mouse3DManager._pCollidingObject)
                {
                this.queueDispatch(Mouse3DManager._mouseOver, this._mouseMoveEvent, Mouse3DManager._pCollidingObject );
                }
                
                }
                
                // Fire mouse move events here if forceMouseMove is on.
                if ( this._forceMouseMove && Mouse3DManager._pCollidingObject)
                {
                
                this.queueDispatch( Mouse3DManager._mouseMove, this._mouseMoveEvent, Mouse3DManager._pCollidingObject);
                
                }
                
                
                // Dispatch all queued events.
                len = Mouse3DManager._queuedEvents.length;
                
                for (i = 0; i < len; ++i)
                {
                // Only dispatch from first implicitly enabled object ( one that is not a child of a mouseChildren = false hierarchy ).
                event = Mouse3DManager._queuedEvents[i];
                dispatcher = event.object;
                
                while (dispatcher && ! dispatcher._iAncestorsAllowMouseEnabled )
                {
                
                dispatcher = dispatcher.parent;
                
                }
                
                
                if (dispatcher)
                {
                
                dispatcher.dispatchEvent(event);
                
                }
                
                }
                Mouse3DManager._queuedEvents.length = 0;
                
                this._updateDirty = false;
                Mouse3DManager._previousCollidingObject = Mouse3DManager._pCollidingObject;//_collidingObject;
                //*/
            };

            Mouse3DManager.prototype.addViewLayer = function (view) {
                throw new away.errors.PartialImplementationError('Stage3DProxy, Stage, DisplayObjectContainer ( as3 / native ) ');
                /*
                var stg:Stage = view.stage;
                
                // Add instance to mouse3dmanager to fire mouse events for multiple views
                if (!view.stage3DProxy.mouse3DManager)
                view.stage3DProxy.mouse3DManager = this;
                
                if (!hasKey(view))
                _view3Ds[view] = 0;
                
                _childDepth = 0;
                traverseDisplayObjects(stg);
                _viewCount = _childDepth;
                */
            };

            Mouse3DManager.prototype.enableMouseListeners = function (view) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
                /*
                view.addEventListener(MouseEvent.CLICK, onClick);
                view.addEventListener(MouseEvent.DOUBLE_CLICK, onDoubleClick);
                view.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
                view.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
                view.addEventListener(MouseEvent.MOUSE_UP, onMouseUp);
                view.addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);
                view.addEventListener(MouseEvent.MOUSE_OVER, onMouseOver);
                view.addEventListener(MouseEvent.MOUSE_OUT, onMouseOut);
                */
            };

            Mouse3DManager.prototype.disableMouseListeners = function (view) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
                /*
                view.removeEventListener(MouseEvent.CLICK, onClick);
                view.removeEventListener(MouseEvent.DOUBLE_CLICK, onDoubleClick);
                view.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
                view.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
                view.removeEventListener(MouseEvent.MOUSE_UP, onMouseUp);
                view.removeEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel);
                view.removeEventListener(MouseEvent.MOUSE_OVER, onMouseOver);
                view.removeEventListener(MouseEvent.MOUSE_OUT, onMouseOut);
                */
            };

            Mouse3DManager.prototype.dispose = function () {
                this._mousePicker.dispose();
            };

            // ---------------------------------------------------------------------
            // Private.
            // ---------------------------------------------------------------------
            Mouse3DManager.prototype.queueDispatch = function (event, sourceEvent, collider) {
                if (typeof collider === "undefined") { collider = null; }
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
                /*
                // 2D properties.
                event.ctrlKey = sourceEvent.ctrlKey;
                event.altKey = sourceEvent.altKey;
                event.shiftKey = sourceEvent.shiftKey;
                event.delta = sourceEvent.delta;
                event.screenX = sourceEvent.localX;
                event.screenY = sourceEvent.localY;
                
                collider ||= _collidingObject;
                
                // 3D properties.
                if (collider) {
                // Object.
                event.object = collider.entity;
                event.renderable = collider.renderable;
                // UV.
                event.uv = collider.uv;
                // Position.
                event.localPosition = collider.localPosition? collider.localPosition.clone() : null;
                // Normal.
                event.localNormal = collider.localNormal? collider.localNormal.clone() : null;
                // Face index.
                event.index = collider.index;
                // SubGeometryIndex.
                event.subGeometryIndex = collider.subGeometryIndex;
                
                } else {
                // Set all to null.
                event.uv = null;
                event.object = null;
                event.localPosition = _nullVector;
                event.localNormal = _nullVector;
                event.index = 0;
                event.subGeometryIndex = 0;
                }
                
                // Store event to be dispatched later.
                _queuedEvents.push(event);
                */
            };

            Mouse3DManager.prototype.reThrowEvent = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent - AS3 <> JS Conversion');
            };

            Mouse3DManager.prototype.hasKey = function (view) {
                for (var v in Mouse3DManager._view3Ds) {
                    if (v === view) {
                        return true;
                    }
                }

                return false;
            };

            Mouse3DManager.prototype.traverseDisplayObjects = function (container) {
                throw new away.errors.PartialImplementationError('DisplayObjectContainer ( as3 / native ) as3 <> JS Conversion');
                /*
                var childCount:number = container.numChildren;
                var c:number = 0;
                var child:DisplayObject;
                for (c = 0; c < childCount; c++) {
                child = container.getChildAt(c);
                for (var v:* in _view3Ds) {
                if (child == v) {
                _view3Ds[child] = _childDepth;
                _view3DLookup[_childDepth] = v;
                _childDepth++;
                }
                }
                if (child is DisplayObjectContainer)
                traverseDisplayObjects(child as DisplayObjectContainer);
                }
                */
            };

            // ---------------------------------------------------------------------
            // Listeners.
            // ---------------------------------------------------------------------
            Mouse3DManager.prototype.onMouseMove = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
                /*
                if (Mouse3DManager._pCollidingObject)
                {
                
                this.queueDispatch(Mouse3DManager._mouseMove, this._mouseMoveEvent = event);
                
                }
                else
                {
                
                this.reThrowEvent(event);
                
                }
                
                this._updateDirty = true;
                */
            };

            Mouse3DManager.prototype.onMouseOut = function (event) {
                this._activeView = null;

                if (Mouse3DManager._pCollidingObject) {
                    this.queueDispatch(Mouse3DManager._mouseOut, event, Mouse3DManager._pCollidingObject);
                }

                this._updateDirty = true;

                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onMouseOver = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onClick = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onDoubleClick = function (event) {
                if (Mouse3DManager._pCollidingObject) {
                    this.queueDispatch(Mouse3DManager._mouseDoubleClick, event);
                } else {
                    this.reThrowEvent(event);
                }

                this._updateDirty = true;
            };

            Mouse3DManager.prototype.onMouseDown = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onMouseUp = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Mouse3DManager.prototype.onMouseWheel = function (event) {
                throw new away.errors.PartialImplementationError('MouseEvent ( as3 / native ) as3 <> JS Conversion');
            };

            Object.defineProperty(Mouse3DManager.prototype, "forceMouseMove", {
                get: // ---------------------------------------------------------------------
                // Getters & setters.
                // ---------------------------------------------------------------------
                function () {
                    return this._forceMouseMove;
                },
                set: function (value) {
                    this._forceMouseMove = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Mouse3DManager.prototype, "mousePicker", {
                get: function () {
                    return this._mousePicker;
                },
                set: function (value) {
                    this._mousePicker = value;
                },
                enumerable: true,
                configurable: true
            });

            Mouse3DManager._viewCount = 0;

            Mouse3DManager._queuedEvents = new Array();

            Mouse3DManager._mouseUp = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_UP);
            Mouse3DManager._mouseClick = new away.events.MouseEvent3D(away.events.MouseEvent3D.CLICK);
            Mouse3DManager._mouseOut = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_OUT);
            Mouse3DManager._mouseDown = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_DOWN);
            Mouse3DManager._mouseMove = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_MOVE);
            Mouse3DManager._mouseOver = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_OVER);
            Mouse3DManager._mouseWheel = new away.events.MouseEvent3D(away.events.MouseEvent3D.MOUSE_WHEEL);
            Mouse3DManager._mouseDoubleClick = new away.events.MouseEvent3D(away.events.MouseEvent3D.DOUBLE_CLICK);

            Mouse3DManager._previousCollidingView = -1;
            Mouse3DManager._collidingView = -1;
            return Mouse3DManager;
        })();
        managers.Mouse3DManager = Mouse3DManager;
    })(away.managers || (away.managers = {}));
    var managers = away.managers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        //import flash.events.Event;
        var Stage3DEvent = (function (_super) {
            __extends(Stage3DEvent, _super);
            function Stage3DEvent(type) {
                _super.call(this, type);
            }
            Stage3DEvent.CONTEXT3D_CREATED = "Context3DCreated";
            Stage3DEvent.CONTEXT3D_DISPOSED = "Context3DDisposed";
            Stage3DEvent.CONTEXT3D_RECREATED = "Context3DRecreated";
            Stage3DEvent.VIEWPORT_UPDATED = "ViewportUpdated";
            return Stage3DEvent;
        })(events.Event);
        events.Stage3DEvent = Stage3DEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (managers) {
        //import away3d.arcane;
        //import flash.display.Stage;
        //import flash.utils.Dictionary;
        //use namespace arcane;
        /**
        * The Stage3DManager class provides a multiton object that handles management for Stage3D objects. Stage3D objects
        * should not be requested directly, but are exposed by a Stage3DProxy.
        *
        * @see away3d.core.managers.Stage3DProxy
        */
        var Stage3DManager = (function () {
            /**
            * Creates a new Stage3DManager class.
            * @param stage The Stage object that contains the Stage3D objects to be managed.
            * @private
            */
            function Stage3DManager(stage, Stage3DManagerSingletonEnforcer) {
                if (!Stage3DManagerSingletonEnforcer) {
                    throw new Error("This class is a multiton and cannot be instantiated manually. Use Stage3DManager.getInstance instead.");
                }

                this._stage = stage;

                if (!Stage3DManager._stageProxies) {
                    Stage3DManager._stageProxies = new Array(this._stage.stage3Ds.length);
                }
            }
            Stage3DManager.getInstance = /**
            * Gets a Stage3DManager instance for the given Stage object.
            * @param stage The Stage object that contains the Stage3D objects to be managed.
            * @return The Stage3DManager instance for the given Stage object.
            */
            function (stage) {
                var stage3dManager = Stage3DManager.getStage3DManagerByStageRef(stage);

                if (stage3dManager == null) {
                    stage3dManager = new away.managers.Stage3DManager(stage, new Stage3DManagerSingletonEnforcer());

                    var stageInstanceData = new Stage3DManagerInstanceData();
                    stageInstanceData.stage = stage;
                    stageInstanceData.stage3DManager = stage3dManager;

                    Stage3DManager._instances.push(stageInstanceData);
                }

                return stage3dManager;
            };

            Stage3DManager.getStage3DManagerByStageRef = /**
            *
            * @param stage
            * @returns {  away.managers.Stage3DManager }
            * @constructor
            */
            function (stage) {
                if (Stage3DManager._instances == null) {
                    Stage3DManager._instances = new Array();
                }

                var l = Stage3DManager._instances.length;
                var s;

                for (var c = 0; c < l; c++) {
                    s = Stage3DManager._instances[c];

                    if (s.stage == stage) {
                        return s.stage3DManager;
                    }
                }

                return null;
            };

            /**
            * Requests the Stage3DProxy for the given index.
            * @param index The index of the requested Stage3D.
            * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
            * @param profile The compatibility profile, an enumeration of Context3DProfile
            * @return The Stage3DProxy for the given index.
            */
            Stage3DManager.prototype.getStage3DProxy = function (index, forceSoftware, profile) {
                if (typeof forceSoftware === "undefined") { forceSoftware = false; }
                if (typeof profile === "undefined") { profile = "baseline"; }
                if (!Stage3DManager._stageProxies[index]) {
                    Stage3DManager._numStageProxies++;
                    Stage3DManager._stageProxies[index] = new away.managers.Stage3DProxy(index, this._stage.stage3Ds[index], this, forceSoftware, profile);
                }

                return Stage3DManager._stageProxies[index];
            };

            /**
            * Removes a Stage3DProxy from the manager.
            * @param stage3DProxy
            * @private
            */
            Stage3DManager.prototype.iRemoveStage3DProxy = function (stage3DProxy) {
                Stage3DManager._numStageProxies--;
                Stage3DManager._stageProxies[stage3DProxy._iStage3DIndex] = null;
            };

            /**
            * Get the next available stage3DProxy. An error is thrown if there are no Stage3DProxies available
            * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
            * @param profile The compatibility profile, an enumeration of Context3DProfile
            * @return The allocated stage3DProxy
            */
            Stage3DManager.prototype.getFreeStage3DProxy = function (forceSoftware, profile) {
                if (typeof forceSoftware === "undefined") { forceSoftware = false; }
                if (typeof profile === "undefined") { profile = "baseline"; }
                var i = 0;
                var len = Stage3DManager._stageProxies.length;

                while (i < len) {
                    if (!Stage3DManager._stageProxies[i]) {
                        this.getStage3DProxy(i, forceSoftware, profile);

                        Stage3DManager._stageProxies[i].width = this._stage.stageWidth;
                        Stage3DManager._stageProxies[i].height = this._stage.stageHeight;

                        return Stage3DManager._stageProxies[i];
                    }

                    ++i;
                }

                throw new Error("Too many Stage3D instances used!");
                return null;
            };

            Object.defineProperty(Stage3DManager.prototype, "hasFreeStage3DProxy", {
                get: /**
                * Checks if a new stage3DProxy can be created and managed by the class.
                * @return true if there is one slot free for a new stage3DProxy
                */
                function () {
                    return Stage3DManager._numStageProxies < Stage3DManager._stageProxies.length ? true : false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DManager.prototype, "numProxySlotsFree", {
                get: /**
                * Returns the amount of stage3DProxy objects that can be created and managed by the class
                * @return the amount of free slots
                */
                function () {
                    return Stage3DManager._stageProxies.length - Stage3DManager._numStageProxies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DManager.prototype, "numProxySlotsUsed", {
                get: /**
                * Returns the amount of Stage3DProxy objects currently managed by the class.
                * @return the amount of slots used
                */
                function () {
                    return Stage3DManager._numStageProxies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Stage3DManager.prototype, "numProxySlotsTotal", {
                get: /**
                * Returns the maximum amount of Stage3DProxy objects that can be managed by the class
                * @return the maximum amount of Stage3DProxy objects that can be managed by the class
                */
                function () {
                    return Stage3DManager._stageProxies.length;
                },
                enumerable: true,
                configurable: true
            });
            Stage3DManager._numStageProxies = 0;
            return Stage3DManager;
        })();
        managers.Stage3DManager = Stage3DManager;
    })(away.managers || (away.managers = {}));
    var managers = away.managers;
})(away || (away = {}));

var Stage3DManagerInstanceData = (function () {
    function Stage3DManagerInstanceData() {
    }
    return Stage3DManagerInstanceData;
})();

var Stage3DManagerSingletonEnforcer = (function () {
    function Stage3DManagerSingletonEnforcer() {
    }
    return Stage3DManagerSingletonEnforcer;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (managers) {
        var AGALProgram3DCache = (function () {
            function AGALProgram3DCache(stage3DProxy, agalProgram3DCacheSingletonEnforcer) {
                if (!agalProgram3DCacheSingletonEnforcer) {
                    throw new Error("This class is a multiton and cannot be instantiated manually. Use Stage3DManager.getInstance instead.");
                }

                this._stage3DProxy = stage3DProxy;

                this._program3Ds = new Object();
                this._ids = new Object();
                this._usages = new Object();
                this._keys = new Object();
            }
            AGALProgram3DCache.getInstance = function (stage3DProxy) {
                var index = stage3DProxy._iStage3DIndex;

                if (AGALProgram3DCache._instances == null) {
                    AGALProgram3DCache._instances = new Array(8);
                }

                if (!AGALProgram3DCache._instances[index]) {
                    AGALProgram3DCache._instances[index] = new AGALProgram3DCache(stage3DProxy, new AGALProgram3DCacheSingletonEnforcer());

                    stage3DProxy.addEventListener(away.events.Stage3DEvent.CONTEXT3D_DISPOSED, AGALProgram3DCache.onContext3DDisposed, AGALProgram3DCache);
                    stage3DProxy.addEventListener(away.events.Stage3DEvent.CONTEXT3D_CREATED, AGALProgram3DCache.onContext3DDisposed, AGALProgram3DCache);
                    stage3DProxy.addEventListener(away.events.Stage3DEvent.CONTEXT3D_RECREATED, AGALProgram3DCache.onContext3DDisposed, AGALProgram3DCache);
                }

                return AGALProgram3DCache._instances[index];
            };

            AGALProgram3DCache.getInstanceFromIndex = function (index) {
                if (!AGALProgram3DCache._instances[index]) {
                    throw new Error("Instance not created yet!");
                }
                return AGALProgram3DCache._instances[index];
            };

            AGALProgram3DCache.onContext3DDisposed = function (event) {
                var stage3DProxy = event.target;

                var index = stage3DProxy._iStage3DIndex;

                AGALProgram3DCache._instances[index].dispose();
                AGALProgram3DCache._instances[index] = null;

                stage3DProxy.removeEventListener(away.events.Stage3DEvent.CONTEXT3D_DISPOSED, AGALProgram3DCache.onContext3DDisposed, AGALProgram3DCache);
                stage3DProxy.removeEventListener(away.events.Stage3DEvent.CONTEXT3D_CREATED, AGALProgram3DCache.onContext3DDisposed, AGALProgram3DCache);
                stage3DProxy.removeEventListener(away.events.Stage3DEvent.CONTEXT3D_RECREATED, AGALProgram3DCache.onContext3DDisposed, AGALProgram3DCache);
            };

            AGALProgram3DCache.prototype.dispose = function () {
                for (var key in this._program3Ds) {
                    this.destroyProgram(key);
                }

                this._keys = null;
                this._program3Ds = null;
                this._usages = null;
            };

            AGALProgram3DCache.prototype.setProgram3D = function (pass, vertexCode, fragmentCode) {
                var stageIndex = this._stage3DProxy._iStage3DIndex;
                var program;
                var key = this.getKey(vertexCode, fragmentCode);

                if (this._program3Ds[key] == null) {
                    this._keys[AGALProgram3DCache._currentId] = key;
                    this._usages[AGALProgram3DCache._currentId] = 0;
                    this._ids[key] = AGALProgram3DCache._currentId;
                    ++AGALProgram3DCache._currentId;

                    program = this._stage3DProxy._iContext3D.createProgram();

                    //away.Debug.throwPIR( 'AGALProgram3DCache' , 'setProgram3D' , 'Dependency: AGALMiniAssembler.assemble');
                    //TODO: implement AGAL <> GLSL
                    //var vertexByteCode:ByteArray = new AGALMiniAssembler(Debug.active).assemble(Context3DProgramType.VERTEX, vertexCode);
                    //var fragmentByteCode:ByteArray = new AGALMiniAssembler(Debug.active).assemble(Context3DProgramType.FRAGMENT, fragmentCode);
                    //program.upload(vertexByteCode, fragmentByteCode);
                    /*
                    var vertexByteCode  : ByteArray = new AGLSLCompiler().assemble( Context3DProgramType.VERTEX , vertexCode );
                    var fragmentByteCode: ByteArray = new AGLSLCompiler().assemble( Context3DProgramType.FRAGMENT , fragmentCode );
                    
                    program.uploadGLSL(vertexByteCode, fragmentByteCode);
                    
                    */
                    var vertCompiler = new aglsl.AGLSLCompiler();
                    var fragCompiler = new aglsl.AGLSLCompiler();

                    var vertString = vertCompiler.compile(away.display3D.Context3DProgramType.VERTEX, vertexCode);
                    var fragString = fragCompiler.compile(away.display3D.Context3DProgramType.FRAGMENT, fragmentCode);

                    console.log('===GLSL=========================================================');
                    console.log('vertString');
                    console.log(vertString);
                    console.log('fragString');
                    console.log(fragString);

                    console.log('===AGAL=========================================================');
                    console.log('vertexCode');
                    console.log(vertexCode);
                    console.log('fragmentCode');
                    console.log(fragmentCode);

                    program.upload(vertString, fragString);

                    /*
                    
                    var vertCompiler:aglsl.AGLSLCompiler = new aglsl.AGLSLCompiler();
                    var fragCompiler:aglsl.AGLSLCompiler = new aglsl.AGLSLCompiler();
                    
                    var vertString : string = vertCompiler.compile( away.display3D.Context3DProgramType.VERTEX, this.pGetVertexCode() );
                    var fragString : string = fragCompiler.compile( away.display3D.Context3DProgramType.FRAGMENT, this.pGetFragmentCode() );
                    
                    this._program3D.upload( vertString , fragString );
                    
                    */
                    this._program3Ds[key] = program;
                }

                var oldId = pass._iProgram3Dids[stageIndex];
                var newId = this._ids[key];

                if (oldId != newId) {
                    if (oldId >= 0) {
                        this.freeProgram3D(oldId);
                    }

                    this._usages[newId]++;
                }

                pass._iProgram3Dids[stageIndex] = newId;
                pass._iProgram3Ds[stageIndex] = this._program3Ds[key];
            };

            AGALProgram3DCache.prototype.freeProgram3D = function (programId) {
                this._usages[programId]--;

                if (this._usages[programId] == 0) {
                    this.destroyProgram(this._keys[programId]);
                }
            };

            AGALProgram3DCache.prototype.destroyProgram = function (key) {
                this._program3Ds[key].dispose();
                this._program3Ds[key] = null;
                delete this._program3Ds[key];
                this._ids[key] = -1;
            };

            AGALProgram3DCache.prototype.getKey = function (vertexCode, fragmentCode) {
                return vertexCode + "---" + fragmentCode;
            };
            AGALProgram3DCache._currentId = 0;
            return AGALProgram3DCache;
        })();
        managers.AGALProgram3DCache = AGALProgram3DCache;
    })(away.managers || (away.managers = {}));
    var managers = away.managers;
})(away || (away = {}));

var AGALProgram3DCacheSingletonEnforcer = (function () {
    function AGALProgram3DCacheSingletonEnforcer() {
    }
    return AGALProgram3DCacheSingletonEnforcer;
})();
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import flash.display.*;
        //import flash.display3D.textures.CubeTexture;
        //import flash.display3D.textures.Texture;
        //import flash.display3D.textures.TextureBase;
        //import flash.geom.*;
        /**
        * MipmapGenerator is a helper class that uploads BitmapData to a Texture including mipmap levels.
        */
        var MipmapGenerator = (function () {
            function MipmapGenerator() {
            }
            MipmapGenerator.generateHTMLImageElementMipMaps = /**
            * Uploads a BitmapData with mip maps to a target Texture object.
            * @param source
            * @param target The target Texture to upload to.
            * @param mipmap An optional mip map holder to avoids creating new instances for fe animated materials.
            * @param alpha Indicate whether or not the uploaded bitmapData is transparent.
            */
            function (source, target, mipmap, alpha, side) {
                if (typeof mipmap === "undefined") { mipmap = null; }
                if (typeof alpha === "undefined") { alpha = false; }
                if (typeof side === "undefined") { side = -1; }
                MipmapGenerator._rect.width = source.width;
                MipmapGenerator._rect.height = source.height;

                MipmapGenerator._source = new away.display.BitmapData(source.width, source.height, alpha);
                MipmapGenerator._source.drawImage(source, MipmapGenerator._rect, MipmapGenerator._rect);

                MipmapGenerator.generateMipMaps(MipmapGenerator._source, target, mipmap);

                MipmapGenerator._source.dispose();
                MipmapGenerator._source = null;
            };

            MipmapGenerator.generateMipMaps = /**
            * Uploads a BitmapData with mip maps to a target Texture object.
            * @param source The source BitmapData to upload.
            * @param target The target Texture to upload to.
            * @param mipmap An optional mip map holder to avoids creating new instances for fe animated materials.
            * @param alpha Indicate whether or not the uploaded bitmapData is transparent.
            */
            function (source, target, mipmap, alpha, side) {
                if (typeof mipmap === "undefined") { mipmap = null; }
                if (typeof alpha === "undefined") { alpha = false; }
                if (typeof side === "undefined") { side = -1; }
                var w = source.width;
                var h = source.height;
                var regen = mipmap != null;
                var i;

                if (!mipmap) {
                    mipmap = new away.display.BitmapData(w, h, alpha);
                }

                MipmapGenerator._rect.width = w;
                MipmapGenerator._rect.height = h;

                var tx;

                while (w >= 1 || h >= 1) {
                    if (alpha) {
                        mipmap.fillRect(MipmapGenerator._rect, 0);
                    }

                    MipmapGenerator._matrix.a = MipmapGenerator._rect.width / source.width;
                    MipmapGenerator._matrix.d = MipmapGenerator._rect.height / source.height;

                    mipmap.width = MipmapGenerator._rect.width;
                    mipmap.height = MipmapGenerator._rect.height;
                    mipmap.copyPixels(source, source.rect, MipmapGenerator._rect);

                    if (target instanceof away.display3D.Texture) {
                        tx = target;
                        tx.uploadFromBitmapData(mipmap, i++);
                    } else {
                        away.Debug.throwPIR('MipMapGenerator', 'generateMipMaps', 'Dependency: CubeTexture');
                        // TODO: implement cube texture upload;
                        //CubeTexture(target).uploadFromBitmapData(mipmap, side, i++);
                    }

                    w >>= 1;
                    h >>= 1;

                    MipmapGenerator._rect.width = w > 1 ? w : 1;
                    MipmapGenerator._rect.height = h > 1 ? h : 1;
                }

                if (!regen) {
                    mipmap.dispose();
                }
            };
            MipmapGenerator._matrix = new away.geom.Matrix();
            MipmapGenerator._rect = new away.geom.Rectangle();
            return MipmapGenerator;
        })();
        materials.MipmapGenerator = MipmapGenerator;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (net) {
        var URLVariables = (function () {
            /**
            *
            * @param source
            */
            function URLVariables(source) {
                if (typeof source === "undefined") { source = null; }
                this._variables = new Object();
                if (source !== null) {
                    this.decode(source);
                }
            }
            /**
            *
            * @param source
            */
            URLVariables.prototype.decode = function (source) {
                source = source.split("+").join(" ");

                var tokens, re = /[?&]?([^=]+)=([^&]*)/g;

                while (tokens = re.exec(source)) {
                    this._variables[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
                }
            };

            /**
            *
            * @returns {string}
            */
            URLVariables.prototype.toString = function () {
                return '';
            };

            Object.defineProperty(URLVariables.prototype, "variables", {
                get: /**
                *
                * @returns {Object}
                */
                function () {
                    return this._variables;
                },
                set: /**
                *
                * @returns {Object}
                */
                function (obj) {
                    this._variables = obj;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(URLVariables.prototype, "formData", {
                get: /**
                *
                * @returns {Object}
                */
                function () {
                    var fd = new FormData();

                    for (var s in this._variables) {
                        fd.append(s, this._variables[s]);
                    }

                    return fd;
                },
                enumerable: true,
                configurable: true
            });

            return URLVariables;
        })();
        net.URLVariables = URLVariables;
    })(away.net || (away.net = {}));
    var net = away.net;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var PerspectiveMatrix3D = (function (_super) {
            __extends(PerspectiveMatrix3D, _super);
            function PerspectiveMatrix3D(v) {
                if (typeof v === "undefined") { v = null; }
                _super.call(this, v);
            }
            PerspectiveMatrix3D.prototype.perspectiveFieldOfViewLH = function (fieldOfViewY, aspectRatio, zNear, zFar) {
                var yScale = 1 / Math.tan(fieldOfViewY / 2);
                var xScale = yScale / aspectRatio;
                this.copyRawDataFrom([
                    xScale,
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    yScale,
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    zFar / (zFar - zNear),
                    1.0,
                    0.0,
                    0.0,
                    (zNear * zFar) / (zNear - zFar),
                    0.0
                ]);
            };
            return PerspectiveMatrix3D;
        })(away.geom.Matrix3D);
        utils.PerspectiveMatrix3D = PerspectiveMatrix3D;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var RequestAnimationFrame = (function () {
            function RequestAnimationFrame(callback, callbackContext) {
                var _this = this;
                this._active = false;
                this._argsArray = new Array();
                this._getTimer = away.utils.getTimer;

                this.setCallback(callback, callbackContext);

                this._rafUpdateFunction = function () {
                    if (_this._active) {
                        _this._tick();
                    }
                };

                this._argsArray.push(this._dt);
            }
            // Public
            /**
            *
            * @param callback
            * @param callbackContext
            */
            RequestAnimationFrame.prototype.setCallback = function (callback, callbackContext) {
                this._callback = callback;
                this._callbackContext = callbackContext;
            };

            /**
            *
            */
            RequestAnimationFrame.prototype.start = function () {
                this._prevTime = this._getTimer();
                this._active = true;

                if (window['mozRequestAnimationFrame']) {
                    window.requestAnimationFrame = window['mozRequestAnimationFrame'];
                } else if (window['webkitRequestAnimationFrame']) {
                    window.requestAnimationFrame = window['webkitRequestAnimationFrame'];
                } else if (window['oRequestAnimationFrame']) {
                    window.requestAnimationFrame = window['oRequestAnimationFrame'];
                }

                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(this._rafUpdateFunction);
                }
            };

            /**
            *
            */
            RequestAnimationFrame.prototype.stop = function () {
                this._active = false;
            };

            Object.defineProperty(RequestAnimationFrame.prototype, "active", {
                get: // Get / Set
                /**
                *
                * @returns {boolean}
                */
                function () {
                    return this._active;
                },
                enumerable: true,
                configurable: true
            });

            // Private
            /**
            *
            * @private
            */
            RequestAnimationFrame.prototype._tick = function () {
                this._currentTime = this._getTimer();
                this._dt = this._currentTime - this._prevTime;
                this._argsArray[0] = this._dt;
                this._callback.apply(this._callbackContext, this._argsArray);

                window.requestAnimationFrame(this._rafUpdateFunction);

                this._prevTime = this._currentTime;
            };
            return RequestAnimationFrame;
        })();
        utils.RequestAnimationFrame = RequestAnimationFrame;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
///<reference path="../_definitions.ts"/>
var away;
(function (away) {
    var Debug = (function () {
        function Debug() {
        }
        Debug.breakpoint = function () {
            away.Debug['break']();
        };

        Debug.throwPIROnKeyWordOnly = function (str, enable) {
            if (typeof enable === "undefined") { enable = true; }
            if (!enable) {
                away.Debug.keyword = null;
            } else {
                away.Debug.keyword = str;
            }
        };

        Debug.throwPIR = function (clss, fnc, msg) {
            Debug.logPIR('PartialImplementationError ' + clss, fnc, msg);

            if (Debug.THROW_ERRORS) {
                if (away.Debug.keyword) {
                    var e = clss + fnc + msg;

                    if (e.indexOf(away.Debug.keyword) == -1) {
                        return;
                    }
                }

                throw new away.errors.PartialImplementationError(clss + '.' + fnc + ': ' + msg);
            }
        };

        Debug.logPIR = function (clss, fnc, msg) {
            if (typeof msg === "undefined") { msg = ''; }
            if (Debug.LOG_PI_ERRORS) {
                console.log(clss + '.' + fnc + ': ' + msg);
            }
        };

        Debug.log = function () {
            var args = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                args[_i] = arguments[_i + 0];
            }
            if (Debug.ENABLE_LOG) {
                console.log.apply(console, arguments);
            }
        };
        Debug.THROW_ERRORS = true;
        Debug.ENABLE_LOG = true;
        Debug.LOG_PI_ERRORS = true;

        Debug.keyword = null;
        return Debug;
    })();
    away.Debug = Debug;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        * @class away.base.SubGeometryBase
        */
        var SubGeometryBase = (function () {
            function SubGeometryBase() {
                this._faceNormalsDirty = true;
                this._faceTangentsDirty = true;
                this._indexBuffer = new Array(8);
                this._indexBufferContext = new Array(8);
                this._indicesInvalid = new Array(8);
                this._autoDeriveVertexNormals = true;
                this._autoDeriveVertexTangents = true;
                this._autoGenerateUVs = false;
                this._useFaceWeights = false;
                this._vertexNormalsDirty = true;
                this._vertexTangentsDirty = true;
                this._scaleU = 1;
                this._scaleV = 1;
                this._uvsDirty = true;
            }
            Object.defineProperty(SubGeometryBase.prototype, "autoGenerateDummyUVs", {
                get: /**
                * Defines whether a UV buffer should be automatically generated to contain dummy UV coordinates.
                * Set to true if a geometry lacks UV data but uses a material that requires it, or leave as false
                * in cases where UV data is explicitly defined or the material does not require UV data.
                */
                function () {
                    return this._autoGenerateUVs;
                },
                set: function (value) {
                    this._autoGenerateUVs = value;
                    this._uvsDirty = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "autoDeriveVertexNormals", {
                get: /**
                * True if the vertex normals should be derived from the geometry, false if the vertex normals are set
                * explicitly.
                */
                function () {
                    return this._autoDeriveVertexNormals;
                },
                set: function (value) {
                    this._autoDeriveVertexNormals = value;
                    this._vertexNormalsDirty = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "useFaceWeights", {
                get: /**
                * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
                */
                function () {
                    return this._useFaceWeights;
                },
                set: function (value) {
                    this._useFaceWeights = value;

                    if (this._autoDeriveVertexNormals) {
                        this._vertexNormalsDirty = true;
                    }

                    if (this._autoDeriveVertexTangents) {
                        this._vertexTangentsDirty = true;
                    }

                    this._faceNormalsDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "numTriangles", {
                get: /**
                * The total amount of triangles in the SubGeometry.
                */
                function () {
                    return this._numTriangles;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Retrieves the VertexBuffer3D object that contains triangle indices.
            * @param context The Context3D for which we request the buffer
            * @return The VertexBuffer3D object that contains triangle indices.
            */
            SubGeometryBase.prototype.getIndexBuffer = function (stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (!this._indexBuffer[contextIndex] || this._indexBufferContext[contextIndex] != context) {
                    this._indexBuffer[contextIndex] = context.createIndexBuffer(this._numIndices);
                    this._indexBufferContext[contextIndex] = context;
                    this._indicesInvalid[contextIndex] = true;
                }

                if (this._indicesInvalid[contextIndex]) {
                    this._indexBuffer[contextIndex].uploadFromArray(this._indices, 0, this._numIndices);
                    this._indicesInvalid[contextIndex] = false;
                }

                return this._indexBuffer[contextIndex];
            };

            /**
            * Updates the tangents for each face.
            */
            SubGeometryBase.prototype.pUpdateFaceTangents = function () {
                var i = 0;
                var index1;
                var index2;
                var index3;
                var len = this._indices.length;
                var ui;
                var vi;
                var v0;
                var dv1;
                var dv2;
                var denom;
                var x0, y0, z0;
                var dx1, dy1, dz1;
                var dx2, dy2, dz2;
                var cx, cy, cz;
                var vertices = this._vertexData;
                var uvs = this.UVData;
                var posStride = this.vertexStride;
                var posOffset = this.vertexOffset;
                var texStride = this.UVStride;
                var texOffset = this.UVOffset;

                if (this._faceTangents == null) {
                    this._faceTangents = new Array(this._indices.length);
                }

                while (i < len) {
                    index1 = this._indices[i];
                    index2 = this._indices[i + 1];
                    index3 = this._indices[i + 2];

                    ui = texOffset + index1 * texStride + 1;
                    v0 = uvs[ui];
                    ui = texOffset + index2 * texStride + 1;
                    dv1 = uvs[ui] - v0;
                    ui = texOffset + index3 * texStride + 1;
                    dv2 = uvs[ui] - v0;

                    vi = posOffset + index1 * posStride;
                    x0 = vertices[vi];
                    y0 = vertices[(vi + 1)];
                    z0 = vertices[(vi + 2)];
                    vi = posOffset + index2 * posStride;
                    dx1 = vertices[(vi)] - x0;
                    dy1 = vertices[(vi + 1)] - y0;
                    dz1 = vertices[(vi + 2)] - z0;
                    vi = posOffset + index3 * posStride;
                    dx2 = vertices[(vi)] - x0;
                    dy2 = vertices[(vi + 1)] - y0;
                    dz2 = vertices[(vi + 2)] - z0;

                    cx = dv2 * dx1 - dv1 * dx2;
                    cy = dv2 * dy1 - dv1 * dy2;
                    cz = dv2 * dz1 - dv1 * dz2;
                    denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);

                    this._faceTangents[i++] = denom * cx;
                    this._faceTangents[i++] = denom * cy;
                    this._faceTangents[i++] = denom * cz;
                }

                this._faceTangentsDirty = false;
            };

            /**
            * Updates the normals for each face.
            */
            SubGeometryBase.prototype.updateFaceNormals = function () {
                var i = 0;
                var j = 0;
                var k = 0;
                var index;

                var len = this._indices.length;
                var x1, x2, x3;
                var y1, y2, y3;
                var z1, z2, z3;
                var dx1, dy1, dz1;
                var dx2, dy2, dz2;
                var cx, cy, cz;
                var d;
                var vertices = this._vertexData;
                var posStride = this.vertexStride;
                var posOffset = this.vertexOffset;

                if (this._faceNormals == null) {
                    this._faceNormals = new Array(len);
                }

                if (this._useFaceWeights) {
                    if (this._faceWeights == null) {
                        this._faceWeights = new Array(len / 3);
                    }
                }

                while (i < len) {
                    index = posOffset + this._indices[i++] * posStride;
                    x1 = vertices[index];
                    y1 = vertices[index + 1];
                    z1 = vertices[index + 2];
                    index = posOffset + this._indices[i++] * posStride;
                    x2 = vertices[index];
                    y2 = vertices[index + 1];
                    z2 = vertices[index + 2];
                    index = posOffset + this._indices[i++] * posStride;
                    x3 = vertices[index];
                    y3 = vertices[index + 1];
                    z3 = vertices[index + 2];
                    dx1 = x3 - x1;
                    dy1 = y3 - y1;
                    dz1 = z3 - z1;
                    dx2 = x2 - x1;
                    dy2 = y2 - y1;
                    dz2 = z2 - z1;
                    cx = dz1 * dy2 - dy1 * dz2;
                    cy = dx1 * dz2 - dz1 * dx2;
                    cz = dy1 * dx2 - dx1 * dy2;
                    d = Math.sqrt(cx * cx + cy * cy + cz * cz);

                    if (this._useFaceWeights) {
                        var w = d * 10000;

                        if (w < 1) {
                            w = 1;
                        }

                        this._faceWeights[k++] = w;
                    }

                    d = 1 / d;

                    this._faceNormals[j++] = cx * d;
                    this._faceNormals[j++] = cy * d;
                    this._faceNormals[j++] = cz * d;
                }

                this._faceNormalsDirty = false;
            };

            /**
            * Updates the vertex normals based on the geometry.
            */
            SubGeometryBase.prototype.pUpdateVertexNormals = function (target) {
                if (this._faceNormalsDirty) {
                    this.updateFaceNormals();
                }

                var v1;
                var f1 = 0;
                var f2 = 1;
                var f3 = 2;
                var lenV = this._vertexData.length;
                var normalStride = this.vertexNormalStride;
                var normalOffset = this.vertexNormalOffset;

                if (target == null) {
                    target = new Array(lenV);
                }

                v1 = normalOffset;

                while (v1 < lenV) {
                    target[v1] = 0.0;
                    target[v1 + 1] = 0.0;
                    target[v1 + 2] = 0.0;
                    v1 += normalStride;
                }

                var i = 0;
                var k = 0;
                var lenI = this._indices.length;
                var index;
                var weight;

                while (i < lenI) {
                    weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                    index = normalOffset + this._indices[i++] * normalStride;
                    target[index++] += this._faceNormals[f1] * weight;
                    target[index++] += this._faceNormals[f2] * weight;
                    target[index] += this._faceNormals[f3] * weight;
                    index = normalOffset + this._indices[i++] * normalStride;
                    target[index++] += this._faceNormals[f1] * weight;
                    target[index++] += this._faceNormals[f2] * weight;
                    target[index] += this._faceNormals[f3] * weight;
                    index = normalOffset + this._indices[i++] * normalStride;
                    target[index++] += this._faceNormals[f1] * weight;
                    target[index++] += this._faceNormals[f2] * weight;
                    target[index] += this._faceNormals[f3] * weight;
                    f1 += 3;
                    f2 += 3;
                    f3 += 3;
                }

                v1 = normalOffset;
                while (v1 < lenV) {
                    var vx = target[v1];
                    var vy = target[v1 + 1];
                    var vz = target[v1 + 2];
                    var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                    target[v1] = vx * d;
                    target[v1 + 1] = vy * d;
                    target[v1 + 2] = vz * d;
                    v1 += normalStride;
                }

                this._vertexNormalsDirty = false;

                return target;
            };

            /**
            * Updates the vertex tangents based on the geometry.
            */
            SubGeometryBase.prototype.pUpdateVertexTangents = function (target) {
                if (this._faceTangentsDirty) {
                    this.pUpdateFaceTangents();
                }

                var i;
                var lenV = this._vertexData.length;
                var tangentStride = this.vertexTangentStride;
                var tangentOffset = this.vertexTangentOffset;

                if (target == null) {
                    target = new Array(lenV);
                }

                i = tangentOffset;

                while (i < lenV) {
                    target[i] = 0.0;
                    target[i + 1] = 0.0;
                    target[i + 2] = 0.0;
                    i += tangentStride;
                }

                var k = 0;
                var lenI = this._indices.length;
                var index;
                var weight;
                var f1 = 0;
                var f2 = 1;
                var f3 = 2;

                i = 0;

                while (i < lenI) {
                    weight = this._useFaceWeights ? this._faceWeights[k++] : 1;
                    index = tangentOffset + this._indices[i++] * tangentStride;
                    target[index++] += this._faceTangents[f1] * weight;
                    target[index++] += this._faceTangents[f2] * weight;
                    target[index] += this._faceTangents[f3] * weight;
                    index = tangentOffset + this._indices[i++] * tangentStride;
                    target[index++] += this._faceTangents[f1] * weight;
                    target[index++] += this._faceTangents[f2] * weight;
                    target[index] += this._faceTangents[f3] * weight;
                    index = tangentOffset + this._indices[i++] * tangentStride;
                    target[index++] += this._faceTangents[f1] * weight;
                    target[index++] += this._faceTangents[f2] * weight;
                    target[index] += this._faceTangents[f3] * weight;
                    f1 += 3;
                    f2 += 3;
                    f3 += 3;
                }

                i = tangentOffset;

                while (i < lenV) {
                    var vx = target[i];
                    var vy = target[i + 1];
                    var vz = target[i + 2];
                    var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                    target[i] = vx * d;
                    target[i + 1] = vy * d;
                    target[i + 2] = vz * d;
                    i += tangentStride;
                }

                this._vertexTangentsDirty = false;

                return target;
            };

            SubGeometryBase.prototype.dispose = function () {
                this.pDisposeIndexBuffers(this._indexBuffer);
                this._indices = null;
                this._indexBufferContext = null;
                this._faceNormals = null;
                this._faceWeights = null;
                this._faceTangents = null;
                this._vertexData = null;
            };

            Object.defineProperty(SubGeometryBase.prototype, "indexData", {
                get: /**
                * The raw index data that define the faces.
                *
                * @private
                */
                function () {
                    return this._indices;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the face indices of the SubGeometry.
            * @param indices The face indices to upload.
            */
            SubGeometryBase.prototype.updateIndexData = function (indices/*uint*/ ) {
                this._indices = indices;
                this._numIndices = indices.length;

                var numTriangles = this._numIndices / 3;

                if (this._numTriangles != numTriangles) {
                    this.pDisposeIndexBuffers(this._indexBuffer);
                }

                this._numTriangles = numTriangles;
                this.pInvalidateBuffers(this._indicesInvalid);
                this._faceNormalsDirty = true;

                if (this._autoDeriveVertexNormals) {
                    this._vertexNormalsDirty = true;
                }

                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }
            };

            /**
            * Disposes all buffers in a given vector.
            * @param buffers The vector of buffers to dispose.
            */
            SubGeometryBase.prototype.pDisposeIndexBuffers = function (buffers) {
                for (var i = 0; i < 8; ++i) {
                    if (buffers[i]) {
                        buffers[i].dispose();
                        buffers[i] = null;
                    }
                }
            };

            /**
            * Disposes all buffers in a given vector.
            * @param buffers The vector of buffers to dispose.
            */
            SubGeometryBase.prototype.pDisposeVertexBuffers = function (buffers) {
                for (var i = 0; i < 8; ++i) {
                    if (buffers[i]) {
                        buffers[i].dispose();
                        buffers[i] = null;
                    }
                }
            };

            Object.defineProperty(SubGeometryBase.prototype, "autoDeriveVertexTangents", {
                get: /**
                * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set
                * explicitly.
                */
                function () {
                    return this._autoDeriveVertexTangents;
                },
                set: function (value) {
                    this._autoDeriveVertexTangents = value;
                    this._vertexTangentsDirty = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "faceNormals", {
                get: /**
                * The raw data of the face normals, in the same order as the faces are listed in the index list.
                *
                * @private
                */
                function () {
                    if (this._faceNormalsDirty) {
                        this.updateFaceNormals();
                    }

                    return this._faceNormals;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Invalidates all buffers in a vector, causing them the update when they are first requested.
            * @param buffers The vector of buffers to invalidate.
            */
            SubGeometryBase.prototype.pInvalidateBuffers = function (invalid) {
                for (var i = 0; i < 8; ++i) {
                    invalid[i] = true;
                }
            };

            Object.defineProperty(SubGeometryBase.prototype, "UVStride", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexPositionData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexNormalData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexTangentData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "UVData", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexStride", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexNormalStride", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexTangentStride", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexOffset", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexNormalOffset", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "vertexTangentOffset", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "UVOffset", {
                get: function () {
                    throw new away.errors.AbstractMethodError();
                },
                enumerable: true,
                configurable: true
            });

            SubGeometryBase.prototype.pInvalidateBounds = function () {
                if (this._parentGeometry) {
                    var me = this;
                    this._parentGeometry.iInvalidateBounds(me);
                }
            };

            Object.defineProperty(SubGeometryBase.prototype, "parentGeometry", {
                get: /**
                * The Geometry object that 'owns' this SubGeometry object.
                *
                * @private
                */
                function () {
                    return this._parentGeometry;
                },
                set: function (value) {
                    this._parentGeometry = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SubGeometryBase.prototype, "scaleU", {
                get: /**
                * Scales the uv coordinates
                * @param scaleU The amount by which to scale on the u axis. Default is 1;
                * @param scaleV The amount by which to scale on the v axis. Default is 1;
                */
                function () {
                    return this._scaleU;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometryBase.prototype, "scaleV", {
                get: function () {
                    return this._scaleV;
                },
                enumerable: true,
                configurable: true
            });

            SubGeometryBase.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                var offset = this.UVOffset;
                var stride = this.UVStride;
                var uvs = this.UVData;
                var len = uvs.length;
                var ratioU = scaleU / this._scaleU;
                var ratioV = scaleV / this._scaleV;

                for (var i = offset; i < len; i += stride) {
                    uvs[i] *= ratioU;
                    uvs[i + 1] *= ratioV;
                }

                this._scaleU = scaleU;
                this._scaleV = scaleV;
            };

            /**
            * Scales the geometry.
            * @param scale The amount by which to scale.
            */
            SubGeometryBase.prototype.scale = function (scale) {
                var vertices = this.UVData;
                var len = vertices.length;
                var offset = this.vertexOffset;
                var stride = this.vertexStride;

                for (var i = offset; i < len; i += stride) {
                    vertices[i] *= scale;
                    vertices[i + 1] *= scale;
                    vertices[i + 2] *= scale;
                }
            };

            SubGeometryBase.prototype.applyTransformation = function (transform) {
                var vertices = this._vertexData;
                var normals = this.vertexNormalData;
                var tangents = this.vertexTangentData;
                var posStride = this.vertexStride;
                var normalStride = this.vertexNormalStride;
                var tangentStride = this.vertexTangentStride;
                var posOffset = this.vertexOffset;
                var normalOffset = this.vertexNormalOffset;
                var tangentOffset = this.vertexTangentOffset;
                var len = vertices.length / posStride;
                var i;
                var i1;
                var i2;
                var vector = new away.geom.Vector3D();

                var bakeNormals = normals != null;
                var bakeTangents = tangents != null;
                var invTranspose;

                if (bakeNormals || bakeTangents) {
                    invTranspose = transform.clone();
                    invTranspose.invert();
                    invTranspose.transpose();
                }

                var vi0 = posOffset;
                var ni0 = normalOffset;
                var ti0 = tangentOffset;

                for (i = 0; i < len; ++i) {
                    i1 = vi0 + 1;
                    i2 = vi0 + 2;

                    // bake position
                    vector.x = vertices[vi0];
                    vector.y = vertices[i1];
                    vector.z = vertices[i2];
                    vector = transform.transformVector(vector);
                    vertices[vi0] = vector.x;
                    vertices[i1] = vector.y;
                    vertices[i2] = vector.z;
                    vi0 += posStride;

                    if (bakeNormals) {
                        i1 = ni0 + 1;
                        i2 = ni0 + 2;
                        vector.x = normals[ni0];
                        vector.y = normals[i1];
                        vector.z = normals[i2];
                        vector = invTranspose.deltaTransformVector(vector);
                        vector.normalize();
                        normals[ni0] = vector.x;
                        normals[i1] = vector.y;
                        normals[i2] = vector.z;
                        ni0 += normalStride;
                    }

                    if (bakeTangents) {
                        i1 = ti0 + 1;
                        i2 = ti0 + 2;
                        vector.x = tangents[ti0];
                        vector.y = tangents[i1];
                        vector.z = tangents[i2];
                        vector = invTranspose.deltaTransformVector(vector);
                        vector.normalize();
                        tangents[ti0] = vector.x;
                        tangents[i1] = vector.y;
                        tangents[i2] = vector.z;
                        ti0 += tangentStride;
                    }
                }
            };

            SubGeometryBase.prototype.pUpdateDummyUVs = function (target) {
                this._uvsDirty = false;
                var idx;
                var uvIdx;
                var stride = this.UVStride;
                var skip = stride - 2;
                var len = this._vertexData.length / this.vertexStride * stride;

                if (!target) {
                    target = new Array();
                }

                target.length = len;

                idx = this.UVOffset;
                uvIdx = 0;

                while (idx < len) {
                    target[idx++] = uvIdx * .5;
                    target[idx++] = 1.0 - (uvIdx & 1);
                    idx += skip;

                    if (++uvIdx == 3) {
                        uvIdx = 0;
                    }
                }

                return target;
            };
            return SubGeometryBase;
        })();
        base.SubGeometryBase = SubGeometryBase;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (events) {
        /**
        * Dispatched to notify changes in a geometry object's state.
        *
        * @class away.events.GeometryEvent
        * @see away3d.core.base.Geometry
        */
        var GeometryEvent = (function (_super) {
            __extends(GeometryEvent, _super);
            /**
            * Create a new GeometryEvent
            * @param type The event type.
            * @param subGeometry An optional SubGeometry object that is the subject of this event.
            */
            function GeometryEvent(type, subGeometry) {
                if (typeof subGeometry === "undefined") { subGeometry = null; }
                _super.call(this, type);
                this._subGeometry = subGeometry;
            }
            Object.defineProperty(GeometryEvent.prototype, "subGeometry", {
                get: /**
                * The SubGeometry object that is the subject of this event, if appropriate.
                */
                function () {
                    return this._subGeometry;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the event.
            * @return An exact duplicate of the current object.
            */
            GeometryEvent.prototype.clone = function () {
                return new GeometryEvent(this.type, this._subGeometry);
            };
            GeometryEvent.SUB_GEOMETRY_ADDED = "SubGeometryAdded";

            GeometryEvent.SUB_GEOMETRY_REMOVED = "SubGeometryRemoved";

            GeometryEvent.BOUNDS_INVALID = "BoundsInvalid";
            return GeometryEvent;
        })(away.events.Event);
        events.GeometryEvent = GeometryEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (base) {
        /**
        * @class away.base.Geometry
        */
        var CompactSubGeometry = (function (_super) {
            __extends(CompactSubGeometry, _super);
            function CompactSubGeometry() {
                _super.call(this);
                this._pVertexDataInvalid = Array(8);
                this._vertexBuffer = new Array(8);
                this._bufferContext = new Array(8);

                this._autoDeriveVertexNormals = false;
                this._autoDeriveVertexTangents = false;
            }
            Object.defineProperty(CompactSubGeometry.prototype, "numVertices", {
                get: function () {
                    return this._pNumVertices;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex data. All vertex properties are contained in a single Vector, and the order is as follows:
            * 0 - 2: vertex position X, Y, Z
            * 3 - 5: normal X, Y, Z
            * 6 - 8: tangent X, Y, Z
            * 9 - 10: U V
            * 11 - 12: Secondary U V
            */
            CompactSubGeometry.prototype.updateData = function (data) {
                if (this._autoDeriveVertexNormals) {
                    this._vertexNormalsDirty = true;
                }

                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }

                this._faceNormalsDirty = true;
                this._faceTangentsDirty = true;
                this._isolatedVertexPositionDataDirty = true;
                this._vertexData = data;

                var numVertices = this._vertexData.length / 13;

                if (numVertices != this._pNumVertices) {
                    this.pDisposeVertexBuffers(this._vertexBuffer);
                }

                this._pNumVertices = numVertices;

                if (this._pNumVertices == 0) {
                    throw new Error("Bad data: geometry can't have zero triangles");
                }

                this.pInvalidateBuffers(this._pVertexDataInvalid);
                this.pInvalidateBounds();
            };

            CompactSubGeometry.prototype.activateVertexBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 0, away.display3D.Context3DVertexBufferFormat.FLOAT_3);
            };

            CompactSubGeometry.prototype.activateUVBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (this._uvsDirty && this._autoGenerateUVs) {
                    this._vertexData = this.pUpdateDummyUVs(this._vertexData);
                    this.pInvalidateBuffers(this._pVertexDataInvalid);
                }

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 9, away.display3D.Context3DVertexBufferFormat.FLOAT_2);
            };

            CompactSubGeometry.prototype.activateSecondaryUVBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 11, away.display3D.Context3DVertexBufferFormat.FLOAT_2);
            };

            CompactSubGeometry.prototype.pUploadData = function (contextIndex) {
                this._pActiveBuffer.uploadFromArray(this._vertexData, 0, this._pNumVertices);
                this._pVertexDataInvalid[contextIndex] = this._pActiveDataInvalid = false;
            };

            CompactSubGeometry.prototype.activateVertexNormalBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 3, away.display3D.Context3DVertexBufferFormat.FLOAT_3);
            };

            CompactSubGeometry.prototype.activateVertexTangentBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (contextIndex != this._contextIndex) {
                    this.pUpdateActiveBuffer(contextIndex);
                }

                if (!this._pActiveBuffer || this._activeContext != context) {
                    this.pCreateBuffer(contextIndex, context);
                }

                if (this._pActiveDataInvalid) {
                    this.pUploadData(contextIndex);
                }

                context.setVertexBufferAt(index, this._pActiveBuffer, 6, away.display3D.Context3DVertexBufferFormat.FLOAT_3);
            };

            CompactSubGeometry.prototype.pCreateBuffer = function (contextIndex, context) {
                this._vertexBuffer[contextIndex] = this._pActiveBuffer = context.createVertexBuffer(this._pNumVertices, 13);
                this._bufferContext[contextIndex] = this._activeContext = context;
                this._pVertexDataInvalid[contextIndex] = this._pActiveDataInvalid = true;
            };

            CompactSubGeometry.prototype.pUpdateActiveBuffer = function (contextIndex) {
                this._contextIndex = contextIndex;
                this._pActiveDataInvalid = this._pVertexDataInvalid[contextIndex];
                this._pActiveBuffer = this._vertexBuffer[contextIndex];
                this._activeContext = this._bufferContext[contextIndex];
            };

            Object.defineProperty(CompactSubGeometry.prototype, "vertexData", {
                get: function () {
                    if (this._autoDeriveVertexNormals && this._vertexNormalsDirty) {
                        this._vertexData = this.pUpdateVertexNormals(this._vertexData);
                    }

                    if (this._autoDeriveVertexTangents && this._vertexTangentsDirty) {
                        this._vertexData = this.pUpdateVertexTangents(this._vertexData);
                    }

                    if (this._uvsDirty && this._autoGenerateUVs) {
                        this._vertexData = this.pUpdateDummyUVs(this._vertexData);
                    }

                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            CompactSubGeometry.prototype.pUpdateVertexNormals = function (target) {
                this.pInvalidateBuffers(this._pVertexDataInvalid);
                return _super.prototype.pUpdateVertexNormals.call(this, target);
            };

            CompactSubGeometry.prototype.pUpdateVertexTangents = function (target) {
                if (this._vertexNormalsDirty) {
                    this._vertexData = this.pUpdateVertexNormals(this._vertexData);
                }

                this.pInvalidateBuffers(this._pVertexDataInvalid);

                return _super.prototype.pUpdateVertexTangents.call(this, target);
            };

            Object.defineProperty(CompactSubGeometry.prototype, "vertexNormalData", {
                get: function () {
                    if (this._autoDeriveVertexNormals && this._vertexNormalsDirty) {
                        this._vertexData = this.pUpdateVertexNormals(this._vertexData);
                    }

                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexTangentData", {
                get: function () {
                    if (this._autoDeriveVertexTangents && this._vertexTangentsDirty) {
                        this._vertexData = this.pUpdateVertexTangents(this._vertexData);
                    }

                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "UVData", {
                get: function () {
                    if (this._uvsDirty && this._autoGenerateUVs) {
                        this._vertexData = this.pUpdateDummyUVs(this._vertexData);
                        this.pInvalidateBuffers(this._pVertexDataInvalid);
                    }

                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            CompactSubGeometry.prototype.applyTransformation = function (transform) {
                _super.prototype.applyTransformation.call(this, transform);
                this.pInvalidateBuffers(this._pVertexDataInvalid);
            };

            CompactSubGeometry.prototype.scale = function (scale) {
                _super.prototype.scale.call(this, scale);
                this.pInvalidateBuffers(this._pVertexDataInvalid);
            };

            CompactSubGeometry.prototype.clone = function () {
                var clone = new away.base.CompactSubGeometry();

                clone._autoDeriveVertexNormals = this._autoDeriveVertexNormals;
                clone._autoDeriveVertexTangents = this._autoDeriveVertexTangents;

                clone.updateData(this._vertexData.concat());
                clone.updateIndexData(this._indices.concat());

                return clone;
            };

            CompactSubGeometry.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                _super.prototype.scaleUV.call(this, scaleU, scaleV);

                this.pInvalidateBuffers(this._pVertexDataInvalid);
            };

            Object.defineProperty(CompactSubGeometry.prototype, "vertexStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexNormalStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexTangentStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "UVStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "secondaryUVStride", {
                get: function () {
                    return 13;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexNormalOffset", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "vertexTangentOffset", {
                get: function () {
                    return 6;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "UVOffset", {
                get: function () {
                    return 9;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "secondaryUVOffset", {
                get: function () {
                    return 11;
                },
                enumerable: true,
                configurable: true
            });

            CompactSubGeometry.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.pDisposeVertexBuffers(this._vertexBuffer);
                this._vertexBuffer = null;
            };

            CompactSubGeometry.prototype.pDisposeVertexBuffers = function (buffers) {
                _super.prototype.pDisposeVertexBuffers.call(this, buffers);
                this._pActiveBuffer = null;
            };

            CompactSubGeometry.prototype.pInvalidateBuffers = function (invalid) {
                _super.prototype.pInvalidateBuffers.call(this, invalid);
                this._pActiveDataInvalid = true;
            };

            CompactSubGeometry.prototype.cloneWithSeperateBuffers = function () {
                var clone = new away.base.SubGeometry();

                clone.updateVertexData(this._isolatedVertexPositionData ? this._isolatedVertexPositionData : this._isolatedVertexPositionData = this.stripBuffer(0, 3));
                clone.autoDeriveVertexNormals = this._autoDeriveVertexNormals;
                clone.autoDeriveVertexTangents = this._autoDeriveVertexTangents;

                if (!this._autoDeriveVertexNormals) {
                    clone.updateVertexNormalData(this.stripBuffer(3, 3));
                }

                if (!this._autoDeriveVertexTangents) {
                    clone.updateVertexTangentData(this.stripBuffer(6, 3));
                }

                clone.updateUVData(this.stripBuffer(9, 2));
                clone.updateSecondaryUVData(this.stripBuffer(11, 2));
                clone.updateIndexData(this.indexData.concat());

                return clone;
            };

            Object.defineProperty(CompactSubGeometry.prototype, "vertexPositionData", {
                get: function () {
                    if (this._isolatedVertexPositionDataDirty || !this._isolatedVertexPositionData) {
                        this._isolatedVertexPositionData = this.stripBuffer(0, 3);
                        this._isolatedVertexPositionDataDirty = false;
                    }

                    return this._isolatedVertexPositionData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompactSubGeometry.prototype, "strippedUVData", {
                get: function () {
                    return this.stripBuffer(9, 2);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Isolate and returns a Vector.Number of a specific buffer type
            *
            * - stripBuffer(0, 3), return only the vertices
            * - stripBuffer(3, 3): return only the normals
            * - stripBuffer(6, 3): return only the tangents
            * - stripBuffer(9, 2): return only the uv's
            * - stripBuffer(11, 2): return only the secondary uv's
            */
            CompactSubGeometry.prototype.stripBuffer = function (offset, numEntries) {
                var data = new Array(this._pNumVertices * numEntries);
                var i = 0;
                var j = offset;
                var skip = 13 - numEntries;

                for (var v = 0; v < this._pNumVertices; ++v) {
                    for (var k = 0; k < numEntries; ++k) {
                        data[i++] = this._vertexData[j++];
                    }

                    j += skip;
                }

                return data;
            };

            CompactSubGeometry.prototype.fromVectors = function (verts, uvs, normals, tangents) {
                var vertLen = verts.length / 3 * 13;

                var index = 0;
                var v = 0;
                var n = 0;
                var t = 0;
                var u = 0;

                var data = new Array(vertLen);

                while (index < vertLen) {
                    data[index++] = verts[v++];
                    data[index++] = verts[v++];
                    data[index++] = verts[v++];

                    if (normals && normals.length) {
                        data[index++] = normals[n++];
                        data[index++] = normals[n++];
                        data[index++] = normals[n++];
                    } else {
                        data[index++] = 0;
                        data[index++] = 0;
                        data[index++] = 0;
                    }

                    if (tangents && tangents.length) {
                        data[index++] = tangents[t++];
                        data[index++] = tangents[t++];
                        data[index++] = tangents[t++];
                    } else {
                        data[index++] = 0;
                        data[index++] = 0;
                        data[index++] = 0;
                    }

                    if (uvs && uvs.length) {
                        data[index++] = uvs[u];
                        data[index++] = uvs[u + 1];

                        // use same secondary uvs as primary
                        data[index++] = uvs[u++];
                        data[index++] = uvs[u++];
                    } else {
                        data[index++] = 0;
                        data[index++] = 0;
                        data[index++] = 0;
                        data[index++] = 0;
                    }
                }

                this.autoDeriveVertexNormals = !(normals && normals.length);
                this.autoDeriveVertexTangents = !(tangents && tangents.length);
                this.autoGenerateDummyUVs = !(uvs && uvs.length);
                this.updateData(data);
            };
            return CompactSubGeometry;
        })(away.base.SubGeometryBase);
        base.CompactSubGeometry = CompactSubGeometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        *
        * SkinnedSubGeometry provides a SubGeometry extension that contains data needed to skin vertices. In particular,
        * it provides joint indices and weights.
        * Important! Joint indices need to be pre-multiplied by 3, since they index the matrix array (and each matrix has 3 float4 elements)
        *
        * @class away.base.SkinnedSubGeometry
        *
        */
        var SkinnedSubGeometry = (function (_super) {
            __extends(SkinnedSubGeometry, _super);
            /**
            * Creates a new SkinnedSubGeometry object.
            * @param jointsPerVertex The amount of joints that can be assigned per vertex.
            */
            function SkinnedSubGeometry(jointsPerVertex) {
                _super.call(this);
                this._jointWeightsBuffer = new Array(8);
                this._jointIndexBuffer = new Array(8);
                this._jointWeightsInvalid = new Array(8);
                this._jointIndicesInvalid = new Array(8);
                this._jointWeightContext = new Array(8);
                this._jointIndexContext = new Array(8);

                this._jointsPerVertex = jointsPerVertex;
                this._bufferFormat = "float" + this._jointsPerVertex;
            }
            Object.defineProperty(SkinnedSubGeometry.prototype, "condensedIndexLookUp", {
                get: /**
                * If indices have been condensed, this will contain the original index for each condensed index.
                */
                function () {
                    return this._condensedIndexLookUp;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkinnedSubGeometry.prototype, "numCondensedJoints", {
                get: /**
                * The amount of joints used when joint indices have been condensed.
                */
                function () {
                    return this._numCondensedJoints;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SkinnedSubGeometry.prototype, "animatedData", {
                get: /**
                * The animated vertex positions when set explicitly if the skinning transformations couldn't be performed on GPU.
                */
                function () {
                    return this._animatedData || this._vertexData.concat();
                },
                enumerable: true,
                configurable: true
            });

            SkinnedSubGeometry.prototype.updateAnimatedData = function (value) {
                this._animatedData = value;
                this.pInvalidateBuffers(this._pVertexDataInvalid);
            };

            /**
            * Assigns the attribute stream for joint weights
            * @param index The attribute stream index for the vertex shader
            * @param stage3DProxy The Stage3DProxy to assign the stream to
            */
            SkinnedSubGeometry.prototype.activateJointWeightsBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;
                if (this._jointWeightContext[contextIndex] != context || !this._jointWeightsBuffer[contextIndex]) {
                    this._jointWeightsBuffer[contextIndex] = context.createVertexBuffer(this._pNumVertices, this._jointsPerVertex);
                    this._jointWeightContext[contextIndex] = context;
                    this._jointWeightsInvalid[contextIndex] = true;
                }
                if (this._jointWeightsInvalid[contextIndex]) {
                    this._jointWeightsBuffer[contextIndex].uploadFromArray(this._jointWeightsData, 0, this._jointWeightsData.length / this._jointsPerVertex);
                    this._jointWeightsInvalid[contextIndex] = false;
                }
                context.setVertexBufferAt(index, this._jointWeightsBuffer[contextIndex], 0, this._bufferFormat);
            };

            /**
            * Assigns the attribute stream for joint indices
            * @param index The attribute stream index for the vertex shader
            * @param stage3DProxy The Stage3DProxy to assign the stream to
            */
            SkinnedSubGeometry.prototype.activateJointIndexBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (this._jointIndexContext[contextIndex] != context || !this._jointIndexBuffer[contextIndex]) {
                    this._jointIndexBuffer[contextIndex] = context.createVertexBuffer(this._pNumVertices, this._jointsPerVertex);
                    this._jointIndexContext[contextIndex] = context;
                    this._jointIndicesInvalid[contextIndex] = true;
                }
                if (this._jointIndicesInvalid[contextIndex]) {
                    this._jointIndexBuffer[contextIndex].uploadFromArray(this._numCondensedJoints > 0 ? this._condensedJointIndexData : this._jointIndexData, 0, this._jointIndexData.length / this._jointsPerVertex);
                    this._jointIndicesInvalid[contextIndex] = false;
                }
                context.setVertexBufferAt(index, this._jointIndexBuffer[contextIndex], 0, this._bufferFormat);
            };

            SkinnedSubGeometry.prototype.pUploadData = function (contextIndex) {
                if (this._animatedData) {
                    this._pActiveBuffer.uploadFromArray(this._animatedData, 0, this._pNumVertices);
                    this._pVertexDataInvalid[contextIndex] = this._pActiveDataInvalid = false;
                } else {
                    _super.prototype.pUploadData.call(this, contextIndex);
                }
            };

            /**
            * Clones the current object.
            * @return An exact duplicate of the current object.
            */
            SkinnedSubGeometry.prototype.clone = function () {
                var clone = new SkinnedSubGeometry(this._jointsPerVertex);

                clone.updateData(this._vertexData.concat());
                clone.updateIndexData(this._indices.concat());
                clone.iUpdateJointIndexData(this._jointIndexData.concat());
                clone.iUpdateJointWeightsData(this._jointWeightsData.concat());
                clone._autoDeriveVertexNormals = this._autoDeriveVertexNormals;
                clone._autoDeriveVertexTangents = this._autoDeriveVertexTangents;
                clone._numCondensedJoints = this._numCondensedJoints;
                clone._condensedIndexLookUp = this._condensedIndexLookUp;
                clone._condensedJointIndexData = this._condensedJointIndexData;

                return clone;
            };

            /**
            * Cleans up any resources used by this object.
            */
            SkinnedSubGeometry.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.pDisposeVertexBuffers(this._jointWeightsBuffer);
                this.pDisposeVertexBuffers(this._jointIndexBuffer);
            };

            /**
            */
            SkinnedSubGeometry.prototype.iCondenseIndexData = function () {
                var len = this._jointIndexData.length;
                var oldIndex;
                var newIndex = 0;
                var dic = new Object();

                this._condensedJointIndexData = new Array(len);
                this._condensedIndexLookUp = new Array();

                for (var i = 0; i < len; ++i) {
                    oldIndex = this._jointIndexData[i];

                    if (dic[oldIndex] == undefined) {
                        dic[oldIndex] = newIndex;
                        this._condensedIndexLookUp[newIndex++] = oldIndex;
                        this._condensedIndexLookUp[newIndex++] = oldIndex + 1;
                        this._condensedIndexLookUp[newIndex++] = oldIndex + 2;
                    }
                    this._condensedJointIndexData[i] = dic[oldIndex];
                }
                this._numCondensedJoints = newIndex / 3;

                this.pInvalidateBuffers(this._jointIndicesInvalid);
            };

            Object.defineProperty(SkinnedSubGeometry.prototype, "iJointWeightsData", {
                get: /**
                * The raw joint weights data.
                */
                function () {
                    return this._jointWeightsData;
                },
                enumerable: true,
                configurable: true
            });

            SkinnedSubGeometry.prototype.iUpdateJointWeightsData = function (value) {
                // invalidate condensed stuff
                this._numCondensedJoints = 0;
                this._condensedIndexLookUp = null;
                this._condensedJointIndexData = null;

                this._jointWeightsData = value;
                this.pInvalidateBuffers(this._jointWeightsInvalid);
            };

            Object.defineProperty(SkinnedSubGeometry.prototype, "iJointIndexData", {
                get: /**
                * The raw joint index data.
                */
                function () {
                    return this._jointIndexData;
                },
                enumerable: true,
                configurable: true
            });

            SkinnedSubGeometry.prototype.iUpdateJointIndexData = function (value) {
                this._jointIndexData = value;
                this.pInvalidateBuffers(this._jointIndicesInvalid);
            };
            return SkinnedSubGeometry;
        })(base.CompactSubGeometry);
        base.SkinnedSubGeometry = SkinnedSubGeometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        /**
        *
        * Geometry is a collection of SubGeometries, each of which contain the actual geometrical data such as vertices,
        * normals, uvs, etc. It also contains a reference to an animation class, which defines how the geometry moves.
        * A Geometry object is assigned to a Mesh, a scene graph occurence of the geometry, which in turn assigns
        * the SubGeometries to its respective SubMesh objects.
        *
        *
        *
        * @see away3d.core.base.SubGeometry
        * @see away3d.scenegraph.Mesh
        *
        * @class away.base.Geometry
        */
        var Geometry = (function (_super) {
            __extends(Geometry, _super);
            /**
            * Creates a new Geometry object.
            */
            function Geometry() {
                _super.call(this);

                this._subGeometries = new Array();
            }
            Object.defineProperty(Geometry.prototype, "assetType", {
                get: function () {
                    return away.library.AssetType.GEOMETRY;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Geometry.prototype, "subGeometries", {
                get: /**
                * A collection of SubGeometry objects, each of which contain geometrical data such as vertices, normals, etc.
                */
                function () {
                    return this._subGeometries;
                },
                enumerable: true,
                configurable: true
            });
            Geometry.prototype.getSubGeometries = function () {
                return this._subGeometries;
            };

            Geometry.prototype.applyTransformation = function (transform) {
                var len = this._subGeometries.length;
                for (var i = 0; i < len; ++i) {
                    this._subGeometries[i].applyTransformation(transform);
                }
            };

            /**
            * Adds a new SubGeometry object to the list.
            * @param subGeometry The SubGeometry object to be added.
            */
            Geometry.prototype.addSubGeometry = function (subGeometry) {
                this._subGeometries.push(subGeometry);

                subGeometry.parentGeometry = this;

                // TODO: add hasEventListener optimisation;
                //if (hasEventListener(GeometryEvent.SUB_GEOMETRY_ADDED))
                this.dispatchEvent(new away.events.GeometryEvent(away.events.GeometryEvent.SUB_GEOMETRY_ADDED, subGeometry));

                this.iInvalidateBounds(subGeometry);
            };

            /**
            * Removes a new SubGeometry object from the list.
            * @param subGeometry The SubGeometry object to be removed.
            */
            Geometry.prototype.removeSubGeometry = function (subGeometry) {
                this._subGeometries.splice(this._subGeometries.indexOf(subGeometry), 1);

                subGeometry.parentGeometry = null;

                // TODO: add hasEventListener optimisation;
                //if (hasEventListener(GeometryEvent.SUB_GEOMETRY_REMOVED))
                this.dispatchEvent(new away.events.GeometryEvent(away.events.GeometryEvent.SUB_GEOMETRY_REMOVED, subGeometry));

                this.iInvalidateBounds(subGeometry);
            };

            /**
            * Clones the geometry.
            * @return An exact duplicate of the current Geometry object.
            */
            Geometry.prototype.clone = function () {
                var clone = new Geometry();
                var len = this._subGeometries.length;

                for (var i = 0; i < len; ++i) {
                    clone.addSubGeometry(this._subGeometries[i].clone());
                }

                return clone;
            };

            /**
            * Scales the geometry.
            * @param scale The amount by which to scale.
            */
            Geometry.prototype.scale = function (scale) {
                var numSubGeoms = this._subGeometries.length;
                for (var i = 0; i < numSubGeoms; ++i) {
                    this._subGeometries[i].scale(scale);
                }
            };

            /**
            * Clears all resources used by the Geometry object, including SubGeometries.
            */
            Geometry.prototype.dispose = function () {
                var numSubGeoms = this._subGeometries.length;

                for (var i = 0; i < numSubGeoms; ++i) {
                    var subGeom = this._subGeometries[0];
                    this.removeSubGeometry(subGeom);
                    subGeom.dispose();
                }
            };

            /**
            * Scales the uv coordinates (tiling)
            * @param scaleU The amount by which to scale on the u axis. Default is 1;
            * @param scaleV The amount by which to scale on the v axis. Default is 1;
            */
            Geometry.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                var numSubGeoms = this._subGeometries.length;

                for (var i = 0; i < numSubGeoms; ++i) {
                    this._subGeometries[i].scaleUV(scaleU, scaleV);
                }
            };

            /**
            * Updates the SubGeometries so all vertex data is represented in different buffers.
            * Use this for compatibility with Pixel Bender and PBPickingCollider
            */
            Geometry.prototype.convertToSeparateBuffers = function () {
                var subGeom;
                var numSubGeoms = this._subGeometries.length;
                var _removableCompactSubGeometries = new Array();

                for (var i = 0; i < numSubGeoms; ++i) {
                    subGeom = this._subGeometries[i];

                    if (subGeom instanceof away.base.SubGeometry) {
                        continue;
                    }

                    _removableCompactSubGeometries.push(subGeom);

                    this.addSubGeometry(subGeom.cloneWithSeperateBuffers());
                }

                var l = _removableCompactSubGeometries.length;
                var s;

                for (var c = 0; c < l; c++) {
                    s = _removableCompactSubGeometries[c];
                    this.removeSubGeometry(s);
                    s.dispose();
                }
            };

            Geometry.prototype.iValidate = function () {
                // To be overridden when necessary
            };

            Geometry.prototype.iInvalidateBounds = function (subGeom) {
                //if (hasEventListener(GeometryEvent.BOUNDS_INVALID))
                this.dispatchEvent(new away.events.GeometryEvent(away.events.GeometryEvent.BOUNDS_INVALID, subGeom));
            };
            return Geometry;
        })(away.library.NamedAssetBase);
        base.Geometry = Geometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    /**
    * @module away.base
    */
    (function (base) {
        //import away3d.arcane;
        //import away3d.managers.Stage3DProxy;
        //import flash.display3D.Context3D;
        //import flash.display3D.Context3DVertexBufferFormat;
        //import flash.display3D.VertexBuffer3D;
        //import flash.geom.Matrix3D;
        //use namespace arcane;
        /**
        * The SubGeometry class is a collections of geometric data that describes a triangle mesh. It is owned by a
        * Geometry instance, and wrapped by a SubMesh in the scene graph.
        * Several SubGeometries are grouped so they can be rendered with different materials, but still represent a single
        * object.
        *
        * @see away3d.core.base.Geometry
        * @see away3d.core.base.SubMesh
        *
        * @class away.base.SubGeometry
        */
        var SubGeometry = (function (_super) {
            __extends(SubGeometry, _super);
            /**
            * Creates a new SubGeometry object.
            */
            function SubGeometry() {
                _super.call(this);
                this._verticesInvalid = new Array(8);
                this._uvsInvalid = new Array(8);
                this._secondaryUvsInvalid = new Array(8);
                this._normalsInvalid = new Array(8);
                this._tangentsInvalid = new Array(8);
                // buffers:
                this._vertexBuffer = new Array(8);
                this._uvBuffer = new Array(8);
                this._secondaryUvBuffer = new Array(8);
                this._vertexNormalBuffer = new Array(8);
                this._vertexTangentBuffer = new Array(8);
                // buffer dirty flags, per context:
                this._vertexBufferContext = new Array(8);
                this._uvBufferContext = new Array(8);
                this._secondaryUvBufferContext = new Array(8);
                this._vertexNormalBufferContext = new Array(8);
                this._vertexTangentBufferContext = new Array(8);
            }
            Object.defineProperty(SubGeometry.prototype, "numVertices", {
                get: /**
                * The total amount of vertices in the SubGeometry.
                */
                function () {
                    return this._numVertices;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.activateVertexBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (!this._vertexBuffer[contextIndex] || this._vertexBufferContext[contextIndex] != context) {
                    this._vertexBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                    this._vertexBufferContext[contextIndex] = context;
                    this._verticesInvalid[contextIndex] = true;
                }

                if (this._verticesInvalid[contextIndex]) {
                    this._vertexBuffer[contextIndex].uploadFromArray(this._vertexData, 0, this._numVertices);
                    this._verticesInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._vertexBuffer[contextIndex], 0, away.display3D.Context3DVertexBufferFormat.FLOAT_3);
            };

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.activateUVBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (this._autoGenerateUVs && this._uvsDirty) {
                    this._uvs = this.pUpdateDummyUVs(this._uvs);
                }

                if (!this._uvBuffer[contextIndex] || this._uvBufferContext[contextIndex] != context) {
                    this._uvBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 2);
                    this._uvBufferContext[contextIndex] = context;
                    this._uvsInvalid[contextIndex] = true;
                }

                if (this._uvsInvalid[contextIndex]) {
                    this._uvBuffer[contextIndex].uploadFromArray(this._uvs, 0, this._numVertices);
                    this._uvsInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._uvBuffer[contextIndex], 0, away.display3D.Context3DVertexBufferFormat.FLOAT_2);
            };

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.activateSecondaryUVBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (!this._secondaryUvBuffer[contextIndex] || this._secondaryUvBufferContext[contextIndex] != context) {
                    this._secondaryUvBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 2);
                    this._secondaryUvBufferContext[contextIndex] = context;
                    this._secondaryUvsInvalid[contextIndex] = true;
                }

                if (this._secondaryUvsInvalid[contextIndex]) {
                    this._secondaryUvBuffer[contextIndex].uploadFromArray(this._secondaryUvs, 0, this._numVertices);
                    this._secondaryUvsInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._secondaryUvBuffer[contextIndex], 0, away.display3D.Context3DVertexBufferFormat.FLOAT_2);
            };

            /**
            * Retrieves the VertexBuffer3D object that contains vertex normals.
            * @param context The Context3D for which we request the buffer
            * @return The VertexBuffer3D object that contains vertex normals.
            */
            SubGeometry.prototype.activateVertexNormalBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (this._autoDeriveVertexNormals && this._vertexNormalsDirty) {
                    this._vertexNormals = this.pUpdateVertexNormals(this._vertexNormals);
                }

                if (!this._vertexNormalBuffer[contextIndex] || this._vertexNormalBufferContext[contextIndex] != context) {
                    this._vertexNormalBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                    this._vertexNormalBufferContext[contextIndex] = context;
                    this._normalsInvalid[contextIndex] = true;
                }

                if (this._normalsInvalid[contextIndex]) {
                    this._vertexNormalBuffer[contextIndex].uploadFromArray(this._vertexNormals, 0, this._numVertices);
                    this._normalsInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._vertexNormalBuffer[contextIndex], 0, away.display3D.Context3DVertexBufferFormat.FLOAT_3);
            };

            /**
            * Retrieves the VertexBuffer3D object that contains vertex tangents.
            * @param context The Context3D for which we request the buffer
            * @return The VertexBuffer3D object that contains vertex tangents.
            */
            SubGeometry.prototype.activateVertexTangentBuffer = function (index, stage3DProxy) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                if (this._vertexTangentsDirty) {
                    this._vertexTangents = this.pUpdateVertexTangents(this._vertexTangents);
                }

                if (!this._vertexTangentBuffer[contextIndex] || this._vertexTangentBufferContext[contextIndex] != context) {
                    this._vertexTangentBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                    this._vertexTangentBufferContext[contextIndex] = context;
                    this._tangentsInvalid[contextIndex] = true;
                }

                if (this._tangentsInvalid[contextIndex]) {
                    this._vertexTangentBuffer[contextIndex].uploadFromArray(this._vertexTangents, 0, this._numVertices);
                    this._tangentsInvalid[contextIndex] = false;
                }

                context.setVertexBufferAt(index, this._vertexTangentBuffer[contextIndex], 0, away.display3D.Context3DVertexBufferFormat.FLOAT_3);
            };

            SubGeometry.prototype.applyTransformation = function (transform) {
                _super.prototype.applyTransformation.call(this, transform);
                this.pInvalidateBuffers(this._verticesInvalid);
                this.pInvalidateBuffers(this._normalsInvalid);
                this.pInvalidateBuffers(this._tangentsInvalid);
            };

            /**
            * Clones the current object
            * @return An exact duplicate of the current object.
            */
            SubGeometry.prototype.clone = function () {
                var clone = new away.base.SubGeometry();
                clone.updateVertexData(this._vertexData.concat());
                clone.updateUVData(this._uvs.concat());
                clone.updateIndexData(this._indices.concat());

                if (this._secondaryUvs) {
                    clone.updateSecondaryUVData(this._secondaryUvs.concat());
                }

                if (!this._autoDeriveVertexNormals) {
                    clone.updateVertexNormalData(this._vertexNormals.concat());
                }

                if (!this._autoDeriveVertexTangents) {
                    clone.updateVertexTangentData(this._vertexTangents.concat());
                }

                return clone;
            };

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.scale = function (scale) {
                _super.prototype.scale.call(this, scale);
                this.pInvalidateBuffers(this._verticesInvalid);
            };

            /**
            * @inheritDoc
            */
            SubGeometry.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                _super.prototype.scaleUV.call(this, scaleU, scaleV);
                this.pInvalidateBuffers(this._uvsInvalid);
            };

            /**
            * Clears all resources used by the SubGeometry object.
            */
            SubGeometry.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this.pDisposeAllVertexBuffers();
                this._vertexBuffer = null;
                this._vertexNormalBuffer = null;
                this._uvBuffer = null;
                this._secondaryUvBuffer = null;
                this._vertexTangentBuffer = null;
                this._indexBuffer = null;
                this._uvs = null;
                this._secondaryUvs = null;
                this._vertexNormals = null;
                this._vertexTangents = null;
                this._vertexBufferContext = null;
                this._uvBufferContext = null;
                this._secondaryUvBufferContext = null;
                this._vertexNormalBufferContext = null;
                this._vertexTangentBufferContext = null;
            };

            SubGeometry.prototype.pDisposeAllVertexBuffers = function () {
                this.pDisposeVertexBuffers(this._vertexBuffer);
                this.pDisposeVertexBuffers(this._vertexNormalBuffer);
                this.pDisposeVertexBuffers(this._uvBuffer);
                this.pDisposeVertexBuffers(this._secondaryUvBuffer);
                this.pDisposeVertexBuffers(this._vertexTangentBuffer);
            };

            Object.defineProperty(SubGeometry.prototype, "vertexData", {
                get: /**
                * The raw vertex position data.
                */
                function () {
                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexPositionData", {
                get: function () {
                    return this._vertexData;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex data of the SubGeometry.
            * @param vertices The new vertex data to upload.
            */
            SubGeometry.prototype.updateVertexData = function (vertices) {
                if (this._autoDeriveVertexNormals) {
                    this._vertexNormalsDirty = true;
                }

                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }

                this._faceNormalsDirty = true;
                this._vertexData = vertices;
                var numVertices = vertices.length / 3;

                if (numVertices != this._numVertices) {
                    this.pDisposeAllVertexBuffers();
                }

                this._numVertices = numVertices;
                this.pInvalidateBuffers(this._verticesInvalid);
                this.pInvalidateBounds();
            };

            Object.defineProperty(SubGeometry.prototype, "UVData", {
                get: /**
                * The raw texture coordinate data.
                */
                function () {
                    if (this._uvsDirty && this._autoGenerateUVs) {
                        this._uvs = this.pUpdateDummyUVs(this._uvs);
                    }

                    return this._uvs;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "secondaryUVData", {
                get: function () {
                    return this._secondaryUvs;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the uv coordinates of the SubGeometry.
            * @param uvs The uv coordinates to upload.
            */
            SubGeometry.prototype.updateUVData = function (uvs) {
                if (this._autoDeriveVertexTangents) {
                    this._vertexTangentsDirty = true;
                }

                this._faceTangentsDirty = true;
                this._uvs = uvs;
                this.pInvalidateBuffers(this._uvsInvalid);
            };

            SubGeometry.prototype.updateSecondaryUVData = function (uvs) {
                this._secondaryUvs = uvs;
                this.pInvalidateBuffers(this._secondaryUvsInvalid);
            };

            Object.defineProperty(SubGeometry.prototype, "vertexNormalData", {
                get: /**
                * The raw vertex normal data.
                */
                function () {
                    if (this._autoDeriveVertexNormals && this._vertexNormalsDirty) {
                        this._vertexNormals = this.pUpdateVertexNormals(this._vertexNormals);
                    }

                    return this._vertexNormals;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex normals of the SubGeometry. When updating the vertex normals like this,
            * autoDeriveVertexNormals will be set to false and vertex normals will no longer be calculated automatically.
            * @param vertexNormals The vertex normals to upload.
            */
            SubGeometry.prototype.updateVertexNormalData = function (vertexNormals) {
                this._vertexNormalsDirty = false;
                this._autoDeriveVertexNormals = (vertexNormals == null);
                this._vertexNormals = vertexNormals;
                this.pInvalidateBuffers(this._normalsInvalid);
            };

            Object.defineProperty(SubGeometry.prototype, "vertexTangentData", {
                get: /**
                * The raw vertex tangent data.
                *
                * @private
                */
                function () {
                    if (this._autoDeriveVertexTangents && this._vertexTangentsDirty) {
                        this._vertexTangents = this.pUpdateVertexTangents(this._vertexTangents);
                    }

                    return this._vertexTangents;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the vertex tangents of the SubGeometry. When updating the vertex tangents like this,
            * autoDeriveVertexTangents will be set to false and vertex tangents will no longer be calculated automatically.
            * @param vertexTangents The vertex tangents to upload.
            */
            SubGeometry.prototype.updateVertexTangentData = function (vertexTangents) {
                this._vertexTangentsDirty = false;
                this._autoDeriveVertexTangents = (vertexTangents == null);
                this._vertexTangents = vertexTangents;
                this.pInvalidateBuffers(this._tangentsInvalid);
            };

            SubGeometry.prototype.fromVectors = function (vertices, uvs, normals, tangents) {
                this.updateVertexData(vertices);
                this.updateUVData(uvs);
                this.updateVertexNormalData(normals);
                this.updateVertexTangentData(tangents);
            };

            SubGeometry.prototype.pUpdateVertexNormals = function (target) {
                this.pInvalidateBuffers(this._normalsInvalid);
                return _super.prototype.pUpdateVertexNormals.call(this, target);
            };

            SubGeometry.prototype.pUpdateVertexTangents = function (target) {
                if (this._vertexNormalsDirty) {
                    this._vertexNormals = this.pUpdateVertexNormals(this._vertexNormals);
                }

                this.pInvalidateBuffers(this._tangentsInvalid);
                return _super.prototype.pUpdateVertexTangents.call(this, target);
            };

            SubGeometry.prototype.pUpdateDummyUVs = function (target) {
                this.pInvalidateBuffers(this._uvsInvalid);
                return _super.prototype.pUpdateDummyUVs.call(this, target);
            };

            SubGeometry.prototype.pDisposeForStage3D = function (stage3DProxy) {
                var index = stage3DProxy._iStage3DIndex;
                if (this._vertexBuffer[index]) {
                    this._vertexBuffer[index].dispose();
                    this._vertexBuffer[index] = null;
                }
                if (this._uvBuffer[index]) {
                    this._uvBuffer[index].dispose();
                    this._uvBuffer[index] = null;
                }
                if (this._secondaryUvBuffer[index]) {
                    this._secondaryUvBuffer[index].dispose();
                    this._secondaryUvBuffer[index] = null;
                }
                if (this._vertexNormalBuffer[index]) {
                    this._vertexNormalBuffer[index].dispose();
                    this._vertexNormalBuffer[index] = null;
                }
                if (this._vertexTangentBuffer[index]) {
                    this._vertexTangentBuffer[index].dispose();
                    this._vertexTangentBuffer[index] = null;
                }
                if (this._indexBuffer[index]) {
                    this._indexBuffer[index].dispose();
                    this._indexBuffer[index] = null;
                }
            };

            Object.defineProperty(SubGeometry.prototype, "vertexStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexTangentStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexNormalStride", {
                get: function () {
                    return 3;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "UVStride", {
                get: function () {
                    return 2;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "secondaryUVStride", {
                get: function () {
                    return 2;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexNormalOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "vertexTangentOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "UVOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SubGeometry.prototype, "secondaryUVOffset", {
                get: function () {
                    return 0;
                },
                enumerable: true,
                configurable: true
            });

            SubGeometry.prototype.cloneWithSeperateBuffers = function () {
                var obj = this.clone();
                return obj;
            };
            return SubGeometry;
        })(away.base.SubGeometryBase);
        base.SubGeometry = SubGeometry;
    })(away.base || (away.base = {}));
    var base = away.base;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (controllers) {
        var ControllerBase = (function () {
            function ControllerBase(targetObject) {
                if (typeof targetObject === "undefined") { targetObject = null; }
                this._pAutoUpdate = true;
                this.targetObject = targetObject;
            }
            ControllerBase.prototype.pNotifyUpdate = function () {
                if (this._pTargetObject && this._pTargetObject.iGetImplicitPartition() && this._pAutoUpdate) {
                    this._pTargetObject.iGetImplicitPartition().iMarkForUpdate(this._pTargetObject);
                }
            };

            Object.defineProperty(ControllerBase.prototype, "targetObject", {
                get: function () {
                    return this._pTargetObject;
                },
                set: function (val) {
                    if (this._pTargetObject == val) {
                        return;
                    }

                    if (this._pTargetObject && this._pAutoUpdate) {
                        this._pTargetObject._iController = null;
                    }
                    this._pTargetObject = val;

                    if (this._pTargetObject && this._pAutoUpdate) {
                        this._pTargetObject._iController = this;
                    }
                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ControllerBase.prototype, "autoUpdate", {
                get: function () {
                    return this._pAutoUpdate;
                },
                set: function (val) {
                    if (this._pAutoUpdate == val) {
                        return;
                    }
                    this._pAutoUpdate = val;

                    if (this._pTargetObject) {
                        if (this._pTargetObject) {
                            this._pTargetObject._iController = this;
                        } else {
                            this._pTargetObject._iController = null;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });


            ControllerBase.prototype.update = function (interpolate) {
                if (typeof interpolate === "undefined") { interpolate = true; }
                throw new away.errors.AbstractMethodError();
            };
            return ControllerBase;
        })();
        controllers.ControllerBase = ControllerBase;
    })(away.controllers || (away.controllers = {}));
    var controllers = away.controllers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (controllers) {
        var LookAtController = (function (_super) {
            __extends(LookAtController, _super);
            function LookAtController(targetObject, lookAtObject) {
                if (typeof targetObject === "undefined") { targetObject = null; }
                if (typeof lookAtObject === "undefined") { lookAtObject = null; }
                _super.call(this, targetObject);
                this._pOrigin = new away.geom.Vector3D(0.0, 0.0, 0.0);
                if (lookAtObject) {
                    this.lookAtObject = lookAtObject;
                } else {
                    this.lookAtPosition = new away.geom.Vector3D();
                }
            }
            Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
                get: function () {
                    return this._pLookAtPosition;
                },
                set: function (val) {
                    if (this._pLookAtObject) {
                        this._pLookAtObject.removeEventListener(away.events.Object3DEvent.SCENETRANSFORM_CHANGED, this.onLookAtObjectChanged, this);
                        this._pLookAtObject = null;
                    }

                    this._pLookAtPosition = val;
                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LookAtController.prototype, "lookAtObject", {
                get: function () {
                    return this._pLookAtObject;
                },
                set: function (val) {
                    if (this._pLookAtPosition) {
                        this._pLookAtPosition = null;
                    }

                    if (this._pLookAtObject == val) {
                        return;
                    }

                    if (this._pLookAtObject) {
                        this._pLookAtObject.removeEventListener(away.events.Object3DEvent.SCENETRANSFORM_CHANGED, this.onLookAtObjectChanged, this);
                    }
                    this._pLookAtObject = val;

                    if (this._pLookAtObject) {
                        this._pLookAtObject.addEventListener(away.events.Object3DEvent.SCENETRANSFORM_CHANGED, this.onLookAtObjectChanged, this);
                    }

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            //@override
            LookAtController.prototype.update = function (interpolate) {
                if (typeof interpolate === "undefined") { interpolate = true; }
                interpolate = interpolate;

                if (this._pTargetObject) {
                    if (this._pLookAtPosition) {
                        this._pTargetObject.lookAt(this._pLookAtPosition);
                    } else if (this._pLookAtObject) {
                        this._pTargetObject.lookAt(this._pLookAtObject.scene ? this._pLookAtObject.scenePosition : this._pLookAtObject.position);
                    }
                }
            };

            LookAtController.prototype.onLookAtObjectChanged = function (event) {
                this.pNotifyUpdate();
            };
            return LookAtController;
        })(away.controllers.ControllerBase);
        controllers.LookAtController = LookAtController;
    })(away.controllers || (away.controllers = {}));
    var controllers = away.controllers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (controllers) {
        /**
        * Extended camera used to hover round a specified target object.
        *
        * @see    away3d.containers.View3D
        */
        var HoverController = (function (_super) {
            __extends(HoverController, _super);
            /**
            * Creates a new <code>HoverController</code> object.
            */
            function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, steps, yFactor, wrapPanAngle) {
                if (typeof targetObject === "undefined") { targetObject = null; }
                if (typeof lookAtObject === "undefined") { lookAtObject = null; }
                if (typeof panAngle === "undefined") { panAngle = 0; }
                if (typeof tiltAngle === "undefined") { tiltAngle = 90; }
                if (typeof distance === "undefined") { distance = 1000; }
                if (typeof minTiltAngle === "undefined") { minTiltAngle = -90; }
                if (typeof maxTiltAngle === "undefined") { maxTiltAngle = 90; }
                if (typeof minPanAngle === "undefined") { minPanAngle = null; }
                if (typeof maxPanAngle === "undefined") { maxPanAngle = null; }
                if (typeof steps === "undefined") { steps = 8; }
                if (typeof yFactor === "undefined") { yFactor = 2; }
                if (typeof wrapPanAngle === "undefined") { wrapPanAngle = false; }
                _super.call(this, targetObject, lookAtObject);
                this._iCurrentPanAngle = 0;
                this._iCurrentTiltAngle = 90;
                this._panAngle = 0;
                this._tiltAngle = 90;
                this._distance = 1000;
                this._minPanAngle = -Infinity;
                this._maxPanAngle = Infinity;
                this._minTiltAngle = -90;
                this._maxTiltAngle = 90;
                this._steps = 8;
                this._yFactor = 2;
                this._wrapPanAngle = false;

                this.distance = distance;
                this.panAngle = panAngle;
                this.tiltAngle = tiltAngle;
                this.minPanAngle = (minPanAngle != null) ? minPanAngle : -Infinity;
                this.maxPanAngle = (maxPanAngle != null) ? maxPanAngle : Infinity;
                this.minTiltAngle = minTiltAngle;
                this.maxTiltAngle = maxTiltAngle;
                this.steps = steps;
                this.yFactor = yFactor;
                this.wrapPanAngle = wrapPanAngle;

                //values passed in contrustor are applied immediately
                this._iCurrentPanAngle = this._panAngle;
                this._iCurrentTiltAngle = this._tiltAngle;
            }
            Object.defineProperty(HoverController.prototype, "steps", {
                get: /**
                * Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.
                *
                * Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.
                *
                * @see    #tiltAngle
                * @see    #panAngle
                */
                function () {
                    return this._steps;
                },
                set: function (val) {
                    val = (val < 1) ? 1 : val;

                    if (this._steps == val)
                        return;

                    this._steps = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "panAngle", {
                get: /**
                * Rotation of the camera in degrees around the y axis. Defaults to 0.
                */
                function () {
                    return this._panAngle;
                },
                set: function (val) {
                    val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));

                    if (this._panAngle == val)
                        return;

                    this._panAngle = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "tiltAngle", {
                get: /**
                * Elevation angle of the camera in degrees. Defaults to 90.
                */
                function () {
                    return this._tiltAngle;
                },
                set: function (val) {
                    val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));

                    if (this._tiltAngle == val)
                        return;

                    this._tiltAngle = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "distance", {
                get: /**
                * Distance between the camera and the specified target. Defaults to 1000.
                */
                function () {
                    return this._distance;
                },
                set: function (val) {
                    if (this._distance == val)
                        return;

                    this._distance = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "minPanAngle", {
                get: /**
                * Minimum bounds for the <code>panAngle</code>. Defaults to -Infinity.
                *
                * @see    #panAngle
                */
                function () {
                    return this._minPanAngle;
                },
                set: function (val) {
                    if (this._minPanAngle == val)
                        return;

                    this._minPanAngle = val;

                    this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "maxPanAngle", {
                get: /**
                * Maximum bounds for the <code>panAngle</code>. Defaults to Infinity.
                *
                * @see    #panAngle
                */
                function () {
                    return this._maxPanAngle;
                },
                set: function (val) {
                    if (this._maxPanAngle == val)
                        return;

                    this._maxPanAngle = val;

                    this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "minTiltAngle", {
                get: /**
                * Minimum bounds for the <code>tiltAngle</code>. Defaults to -90.
                *
                * @see    #tiltAngle
                */
                function () {
                    return this._minTiltAngle;
                },
                set: function (val) {
                    if (this._minTiltAngle == val)
                        return;

                    this._minTiltAngle = val;

                    this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
                get: /**
                * Maximum bounds for the <code>tiltAngle</code>. Defaults to 90.
                *
                * @see    #tiltAngle
                */
                function () {
                    return this._maxTiltAngle;
                },
                set: function (val) {
                    if (this._maxTiltAngle == val)
                        return;

                    this._maxTiltAngle = val;

                    this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "yFactor", {
                get: /**
                * Fractional difference in distance between the horizontal camera orientation and vertical camera orientation. Defaults to 2.
                *
                * @see    #distance
                */
                function () {
                    return this._yFactor;
                },
                set: function (val) {
                    if (this._yFactor == val)
                        return;

                    this._yFactor = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
                get: /**
                * Defines whether the value of the pan angle wraps when over 360 degrees or under 0 degrees. Defaults to false.
                */
                function () {
                    return this._wrapPanAngle;
                },
                set: function (val) {
                    if (this._wrapPanAngle == val)
                        return;

                    this._wrapPanAngle = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Updates the current tilt angle and pan angle values.
            *
            * Values are calculated using the defined <code>tiltAngle</code>, <code>panAngle</code> and <code>steps</code> variables.
            *
            * @param interpolate   If the update to a target pan- or tiltAngle is interpolated. Default is true.
            *
            * @see    #tiltAngle
            * @see    #panAngle
            * @see    #steps
            */
            HoverController.prototype.update = function (interpolate) {
                if (typeof interpolate === "undefined") { interpolate = true; }
                if (this._tiltAngle != this._iCurrentTiltAngle || this._panAngle != this._iCurrentPanAngle) {
                    this.pNotifyUpdate();

                    if (this._wrapPanAngle) {
                        if (this._panAngle < 0) {
                            this._iCurrentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
                            this._panAngle = this._panAngle % 360 + 360;
                        } else {
                            this._iCurrentPanAngle += this._panAngle % 360 - this._panAngle;
                            this._panAngle = this._panAngle % 360;
                        }

                        while (this._panAngle - this._iCurrentPanAngle < -180)
                            this._iCurrentPanAngle -= 360;

                        while (this._panAngle - this._iCurrentPanAngle > 180)
                            this._iCurrentPanAngle += 360;
                    }

                    if (interpolate) {
                        this._iCurrentTiltAngle += (this._tiltAngle - this._iCurrentTiltAngle) / (this.steps + 1);
                        this._iCurrentPanAngle += (this._panAngle - this._iCurrentPanAngle) / (this.steps + 1);
                    } else {
                        this._iCurrentPanAngle = this._panAngle;
                        this._iCurrentTiltAngle = this._tiltAngle;
                    }

                    if ((Math.abs(this.tiltAngle - this._iCurrentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._iCurrentPanAngle) < 0.01)) {
                        this._iCurrentTiltAngle = this._tiltAngle;
                        this._iCurrentPanAngle = this._panAngle;
                    }
                }

                var pos = (this.lookAtObject) ? this.lookAtObject.position : (this.lookAtPosition) ? this.lookAtPosition : this._pOrigin;
                this.targetObject.x = pos.x + this.distance * Math.sin(this._iCurrentPanAngle * away.math.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._iCurrentTiltAngle * away.math.MathConsts.DEGREES_TO_RADIANS);
                this.targetObject.z = pos.z + this.distance * Math.cos(this._iCurrentPanAngle * away.math.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._iCurrentTiltAngle * away.math.MathConsts.DEGREES_TO_RADIANS);
                this.targetObject.y = pos.y + this.distance * Math.sin(this._iCurrentTiltAngle * away.math.MathConsts.DEGREES_TO_RADIANS) * this.yFactor;

                _super.prototype.update.call(this);
            };
            return HoverController;
        })(away.controllers.LookAtController);
        controllers.HoverController = HoverController;
    })(away.controllers || (away.controllers = {}));
    var controllers = away.controllers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (controllers) {
        /**
        * Extended camera used to hover round a specified target object.
        *
        * @see    away3d.containers.View3D
        */
        var FirstPersonController = (function (_super) {
            __extends(FirstPersonController, _super);
            /**
            * Creates a new <code>HoverController</code> object.
            */
            function FirstPersonController(targetObject, panAngle, tiltAngle, minTiltAngle, maxTiltAngle, steps, wrapPanAngle) {
                if (typeof targetObject === "undefined") { targetObject = null; }
                if (typeof panAngle === "undefined") { panAngle = 0; }
                if (typeof tiltAngle === "undefined") { tiltAngle = 90; }
                if (typeof minTiltAngle === "undefined") { minTiltAngle = -90; }
                if (typeof maxTiltAngle === "undefined") { maxTiltAngle = 90; }
                if (typeof steps === "undefined") { steps = 8; }
                if (typeof wrapPanAngle === "undefined") { wrapPanAngle = false; }
                _super.call(this, targetObject);
                this._iCurrentPanAngle = 0;
                this._iCurrentTiltAngle = 90;
                this._panAngle = 0;
                this._tiltAngle = 90;
                this._minTiltAngle = -90;
                this._maxTiltAngle = 90;
                this._steps = 8;
                this._walkIncrement = 0;
                this._strafeIncrement = 0;
                this._wrapPanAngle = false;
                this.fly = false;

                this.panAngle = panAngle;
                this.tiltAngle = tiltAngle;
                this.minTiltAngle = minTiltAngle;
                this.maxTiltAngle = maxTiltAngle;
                this.steps = steps;
                this.wrapPanAngle = wrapPanAngle;

                //values passed in contrustor are applied immediately
                this._iCurrentPanAngle = this._panAngle;
                this._iCurrentTiltAngle = this._tiltAngle;
            }
            Object.defineProperty(FirstPersonController.prototype, "steps", {
                get: /**
                * Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.
                *
                * Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.
                *
                * @see    #tiltAngle
                * @see    #panAngle
                */
                function () {
                    return this._steps;
                },
                set: function (val) {
                    val = (val < 1) ? 1 : val;

                    if (this._steps == val)
                        return;

                    this._steps = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FirstPersonController.prototype, "panAngle", {
                get: /**
                * Rotation of the camera in degrees around the y axis. Defaults to 0.
                */
                function () {
                    return this._panAngle;
                },
                set: function (val) {
                    if (this._panAngle == val)
                        return;

                    this._panAngle = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FirstPersonController.prototype, "tiltAngle", {
                get: /**
                * Elevation angle of the camera in degrees. Defaults to 90.
                */
                function () {
                    return this._tiltAngle;
                },
                set: function (val) {
                    val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));

                    if (this._tiltAngle == val)
                        return;

                    this._tiltAngle = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FirstPersonController.prototype, "minTiltAngle", {
                get: /**
                * Minimum bounds for the <code>tiltAngle</code>. Defaults to -90.
                *
                * @see    #tiltAngle
                */
                function () {
                    return this._minTiltAngle;
                },
                set: function (val) {
                    if (this._minTiltAngle == val)
                        return;

                    this._minTiltAngle = val;

                    this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FirstPersonController.prototype, "maxTiltAngle", {
                get: /**
                * Maximum bounds for the <code>tiltAngle</code>. Defaults to 90.
                *
                * @see    #tiltAngle
                */
                function () {
                    return this._maxTiltAngle;
                },
                set: function (val) {
                    if (this._maxTiltAngle == val)
                        return;

                    this._maxTiltAngle = val;

                    this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FirstPersonController.prototype, "wrapPanAngle", {
                get: /**
                * Defines whether the value of the pan angle wraps when over 360 degrees or under 0 degrees. Defaults to false.
                */
                function () {
                    return this._wrapPanAngle;
                },
                set: function (val) {
                    if (this._wrapPanAngle == val)
                        return;

                    this._wrapPanAngle = val;

                    this.pNotifyUpdate();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Updates the current tilt angle and pan angle values.
            *
            * Values are calculated using the defined <code>tiltAngle</code>, <code>panAngle</code> and <code>steps</code> variables.
            *
            * @param interpolate   If the update to a target pan- or tiltAngle is interpolated. Default is true.
            *
            * @see    #tiltAngle
            * @see    #panAngle
            * @see    #steps
            */
            FirstPersonController.prototype.update = function (interpolate) {
                if (typeof interpolate === "undefined") { interpolate = true; }
                if (this._tiltAngle != this._iCurrentTiltAngle || this._panAngle != this._iCurrentPanAngle) {
                    this.pNotifyUpdate();

                    if (this._wrapPanAngle) {
                        if (this._panAngle < 0) {
                            this._iCurrentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
                            this._panAngle = this._panAngle % 360 + 360;
                        } else {
                            this._iCurrentPanAngle += this._panAngle % 360 - this._panAngle;
                            this._panAngle = this._panAngle % 360;
                        }

                        while (this._panAngle - this._iCurrentPanAngle < -180)
                            this._iCurrentPanAngle -= 360;

                        while (this._panAngle - this._iCurrentPanAngle > 180)
                            this._iCurrentPanAngle += 360;
                    }

                    if (interpolate) {
                        this._iCurrentTiltAngle += (this._tiltAngle - this._iCurrentTiltAngle) / (this.steps + 1);
                        this._iCurrentPanAngle += (this._panAngle - this._iCurrentPanAngle) / (this.steps + 1);
                    } else {
                        this._iCurrentTiltAngle = this._tiltAngle;
                        this._iCurrentPanAngle = this._panAngle;
                    }

                    if ((Math.abs(this.tiltAngle - this._iCurrentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._iCurrentPanAngle) < 0.01)) {
                        this._iCurrentTiltAngle = this._tiltAngle;
                        this._iCurrentPanAngle = this._panAngle;
                    }
                }

                this.targetObject.rotationX = this._iCurrentTiltAngle;
                this.targetObject.rotationY = this._iCurrentPanAngle;

                if (this._walkIncrement) {
                    if (this.fly)
                        this.targetObject.moveForward(this._walkIncrement);
else {
                        this.targetObject.x += this._walkIncrement * Math.sin(this._panAngle * away.math.MathConsts.DEGREES_TO_RADIANS);
                        this.targetObject.z += this._walkIncrement * Math.cos(this._panAngle * away.math.MathConsts.DEGREES_TO_RADIANS);
                    }
                    this._walkIncrement = 0;
                }

                if (this._strafeIncrement) {
                    this.targetObject.moveRight(this._strafeIncrement);
                    this._strafeIncrement = 0;
                }
            };

            FirstPersonController.prototype.incrementWalk = function (val) {
                if (val == 0)
                    return;

                this._walkIncrement += val;

                this.pNotifyUpdate();
            };

            FirstPersonController.prototype.incrementStrafe = function (val) {
                if (val == 0)
                    return;

                this._strafeIncrement += val;

                this.pNotifyUpdate();
            };
            return FirstPersonController;
        })(away.controllers.ControllerBase);
        controllers.FirstPersonController = FirstPersonController;
    })(away.controllers || (away.controllers = {}));
    var controllers = away.controllers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (controllers) {
        /**
        * Controller used to follow behind an object on the XZ plane, with an optional
        * elevation (tiltAngle).
        *
        * @see    away3d.containers.View3D
        */
        var FollowController = (function (_super) {
            __extends(FollowController, _super);
            function FollowController(targetObject, lookAtObject, tiltAngle, distance) {
                if (typeof targetObject === "undefined") { targetObject = null; }
                if (typeof lookAtObject === "undefined") { lookAtObject = null; }
                if (typeof tiltAngle === "undefined") { tiltAngle = 45; }
                if (typeof distance === "undefined") { distance = 700; }
                _super.call(this, targetObject, lookAtObject, 0, tiltAngle, distance);
            }
            FollowController.prototype.update = function (interpolate) {
                if (typeof interpolate === "undefined") { interpolate = true; }
                interpolate = interpolate;

                if (!this.lookAtObject)
                    return;

                this.panAngle = this._pLookAtObject.rotationY - 180;
                _super.prototype.update.call(this);
            };
            return FollowController;
        })(away.controllers.HoverController);
        controllers.FollowController = FollowController;
    })(away.controllers || (away.controllers = {}));
    var controllers = away.controllers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (controllers) {
        /**
        * Uses spring physics to animate the target object towards a position that is
        * defined as the lookAtTarget object's position plus the vector defined by the
        * positionOffset property.
        */
        var SpringController = (function (_super) {
            __extends(SpringController, _super);
            function SpringController(targetObject, lookAtObject, stiffness, mass, damping) {
                if (typeof targetObject === "undefined") { targetObject = null; }
                if (typeof lookAtObject === "undefined") { lookAtObject = null; }
                if (typeof stiffness === "undefined") { stiffness = 1; }
                if (typeof mass === "undefined") { mass = 40; }
                if (typeof damping === "undefined") { damping = 4; }
                _super.call(this, targetObject, lookAtObject);
                /**
                * Offset of spring center from target in target object space, ie: Where the camera should ideally be in the target object space.
                */
                this.positionOffset = new away.geom.Vector3D(0, 500, -1000);

                this.stiffness = stiffness;
                this.damping = damping;
                this.mass = mass;

                this._velocity = new away.geom.Vector3D();
                this._dv = new away.geom.Vector3D();
                this._stretch = new away.geom.Vector3D();
                this._force = new away.geom.Vector3D();
                this._acceleration = new away.geom.Vector3D();
                this._desiredPosition = new away.geom.Vector3D();
            }
            SpringController.prototype.update = function (interpolate) {
                if (typeof interpolate === "undefined") { interpolate = true; }
                interpolate = interpolate;

                var offs;

                if (!this._pLookAtObject || !this._pTargetObject)
                    return;

                offs = this._pLookAtObject.transform.deltaTransformVector(this.positionOffset);
                this._desiredPosition.x = this._pLookAtObject.x + offs.x;
                this._desiredPosition.y = this._pLookAtObject.y + offs.y;
                this._desiredPosition.z = this._pLookAtObject.z + offs.z;

                this._stretch.x = this._pTargetObject.x - this._desiredPosition.x;
                this._stretch.y = this._pTargetObject.y - this._desiredPosition.y;
                this._stretch.z = this._pTargetObject.z - this._desiredPosition.z;
                this._stretch.scaleBy(-this.stiffness);

                this._dv.copyFrom(this._velocity);
                this._dv.scaleBy(this.damping);

                this._force.x = this._stretch.x - this._dv.x;
                this._force.y = this._stretch.y - this._dv.y;
                this._force.z = this._stretch.z - this._dv.z;

                this._acceleration.copyFrom(this._force);
                this._acceleration.scaleBy(1 / this.mass);

                this._velocity.x += this._acceleration.x;
                this._velocity.y += this._acceleration.y;
                this._velocity.z += this._acceleration.z;

                this._pTargetObject.x += this._velocity.x;
                this._pTargetObject.y += this._velocity.y;
                this._pTargetObject.z += this._velocity.z;

                _super.prototype.update.call(this);
            };
            return SpringController;
        })(controllers.LookAtController);
        controllers.SpringController = SpringController;
    })(away.controllers || (away.controllers = {}));
    var controllers = away.controllers;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (lights) {
        var LightBase = (function (_super) {
            __extends(LightBase, _super);
            function LightBase() {
                _super.call(this);
                this._color = 0xffffff;
                this._colorR = 1;
                this._colorG = 1;
                this._colorB = 1;
                this._ambientColor = 0xffffff;
                this._ambient = 0;
                this._iAmbientR = 0;
                this._iAmbientG = 0;
                this._iAmbientB = 0;
                this._specular = 1;
                this._iSpecularR = 1;
                this._iSpecularG = 1;
                this._iSpecularB = 1;
                this._diffuse = 1;
                this._iDiffuseR = 1;
                this._iDiffuseG = 1;
                this._iDiffuseB = 1;
                this._castsShadows = false;
            }
            Object.defineProperty(LightBase.prototype, "castsShadows", {
                get: function () {
                    return this._castsShadows;
                },
                set: function (value) {
                    if (this._castsShadows == value) {
                        return;
                    }

                    this._castsShadows = value;

                    if (value) {
                        if (this._shadowMapper == null) {
                            this._shadowMapper = this.pCreateShadowMapper();
                        }

                        this._shadowMapper.light = this;
                    } else {
                        this._shadowMapper.dispose();
                        this._shadowMapper = null;
                    }

                    //*/
                    this.dispatchEvent(new away.events.LightEvent(away.events.LightEvent.CASTS_SHADOW_CHANGE));
                },
                enumerable: true,
                configurable: true
            });


            LightBase.prototype.pCreateShadowMapper = function () {
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(LightBase.prototype, "specular", {
                get: function () {
                    return this._specular;
                },
                set: function (value) {
                    if (value < 0) {
                        value = 0;
                    }
                    this._specular = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "diffuse", {
                get: function () {
                    return this._diffuse;
                },
                set: function (value) {
                    if (value < 0) {
                        value = 0;
                    }
                    this._diffuse = value;
                    this.updateDiffuse();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value;
                    this._colorR = ((this._color >> 16) & 0xff) / 0xff;
                    this._colorG = ((this._color >> 8) & 0xff) / 0xff;
                    this._colorB = (this._color & 0xff) / 0xff;
                    this.updateDiffuse();
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "ambient", {
                get: function () {
                    return this._ambient;
                },
                set: function (value) {
                    if (value < 0) {
                        value = 0;
                    } else if (value > 1) {
                        value = 1;
                    }
                    this._ambient = value;
                    this.updateAmbient();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightBase.prototype, "ambientColor", {
                get: function () {
                    return this._ambientColor;
                },
                set: function (value) {
                    this._ambientColor = value;
                    this.updateAmbient();
                },
                enumerable: true,
                configurable: true
            });


            LightBase.prototype.updateAmbient = function () {
                this._iAmbientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
                this._iAmbientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
                this._iAmbientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
            };

            LightBase.prototype.iGetObjectProjectionMatrix = function (renderable, target) {
                if (typeof target === "undefined") { target = null; }
                throw new away.errors.AbstractMethodError();
            };

            //@override
            LightBase.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.LightNode(this);
            };

            Object.defineProperty(LightBase.prototype, "assetType", {
                get: //@override
                function () {
                    return away.library.AssetType.LIGHT;
                },
                enumerable: true,
                configurable: true
            });

            LightBase.prototype.updateSpecular = function () {
                this._iSpecularR = this._colorR * this._specular;
                this._iSpecularG = this._colorG * this._specular;
                this._iSpecularB = this._colorB * this._specular;
            };

            LightBase.prototype.updateDiffuse = function () {
                this._iDiffuseR = this._colorR * this._diffuse;
                this._iDiffuseG = this._colorG * this._diffuse;
                this._iDiffuseB = this._colorB * this._diffuse;
            };

            Object.defineProperty(LightBase.prototype, "shadowMapper", {
                get: function () {
                    return this._shadowMapper;
                },
                set: function (value) {
                    this._shadowMapper = value;
                    this._shadowMapper.light = this;
                },
                enumerable: true,
                configurable: true
            });

            return LightBase;
        })(away.entities.Entity);
        lights.LightBase = LightBase;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (lights) {
        var PointLight = (function (_super) {
            __extends(PointLight, _super);
            function PointLight() {
                _super.call(this);
                this._pRadius = 90000;
                this._pFallOff = 100000;
                this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
            }
            PointLight.prototype.pCreateShadowMapper = function () {
                return new away.lights.CubeMapShadowMapper();
            };

            PointLight.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.PointLightNode(this);
            };

            Object.defineProperty(PointLight.prototype, "radius", {
                get: function () {
                    return this._pRadius;
                },
                set: function (value) {
                    this._pRadius = value;
                    if (this._pRadius < 0) {
                        this._pRadius = 0;
                    } else if (this._pRadius > this._pFallOff) {
                        this._pFallOff = this._pRadius;
                        this.pInvalidateBounds();
                    }
                    this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
                },
                enumerable: true,
                configurable: true
            });


            PointLight.prototype.iFallOffFactor = function () {
                return this._pFallOffFactor;
            };

            Object.defineProperty(PointLight.prototype, "fallOff", {
                get: function () {
                    return this._pFallOff;
                },
                set: function (value) {
                    this._pFallOff = value;
                    if (this._pFallOff < 0) {
                        this._pFallOff = 0;
                    }
                    if (this._pFallOff < this._pRadius) {
                        this._pRadius = this._pFallOff;
                    }
                    this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
                    this.pInvalidateBounds();
                },
                enumerable: true,
                configurable: true
            });


            PointLight.prototype.pUpdateBounds = function () {
                this._pBounds.fromSphere(new away.geom.Vector3D(), this._pFallOff);
                this._pBoundsInvalid = false;
            };

            PointLight.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.BoundingSphere();
            };

            PointLight.prototype.iGetObjectProjectionMatrix = function (renderable, target) {
                if (typeof target === "undefined") { target = null; }
                var raw = [];
                var bounds = renderable.sourceEntity.bounds;
                var m = new away.geom.Matrix3D();

                // todo: do not use lookAt on Light
                m.copyFrom(renderable.sceneTransform);
                m.append(this._pParent.inverseSceneTransform);
                this.lookAt(m.position);

                m.copyFrom(renderable.sceneTransform);
                m.append(this.inverseSceneTransform);
                m.copyColumnTo(3, this._pPos);

                var v1 = m.deltaTransformVector(bounds.min);
                var v2 = m.deltaTransformVector(bounds.max);
                var z = this._pPos.z;
                var d1 = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
                var d2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
                var d = Math.sqrt(d1 > d2 ? d1 : d2);
                var zMin;
                var zMax;

                zMin = z - d;
                zMax = z + d;

                raw[5] = raw[0] = zMin / d;
                raw[10] = zMax / (zMax - zMin);
                raw[11] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[12] = raw[13] = raw[15] = 0;
                raw[14] = -zMin * raw[10];

                if (!target) {
                    target = new away.geom.Matrix3D();
                }
                target.copyRawDataFrom(raw);
                target.prepend(m);

                return target;
            };
            return PointLight;
        })(away.lights.LightBase);
        lights.PointLight = PointLight;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (lights) {
        var DirectionalLight = (function (_super) {
            __extends(DirectionalLight, _super);
            function DirectionalLight(xDir, yDir, zDir) {
                if (typeof xDir === "undefined") { xDir = 0; }
                if (typeof yDir === "undefined") { yDir = -1; }
                if (typeof zDir === "undefined") { zDir = 1; }
                _super.call(this);
                this.direction = new away.geom.Vector3D(xDir, yDir, zDir);
                this._sceneDirection = new away.geom.Vector3D();
            }
            //@override
            DirectionalLight.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.DirectionalLightNode(this);
            };

            Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
                get: function () {
                    if (this._pSceneTransformDirty) {
                        this.pUpdateSceneTransform();
                    }
                    return this._sceneDirection;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DirectionalLight.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (value) {
                    this._direction = value;

                    if (!this._tmpLookAt) {
                        this._tmpLookAt = new away.geom.Vector3D();
                    }
                    this._tmpLookAt.x = this.x + this._direction.x;
                    this._tmpLookAt.y = this.y + this._direction.y;
                    this._tmpLookAt.z = this.z + this._direction.z;

                    this.lookAt(this._tmpLookAt);
                },
                enumerable: true,
                configurable: true
            });


            //@override
            DirectionalLight.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            //@override
            DirectionalLight.prototype.pUpdateBounds = function () {
            };

            //@override
            DirectionalLight.prototype.pUpdateSceneTransform = function () {
                _super.prototype.pUpdateSceneTransform.call(this);
                this.sceneTransform.copyColumnTo(2, this._sceneDirection);
                this._sceneDirection.normalize();
            };

            //@override
            DirectionalLight.prototype.pCreateShadowMapper = function () {
                return new away.lights.DirectionalShadowMapper();
            };

            //override
            DirectionalLight.prototype.iGetObjectProjectionMatrix = function (renderable, target) {
                if (typeof target === "undefined") { target = null; }
                var raw = [];
                var bounds = renderable.sourceEntity.bounds;
                var m = new away.geom.Matrix3D();

                m.copyFrom(renderable.sceneTransform);
                m.append(this.inverseSceneTransform);

                if (!this._projAABBPoints) {
                    this._projAABBPoints = [];
                }
                m.transformVectors(bounds.aabbPoints, this._projAABBPoints);

                var xMin = Infinity, xMax = -Infinity;
                var yMin = Infinity, yMax = -Infinity;
                var zMin = Infinity, zMax = -Infinity;
                var d;
                for (var i = 0; i < 24;) {
                    d = this._projAABBPoints[i++];
                    if (d < xMin)
                        xMin = d;
                    if (d > xMax)
                        xMax = d;
                    d = this._projAABBPoints[i++];
                    if (d < yMin)
                        yMin = d;
                    if (d > yMax)
                        yMax = d;
                    d = this._projAABBPoints[i++];
                    if (d < zMin)
                        zMin = d;
                    if (d > zMax)
                        zMax = d;
                }

                var invXRange = 1 / (xMax - xMin);
                var invYRange = 1 / (yMax - yMin);
                var invZRange = 1 / (zMax - zMin);
                raw[0] = 2 * invXRange;
                raw[5] = 2 * invYRange;
                raw[10] = invZRange;
                raw[12] = -(xMax + xMin) * invXRange;
                raw[13] = -(yMax + yMin) * invYRange;
                raw[14] = -zMin * invZRange;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
                raw[15] = 1;

                if (!target) {
                    target = new away.geom.Matrix3D();
                }
                target.copyRawDataFrom(raw);
                target.prepend(m);

                return target;
            };
            return DirectionalLight;
        })(away.lights.LightBase);
        lights.DirectionalLight = DirectionalLight;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts" />
    (function (lights) {
        var LightProbe = (function (_super) {
            __extends(LightProbe, _super);
            function LightProbe(diffuseMap, specularMap) {
                if (typeof specularMap === "undefined") { specularMap = null; }
                _super.call(this);
                this._diffuseMap = diffuseMap;
                this._specularMap = specularMap;
            }
            //@override
            LightProbe.prototype.pCreateEntityPartitionNode = function () {
                return new away.partition.LightProbeNode(this);
            };

            Object.defineProperty(LightProbe.prototype, "diffuseMap", {
                get: function () {
                    return this._diffuseMap;
                },
                set: function (value) {
                    this._diffuseMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightProbe.prototype, "specularMap", {
                get: function () {
                    return this._specularMap;
                },
                set: function (value) {
                    this._specularMap = value;
                },
                enumerable: true,
                configurable: true
            });


            //@override
            LightProbe.prototype.pUpdateBounds = function () {
                this._pBoundsInvalid = false;
            };

            //@override
            LightProbe.prototype.pGetDefaultBoundingVolume = function () {
                return new away.bounds.NullBounds();
            };

            //@override
            LightProbe.prototype.iGetObjectProjectionMatrix = function (renderable, target) {
                if (typeof target === "undefined") { target = null; }
                // TODO: not used
                renderable = renderable;
                target = target;

                throw new away.errors.Error("Object projection matrices are not supported for LightProbe objects!");
                return null;
            };
            return LightProbe;
        })(away.lights.LightBase);
        lights.LightProbe = LightProbe;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (lights) {
        var ShadowMapperBase = (function () {
            function ShadowMapperBase() {
                this._pDepthMapSize = 2048;
                this._autoUpdateShadows = true;
                this._pCasterCollector = this.pCreateCasterCollector();
            }
            ShadowMapperBase.prototype.pCreateCasterCollector = function () {
                return new away.traverse.ShadowCasterCollector();
            };

            Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
                get: function () {
                    return this._autoUpdateShadows;
                },
                set: function (value) {
                    this._autoUpdateShadows = value;
                },
                enumerable: true,
                configurable: true
            });


            ShadowMapperBase.prototype.updateShadows = function () {
                this._iShadowsInvalid = true;
            };

            ShadowMapperBase.prototype.iSetDepthMap = function (depthMap) {
                if (this._depthMap == depthMap) {
                    return;
                }
                if (this._depthMap && !this._explicitDepthMap) {
                    this._depthMap.dispose();
                }
                this._depthMap = depthMap;
                if (this._depthMap) {
                    this._explicitDepthMap = true;
                    this._pDepthMapSize = this._depthMap.width;
                } else {
                    this._explicitDepthMap = false;
                }
            };

            Object.defineProperty(ShadowMapperBase.prototype, "light", {
                get: function () {
                    return this._pLight;
                },
                set: function (value) {
                    this._pLight = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
                get: function () {
                    if (!this._depthMap) {
                        this._depthMap = this.pCreateDepthTexture();
                    }
                    return this._depthMap;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
                get: function () {
                    return this._pDepthMapSize;
                },
                set: function (value) {
                    if (value == this._pDepthMapSize) {
                        return;
                    }
                    this._pDepthMapSize = value;

                    if (this._explicitDepthMap) {
                        throw Error("Cannot set depth map size for the current renderer.");
                    } else if (this._depthMap) {
                        this._depthMap.dispose();
                        this._depthMap = null;
                    }
                },
                enumerable: true,
                configurable: true
            });


            ShadowMapperBase.prototype.dispose = function () {
                this._pCasterCollector = null;
                if (this._depthMap && !this._explicitDepthMap) {
                    this._depthMap.dispose();
                }
                this._depthMap = null;
            };

            ShadowMapperBase.prototype.pCreateDepthTexture = function () {
                return new away.textures.RenderTexture(this._pDepthMapSize, this._pDepthMapSize);
            };

            ShadowMapperBase.prototype.iRenderDepthMap = function (stage3DProxy, entityCollector, renderer) {
                this._iShadowsInvalid = false;

                this.pUpdateDepthProjection(entityCollector.camera);

                if (!this._depthMap) {
                    this._depthMap = this.pCreateDepthTexture();
                }
                this.pDrawDepthMap(this._depthMap.getTextureForStage3D(stage3DProxy), entityCollector.scene, renderer);
            };

            ShadowMapperBase.prototype.pUpdateDepthProjection = function (viewCamera) {
                throw new away.errors.AbstractMethodError();
            };

            ShadowMapperBase.prototype.pDrawDepthMap = function (target, scene, renderer) {
                throw new away.errors.AbstractMethodError();
            };
            return ShadowMapperBase;
        })();
        lights.ShadowMapperBase = ShadowMapperBase;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (lights) {
        var CubeMapShadowMapper = (function (_super) {
            __extends(CubeMapShadowMapper, _super);
            function CubeMapShadowMapper() {
                _super.call(this);

                this._pDepthMapSize = 512;
                this._needsRender = [];
                this.initCameras();
            }
            CubeMapShadowMapper.prototype.initCameras = function () {
                this._depthCameras = [];
                this._lenses = [];

                // posX, negX, posY, negY, posZ, negZ
                this.addCamera(0, 90, 0);
                this.addCamera(0, -90, 0);
                this.addCamera(-90, 0, 0);
                this.addCamera(90, 0, 0);
                this.addCamera(0, 0, 0);
                this.addCamera(0, 180, 0);
            };

            CubeMapShadowMapper.prototype.addCamera = function (rotationX, rotationY, rotationZ) {
                var cam = new away.cameras.Camera3D();
                cam.rotationX = rotationX;
                cam.rotationY = rotationY;
                cam.rotationZ = rotationZ;
                cam.lens.near = .01;

                var lens = cam.lens;
                lens.fieldOfView = 90;
                this._lenses.push(lens);
                cam.lens.iAspectRatio = 1;
                this._depthCameras.push(cam);
            };

            //@override
            CubeMapShadowMapper.prototype.pCreateDepthTexture = function () {
                throw new away.errors.PartialImplementationError();
                /*
                return new away.textures.RenderCubeTexture( this._depthMapSize );
                */
            };

            //@override
            CubeMapShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                var light = (this._pLight);
                var maxDistance = light._pFallOff;
                var pos = this._pLight.scenePosition;

                for (var i = 0; i < 6; ++i) {
                    this._lenses[i].far = maxDistance;
                    this._depthCameras[i].position = pos;
                    this._needsRender[i] = true;
                }
            };

            //@override
            CubeMapShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
                for (var i = 0; i < 6; ++i) {
                    if (this._needsRender[i]) {
                        this._pCasterCollector.camera = this._depthCameras[i];
                        this._pCasterCollector.clear();
                        scene.traversePartitions(this._pCasterCollector);
                        renderer.iRender(this._pCasterCollector, target, null, i);
                        this._pCasterCollector.cleanUp();
                    }
                }
            };
            return CubeMapShadowMapper;
        })(away.lights.ShadowMapperBase);
        lights.CubeMapShadowMapper = CubeMapShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts" />
    (function (lights) {
        var DirectionalShadowMapper = (function (_super) {
            __extends(DirectionalShadowMapper, _super);
            function DirectionalShadowMapper() {
                _super.call(this);
                this._pLightOffset = 10000;
                this._pSnap = 64;
                this._pCullPlanes = [];
                this._pOverallDepthLens = new away.cameras.FreeMatrixLens();
                this._pOverallDepthCamera = new away.cameras.Camera3D(this._pOverallDepthLens);
                this._pLocalFrustum = [];
                this._pMatrix = new away.geom.Matrix3D();
            }
            Object.defineProperty(DirectionalShadowMapper.prototype, "snap", {
                get: function () {
                    return this._pSnap;
                },
                set: function (value) {
                    this._pSnap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DirectionalShadowMapper.prototype, "lightOffset", {
                get: function () {
                    return this._pLightOffset;
                },
                set: function (value) {
                    this._pLightOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DirectionalShadowMapper.prototype, "iDepthProjection", {
                get: //@arcane
                function () {
                    return this._pOverallDepthCamera.viewProjection;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
                get: //@arcane
                function () {
                    return this._pMaxZ - this._pMinZ;
                },
                enumerable: true,
                configurable: true
            });

            //@override
            DirectionalShadowMapper.prototype.pDrawDepthMap = function (target, scene, renderer) {
                this._pCasterCollector.camera = this._pOverallDepthCamera;
                this._pCasterCollector.cullPlanes = this._pCullPlanes;
                this._pCasterCollector.clear();
                scene.traversePartitions(this._pCasterCollector);
                renderer.iRender(this._pCasterCollector, target);
                this._pCasterCollector.cleanUp();
            };

            //@protected
            DirectionalShadowMapper.prototype.pUpdateCullPlanes = function (viewCamera) {
                var lightFrustumPlanes = this._pOverallDepthCamera.frustumPlanes;
                var viewFrustumPlanes = viewCamera.frustumPlanes;
                this._pCullPlanes.length = 4;

                this._pCullPlanes[0] = lightFrustumPlanes[0];
                this._pCullPlanes[1] = lightFrustumPlanes[1];
                this._pCullPlanes[2] = lightFrustumPlanes[2];
                this._pCullPlanes[3] = lightFrustumPlanes[3];

                var light = this._pLight;
                var dir = light.sceneDirection;
                var dirX = dir.x;
                var dirY = dir.y;
                var dirZ = dir.z;
                var j = 4;
                for (var i = 0; i < 6; ++i) {
                    var plane = viewFrustumPlanes[i];
                    if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0) {
                        this._pCullPlanes[j++] = plane;
                    }
                }
            };

            //@override
            DirectionalShadowMapper.prototype.pUpdateDepthProjection = function (viewCamera) {
                this.pUpdateProjectionFromFrustumCorners(viewCamera, viewCamera.lens.frustumCorners, this._pMatrix);
                this._pOverallDepthLens.matrix = this._pMatrix;
                this.pUpdateCullPlanes(viewCamera);
            };

            DirectionalShadowMapper.prototype.pUpdateProjectionFromFrustumCorners = function (viewCamera, corners, matrix) {
                var raw = [];
                var dir;
                var x, y, z;
                var minX, minY;
                var maxX, maxY;
                var i;

                var light = this._pLight;
                dir = light.sceneDirection;
                this._pOverallDepthCamera.transform = this._pLight.sceneTransform;
                x = Math.floor((viewCamera.x - dir.x * this._pLightOffset) / this._pSnap) * this._pSnap;
                y = Math.floor((viewCamera.y - dir.y * this._pLightOffset) / this._pSnap) * this._pSnap;
                z = Math.floor((viewCamera.z - dir.z * this._pLightOffset) / this._pSnap) * this._pSnap;
                this._pOverallDepthCamera.x = x;
                this._pOverallDepthCamera.y = y;
                this._pOverallDepthCamera.z = z;

                this._pMatrix.copyFrom(this._pOverallDepthCamera.inverseSceneTransform);
                this._pMatrix.prepend(viewCamera.sceneTransform);
                this._pMatrix.transformVectors(corners, this._pLocalFrustum);

                minX = maxX = this._pLocalFrustum[0];
                minY = maxY = this._pLocalFrustum[1];
                this._pMaxZ = this._pLocalFrustum[2];

                i = 3;
                while (i < 24) {
                    x = this._pLocalFrustum[i];
                    y = this._pLocalFrustum[i + 1];
                    z = this._pLocalFrustum[i + 2];
                    if (x < minX)
                        minX = x;
                    if (x > maxX)
                        maxX = x;
                    if (y < minY)
                        minY = y;
                    if (y > maxY)
                        maxY = y;
                    if (z > this._pMaxZ)
                        this._pMaxZ = z;
                    i += 3;
                }
                this._pMinZ = 1;

                var w = maxX - minX;
                var h = maxY - minY;
                var d = 1 / (this._pMaxZ - this._pMinZ);

                if (minX < 0) {
                    minX -= this._pSnap;
                }
                if (minY < 0) {
                    minY -= this._pSnap;
                }
                minX = Math.floor(minX / this._pSnap) * this._pSnap;
                minY = Math.floor(minY / this._pSnap) * this._pSnap;

                var snap2 = 2 * this._pSnap;
                w = Math.floor(w / snap2 + 2) * snap2;
                h = Math.floor(h / snap2 + 2) * snap2;

                maxX = minX + w;
                maxY = minY + h;

                w = 1 / w;
                h = 1 / h;

                raw[0] = 2 * w;
                raw[5] = 2 * h;
                raw[10] = d;
                raw[12] = -(maxX + minX) * w;
                raw[13] = -(maxY + minY) * h;
                raw[14] = -this._pMinZ * d;
                raw[15] = 1;
                raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;

                matrix.copyRawDataFrom(raw);
            };
            return DirectionalShadowMapper;
        })(away.lights.ShadowMapperBase);
        lights.DirectionalShadowMapper = DirectionalShadowMapper;
    })(away.lights || (away.lights = {}));
    var lights = away.lights;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (data) {
        var RenderableListItem = (function () {
            function RenderableListItem() {
            }
            return RenderableListItem;
        })();
        data.RenderableListItem = RenderableListItem;
    })(away.data || (away.data = {}));
    var data = away.data;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (data) {
        var EntityListItem = (function () {
            function EntityListItem() {
            }
            return EntityListItem;
        })();
        data.EntityListItem = EntityListItem;
    })(away.data || (away.data = {}));
    var data = away.data;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (data) {
        var EntityListItemPool = (function () {
            function EntityListItemPool() {
                this._index = 0;
                this._poolSize = 0;
                this._pool = [];
            }
            EntityListItemPool.prototype.getItem = function () {
                var item;
                if (this._index == this._poolSize) {
                    item = new away.data.EntityListItem();
                    this._pool[this._index++] = item;
                    ++this._poolSize;
                } else {
                    item = this._pool[this._index++];
                }
                return item;
            };

            EntityListItemPool.prototype.freeAll = function () {
                this._index = 0;
            };

            EntityListItemPool.prototype.dispose = function () {
                this._pool.length = 0;
            };
            return EntityListItemPool;
        })();
        data.EntityListItemPool = EntityListItemPool;
    })(away.data || (away.data = {}));
    var data = away.data;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (data) {
        var RenderableListItemPool = (function () {
            function RenderableListItemPool() {
                this._index = 0;
                this._poolSize = 0;
                this._pool = [];
            }
            RenderableListItemPool.prototype.getItem = function () {
                if (this._index == this._poolSize) {
                    var item = new away.data.RenderableListItem();
                    this._pool[this._index++] = item;
                    ++this._poolSize;
                    return item;
                } else {
                    return this._pool[this._index++];
                }
            };

            RenderableListItemPool.prototype.freeAll = function () {
                this._index = 0;
            };

            RenderableListItemPool.prototype.dispose = function () {
                this._pool.length = 0;
            };
            return RenderableListItemPool;
        })();
        data.RenderableListItemPool = RenderableListItemPool;
    })(away.data || (away.data = {}));
    var data = away.data;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (traverse) {
        var PartitionTraverser = (function () {
            function PartitionTraverser() {
            }
            PartitionTraverser.prototype.enterNode = function (node) {
                node = node;
                return true;
            };

            PartitionTraverser.prototype.applySkyBox = function (renderable) {
                throw new away.errors.AbstractMethodError();
            };

            PartitionTraverser.prototype.applyRenderable = function (renderable) {
                throw new away.errors.AbstractMethodError();
            };

            PartitionTraverser.prototype.applyUnknownLight = function (light) {
                throw new away.errors.AbstractMethodError();
            };

            PartitionTraverser.prototype.applyDirectionalLight = function (light) {
                throw new away.errors.AbstractMethodError();
            };

            PartitionTraverser.prototype.applyPointLight = function (light) {
                throw new away.errors.AbstractMethodError();
            };

            PartitionTraverser.prototype.applyLightProbe = function (light) {
                throw new away.errors.AbstractMethodError();
            };

            PartitionTraverser.prototype.applyEntity = function (entity) {
                throw new away.errors.AbstractMethodError();
            };

            Object.defineProperty(PartitionTraverser.prototype, "entryPoint", {
                get: function () {
                    return this._iEntryPoint;
                },
                enumerable: true,
                configurable: true
            });
            PartitionTraverser._iCollectionMark = 0;
            return PartitionTraverser;
        })();
        traverse.PartitionTraverser = PartitionTraverser;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (traverse) {
        var EntityCollector = (function (_super) {
            __extends(EntityCollector, _super);
            function EntityCollector() {
                _super.call(this);
                this._pNumEntities = 0;
                this._pNumLights = 0;
                this._pNumTriangles = 0;
                this._pNumMouseEnableds = 0;
                this._numDirectionalLights = 0;
                this._numPointLights = 0;
                this._numLightProbes = 0;
                this._numCullPlanes = 0;
                this.init();
            }
            EntityCollector.prototype.init = function () {
                this._pLights = [];
                this._directionalLights = [];
                this._pointLights = [];
                this._lightProbes = [];
                this._pRenderableListItemPool = new away.data.RenderableListItemPool();
                this._pEntityListItemPool = new away.data.EntityListItemPool();
            };

            Object.defineProperty(EntityCollector.prototype, "camera", {
                get: function () {
                    return this._pCamera;
                },
                set: function (value) {
                    this._pCamera = value;
                    this._iEntryPoint = this._pCamera.scenePosition;
                    this._pCameraForward = this._pCamera.forwardVector;
                    this._cullPlanes = this._pCamera.frustumPlanes;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EntityCollector.prototype, "cullPlanes", {
                get: function () {
                    return this._customCullPlanes;
                },
                set: function (value) {
                    this._customCullPlanes = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EntityCollector.prototype, "numMouseEnableds", {
                get: function () {
                    return this._pNumMouseEnableds;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "skyBox", {
                get: function () {
                    return this._pSkyBox;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "opaqueRenderableHead", {
                get: function () {
                    return this._pOpaqueRenderableHead;
                },
                set: function (value) {
                    this._pOpaqueRenderableHead = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EntityCollector.prototype, "blendedRenderableHead", {
                get: function () {
                    return this._pBlendedRenderableHead;
                },
                set: function (value) {
                    this._pBlendedRenderableHead = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(EntityCollector.prototype, "entityHead", {
                get: function () {
                    return this._entityHead;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "lights", {
                get: function () {
                    return this._pLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "directionalLights", {
                get: function () {
                    return this._directionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "pointLights", {
                get: function () {
                    return this._pointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(EntityCollector.prototype, "lightProbes", {
                get: function () {
                    return this._lightProbes;
                },
                enumerable: true,
                configurable: true
            });

            EntityCollector.prototype.clear = function () {
                this._cullPlanes = this._customCullPlanes ? this._customCullPlanes : (this._pCamera ? this._pCamera.frustumPlanes : null);
                this._numCullPlanes = this._cullPlanes ? this._cullPlanes.length : 0;
                this._pNumTriangles = this._pNumMouseEnableds = 0;
                this._pBlendedRenderableHead = null;
                this._pOpaqueRenderableHead = null;
                this._entityHead = null;
                this._pRenderableListItemPool.freeAll();
                this._pEntityListItemPool.freeAll();
                this._pSkyBox = null;
                if (this._pNumLights > 0) {
                    this._pLights.length = this._pNumLights = 0;
                }
                if (this._numDirectionalLights > 0) {
                    this._directionalLights.length = this._numDirectionalLights = 0;
                }
                if (this._numPointLights > 0) {
                    this._pointLights.length = this._numPointLights = 0;
                }
                if (this._numLightProbes > 0) {
                    this._lightProbes.length = this._numLightProbes = 0;
                }
            };

            //@override
            EntityCollector.prototype.enterNode = function (node) {
                var enter = away.traverse.PartitionTraverser._iCollectionMark != node._iCollectionMark && node.isInFrustum(this._cullPlanes, this._numCullPlanes);

                node._iCollectionMark = away.traverse.PartitionTraverser._iCollectionMark;

                return enter;
            };

            //@override
            EntityCollector.prototype.applySkyBox = function (renderable) {
                this._pSkyBox = renderable;
            };

            //@override
            EntityCollector.prototype.applyRenderable = function (renderable) {
                var material;
                var entity = renderable.sourceEntity;
                if (renderable.mouseEnabled) {
                    ++this._pNumMouseEnableds;
                }
                this._pNumTriangles += renderable.numTriangles;

                material = renderable.material;
                if (material) {
                    var item = this._pRenderableListItemPool.getItem();
                    item.renderable = renderable;
                    item.materialId = material._iUniqueId;
                    item.renderOrderId = material._iRenderOrderId;
                    item.cascaded = false;
                    var dx = this._iEntryPoint.x - entity.x;
                    var dy = this._iEntryPoint.y - entity.y;
                    var dz = this._iEntryPoint.z - entity.z;

                    // project onto camera's z-axis
                    item.zIndex = dx * this._pCameraForward.x + dy * this._pCameraForward.y + dz * this._pCameraForward.z + entity.zOffset;
                    item.renderSceneTransform = renderable.getRenderSceneTransform(this._pCamera);
                    if (material.requiresBlending) {
                        item.next = this._pBlendedRenderableHead;
                        this._pBlendedRenderableHead = item;
                    } else {
                        item.next = this._pOpaqueRenderableHead;
                        this._pOpaqueRenderableHead = item;
                    }
                }
            };

            //@override
            EntityCollector.prototype.applyEntity = function (entity) {
                ++this._pNumEntities;

                var item = this._pEntityListItemPool.getItem();
                item.entity = entity;

                item.next = this._entityHead;
                this._entityHead = item;
                //console.log ( 'EntityCollector' , 'applyEntity: ' , entity , ' item: ' , item , 'item.next' , item.next , ' head: ' , this._entityHead );
            };

            //@override
            EntityCollector.prototype.applyUnknownLight = function (light) {
                this._pLights[this._pNumLights++] = light;
            };

            //@override
            EntityCollector.prototype.applyDirectionalLight = function (light) {
                this._pLights[this._pNumLights++] = light;
                this._directionalLights[this._numDirectionalLights++] = light;
            };

            //@override
            EntityCollector.prototype.applyPointLight = function (light) {
                this._pLights[this._pNumLights++] = light;
                this._pointLights[this._numPointLights++] = light;
            };

            //@override
            EntityCollector.prototype.applyLightProbe = function (light) {
                this._pLights[this._pNumLights++] = light;
                this._lightProbes[this._numLightProbes++] = light;
            };

            /**
            * Cleans up any data at the end of a frame.
            */
            EntityCollector.prototype.cleanUp = function () {
            };
            return EntityCollector;
        })(away.traverse.PartitionTraverser);
        traverse.EntityCollector = EntityCollector;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (traverse) {
        var ShadowCasterCollector = (function (_super) {
            __extends(ShadowCasterCollector, _super);
            function ShadowCasterCollector() {
                _super.call(this);
            }
            //@override
            ShadowCasterCollector.prototype.applyRenderable = function (renderable) {
                // the test for material is temporary, you SHOULD be hammered with errors if you try to render anything without a material
                var material = renderable.material;
                var entity = renderable.sourceEntity;
                if (material) {
                    var item = this._pRenderableListItemPool.getItem();
                    item.renderable = renderable;
                    item.next = this._pOpaqueRenderableHead;
                    item.cascaded = false;
                    var dx = this._iEntryPoint.x - entity.x;
                    var dy = this._iEntryPoint.y - entity.y;
                    var dz = this._iEntryPoint.z - entity.z;
                    item.zIndex = dx * this._pCameraForward.x + dy * this._pCameraForward.y + dz * this._pCameraForward.z;
                    item.renderSceneTransform = renderable.getRenderSceneTransform(this._pCamera);
                    item.renderOrderId = material._iDepthPassId;
                    this._pOpaqueRenderableHead = item;
                }
            };

            //@override
            ShadowCasterCollector.prototype.applyUnknownLight = function (light) {
            };

            //@override
            ShadowCasterCollector.prototype.applyDirectionalLight = function (light) {
            };

            //@override
            ShadowCasterCollector.prototype.applyPointLight = function (light) {
            };

            //@override
            ShadowCasterCollector.prototype.applyLightProbe = function (light) {
            };

            //@override
            ShadowCasterCollector.prototype.applySkyBox = function (renderable) {
            };

            //@override
            ShadowCasterCollector.prototype.enterNode = function (node) {
                var enter = away.traverse.PartitionTraverser._iCollectionMark != node._iCollectionMark && node.isCastingShadow();

                if (!enter) {
                    node._iCollectionMark = away.traverse.PartitionTraverser._iCollectionMark;

                    return false;
                }

                return _super.prototype.enterNode.call(this, node);
            };
            return ShadowCasterCollector;
        })(away.traverse.EntityCollector);
        traverse.ShadowCasterCollector = ShadowCasterCollector;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (traverse) {
        /**
        * The RaycastCollector class is a traverser for scene partitions that collects all scene graph entities that are
        * considered intersecting with the defined ray.
        *
        * @see away3d.partition.Partition3D
        * @see away3d.partition.Entity
        */
        var RaycastCollector = (function (_super) {
            __extends(RaycastCollector, _super);
            /**
            * Creates a new RaycastCollector object.
            */
            function RaycastCollector() {
                _super.call(this);
                this._rayPosition = new away.geom.Vector3D();
                this._rayDirection = new away.geom.Vector3D();
            }
            Object.defineProperty(RaycastCollector.prototype, "rayPosition", {
                get: /**
                * Provides the starting position of the ray.
                */
                function () {
                    return this._rayPosition;
                },
                set: function (value) {
                    this._rayPosition = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RaycastCollector.prototype, "rayDirection", {
                get: /**
                * Provides the direction vector of the ray.
                */
                function () {
                    return this._rayDirection;
                },
                set: function (value) {
                    this._rayDirection = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Returns true if the current node is at least partly in the frustum. If so, the partition node knows to pass on the traverser to its children.
            *
            * @param node The Partition3DNode object to frustum-test.
            */
            RaycastCollector.prototype.enterNode = function (node) {
                return node.isIntersectingRay(this._rayPosition, this._rayDirection);
            };

            /**
            * @inheritDoc
            */
            RaycastCollector.prototype.applySkyBox = function (renderable) {
            };

            /**
            * Adds an IRenderable object to the potentially visible objects.
            * @param renderable The IRenderable object to add.
            */
            RaycastCollector.prototype.applyRenderable = function (renderable) {
            };

            /**
            * @inheritDoc
            */
            RaycastCollector.prototype.applyUnknownLight = function (light) {
            };
            return RaycastCollector;
        })(away.traverse.EntityCollector);
        traverse.RaycastCollector = RaycastCollector;
    })(away.traverse || (away.traverse = {}));
    var traverse = away.traverse;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (partition) {
        /**
        * RenderableNode is a space partitioning leaf node that contains any Entity that is itself a IRenderable
        * object. This excludes Mesh (since the renderable objects are its SubMesh children).
        */
        var RenderableNode = (function (_super) {
            __extends(RenderableNode, _super);
            /**
            * Creates a new RenderableNode object.
            * @param mesh The mesh to be contained in the node.
            */
            function RenderableNode(renderable) {
                var e = renderable;

                _super.call(this, e);

                this._renderable = renderable;
            }
            /**
            * @inheritDoc
            */
            RenderableNode.prototype.acceptTraverser = function (traverser) {
                if (traverser.enterNode(this)) {
                    _super.prototype.acceptTraverser.call(this, traverser);

                    traverser.applyRenderable(this._renderable);
                }
            };
            return RenderableNode;
        })(partition.EntityNode);
        partition.RenderableNode = RenderableNode;
    })(away.partition || (away.partition = {}));
    var partition = away.partition;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (pick) {
        /**
        * Picks a 3d object from a view or scene by performing a separate render pass on the scene around the area being picked using key color values,
        * then reading back the color value of the pixel in the render representing the picking ray. Requires multiple passes and readbacks for retriving details
        * on an entity that has its shaderPickingDetails property set to true.
        *
        * A read-back operation from any GPU is not a very efficient process, and the amount of processing used can vary significantly between different hardware.
        *
        * @see away3d.entities.Entity#shaderPickingDetails
        */
        // TODO: Dependencies needed to before implementing IPicker - EntityCollector
        var ShaderPicker = (function () {
            /**
            * Creates a new <code>ShaderPicker</code> object.
            */
            function ShaderPicker() {
                this._onlyMouseEnabled = true;
                this._interactives = new Array();
                this._localHitPosition = new away.geom.Vector3D();
                this._hitUV = new away.geom.Point();
                this._localHitNormal = new away.geom.Vector3D();
                this._rayPos = new away.geom.Vector3D();
                this._rayDir = new away.geom.Vector3D();
                this._id = new Array(4);
                this._viewportData = new Array(4);
                this._boundOffsetScale = new Array(8);
                this._boundOffsetScale[3] = 0;
                this._boundOffsetScale[7] = 1;
            }
            Object.defineProperty(ShaderPicker.prototype, "onlyMouseEnabled", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._onlyMouseEnabled;
                },
                set: function (value) {
                    this._onlyMouseEnabled = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            // TODO implement dependency : EntityCollector
            // TODO: GLSL implementation / conversion
            ShaderPicker.prototype.getViewCollision = function (x, y, view) {
                away.Debug.throwPIR('ShaderPicker', 'getViewCollision', 'implement');

                return null;

                var collector = view.iEntityCollector;

                this._stage3DProxy = view.stage3DProxy;

                if (!this._stage3DProxy)
                    return null;

                this._context = this._stage3DProxy._iContext3D;

                this._viewportData[0] = view.width;
                this._viewportData[1] = view.height;
                this._viewportData[2] = -(this._projX = 2 * x / view.width - 1);
                this._viewportData[3] = this._projY = 2 * y / view.height - 1;

                // _potentialFound will be set to true if any object is actually rendered
                this._potentialFound = false;

                this.pDraw(collector, null);

                // clear buffers
                this._context.setVertexBufferAt(0, null);

                if (!this._context || !this._potentialFound) {
                    return null;
                }

                if (!this._bitmapData)
                    this._bitmapData = new away.display.BitmapData(1, 1, false, 0);

                this._context.drawToBitmapData(this._bitmapData);
                this._hitColor = this._bitmapData.getPixel(0, 0);

                if (!this._hitColor) {
                    this._context.present();
                    return null;
                }

                this._hitRenderable = this._interactives[this._hitColor - 1];
                this._hitEntity = this._hitRenderable.sourceEntity;
                if (this._onlyMouseEnabled && (!this._hitEntity._iAncestorsAllowMouseEnabled || !this._hitEntity.mouseEnabled)) {
                    return null;
                }

                var _collisionVO = this._hitEntity.pickingCollisionVO;
                if (this._hitRenderable.shaderPickingDetails) {
                    this.getHitDetails(view.camera);
                    _collisionVO.localPosition = this._localHitPosition;
                    _collisionVO.localNormal = this._localHitNormal;
                    _collisionVO.uv = this._hitUV;
                    _collisionVO.index = this._faceIndex;
                    _collisionVO.subGeometryIndex = this._subGeometryIndex;
                } else {
                    _collisionVO.localPosition = null;
                    _collisionVO.localNormal = null;
                    _collisionVO.uv = null;
                    _collisionVO.index = 0;
                    _collisionVO.subGeometryIndex = 0;
                }

                return _collisionVO;
                //*/
            };

            //*/
            /**
            * @inheritDoc
            */
            ShaderPicker.prototype.getSceneCollision = function (position, direction, scene) {
                return null;
            };

            /**
            * @inheritDoc
            */
            // TODO: GLSL implementation / conversion
            ShaderPicker.prototype.pDraw = function (entityCollector, target) {
                var camera = entityCollector.camera;

                this._context.clear(0, 0, 0, 1);
                this._stage3DProxy.scissorRect = ShaderPicker.MOUSE_SCISSOR_RECT;

                this._interactives.length = this._interactiveId = 0;

                if (!this._objectProgram3D) {
                    this.initObjectProgram3D();
                }

                this._context.setBlendFactors(away.display3D.Context3DBlendFactor.ONE, away.display3D.Context3DBlendFactor.ZERO);
                this._context.setDepthTest(true, away.display3D.Context3DCompareMode.LESS);
                this._context.setProgram(this._objectProgram3D);
                this._context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, 4, this._viewportData, 1);
                this.drawRenderables(entityCollector.opaqueRenderableHead, camera);
                this.drawRenderables(entityCollector.blendedRenderableHead, camera);
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param camera The camera for which to render.
            */
            ShaderPicker.prototype.drawRenderables = function (item, camera) {
                away.Debug.throwPIR('ShaderPicker', 'drawRenderables', 'implement');

                var matrix = away.math.Matrix3DUtils.CALCULATION_MATRIX;
                var renderable;
                var viewProjection = camera.viewProjection;

                while (item) {
                    renderable = item.renderable;

                    if (!renderable.sourceEntity.scene || (!renderable.mouseEnabled && this._onlyMouseEnabled)) {
                        item = item.next;
                        continue;
                    }

                    this._potentialFound = true;

                    this._context.setCulling(renderable.material.bothSides ? away.display3D.Context3DTriangleFace.NONE : away.display3D.Context3DTriangleFace.BACK);

                    this._interactives[this._interactiveId++] = renderable;

                    // color code so that reading from bitmapdata will contain the correct value
                    this._id[1] = (this._interactiveId >> 8) / 255;
                    this._id[2] = (this._interactiveId & 0xff) / 255;

                    matrix.copyFrom(renderable.getRenderSceneTransform(camera));
                    matrix.append(viewProjection);
                    this._context.setProgramConstantsFromMatrix(away.display3D.Context3DProgramType.VERTEX, 0, matrix, true);
                    this._context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.FRAGMENT, 0, this._id, 1);
                    renderable.activateVertexBuffer(0, this._stage3DProxy);
                    this._context.drawTriangles(renderable.getIndexBuffer(this._stage3DProxy), 0, renderable.numTriangles);

                    item = item.next;
                }
            };

            ShaderPicker.prototype.updateRay = function (camera) {
                this._rayPos = camera.scenePosition;
                this._rayDir = camera.getRay(this._projX, this._projY, 1);
                this._rayDir.normalize();
            };

            /**
            * Creates the Program3D that color-codes objects.
            */
            ShaderPicker.prototype.initObjectProgram3D = function () {
                var vertexCode;
                var fragmentCode;

                this._objectProgram3D = this._context.createProgram();

                vertexCode = "m44 vt0, va0, vc0			\n" + "mul vt1.xy, vt0.w, vc4.zw	\n" + "add vt0.xy, vt0.xy, vt1.xy	\n" + "mul vt0.xy, vt0.xy, vc4.xy	\n" + "mov op, vt0	\n";
                fragmentCode = "mov oc, fc0";

                away.Debug.throwPIR('ShaderPicker', 'initTriangleProgram3D', 'Dependency: initObjectProgram3D');
                //_objectProgram3D.upload(new AGALMiniAssembler().assemble(Context3DProgramType.VERTEX, vertexCode),new AGALMiniAssembler().assemble(Context3DProgramType.FRAGMENT, fragmentCode));
            };

            /**
            * Creates the Program3D that renders positions.
            */
            ShaderPicker.prototype.initTriangleProgram3D = function () {
                var vertexCode;
                var fragmentCode;

                this._triangleProgram3D = this._context.createProgram();

                // todo: add animation code
                vertexCode = "add vt0, va0, vc5 			\n" + "mul vt0, vt0, vc6 			\n" + "mov v0, vt0				\n" + "m44 vt0, va0, vc0			\n" + "mul vt1.xy, vt0.w, vc4.zw	\n" + "add vt0.xy, vt0.xy, vt1.xy	\n" + "mul vt0.xy, vt0.xy, vc4.xy	\n" + "mov op, vt0	\n";
                fragmentCode = "mov oc, v0";

                //away.Debug.throwPIR( 'ShaderPicker' , 'initTriangleProgram3D' , 'Dependency: AGALMiniAssembler')
                var vertCompiler = new aglsl.AGLSLCompiler();
                var fragCompiler = new aglsl.AGLSLCompiler();

                var vertString = vertCompiler.compile(away.display3D.Context3DProgramType.VERTEX, vertexCode);
                var fragString = fragCompiler.compile(away.display3D.Context3DProgramType.FRAGMENT, fragmentCode);

                this._triangleProgram3D.upload(vertString, fragString);
                //this._triangleProgram3D.upload(new AGALMiniAssembler().assemble(Context3DProgramType.VERTEX, vertexCode), new AGALMiniAssembler().assemble(Context3DProgramType.FRAGMENT, fragmentCode));
            };

            /**
            * Gets more detailed information about the hir position, if required.
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getHitDetails = function (camera) {
                this.getApproximatePosition(camera);
                this.getPreciseDetails(camera);
            };

            /**
            * Finds a first-guess approximate position about the hit position.
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getApproximatePosition = function (camera) {
                var entity = this._hitRenderable.sourceEntity;
                var col;
                var scX, scY, scZ;
                var offsX, offsY, offsZ;
                var localViewProjection = away.math.Matrix3DUtils.CALCULATION_MATRIX;

                localViewProjection.copyFrom(this._hitRenderable.getRenderSceneTransform(camera));
                localViewProjection.append(camera.viewProjection);
                if (!this._triangleProgram3D) {
                    this.initTriangleProgram3D();
                }

                this._boundOffsetScale[4] = 1 / (scX = entity.maxX - entity.minX);
                this._boundOffsetScale[5] = 1 / (scY = entity.maxY - entity.minY);
                this._boundOffsetScale[6] = 1 / (scZ = entity.maxZ - entity.minZ);
                this._boundOffsetScale[0] = offsX = -entity.minX;
                this._boundOffsetScale[1] = offsY = -entity.minY;
                this._boundOffsetScale[2] = offsZ = -entity.minZ;

                this._context.setProgram(this._triangleProgram3D);
                this._context.clear(0, 0, 0, 0, 1, 0, away.display3D.Context3DClearMask.DEPTH);
                this._context.setScissorRectangle(ShaderPicker.MOUSE_SCISSOR_RECT);
                this._context.setProgramConstantsFromMatrix(away.display3D.Context3DProgramType.VERTEX, 0, localViewProjection, true);
                this._context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, 5, this._boundOffsetScale, 2);
                this._hitRenderable.activateVertexBuffer(0, this._stage3DProxy);
                this._context.drawTriangles(this._hitRenderable.getIndexBuffer(this._stage3DProxy), 0, this._hitRenderable.numTriangles);
                this._context.drawToBitmapData(this._bitmapData);

                col = this._bitmapData.getPixel(0, 0);

                this._localHitPosition.x = ((col >> 16) & 0xff) * scX / 255 - offsX;
                this._localHitPosition.y = ((col >> 8) & 0xff) * scY / 255 - offsY;
                this._localHitPosition.z = (col & 0xff) * scZ / 255 - offsZ;
            };

            /**
            * Use the approximate position info to find the face under the mouse position from which we can derive the precise
            * ray-face intersection point, then use barycentric coordinates to figure out the uv coordinates, etc.
            * @param camera The camera used to view the hit object.
            */
            ShaderPicker.prototype.getPreciseDetails = function (camera) {
                var subMesh = this._hitRenderable;

                var subGeom = subMesh.subGeometry;
                var indices = subGeom.indexData;
                var vertices = subGeom.vertexData;
                var len = indices.length;
                var x1, y1, z1;
                var x2, y2, z2;
                var x3, y3, z3;
                var i = 0, j = 1, k = 2;
                var t1, t2, t3;
                var v0x, v0y, v0z;
                var v1x, v1y, v1z;
                var v2x, v2y, v2z;
                var dot00, dot01, dot02, dot11, dot12;
                var s, t, invDenom;
                var uvs = subGeom.UVData;
                var normals = subGeom.faceNormals;
                var x = this._localHitPosition.x, y = this._localHitPosition.y, z = this._localHitPosition.z;
                var u, v;
                var ui1, ui2, ui3;
                var s0x, s0y, s0z;
                var s1x, s1y, s1z;
                var nl;
                var stride = subGeom.vertexStride;
                var vertexOffset = subGeom.vertexOffset;

                this.updateRay(camera);

                while (i < len) {
                    t1 = vertexOffset + indices[i] * stride;
                    t2 = vertexOffset + indices[j] * stride;
                    t3 = vertexOffset + indices[k] * stride;
                    x1 = vertices[t1];
                    y1 = vertices[t1 + 1];
                    z1 = vertices[t1 + 2];
                    x2 = vertices[t2];
                    y2 = vertices[t2 + 1];
                    z2 = vertices[t2 + 2];
                    x3 = vertices[t3];
                    y3 = vertices[t3 + 1];
                    z3 = vertices[t3 + 2];

                    if (!((x < x1 && x < x2 && x < x3) || (y < y1 && y < y2 && y < y3) || (z < z1 && z < z2 && z < z3) || (x > x1 && x > x2 && x > x3) || (y > y1 && y > y2 && y > y3) || (z > z1 && z > z2 && z > z3))) {
                        // calculate barycentric coords for approximated position
                        v0x = x3 - x1;
                        v0y = y3 - y1;
                        v0z = z3 - z1;
                        v1x = x2 - x1;
                        v1y = y2 - y1;
                        v1z = z2 - z1;
                        v2x = x - x1;
                        v2y = y - y1;
                        v2z = z - z1;
                        dot00 = v0x * v0x + v0y * v0y + v0z * v0z;
                        dot01 = v0x * v1x + v0y * v1y + v0z * v1z;
                        dot02 = v0x * v2x + v0y * v2y + v0z * v2z;
                        dot11 = v1x * v1x + v1y * v1y + v1z * v1z;
                        dot12 = v1x * v2x + v1y * v2y + v1z * v2z;
                        invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                        s = (dot11 * dot02 - dot01 * dot12) * invDenom;
                        t = (dot00 * dot12 - dot01 * dot02) * invDenom;

                        if (s >= 0 && t >= 0 && (s + t) <= 1) {
                            // this is def the triangle, now calculate precise coords
                            this.getPrecisePosition(this._hitRenderable.inverseSceneTransform, normals[i], normals[i + 1], normals[i + 2], x1, y1, z1);

                            v2x = this._localHitPosition.x - x1;
                            v2y = this._localHitPosition.y - y1;
                            v2z = this._localHitPosition.z - z1;

                            s0x = x2 - x1;
                            s0y = y2 - y1;
                            s0z = z2 - z1;
                            s1x = x3 - x1;
                            s1y = y3 - y1;
                            s1z = z3 - z1;
                            this._localHitNormal.x = s0y * s1z - s0z * s1y;
                            this._localHitNormal.y = s0z * s1x - s0x * s1z;
                            this._localHitNormal.z = s0x * s1y - s0y * s1x;
                            nl = 1 / Math.sqrt(this._localHitNormal.x * this._localHitNormal.x + this._localHitNormal.y * this._localHitNormal.y + this._localHitNormal.z * this._localHitNormal.z);
                            this._localHitNormal.x *= nl;
                            this._localHitNormal.y *= nl;
                            this._localHitNormal.z *= nl;

                            dot02 = v0x * v2x + v0y * v2y + v0z * v2z;
                            dot12 = v1x * v2x + v1y * v2y + v1z * v2z;
                            s = (dot11 * dot02 - dot01 * dot12) * invDenom;
                            t = (dot00 * dot12 - dot01 * dot02) * invDenom;

                            ui1 = indices[i] << 1;
                            ui2 = indices[j] << 1;
                            ui3 = indices[k] << 1;

                            u = uvs[ui1];
                            v = uvs[ui1 + 1];
                            this._hitUV.x = u + t * (uvs[ui2] - u) + s * (uvs[ui3] - u);
                            this._hitUV.y = v + t * (uvs[ui2 + 1] - v) + s * (uvs[ui3 + 1] - v);

                            this._faceIndex = i;
                            this._subGeometryIndex = away.utils.GeometryUtils.getMeshSubMeshIndex(subMesh);

                            return;
                        }
                    }

                    i += 3;
                    j += 3;
                    k += 3;
                }
            };

            /**
            * Finds the precise hit position by unprojecting the screen coordinate back unto the hit face's plane and
            * calculating the intersection point.
            * @param camera The camera used to render the object.
            * @param invSceneTransform The inverse scene transformation of the hit object.
            * @param nx The x-coordinate of the face's plane normal.
            * @param ny The y-coordinate of the face plane normal.
            * @param nz The z-coordinate of the face plane normal.
            * @param px The x-coordinate of a point on the face's plane (ie a face vertex)
            * @param py The y-coordinate of a point on the face's plane (ie a face vertex)
            * @param pz The z-coordinate of a point on the face's plane (ie a face vertex)
            */
            ShaderPicker.prototype.getPrecisePosition = function (invSceneTransform, nx, ny, nz, px, py, pz) {
                // calculate screen ray and find exact intersection position with triangle
                var rx, ry, rz;
                var ox, oy, oz;
                var t;
                var raw = away.math.Matrix3DUtils.RAW_DATA_CONTAINER;
                var cx = this._rayPos.x, cy = this._rayPos.y, cz = this._rayPos.z;

                // unprojected projection point, gives ray dir in cam space
                ox = this._rayDir.x;
                oy = this._rayDir.y;
                oz = this._rayDir.z;

                // transform ray dir and origin (cam pos) to object space
                //invSceneTransform.copyRawDataTo( raw  );
                invSceneTransform.copyRawDataTo(raw);
                rx = raw[0] * ox + raw[4] * oy + raw[8] * oz;
                ry = raw[1] * ox + raw[5] * oy + raw[9] * oz;
                rz = raw[2] * ox + raw[6] * oy + raw[10] * oz;

                ox = raw[0] * cx + raw[4] * cy + raw[8] * cz + raw[12];
                oy = raw[1] * cx + raw[5] * cy + raw[9] * cz + raw[13];
                oz = raw[2] * cx + raw[6] * cy + raw[10] * cz + raw[14];

                t = ((px - ox) * nx + (py - oy) * ny + (pz - oz) * nz) / (rx * nx + ry * ny + rz * nz);

                this._localHitPosition.x = ox + rx * t;
                this._localHitPosition.y = oy + ry * t;
                this._localHitPosition.z = oz + rz * t;
            };

            ShaderPicker.prototype.dispose = function () {
                this._bitmapData.dispose();
                if (this._triangleProgram3D) {
                    this._triangleProgram3D.dispose();
                }

                if (this._objectProgram3D) {
                    this._objectProgram3D.dispose();
                }

                this._triangleProgram3D = null;
                this._objectProgram3D = null;
                this._bitmapData = null;
                this._hitRenderable = null;
                this._hitEntity = null;
            };
            ShaderPicker.MOUSE_SCISSOR_RECT = new away.geom.Rectangle(0, 0, 1, 1);
            return ShaderPicker;
        })();
        pick.ShaderPicker = ShaderPicker;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (pick) {
        /**
        * Picks a 3d object from a view or scene by 3D raycast calculations.
        * Performs an initial coarse boundary calculation to return a subset of entities whose bounding volumes intersect with the specified ray,
        * then triggers an optional picking collider on individual entity objects to further determine the precise values of the picking ray collision.
        */
        var RaycastPicker = (function () {
            /**
            * Creates a new <code>RaycastPicker</code> object.
            *
            * @param findClosestCollision Determines whether the picker searches for the closest bounds collision along the ray,
            * or simply returns the first collision encountered Defaults to false.
            */
            function RaycastPicker(findClosestCollision) {
                this._raycastCollector = new away.traverse.RaycastCollector();
                this._ignoredEntities = [];
                this._onlyMouseEnabled = true;
                this._numEntities = 0;
                this._findClosestCollision = findClosestCollision;
                this._entities = new Array();
            }
            Object.defineProperty(RaycastPicker.prototype, "onlyMouseEnabled", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._onlyMouseEnabled;
                },
                set: function (value) {
                    this._onlyMouseEnabled = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            RaycastPicker.prototype.getViewCollision = function (x, y, view) {
                //cast ray through the collection of entities on the view
                var collector = view.iEntityCollector;

                if (collector.numMouseEnableds == 0)
                    return null;

                //update ray
                var rayPosition = view.unproject(x, y, 0);
                var rayDirection = view.unproject(x, y, 1);
                rayDirection = rayDirection.subtract(rayPosition);

                // Perform ray-bounds collision checks.
                this._numEntities = 0;
                var node = collector.entityHead;
                var entity;
                while (node) {
                    entity = node.entity;

                    if (this.isIgnored(entity)) {
                        node = node.next;
                        continue;
                    }

                    if (entity._iIsVisible && entity.isIntersectingRay(rayPosition, rayDirection))
                        this._entities[this._numEntities++] = entity;

                    node = node.next;
                }

                if (!this._numEntities)
                    return null;

                return this.getPickingCollisionVO();
            };

            //*/
            /**
            * @inheritDoc
            */
            //* TODO Implement Dependency: EntityListItem, EntityCollector, RaycastCollector
            RaycastPicker.prototype.getSceneCollision = function (position, direction, scene) {
                //clear collector
                this._raycastCollector.clear();

                //setup ray vectors
                this._raycastCollector.rayPosition = position;
                this._raycastCollector.rayDirection = direction;

                // collect entities to test
                scene.traversePartitions(this._raycastCollector);

                this._numEntities = 0;
                var node = this._raycastCollector.entityHead;
                var entity;

                while (node) {
                    entity = node.entity;

                    if (this.isIgnored(entity)) {
                        node = node.next;
                        continue;
                    }

                    this._entities[this._numEntities++] = entity;

                    node = node.next;
                }

                if (!this._numEntities)
                    return null;

                return this.getPickingCollisionVO();
            };

            //*/
            RaycastPicker.prototype.getEntityCollision = function (position, direction, entities) {
                position = position;
                direction = direction;

                this._numEntities = 0;

                var entity;
                var l = entities.length;

                for (var c = 0; c < l; c++) {
                    entity = entities[c];

                    if (entity.isIntersectingRay(position, direction)) {
                        this._entities[this._numEntities++] = entity;
                    }
                }

                return this.getPickingCollisionVO();
            };

            //*/
            RaycastPicker.prototype.setIgnoreList = function (entities) {
                this._ignoredEntities = entities;
            };

            RaycastPicker.prototype.isIgnored = function (entity) {
                if (this._onlyMouseEnabled && (!entity._iAncestorsAllowMouseEnabled || !entity.mouseEnabled)) {
                    return true;
                }

                var ignoredEntity;

                var l = this._ignoredEntities.length;

                for (var c = 0; c < l; c++) {
                    ignoredEntity = this._ignoredEntities[c];

                    if (ignoredEntity == entity) {
                        return true;
                    }
                }

                return false;
            };

            RaycastPicker.prototype.sortOnNearT = function (entity1, entity2) {
                return entity1.pickingCollisionVO.rayEntryDistance > entity2.pickingCollisionVO.rayEntryDistance ? 1 : -1;
            };

            RaycastPicker.prototype.getPickingCollisionVO = function () {
                // trim before sorting
                this._entities.length = this._numEntities;

                // Sort entities from closest to furthest.
                this._entities = this._entities.sort(this.sortOnNearT);

                // ---------------------------------------------------------------------
                // Evaluate triangle collisions when needed.
                // Replaces collision data provided by bounds collider with more precise data.
                // ---------------------------------------------------------------------
                var shortestCollisionDistance = Number.MAX_VALUE;
                var bestCollisionVO;
                var pickingCollisionVO;
                var entity;
                var i;

                for (i = 0; i < this._numEntities; ++i) {
                    entity = this._entities[i];
                    pickingCollisionVO = entity._iPickingCollisionVO;
                    if (entity.pickingCollider) {
                        if ((bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) && entity.iCollidesBefore(shortestCollisionDistance, this._findClosestCollision)) {
                            shortestCollisionDistance = pickingCollisionVO.rayEntryDistance;
                            bestCollisionVO = pickingCollisionVO;
                            if (!this._findClosestCollision) {
                                this.updateLocalPosition(pickingCollisionVO);
                                return pickingCollisionVO;
                            }
                        }
                    } else if (bestCollisionVO == null || pickingCollisionVO.rayEntryDistance < bestCollisionVO.rayEntryDistance) {
                        if (!pickingCollisionVO.rayOriginIsInsideBounds) {
                            this.updateLocalPosition(pickingCollisionVO);
                            return pickingCollisionVO;
                        }
                    }
                }

                return bestCollisionVO;
            };

            RaycastPicker.prototype.updateLocalPosition = function (pickingCollisionVO) {
                var collisionPos = (pickingCollisionVO.localPosition == null) ? new away.geom.Vector3D() : pickingCollisionVO.localPosition;

                //var collisionPos:away.geom.Vector3D = pickingCollisionVO.localPosition ||= new away.geom.Vector3D();
                var rayDir = pickingCollisionVO.localRayDirection;
                var rayPos = pickingCollisionVO.localRayPosition;
                var t = pickingCollisionVO.rayEntryDistance;
                collisionPos.x = rayPos.x + t * rayDir.x;
                collisionPos.y = rayPos.y + t * rayDir.y;
                collisionPos.z = rayPos.z + t * rayDir.z;
            };

            RaycastPicker.prototype.dispose = function () {
            };
            return RaycastPicker;
        })();
        pick.RaycastPicker = RaycastPicker;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (pick) {
        /**
        * Options for the different 3D object picking approaches available in Away3D. Can be used for automatic mouse picking on the view.
        *
        * @see away3d.containers.View3D#mousePicker
        */
        var PickingType = (function () {
            function PickingType() {
            }
            PickingType.SHADER = new away.pick.ShaderPicker();

            PickingType.RAYCAST_FIRST_ENCOUNTERED = new away.pick.RaycastPicker(false);

            PickingType.RAYCAST_BEST_HIT = new away.pick.RaycastPicker(true);
            return PickingType;
        })();
        pick.PickingType = PickingType;
    })(away.pick || (away.pick = {}));
    var pick = away.pick;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import away3d.arcane;
        //import away3d.core.base.CompactSubGeometry;
        //import away3d.core.base.Geometry;
        //import away3d.core.base.ISubGeometry;
        //import away3d.errors.AbstractMethodError;
        //import flash.geom.Matrix3D;
        //use namespace arcane;
        /**
        * PrimitiveBase is an abstract base class for mesh primitives, which are prebuilt simple meshes.
        */
        var PrimitiveBase = (function (_super) {
            __extends(PrimitiveBase, _super);
            /**
            * Creates a new PrimitiveBase object.
            * @param material The material with which to render the object
            */
            function PrimitiveBase() {
                _super.call(this);
                this._geomDirty = true;
                this._uvDirty = true;

                this._subGeometry = new away.base.CompactSubGeometry();
                this._subGeometry.autoGenerateDummyUVs = false;
                this.addSubGeometry(this._subGeometry);
            }
            Object.defineProperty(PrimitiveBase.prototype, "subGeometries", {
                get: /**
                * @inheritDoc
                */
                function () {
                    if (this._geomDirty) {
                        this.updateGeometry();
                    }

                    if (this._uvDirty) {
                        this.updateUVs();
                    }

                    return _super.prototype.getSubGeometries.call(this);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            PrimitiveBase.prototype.clone = function () {
                if (this._geomDirty) {
                    this.updateGeometry();
                }

                if (this._uvDirty) {
                    this.updateUVs();
                }

                return _super.prototype.clone.call(this);
            };

            /**
            * @inheritDoc
            */
            PrimitiveBase.prototype.scale = function (scale) {
                if (this._geomDirty) {
                    this.updateGeometry();
                }

                _super.prototype.scale.call(this, scale);
            };

            /**
            * @inheritDoc
            */
            PrimitiveBase.prototype.scaleUV = function (scaleU, scaleV) {
                if (typeof scaleU === "undefined") { scaleU = 1; }
                if (typeof scaleV === "undefined") { scaleV = 1; }
                if (this._uvDirty) {
                    this.updateUVs();
                }

                _super.prototype.scaleUV.call(this, scaleU, scaleV);
            };

            /**
            * @inheritDoc
            */
            PrimitiveBase.prototype.applyTransformation = function (transform) {
                if (this._geomDirty) {
                    this.updateGeometry();
                }

                _super.prototype.applyTransformation.call(this, transform);
            };

            /**
            * Builds the primitive's geometry when invalid. This method should not be called directly. The calling should
            * be triggered by the invalidateGeometry method (and in turn by updateGeometry).
            */
            PrimitiveBase.prototype.pBuildGeometry = function (target) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Builds the primitive's uv coordinates when invalid. This method should not be called directly. The calling
            * should be triggered by the invalidateUVs method (and in turn by updateUVs).
            */
            PrimitiveBase.prototype.pBuildUVs = function (target) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Invalidates the primitive's geometry, causing it to be updated when requested.
            */
            PrimitiveBase.prototype.pInvalidateGeometry = function () {
                this._geomDirty = true;
            };

            /**
            * Invalidates the primitive's uv coordinates, causing them to be updated when requested.
            */
            PrimitiveBase.prototype.pInvalidateUVs = function () {
                this._uvDirty = true;
            };

            /**
            * Updates the geometry when invalid.
            */
            PrimitiveBase.prototype.updateGeometry = function () {
                this.pBuildGeometry(this._subGeometry);
                this._geomDirty = false;
            };

            /**
            * Updates the uv coordinates when invalid.
            */
            PrimitiveBase.prototype.updateUVs = function () {
                this.pBuildUVs(this._subGeometry);
                this._uvDirty = false;
            };

            PrimitiveBase.prototype.iValidate = function () {
                if (this._geomDirty) {
                    this.updateGeometry();
                }

                if (this._uvDirty) {
                    this.updateUVs();
                }
            };
            return PrimitiveBase;
        })(away.base.Geometry);
        primitives.PrimitiveBase = PrimitiveBase;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        var LineSegment = (function (_super) {
            __extends(LineSegment, _super);
            function LineSegment(v0, v1, color0, color1, thickness) {
                if (typeof color0 === "undefined") { color0 = 0x333333; }
                if (typeof color1 === "undefined") { color1 = 0x333333; }
                if (typeof thickness === "undefined") { thickness = 1; }
                _super.call(this, v0, v1, null, color0, color1, thickness);
                this.TYPE = "line";
            }
            return LineSegment;
        })(away.primitives.Segment);
        primitives.LineSegment = LineSegment;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import away3d.arcane;
        //import away3d.core.base.CompactSubGeometry;
        //use namespace arcane;
        /**
        * A UV Cylinder primitive mesh.
        */
        var TorusGeometry = (function (_super) {
            __extends(TorusGeometry, _super);
            /**
            * Creates a new <code>Torus</code> object.
            * @param radius The radius of the torus.
            * @param tuebRadius The radius of the inner tube of the torus.
            * @param segmentsR Defines the number of horizontal segments that make up the torus.
            * @param segmentsT Defines the number of vertical segments that make up the torus.
            * @param yUp Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function TorusGeometry(radius, tubeRadius, segmentsR, segmentsT, yUp) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof tubeRadius === "undefined") { tubeRadius = 50; }
                if (typeof segmentsR === "undefined") { segmentsR = 16; }
                if (typeof segmentsT === "undefined") { segmentsT = 8; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this);
                this._nextVertexIndex = 0;
                this._currentIndex = 0;
                this._currentTriangleIndex = 0;
                this._numVertices = 0;

                this._radius = radius;
                this._tubeRadius = tubeRadius;
                this._segmentsR = segmentsR;
                this._segmentsT = segmentsT;
                this._yUp = yUp;
            }
            TorusGeometry.prototype.addVertex = function (px, py, pz, nx, ny, nz, tx, ty, tz) {
                var compVertInd = this._vertexOffset + this._nextVertexIndex * this._vertexStride;
                this._rawVertexData[compVertInd++] = px;
                this._rawVertexData[compVertInd++] = py;
                this._rawVertexData[compVertInd++] = pz;
                this._rawVertexData[compVertInd++] = nx;
                this._rawVertexData[compVertInd++] = ny;
                this._rawVertexData[compVertInd++] = nz;
                this._rawVertexData[compVertInd++] = tx;
                this._rawVertexData[compVertInd++] = ty;
                this._rawVertexData[compVertInd] = tz;
                this._nextVertexIndex++;
            };

            TorusGeometry.prototype.addTriangleClockWise = function (cwVertexIndex0, cwVertexIndex1, cwVertexIndex2) {
                this._rawIndices[this._currentIndex++] = cwVertexIndex0;
                this._rawIndices[this._currentIndex++] = cwVertexIndex1;
                this._rawIndices[this._currentIndex++] = cwVertexIndex2;
                this._currentTriangleIndex++;
            };

            /**
            * @inheritDoc
            */
            TorusGeometry.prototype.pBuildGeometry = function (target) {
                var i, j;
                var x, y, z, nx, ny, nz, revolutionAngleR, revolutionAngleT;
                var numTriangles;

                // reset utility variables
                this._numVertices = 0;
                this._nextVertexIndex = 0;
                this._currentIndex = 0;
                this._currentTriangleIndex = 0;
                this._vertexStride = target.vertexStride;
                this._vertexOffset = target.vertexOffset;

                // evaluate target number of vertices, triangles and indices
                this._numVertices = (this._segmentsT + 1) * (this._segmentsR + 1);
                numTriangles = this._segmentsT * this._segmentsR * 2;

                if (this._numVertices == target.numVertices) {
                    this._rawVertexData = target.vertexData;

                    if (target.indexData == null) {
                        this._rawIndices = new Array(numTriangles * 3);
                    } else {
                        this._rawIndices = target.indexData;
                    }
                } else {
                    var numVertComponents = this._numVertices * this._vertexStride;
                    this._rawVertexData = new Array(numVertComponents);
                    this._rawIndices = new Array(numTriangles * 3);
                    this.pInvalidateUVs();
                }

                // evaluate revolution steps
                var revolutionAngleDeltaR = 2 * Math.PI / this._segmentsR;
                var revolutionAngleDeltaT = 2 * Math.PI / this._segmentsT;

                var comp1, comp2;
                var t1, t2, n1, n2;
                var startIndex;

                // surface
                var a, b, c, d, length;

                for (j = 0; j <= this._segmentsT; ++j) {
                    startIndex = this._vertexOffset + this._nextVertexIndex * this._vertexStride;

                    for (i = 0; i <= this._segmentsR; ++i) {
                        // revolution vertex
                        revolutionAngleR = i * revolutionAngleDeltaR;
                        revolutionAngleT = j * revolutionAngleDeltaT;

                        length = Math.cos(revolutionAngleT);
                        nx = length * Math.cos(revolutionAngleR);
                        ny = length * Math.sin(revolutionAngleR);
                        nz = Math.sin(revolutionAngleT);

                        x = this._radius * Math.cos(revolutionAngleR) + this._tubeRadius * nx;
                        y = this._radius * Math.sin(revolutionAngleR) + this._tubeRadius * ny;
                        z = (j == this._segmentsT) ? 0 : this._tubeRadius * nz;

                        if (this._yUp) {
                            n1 = -nz;
                            n2 = ny;
                            t1 = 0;
                            t2 = (length ? nx / length : x / this._radius);
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            n1 = ny;
                            n2 = nz;
                            t1 = (length ? nx / length : x / this._radius);
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._segmentsR) {
                            this.addVertex(x, this._rawVertexData[startIndex + 1], this._rawVertexData[startIndex + 2], nx, n1, n2, -(length ? ny / length : y / this._radius), t1, t2);
                        } else {
                            this.addVertex(x, comp1, comp2, nx, n1, n2, -(length ? ny / length : y / this._radius), t1, t2);
                        }

                        if (i > 0 && j > 0) {
                            a = this._nextVertexIndex - 1;
                            b = this._nextVertexIndex - 2;
                            c = b - this._segmentsR - 1;
                            d = a - this._segmentsR - 1;
                            this.addTriangleClockWise(a, b, c);
                            this.addTriangleClockWise(a, c, d);
                        }
                    }
                }

                // build real data from raw data
                target.updateData(this._rawVertexData);
                target.updateIndexData(this._rawIndices);
            };

            /**
            * @inheritDoc
            */
            TorusGeometry.prototype.pBuildUVs = function (target) {
                var i, j;
                var data;
                var stride = target.UVStride;
                var offset = target.UVOffset;
                var skip = target.UVStride - 2;

                // evaluate num uvs
                var numUvs = this._numVertices * stride;

                if (target.UVData && numUvs == target.UVData.length) {
                    data = target.UVData;
                } else {
                    data = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                // current uv component index
                var currentUvCompIndex = offset;

                for (j = 0; j <= this._segmentsT; ++j) {
                    for (i = 0; i <= this._segmentsR; ++i) {
                        // revolution vertex
                        data[currentUvCompIndex++] = (i / this._segmentsR) * target.scaleU;
                        data[currentUvCompIndex++] = (j / this._segmentsT) * target.scaleV;
                        currentUvCompIndex += skip;
                    }
                }

                // build real data from raw data
                target.updateData(data);
            };

            Object.defineProperty(TorusGeometry.prototype, "radius", {
                get: /**
                * The radius of the torus.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TorusGeometry.prototype, "tubeRadius", {
                get: /**
                * The radius of the inner tube of the torus.
                */
                function () {
                    return this._tubeRadius;
                },
                set: function (value) {
                    this._tubeRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TorusGeometry.prototype, "segmentsR", {
                get: /**
                * Defines the number of horizontal segments that make up the torus. Defaults to 16.
                */
                function () {
                    return this._segmentsR;
                },
                set: function (value) {
                    this._segmentsR = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TorusGeometry.prototype, "segmentsT", {
                get: /**
                * Defines the number of vertical segments that make up the torus. Defaults to 8.
                */
                function () {
                    return this._segmentsT;
                },
                set: function (value) {
                    this._segmentsT = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TorusGeometry.prototype, "yUp", {
                get: /**
                * Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return TorusGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.TorusGeometry = TorusGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import away3d.arcane;
        //import away3d.core.base.CompactSubGeometry;
        //use namespace arcane;
        /**
        * A Cube primitive mesh.
        */
        var CubeGeometry = (function (_super) {
            __extends(CubeGeometry, _super);
            /**
            * Creates a new Cube object.
            * @param width The size of the cube along its X-axis.
            * @param height The size of the cube along its Y-axis.
            * @param depth The size of the cube along its Z-axis.
            * @param segmentsW The number of segments that make up the cube along the X-axis.
            * @param segmentsH The number of segments that make up the cube along the Y-axis.
            * @param segmentsD The number of segments that make up the cube along the Z-axis.
            * @param tile6 The type of uv mapping to use. When true, a texture will be subdivided in a 2x3 grid, each used for a single face. When false, the entire image is mapped on each face.
            */
            function CubeGeometry(width, height, depth, segmentsW, segmentsH, segmentsD, tile6) {
                if (typeof width === "undefined") { width = 100; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof depth === "undefined") { depth = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 1; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof segmentsD === "undefined") { segmentsD = 1; }
                if (typeof tile6 === "undefined") { tile6 = true; }
                _super.call(this);

                this._width = width;
                this._height = height;
                this._depth = depth;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
                this._segmentsD = segmentsD;
                this._tile6 = tile6;
            }
            Object.defineProperty(CubeGeometry.prototype, "width", {
                get: /**
                * The size of the cube along its X-axis.
                */
                function () {
                    return this._width;
                },
                set: function (value) {
                    this._width = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "height", {
                get: /**
                * The size of the cube along its Y-axis.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "depth", {
                get: /**
                * The size of the cube along its Z-axis.
                */
                function () {
                    return this._depth;
                },
                set: function (value) {
                    this._depth = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "tile6", {
                get: /**
                * The type of uv mapping to use. When false, the entire image is mapped on each face.
                * When true, a texture will be subdivided in a 3x2 grid, each used for a single face.
                * Reading the tiles from left to right, top to bottom they represent the faces of the
                * cube in the following order: bottom, top, back, left, front, right. This creates
                * several shared edges (between the top, front, left and right faces) which simplifies
                * texture painting.
                */
                function () {
                    return this._tile6;
                },
                set: function (value) {
                    this._tile6 = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "segmentsW", {
                get: /**
                * The number of segments that make up the cube along the X-axis. Defaults to 1.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "segmentsH", {
                get: /**
                * The number of segments that make up the cube along the Y-axis. Defaults to 1.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CubeGeometry.prototype, "segmentsD", {
                get: /**
                * The number of segments that make up the cube along the Z-axis. Defaults to 1.
                */
                function () {
                    return this._segmentsD;
                },
                set: function (value) {
                    this._segmentsD = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            CubeGeometry.prototype.pBuildGeometry = function (target) {
                var data;
                var indices/*uint*/ ;

                var tl, tr, bl, br;
                var i, j, inc = 0;

                var vidx, fidx;
                var hw, hh, hd;
                var dw, dh, dd;

                var outer_pos;

                var numVerts = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;

                var stride = target.vertexStride;
                var skip = stride - 9;

                if (numVerts == target.numVertices) {
                    data = target.vertexData;

                    indices = (target.indexData) ? target.indexData : new Array((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12);
                    //indices = target.indexData || new Vector.<uint>((_segmentsW*_segmentsH + _segmentsW*_segmentsD + _segmentsH*_segmentsD)*12, true);
                } else {
                    data = new Array(numVerts * stride);
                    indices = new Array((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12);
                    this.pInvalidateUVs();
                }

                // Indices
                vidx = target.vertexOffset;
                fidx = 0;

                // half cube dimensions
                hw = this._width / 2;
                hh = this._height / 2;
                hd = this._depth / 2;

                // Segment dimensions
                dw = this._width / this._segmentsW;
                dh = this._height / this._segmentsH;
                dd = this._depth / this._segmentsD;

                for (i = 0; i <= this._segmentsW; i++) {
                    outer_pos = -hw + i * dw;

                    for (j = 0; j <= this._segmentsH; j++) {
                        // front
                        data[vidx++] = outer_pos;
                        data[vidx++] = -hh + j * dh;
                        data[vidx++] = -hd;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = -1;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        vidx += skip;

                        // back
                        data[vidx++] = outer_pos;
                        data[vidx++] = -hh + j * dh;
                        data[vidx++] = hd;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        data[vidx++] = -1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        vidx += skip;

                        if (i && j) {
                            tl = 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                            tr = 2 * (i * (this._segmentsH + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;

                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }

                inc += 2 * (this._segmentsW + 1) * (this._segmentsH + 1);

                for (i = 0; i <= this._segmentsW; i++) {
                    outer_pos = -hw + i * dw;

                    for (j = 0; j <= this._segmentsD; j++) {
                        // top
                        data[vidx++] = outer_pos;
                        data[vidx++] = hh;
                        data[vidx++] = -hd + j * dd;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        vidx += skip;

                        // bottom
                        data[vidx++] = outer_pos;
                        data[vidx++] = -hh;
                        data[vidx++] = -hd + j * dd;
                        data[vidx++] = 0;
                        data[vidx++] = -1;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        vidx += skip;

                        if (i && j) {
                            tl = inc + 2 * ((i - 1) * (this._segmentsD + 1) + (j - 1));
                            tr = inc + 2 * (i * (this._segmentsD + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;

                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }

                inc += 2 * (this._segmentsW + 1) * (this._segmentsD + 1);

                for (i = 0; i <= this._segmentsD; i++) {
                    outer_pos = hd - i * dd;

                    for (j = 0; j <= this._segmentsH; j++) {
                        // left
                        data[vidx++] = -hw;
                        data[vidx++] = -hh + j * dh;
                        data[vidx++] = outer_pos;
                        data[vidx++] = -1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = -1;
                        vidx += skip;

                        // right
                        data[vidx++] = hw;
                        data[vidx++] = -hh + j * dh;
                        data[vidx++] = outer_pos;
                        data[vidx++] = 1;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 0;
                        data[vidx++] = 1;
                        vidx += skip;

                        if (i && j) {
                            tl = inc + 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                            tr = inc + 2 * (i * (this._segmentsH + 1) + (j - 1));
                            bl = tl + 2;
                            br = tr + 2;

                            indices[fidx++] = tl;
                            indices[fidx++] = bl;
                            indices[fidx++] = br;
                            indices[fidx++] = tl;
                            indices[fidx++] = br;
                            indices[fidx++] = tr;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = br + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tr + 1;
                            indices[fidx++] = bl + 1;
                            indices[fidx++] = tl + 1;
                        }
                    }
                }

                target.updateData(data);
                target.updateIndexData(indices);
            };

            /**
            * @inheritDoc
            */
            CubeGeometry.prototype.pBuildUVs = function (target) {
                var i, j, uidx;
                var data;

                var u_tile_dim, v_tile_dim;
                var u_tile_step, v_tile_step;
                var tl0u, tl0v;
                var tl1u, tl1v;
                var du, dv;
                var stride = target.UVStride;
                var numUvs = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2 * stride;
                var skip = stride - 2;

                if (target.UVData && numUvs == target.UVData.length)
                    data = target.UVData;
else {
                    data = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                if (this._tile6) {
                    u_tile_dim = u_tile_step = 1 / 3;
                    v_tile_dim = v_tile_step = 1 / 2;
                } else {
                    u_tile_dim = v_tile_dim = 1;
                    u_tile_step = v_tile_step = 0;
                }

                // Create planes two and two, the same way that they were
                // constructed in the buildGeometry() function. First calculate
                // the top-left UV coordinate for both planes, and then loop
                // over the points, calculating the UVs from these numbers.
                // When tile6 is true, the layout is as follows:
                //       .-----.-----.-----. (1,1)
                //       | Bot |  T  | Bak |
                //       |-----+-----+-----|
                //       |  L  |  F  |  R  |
                // (0,0)'-----'-----'-----'
                uidx = target.UVOffset;

                // FRONT / BACK
                tl0u = 1 * u_tile_step;
                tl0v = 1 * v_tile_step;
                tl1u = 2 * u_tile_step;
                tl1v = 0 * v_tile_step;
                du = u_tile_dim / this._segmentsW;
                dv = v_tile_dim / this._segmentsH;
                for (i = 0; i <= this._segmentsW; i++) {
                    for (j = 0; j <= this._segmentsH; j++) {
                        data[uidx++] = (tl0u + i * du) * target.scaleU;
                        data[uidx++] = (tl0v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                        data[uidx++] = (tl1u + (u_tile_dim - i * du)) * target.scaleU;
                        data[uidx++] = (tl1v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                    }
                }

                // TOP / BOTTOM
                tl0u = 1 * u_tile_step;
                tl0v = 0 * v_tile_step;
                tl1u = 0 * u_tile_step;
                tl1v = 0 * v_tile_step;
                du = u_tile_dim / this._segmentsW;
                dv = v_tile_dim / this._segmentsD;
                for (i = 0; i <= this._segmentsW; i++) {
                    for (j = 0; j <= this._segmentsD; j++) {
                        data[uidx++] = (tl0u + i * du) * target.scaleU;
                        data[uidx++] = (tl0v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                        data[uidx++] = (tl1u + i * du) * target.scaleU;
                        data[uidx++] = (tl1v + j * dv) * target.scaleV;
                        uidx += skip;
                    }
                }

                // LEFT / RIGHT
                tl0u = 0 * u_tile_step;
                tl0v = 1 * v_tile_step;
                tl1u = 2 * u_tile_step;
                tl1v = 1 * v_tile_step;
                du = u_tile_dim / this._segmentsD;
                dv = v_tile_dim / this._segmentsH;
                for (i = 0; i <= this._segmentsD; i++) {
                    for (j = 0; j <= this._segmentsH; j++) {
                        data[uidx++] = (tl0u + i * du) * target.scaleU;
                        ;
                        data[uidx++] = (tl0v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                        data[uidx++] = (tl1u + (u_tile_dim - i * du)) * target.scaleU;
                        data[uidx++] = (tl1v + (v_tile_dim - j * dv)) * target.scaleV;
                        uidx += skip;
                    }
                }

                target.updateData(data);
            };
            return CubeGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.CubeGeometry = CubeGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A Plane primitive mesh.
        */
        var PlaneGeometry = (function (_super) {
            __extends(PlaneGeometry, _super);
            /**
            * Creates a new Plane object.
            * @param width The width of the plane.
            * @param height The height of the plane.
            * @param segmentsW The number of segments that make up the plane along the X-axis.
            * @param segmentsH The number of segments that make up the plane along the Y or Z-axis.
            * @param yUp Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false).
            * @param doubleSided Defines whether the plane will be visible from both sides, with correct vertex normals.
            */
            function PlaneGeometry(width, height, segmentsW, segmentsH, yUp, doubleSided) {
                if (typeof width === "undefined") { width = 100; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 1; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof yUp === "undefined") { yUp = true; }
                if (typeof doubleSided === "undefined") { doubleSided = false; }
                _super.call(this);

                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
                this._yUp = yUp;
                this._width = width;
                this._height = height;
                this._doubleSided = doubleSided;
            }
            Object.defineProperty(PlaneGeometry.prototype, "segmentsW", {
                get: /**
                * The number of segments that make up the plane along the X-axis. Defaults to 1.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;

                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "segmentsH", {
                get: /**
                * The number of segments that make up the plane along the Y or Z-axis, depending on whether yUp is true or
                * false, respectively. Defaults to 1.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = value;

                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "yUp", {
                get: /**
                *  Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false). Defaults to true.
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "doubleSided", {
                get: /**
                * Defines whether the plane will be visible from both sides, with correct vertex normals (as opposed to bothSides on Material). Defaults to false.
                */
                function () {
                    return this._doubleSided;
                },
                set: function (value) {
                    this._doubleSided = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "width", {
                get: /**
                * The width of the plane.
                */
                function () {
                    return this._width;
                },
                set: function (value) {
                    this._width = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(PlaneGeometry.prototype, "height", {
                get: /**
                * The height of the plane.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            PlaneGeometry.prototype.pBuildGeometry = function (target) {
                var data;
                var indices/*uint*/ ;
                var x, y;
                var numIndices;
                var base;
                var tw = this._segmentsW + 1;
                var numVertices = (this._segmentsH + 1) * tw;
                var stride = target.vertexStride;
                var skip = stride - 9;

                if (this._doubleSided)
                    numVertices *= 2;

                numIndices = this._segmentsH * this._segmentsW * 6;

                if (this._doubleSided)
                    numIndices <<= 1;

                if (numVertices == target.numVertices) {
                    data = target.vertexData;

                    if (indices == null) {
                        indices = new Array(numIndices);
                    } else {
                        indices = target.indexData;
                    }
                } else {
                    data = new Array(numVertices * stride);
                    indices = new Array(numIndices);

                    this.pInvalidateUVs();
                }

                numIndices = 0;

                var index = target.vertexOffset;

                for (var yi = 0; yi <= this._segmentsH; ++yi) {
                    for (var xi = 0; xi <= this._segmentsW; ++xi) {
                        x = (xi / this._segmentsW - .5) * this._width;
                        y = (yi / this._segmentsH - .5) * this._height;

                        data[index++] = x;
                        if (this._yUp) {
                            data[index++] = 0;
                            data[index++] = y;
                        } else {
                            data[index++] = y;
                            data[index++] = 0;
                        }

                        data[index++] = 0;

                        if (this._yUp) {
                            data[index++] = 1;
                            data[index++] = 0;
                        } else {
                            data[index++] = 0;
                            data[index++] = -1;
                        }

                        data[index++] = 1;
                        data[index++] = 0;
                        data[index++] = 0;

                        index += skip;

                        if (this._doubleSided) {
                            for (var i = 0; i < 3; ++i) {
                                data[index] = data[index - stride];
                                ++index;
                            }

                            for (i = 0; i < 3; ++i) {
                                data[index] = -data[index - stride];
                                ++index;
                            }

                            for (i = 0; i < 3; ++i) {
                                data[index] = -data[index - stride];
                                ++index;
                            }

                            index += skip;
                        }

                        if (xi != this._segmentsW && yi != this._segmentsH) {
                            base = xi + yi * tw;
                            var mult = this._doubleSided ? 2 : 1;

                            indices[numIndices++] = base * mult;
                            indices[numIndices++] = (base + tw) * mult;
                            indices[numIndices++] = (base + tw + 1) * mult;
                            indices[numIndices++] = base * mult;
                            indices[numIndices++] = (base + tw + 1) * mult;
                            indices[numIndices++] = (base + 1) * mult;

                            if (this._doubleSided) {
                                indices[numIndices++] = (base + tw + 1) * mult + 1;
                                indices[numIndices++] = (base + tw) * mult + 1;
                                indices[numIndices++] = base * mult + 1;
                                indices[numIndices++] = (base + 1) * mult + 1;
                                indices[numIndices++] = (base + tw + 1) * mult + 1;
                                indices[numIndices++] = base * mult + 1;
                            }
                        }
                    }
                }

                target.updateData(data);
                target.updateIndexData(indices);
            };

            /**
            * @inheritDoc
            */
            PlaneGeometry.prototype.pBuildUVs = function (target) {
                var data;
                var stride = target.UVStride;
                var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
                var skip = stride - 2;

                if (this._doubleSided) {
                    numUvs *= 2;
                }

                if (target.UVData && numUvs == target.UVData.length) {
                    data = target.UVData;
                } else {
                    data = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                var index = target.UVOffset;

                for (var yi = 0; yi <= this._segmentsH; ++yi) {
                    for (var xi = 0; xi <= this._segmentsW; ++xi) {
                        data[index++] = (xi / this._segmentsW) * target.scaleU;
                        data[index++] = (1 - yi / this._segmentsH) * target.scaleV;
                        index += skip;

                        if (this._doubleSided) {
                            data[index++] = (xi / this._segmentsW) * target.scaleU;
                            data[index++] = (1 - yi / this._segmentsH) * target.scaleV;
                            index += skip;
                        }
                    }
                }

                target.updateData(data);
            };
            return PlaneGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.PlaneGeometry = PlaneGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A Capsule primitive mesh.
        */
        var CapsuleGeometry = (function (_super) {
            __extends(CapsuleGeometry, _super);
            /**
            * Creates a new Capsule object.
            * @param radius The radius of the capsule.
            * @param height The height of the capsule.
            * @param segmentsW Defines the number of horizontal segments that make up the capsule. Defaults to 16.
            * @param segmentsH Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven value.
            * @param yUp Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function CapsuleGeometry(radius, height, segmentsW, segmentsH, yUp) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 15; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this);

                this._radius = radius;
                this._height = height;
                this._segmentsW = segmentsW;
                this._segmentsH = (segmentsH % 2 == 0) ? segmentsH + 1 : segmentsH;
                this._yUp = yUp;
            }
            /**
            * @inheritDoc
            */
            CapsuleGeometry.prototype.pBuildGeometry = function (target) {
                var data;
                var indices/*uint*/ ;
                var i;
                var j;
                var triIndex = 0;
                var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
                var stride = target.vertexStride;
                var skip = stride - 9;
                var index = 0;
                var startIndex;
                var comp1, comp2, t1, t2;

                if (numVerts == target.numVertices) {
                    data = target.vertexData;

                    if (target.indexData) {
                        indices = target.indexData;
                    } else {
                        indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
                    }
                } else {
                    data = new Array(numVerts * stride);
                    indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
                    this.pInvalidateUVs();
                }

                for (j = 0; j <= this._segmentsH; ++j) {
                    var horangle = Math.PI * j / this._segmentsH;
                    var z = -this._radius * Math.cos(horangle);
                    var ringradius = this._radius * Math.sin(horangle);

                    startIndex = index;

                    for (i = 0; i <= this._segmentsW; ++i) {
                        var verangle = 2 * Math.PI * i / this._segmentsW;
                        var x = ringradius * Math.cos(verangle);
                        var offset = j > this._segmentsH / 2 ? this._height / 2 : -this._height / 2;
                        var y = ringradius * Math.sin(verangle);
                        var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                        var tanLen = Math.sqrt(y * y + x * x);

                        if (this._yUp) {
                            t1 = 0;
                            t2 = tanLen > .007 ? x / tanLen : 0;
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            t1 = tanLen > .007 ? x / tanLen : 0;
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._segmentsW) {
                            data[index++] = data[startIndex];
                            data[index++] = data[startIndex + 1];
                            data[index++] = data[startIndex + 2];
                            data[index++] = (data[startIndex + 3] + (x * normLen)) * .5;
                            data[index++] = (data[startIndex + 4] + (comp1 * normLen)) * .5;
                            data[index++] = (data[startIndex + 5] + (comp2 * normLen)) * .5;
                            data[index++] = (data[startIndex + 6] + (tanLen > .007 ? -y / tanLen : 1)) * .5;
                            data[index++] = (data[startIndex + 7] + t1) * .5;
                            data[index++] = (data[startIndex + 8] + t2) * .5;
                        } else {
                            // vertex
                            data[index++] = x;
                            data[index++] = (this._yUp) ? comp1 - offset : comp1;
                            data[index++] = (this._yUp) ? comp2 : comp2 + offset;

                            // normal
                            data[index++] = x * normLen;
                            data[index++] = comp1 * normLen;
                            data[index++] = comp2 * normLen;

                            // tangent
                            data[index++] = tanLen > .007 ? -y / tanLen : 1;
                            data[index++] = t1;
                            data[index++] = t2;
                        }

                        if (i > 0 && j > 0) {
                            var a = (this._segmentsW + 1) * j + i;
                            var b = (this._segmentsW + 1) * j + i - 1;
                            var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                            var d = (this._segmentsW + 1) * (j - 1) + i;

                            if (j == this._segmentsH) {
                                data[index - 9] = data[startIndex];
                                data[index - 8] = data[startIndex + 1];
                                data[index - 7] = data[startIndex + 2];

                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            } else if (j == 1) {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                            } else {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            }
                        }

                        index += skip;
                    }
                }

                target.updateData(data);
                target.updateIndexData(indices);
            };

            /**
            * @inheritDoc
            */
            CapsuleGeometry.prototype.pBuildUVs = function (target) {
                var i;
                var j;
                var index;
                var data;
                var stride = target.UVStride;
                var UVlen = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
                var skip = stride - 2;

                if (target.UVData && UVlen == target.UVData.length) {
                    data = target.UVData;
                } else {
                    data = new Array(UVlen);
                    this.pInvalidateGeometry();
                }

                index = target.UVOffset;

                for (j = 0; j <= this._segmentsH; ++j) {
                    for (i = 0; i <= this._segmentsW; ++i) {
                        data[index++] = (i / this._segmentsW) * target.scaleU;
                        data[index++] = (j / this._segmentsH) * target.scaleV;
                        index += skip;
                    }
                }

                target.updateData(data);
            };

            Object.defineProperty(CapsuleGeometry.prototype, "radius", {
                get: /**
                * The radius of the capsule.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CapsuleGeometry.prototype, "height", {
                get: /**
                * The height of the capsule.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CapsuleGeometry.prototype, "segmentsW", {
                get: /**
                * Defines the number of horizontal segments that make up the capsule. Defaults to 16.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CapsuleGeometry.prototype, "segmentsH", {
                get: /**
                * Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = (value % 2 == 0) ? value + 1 : value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CapsuleGeometry.prototype, "yUp", {
                get: /**
                * Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return CapsuleGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.CapsuleGeometry = CapsuleGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A Cylinder primitive mesh.
        */
        var CylinderGeometry = (function (_super) {
            __extends(CylinderGeometry, _super);
            /**
            * Creates a new Cylinder object.
            * @param topRadius The radius of the top end of the cylinder.
            * @param bottomRadius The radius of the bottom end of the cylinder
            * @param height The radius of the bottom end of the cylinder
            * @param segmentsW Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
            * @param segmentsH Defines the number of vertical segments that make up the cylinder. Defaults to 1.
            * @param topClosed Defines whether the top end of the cylinder is closed (true) or open.
            * @param bottomClosed Defines whether the bottom end of the cylinder is closed (true) or open.
            * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function CylinderGeometry(topRadius, bottomRadius, height, segmentsW, segmentsH, topClosed, bottomClosed, surfaceClosed, yUp) {
                if (typeof topRadius === "undefined") { topRadius = 50; }
                if (typeof bottomRadius === "undefined") { bottomRadius = 50; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof topClosed === "undefined") { topClosed = true; }
                if (typeof bottomClosed === "undefined") { bottomClosed = true; }
                if (typeof surfaceClosed === "undefined") { surfaceClosed = true; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this);
                this._currentIndex = 0;
                this._numVertices = 0;

                this._topRadius = topRadius;
                this._pBottomRadius = bottomRadius;
                this._height = height;
                this._pSegmentsW = segmentsW;
                this._pSegmentsH = segmentsH;
                this._topClosed = topClosed;
                this._bottomClosed = bottomClosed;
                this._surfaceClosed = surfaceClosed;
                this._yUp = yUp;
            }
            CylinderGeometry.prototype.addVertex = function (px, py, pz, nx, ny, nz, tx, ty, tz) {
                var compVertInd = this._vertexOffset + this._nextVertexIndex * this._stride;
                this._rawData[compVertInd++] = px;
                this._rawData[compVertInd++] = py;
                this._rawData[compVertInd++] = pz;
                this._rawData[compVertInd++] = nx;
                this._rawData[compVertInd++] = ny;
                this._rawData[compVertInd++] = nz;
                this._rawData[compVertInd++] = tx;
                this._rawData[compVertInd++] = ty;
                this._rawData[compVertInd++] = tz;
                this._nextVertexIndex++;
            };

            CylinderGeometry.prototype.addTriangleClockWise = function (cwVertexIndex0, cwVertexIndex1, cwVertexIndex2) {
                this._rawIndices[this._currentIndex++] = cwVertexIndex0;
                this._rawIndices[this._currentIndex++] = cwVertexIndex1;
                this._rawIndices[this._currentIndex++] = cwVertexIndex2;
                this._currentTriangleIndex++;
            };

            /**
            * @inheritDoc
            */
            CylinderGeometry.prototype.pBuildGeometry = function (target) {
                var i;
                var j;
                var x;
                var y;
                var z;
                var radius;
                var revolutionAngle;

                var dr;
                var latNormElev;
                var latNormBase;
                var numTriangles = 0;

                var comp1;
                var comp2;
                var startIndex = 0;

                var t1;
                var t2;

                this._stride = target.vertexStride;
                this._vertexOffset = target.vertexOffset;

                // reset utility variables
                this._numVertices = 0;
                this._nextVertexIndex = 0;
                this._currentIndex = 0;
                this._currentTriangleIndex = 0;

                if (this._surfaceClosed) {
                    this._numVertices += (this._pSegmentsH + 1) * (this._pSegmentsW + 1);
                    numTriangles += this._pSegmentsH * this._pSegmentsW * 2;
                }
                if (this._topClosed) {
                    this._numVertices += 2 * (this._pSegmentsW + 1);
                    numTriangles += this._pSegmentsW;
                }
                if (this._bottomClosed) {
                    this._numVertices += 2 * (this._pSegmentsW + 1);
                    numTriangles += this._pSegmentsW;
                }

                if (this._numVertices == target.numVertices) {
                    this._rawData = target.vertexData;

                    if (target.indexData) {
                        this._rawIndices = target.indexData;
                    } else {
                        this._rawIndices = new Array(numTriangles * 3);
                    }
                } else {
                    var numVertComponents = this._numVertices * this._stride;
                    this._rawData = new Array(numVertComponents);
                    this._rawIndices = new Array(numTriangles * 3);
                }

                // evaluate revolution steps
                var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;

                if (this._topClosed && this._topRadius > 0) {
                    z = -0.5 * this._height;

                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        if (this._yUp) {
                            t1 = 1;
                            t2 = 0;
                            comp1 = -z;
                            comp2 = 0;
                        } else {
                            t1 = 0;
                            t2 = -1;
                            comp1 = 0;
                            comp2 = z;
                        }

                        this.addVertex(0, comp1, comp2, 0, t1, t2, 1, 0, 0);

                        // revolution vertex
                        revolutionAngle = i * revolutionAngleDelta;
                        x = this._topRadius * Math.cos(revolutionAngle);
                        y = this._topRadius * Math.sin(revolutionAngle);

                        if (this._yUp) {
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._pSegmentsW)
                            this.addVertex(this._rawData[startIndex + this._stride], this._rawData[startIndex + this._stride + 1], this._rawData[startIndex + this._stride + 2], 0, t1, t2, 1, 0, 0);
else
                            this.addVertex(x, comp1, comp2, 0, t1, t2, 1, 0, 0);

                        if (i > 0)
                            this.addTriangleClockWise(this._nextVertexIndex - 1, this._nextVertexIndex - 3, this._nextVertexIndex - 2);
                    }
                }

                if (this._bottomClosed && this._pBottomRadius > 0) {
                    z = 0.5 * this._height;

                    startIndex = this._vertexOffset + this._nextVertexIndex * this._stride;

                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        if (this._yUp) {
                            t1 = -1;
                            t2 = 0;
                            comp1 = -z;
                            comp2 = 0;
                        } else {
                            t1 = 0;
                            t2 = 1;
                            comp1 = 0;
                            comp2 = z;
                        }

                        this.addVertex(0, comp1, comp2, 0, t1, t2, 1, 0, 0);

                        // revolution vertex
                        revolutionAngle = i * revolutionAngleDelta;
                        x = this._pBottomRadius * Math.cos(revolutionAngle);
                        y = this._pBottomRadius * Math.sin(revolutionAngle);

                        if (this._yUp) {
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._pSegmentsW)
                            this.addVertex(x, this._rawData[startIndex + 1], this._rawData[startIndex + 2], 0, t1, t2, 1, 0, 0);
else
                            this.addVertex(x, comp1, comp2, 0, t1, t2, 1, 0, 0);

                        if (i > 0)
                            this.addTriangleClockWise(this._nextVertexIndex - 2, this._nextVertexIndex - 3, this._nextVertexIndex - 1);
                    }
                }

                // The normals on the lateral surface all have the same incline, i.e.
                // the "elevation" component (Y or Z depending on yUp) is constant.
                // Same principle goes for the "base" of these vectors, which will be
                // calculated such that a vector [base,elev] will be a unit vector.
                dr = (this._pBottomRadius - this._topRadius);
                latNormElev = dr / this._height;
                latNormBase = (latNormElev == 0) ? 1 : this._height / dr;

                if (this._surfaceClosed) {
                    var a;
                    var b;
                    var c;
                    var d;
                    var na0, na1, naComp1, naComp2;

                    for (j = 0; j <= this._pSegmentsH; ++j) {
                        radius = this._topRadius - ((j / this._pSegmentsH) * (this._topRadius - this._pBottomRadius));
                        z = -(this._height / 2) + (j / this._pSegmentsH * this._height);

                        startIndex = this._vertexOffset + this._nextVertexIndex * this._stride;

                        for (i = 0; i <= this._pSegmentsW; ++i) {
                            // revolution vertex
                            revolutionAngle = i * revolutionAngleDelta;
                            x = radius * Math.cos(revolutionAngle);
                            y = radius * Math.sin(revolutionAngle);
                            na0 = latNormBase * Math.cos(revolutionAngle);
                            na1 = latNormBase * Math.sin(revolutionAngle);

                            if (this._yUp) {
                                t1 = 0;
                                t2 = -na0;
                                comp1 = -z;
                                comp2 = y;
                                naComp1 = latNormElev;
                                naComp2 = na1;
                            } else {
                                t1 = -na0;
                                t2 = 0;
                                comp1 = y;
                                comp2 = z;
                                naComp1 = na1;
                                naComp2 = latNormElev;
                            }

                            if (i == this._pSegmentsW) {
                                this.addVertex(this._rawData[startIndex], this._rawData[startIndex + 1], this._rawData[startIndex + 2], na0, latNormElev, na1, na1, t1, t2);
                            } else {
                                this.addVertex(x, comp1, comp2, na0, naComp1, naComp2, -na1, t1, t2);
                            }

                            if (i > 0 && j > 0) {
                                a = this._nextVertexIndex - 1;
                                b = this._nextVertexIndex - 2;
                                c = b - this._pSegmentsW - 1;
                                d = a - this._pSegmentsW - 1;
                                this.addTriangleClockWise(a, b, c);
                                this.addTriangleClockWise(a, c, d);
                            }
                        }
                    }
                }

                // build real data from raw data
                target.updateData(this._rawData);
                target.updateIndexData(this._rawIndices);
            };

            /**
            * @inheritDoc
            */
            CylinderGeometry.prototype.pBuildUVs = function (target) {
                var i;
                var j;
                var x;
                var y;
                var revolutionAngle;
                var stride = target.UVStride;
                var skip = stride - 2;
                var UVData;

                // evaluate num uvs
                var numUvs = this._numVertices * stride;

                if (target.UVData && numUvs == target.UVData.length) {
                    UVData = target.UVData;
                } else {
                    UVData = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                // evaluate revolution steps
                var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;

                // current uv component index
                var currentUvCompIndex = target.UVOffset;

                if (this._topClosed) {
                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        revolutionAngle = i * revolutionAngleDelta;
                        x = 0.5 + 0.5 * -Math.cos(revolutionAngle);
                        y = 0.5 + 0.5 * Math.sin(revolutionAngle);

                        UVData[currentUvCompIndex++] = 0.5 * target.scaleU;
                        UVData[currentUvCompIndex++] = 0.5 * target.scaleV;
                        currentUvCompIndex += skip;
                        UVData[currentUvCompIndex++] = x * target.scaleU;
                        UVData[currentUvCompIndex++] = y * target.scaleV;
                        currentUvCompIndex += skip;
                    }
                }

                if (this._bottomClosed) {
                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        revolutionAngle = i * revolutionAngleDelta;
                        x = 0.5 + 0.5 * Math.cos(revolutionAngle);
                        y = 0.5 + 0.5 * Math.sin(revolutionAngle);

                        UVData[currentUvCompIndex++] = 0.5 * target.scaleU;
                        UVData[currentUvCompIndex++] = 0.5 * target.scaleV;
                        currentUvCompIndex += skip;
                        UVData[currentUvCompIndex++] = x * target.scaleU;
                        UVData[currentUvCompIndex++] = y * target.scaleV;
                        currentUvCompIndex += skip;
                    }
                }

                if (this._surfaceClosed) {
                    for (j = 0; j <= this._pSegmentsH; ++j) {
                        for (i = 0; i <= this._pSegmentsW; ++i) {
                            // revolution vertex
                            UVData[currentUvCompIndex++] = (i / this._pSegmentsW) * target.scaleU;
                            UVData[currentUvCompIndex++] = (j / this._pSegmentsH) * target.scaleV;
                            currentUvCompIndex += skip;
                        }
                    }
                }

                // build real data from raw data
                target.updateData(UVData);
            };

            Object.defineProperty(CylinderGeometry.prototype, "topRadius", {
                get: /**
                * The radius of the top end of the cylinder.
                */
                function () {
                    return this._topRadius;
                },
                set: function (value) {
                    this._topRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "bottomRadius", {
                get: /**
                * The radius of the bottom end of the cylinder.
                */
                function () {
                    return this._pBottomRadius;
                },
                set: function (value) {
                    this._pBottomRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "height", {
                get: /**
                * The radius of the top end of the cylinder.
                */
                function () {
                    return this._height;
                },
                set: function (value) {
                    this._height = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "segmentsW", {
                get: /**
                * Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
                */
                function () {
                    return this._pSegmentsW;
                },
                set: function (value) {
                    this.setSegmentsW(value);
                },
                enumerable: true,
                configurable: true
            });


            CylinderGeometry.prototype.setSegmentsW = function (value) {
                this._pSegmentsW = value;
                this.pInvalidateGeometry();
                this.pInvalidateUVs();
            };

            Object.defineProperty(CylinderGeometry.prototype, "segmentsH", {
                get: /**
                * Defines the number of vertical segments that make up the cylinder. Defaults to 1.
                */
                function () {
                    return this._pSegmentsH;
                },
                set: function (value) {
                    this.setSegmentsH(value);
                },
                enumerable: true,
                configurable: true
            });


            CylinderGeometry.prototype.setSegmentsH = function (value) {
                this._pSegmentsH = value;
                this.pInvalidateGeometry();
                this.pInvalidateUVs();
            };

            Object.defineProperty(CylinderGeometry.prototype, "topClosed", {
                get: /**
                * Defines whether the top end of the cylinder is closed (true) or open.
                */
                function () {
                    return this._topClosed;
                },
                set: function (value) {
                    this._topClosed = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "bottomClosed", {
                get: /**
                * Defines whether the bottom end of the cylinder is closed (true) or open.
                */
                function () {
                    return this._bottomClosed;
                },
                set: function (value) {
                    this._bottomClosed = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CylinderGeometry.prototype, "yUp", {
                get: /**
                * Defines whether the cylinder poles should lay on the Y-axis (true) or on the Z-axis (false).
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return CylinderGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.CylinderGeometry = CylinderGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A UV Cone primitive mesh.
        */
        var ConeGeometry = (function (_super) {
            __extends(ConeGeometry, _super);
            /**
            * Creates a new Cone object.
            * @param radius The radius of the bottom end of the cone
            * @param height The height of the cone
            * @param segmentsW Defines the number of horizontal segments that make up the cone. Defaults to 16.
            * @param segmentsH Defines the number of vertical segments that make up the cone. Defaults to 1.
            * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function ConeGeometry(radius, height, segmentsW, segmentsH, closed, yUp) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof height === "undefined") { height = 100; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 1; }
                if (typeof closed === "undefined") { closed = true; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this, 0, radius, height, segmentsW, segmentsH, false, closed, true, yUp);
            }
            Object.defineProperty(ConeGeometry.prototype, "radius", {
                get: /**
                * The radius of the bottom end of the cone.
                */
                function () {
                    return this._pBottomRadius;
                },
                set: function (value) {
                    this._pBottomRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return ConeGeometry;
        })(away.primitives.CylinderGeometry);
        primitives.ConeGeometry = ConeGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        /**
        * A UV RegularPolygon primitive mesh.
        */
        var RegularPolygonGeometry = (function (_super) {
            __extends(RegularPolygonGeometry, _super);
            /**
            * Creates a new RegularPolygon disc object.
            * @param radius The radius of the regular polygon
            * @param sides Defines the number of sides of the regular polygon.
            * @param yUp Defines whether the regular polygon should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function RegularPolygonGeometry(radius, sides, yUp) {
                if (typeof radius === "undefined") { radius = 100; }
                if (typeof sides === "undefined") { sides = 16; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this, radius, 0, 0, sides, 1, true, false, false, yUp);
            }
            Object.defineProperty(RegularPolygonGeometry.prototype, "radius", {
                get: /**
                * The radius of the regular polygon.
                */
                function () {
                    return this._pBottomRadius;
                },
                set: function (value) {
                    this._pBottomRadius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RegularPolygonGeometry.prototype, "sides", {
                get: /**
                * The number of sides of the regular polygon.
                */
                function () {
                    return this._pSegmentsW;
                },
                set: function (value) {
                    this.setSegmentsW(value);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RegularPolygonGeometry.prototype, "subdivisions", {
                get: /**
                * The number of subdivisions from the edge to the center of the regular polygon.
                */
                function () {
                    return this._pSegmentsH;
                },
                set: function (value) {
                    this.setSegmentsH(value);
                },
                enumerable: true,
                configurable: true
            });

            return RegularPolygonGeometry;
        })(away.primitives.CylinderGeometry);
        primitives.RegularPolygonGeometry = RegularPolygonGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (primitives) {
        //import away3d.arcane;
        //import away3d.core.base.CompactSubGeometry;
        /**
        * A UV Sphere primitive mesh.
        */
        var SphereGeometry = (function (_super) {
            __extends(SphereGeometry, _super);
            /**
            * Creates a new Sphere object.
            * @param radius The radius of the sphere.
            * @param segmentsW Defines the number of horizontal segments that make up the sphere.
            * @param segmentsH Defines the number of vertical segments that make up the sphere.
            * @param yUp Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
            */
            function SphereGeometry(radius, segmentsW, segmentsH, yUp) {
                if (typeof radius === "undefined") { radius = 50; }
                if (typeof segmentsW === "undefined") { segmentsW = 16; }
                if (typeof segmentsH === "undefined") { segmentsH = 12; }
                if (typeof yUp === "undefined") { yUp = true; }
                _super.call(this);

                this._radius = radius;
                this._segmentsW = segmentsW;
                this._segmentsH = segmentsH;
                this._yUp = yUp;
            }
            /**
            * @inheritDoc
            */
            SphereGeometry.prototype.pBuildGeometry = function (target) {
                var vertices;
                var indices/*uint*/ ;
                var i;
                var j;
                var triIndex = 0;
                var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
                var stride = target.vertexStride;
                var skip = stride - 9;

                if (numVerts == target.numVertices) {
                    vertices = target.vertexData;

                    if (target.indexData) {
                        indices = target.indexData;
                    } else {
                        indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
                    }
                } else {
                    vertices = new Array(numVerts * stride);
                    indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
                    this.pInvalidateGeometry();
                }

                var startIndex;
                var index = target.vertexOffset;
                var comp1;
                var comp2;
                var t1;
                var t2;

                for (j = 0; j <= this._segmentsH; ++j) {
                    startIndex = index;

                    var horangle = Math.PI * j / this._segmentsH;
                    var z = -this._radius * Math.cos(horangle);
                    var ringradius = this._radius * Math.sin(horangle);

                    for (i = 0; i <= this._segmentsW; ++i) {
                        var verangle = 2 * Math.PI * i / this._segmentsW;
                        var x = ringradius * Math.cos(verangle);
                        var y = ringradius * Math.sin(verangle);
                        var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                        var tanLen = Math.sqrt(y * y + x * x);

                        if (this._yUp) {
                            t1 = 0;
                            t2 = tanLen > .007 ? x / tanLen : 0;
                            comp1 = -z;
                            comp2 = y;
                        } else {
                            t1 = tanLen > .007 ? x / tanLen : 0;
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                        }

                        if (i == this._segmentsW) {
                            vertices[index++] = vertices[startIndex];
                            vertices[index++] = vertices[startIndex + 1];
                            vertices[index++] = vertices[startIndex + 2];
                            vertices[index++] = vertices[startIndex + 3] + (x * normLen) * .5;
                            vertices[index++] = vertices[startIndex + 4] + (comp1 * normLen) * .5;
                            vertices[index++] = vertices[startIndex + 5] + (comp2 * normLen) * .5;
                            vertices[index++] = tanLen > .007 ? -y / tanLen : 1;
                            vertices[index++] = t1;
                            vertices[index++] = t2;
                        } else {
                            vertices[index++] = x;
                            vertices[index++] = comp1;
                            vertices[index++] = comp2;
                            vertices[index++] = x * normLen;
                            vertices[index++] = comp1 * normLen;
                            vertices[index++] = comp2 * normLen;
                            vertices[index++] = tanLen > .007 ? -y / tanLen : 1;
                            vertices[index++] = t1;
                            vertices[index++] = t2;
                        }

                        if (i > 0 && j > 0) {
                            var a = (this._segmentsW + 1) * j + i;
                            var b = (this._segmentsW + 1) * j + i - 1;
                            var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                            var d = (this._segmentsW + 1) * (j - 1) + i;

                            if (j == this._segmentsH) {
                                vertices[index - 9] = vertices[startIndex];
                                vertices[index - 8] = vertices[startIndex + 1];
                                vertices[index - 7] = vertices[startIndex + 2];

                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            } else if (j == 1) {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                            } else {
                                indices[triIndex++] = a;
                                indices[triIndex++] = b;
                                indices[triIndex++] = c;
                                indices[triIndex++] = a;
                                indices[triIndex++] = c;
                                indices[triIndex++] = d;
                            }
                        }

                        index += skip;
                    }
                }

                target.updateData(vertices);
                target.updateIndexData(indices);
            };

            /**
            * @inheritDoc
            */
            SphereGeometry.prototype.pBuildUVs = function (target) {
                var i, j;
                var stride = target.UVStride;
                var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
                var data;
                var skip = stride - 2;

                if (target.UVData && numUvs == target.UVData.length)
                    data = target.UVData;
else {
                    data = new Array(numUvs);
                    this.pInvalidateGeometry();
                }

                var index = target.UVOffset;
                for (j = 0; j <= this._segmentsH; ++j) {
                    for (i = 0; i <= this._segmentsW; ++i) {
                        data[index++] = (i / this._segmentsW) * target.scaleU;
                        data[index++] = (j / this._segmentsH) * target.scaleV;
                        index += skip;
                    }
                }

                target.updateData(data);
            };

            Object.defineProperty(SphereGeometry.prototype, "radius", {
                get: /**
                * The radius of the sphere.
                */
                function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SphereGeometry.prototype, "segmentsW", {
                get: /**
                * Defines the number of horizontal segments that make up the sphere. Defaults to 16.
                */
                function () {
                    return this._segmentsW;
                },
                set: function (value) {
                    this._segmentsW = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SphereGeometry.prototype, "segmentsH", {
                get: /**
                * Defines the number of vertical segments that make up the sphere. Defaults to 12.
                */
                function () {
                    return this._segmentsH;
                },
                set: function (value) {
                    this._segmentsH = value;
                    this.pInvalidateGeometry();
                    this.pInvalidateUVs();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SphereGeometry.prototype, "yUp", {
                get: /**
                * Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
                */
                function () {
                    return this._yUp;
                },
                set: function (value) {
                    this._yUp = value;
                    this.pInvalidateGeometry();
                },
                enumerable: true,
                configurable: true
            });

            return SphereGeometry;
        })(away.primitives.PrimitiveBase);
        primitives.SphereGeometry = SphereGeometry;
    })(away.primitives || (away.primitives = {}));
    var primitives = away.primitives;
})(away || (away = {}));
var away;
(function (away) {
    (function (utils) {
        var ColorUtils = (function () {
            function ColorUtils() {
            }
            ColorUtils.float32ColorToARGB = function (float32Color) {
                var a = (float32Color & 0xff000000) >>> 24;
                var r = (float32Color & 0xff0000) >>> 16;
                var g = (float32Color & 0xff00) >>> 8;
                var b = float32Color & 0xff;
                var result = [a, r, g, b];

                return result;
            };

            ColorUtils.componentToHex = function (c) {
                var hex = c.toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            };

            ColorUtils.RGBToHexString = function (argb) {
                return "#" + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
            };

            ColorUtils.ARGBToHexString = function (argb) {
                return "#" + ColorUtils.componentToHex(argb[0]) + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
            };
            return ColorUtils;
        })();
        utils.ColorUtils = ColorUtils;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (geom) {
        var ColorTransform = (function () {
            function ColorTransform(inRedMultiplier, inGreenMultiplier, inBlueMultiplier, inAlphaMultiplier, inRedOffset, inGreenOffset, inBlueOffset, inAlphaOffset) {
                if (typeof inRedMultiplier === "undefined") { inRedMultiplier = 1.0; }
                if (typeof inGreenMultiplier === "undefined") { inGreenMultiplier = 1.0; }
                if (typeof inBlueMultiplier === "undefined") { inBlueMultiplier = 1.0; }
                if (typeof inAlphaMultiplier === "undefined") { inAlphaMultiplier = 1.0; }
                if (typeof inRedOffset === "undefined") { inRedOffset = 0.0; }
                if (typeof inGreenOffset === "undefined") { inGreenOffset = 0.0; }
                if (typeof inBlueOffset === "undefined") { inBlueOffset = 0.0; }
                if (typeof inAlphaOffset === "undefined") { inAlphaOffset = 0.0; }
                this.redMultiplier = inRedMultiplier;
                this.greenMultiplier = inGreenMultiplier;
                this.blueMultiplier = inBlueMultiplier;
                this.alphaMultiplier = inAlphaMultiplier;
                this.redOffset = inRedOffset;
                this.greenOffset = inGreenOffset;
                this.blueOffset = inBlueOffset;
                this.alphaOffset = inAlphaOffset;
            }
            ColorTransform.prototype.concat = function (second) {
                this.redMultiplier += second.redMultiplier;
                this.greenMultiplier += second.greenMultiplier;
                this.blueMultiplier += second.blueMultiplier;
                this.alphaMultiplier += second.alphaMultiplier;
            };

            Object.defineProperty(ColorTransform.prototype, "color", {
                get: function () {
                    return ((this.redOffset << 16) | (this.greenOffset << 8) | this.blueOffset);
                },
                set: function (value) {
                    var argb = away.utils.ColorUtils.float32ColorToARGB(value);

                    this.redOffset = argb[1];
                    this.greenOffset = argb[2];
                    this.blueOffset = argb[3];

                    this.redMultiplier = 0;
                    this.greenMultiplier = 0;
                    this.blueMultiplier = 0;
                },
                enumerable: true,
                configurable: true
            });

            return ColorTransform;
        })();
        geom.ColorTransform = ColorTransform;
    })(away.geom || (away.geom = {}));
    var geom = away.geom;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * Options for setting the animation mode of a vertex animator object.
        *
        * @see away.animators.VertexAnimator
        */
        var VertexAnimationMode = (function () {
            function VertexAnimationMode() {
            }
            VertexAnimationMode.ADDITIVE = "additive";

            VertexAnimationMode.ABSOLUTE = "absolute";
            return VertexAnimationMode;
        })();
        animators.VertexAnimationMode = VertexAnimationMode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * Provides an abstract base class for nodes in an animation blend tree.
        */
        var AnimationNodeBase = (function (_super) {
            __extends(AnimationNodeBase, _super);
            /**
            * Creates a new <code>AnimationNodeBase</code> object.
            */
            function AnimationNodeBase() {
                _super.call(this);

                this._iUniqueId = away.animators.AnimationNodeBase.ANIMATIONNODE_ID_COUNT++;
            }
            Object.defineProperty(AnimationNodeBase.prototype, "stateClass", {
                get: function () {
                    return this._pStateClass;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            AnimationNodeBase.prototype.dispose = function () {
            };

            Object.defineProperty(AnimationNodeBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.ANIMATION_NODE;
                },
                enumerable: true,
                configurable: true
            });
            AnimationNodeBase.ANIMATIONNODE_ID_COUNT = 0;
            return AnimationNodeBase;
        })(away.library.NamedAssetBase);
        animators.AnimationNodeBase = AnimationNodeBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * Provides an abstract base class for nodes with time-based animation data in an animation blend tree.
        */
        var AnimationClipNodeBase = (function (_super) {
            __extends(AnimationClipNodeBase, _super);
            /**
            * Creates a new <code>AnimationClipNodeBase</code> object.
            */
            function AnimationClipNodeBase() {
                _super.call(this);
                this._pLooping = true;
                this._pTotalDuration = 0;
                this._pStitchDirty = true;
                this._pStitchFinalFrame = false;
                this._pNumFrames = 0;
                this._pDurations = new Array();
                this._pTotalDelta = new away.geom.Vector3D();
                this.fixedFrameRate = true;
            }
            Object.defineProperty(AnimationClipNodeBase.prototype, "looping", {
                get: /**
                * Determines whether the contents of the animation node have looping characteristics enabled.
                */
                function () {
                    return this._pLooping;
                },
                set: function (value) {
                    if (this._pLooping == value)
                        return;

                    this._pLooping = value;

                    this._pStitchDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimationClipNodeBase.prototype, "stitchFinalFrame", {
                get: /**
                * Defines if looping content blends the final frame of animation data with the first (true) or works on the
                * assumption that both first and last frames are identical (false). Defaults to false.
                */
                function () {
                    return this._pStitchFinalFrame;
                },
                set: function (value) {
                    if (this._pStitchFinalFrame == value)
                        return;

                    this._pStitchFinalFrame = value;

                    this._pStitchDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimationClipNodeBase.prototype, "totalDuration", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pTotalDuration;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "totalDelta", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pTotalDelta;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "lastFrame", {
                get: function () {
                    if (this._pStitchDirty)
                        this._pUpdateStitch();

                    return this._pLastFrame;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipNodeBase.prototype, "durations", {
                get: /**
                * Returns a vector of time values representing the duration (in milliseconds) of each animation frame in the clip.
                */
                function () {
                    return this._pDurations;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates the node's final frame stitch state.
            *
            * @see #stitchFinalFrame
            */
            AnimationClipNodeBase.prototype._pUpdateStitch = function () {
                this._pStitchDirty = false;

                this._pLastFrame = (this._pStitchFinalFrame) ? this._pNumFrames : this._pNumFrames - 1;

                this._pTotalDuration = 0;
                this._pTotalDelta.x = 0;
                this._pTotalDelta.y = 0;
                this._pTotalDelta.z = 0;
            };
            return AnimationClipNodeBase;
        })(animators.AnimationNodeBase);
        animators.AnimationClipNodeBase = AnimationClipNodeBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        * A vertex animation node containing time-based animation data as individual geometry obejcts.
        */
        var VertexClipNode = (function (_super) {
            __extends(VertexClipNode, _super);
            /**
            * Creates a new <code>VertexClipNode</code> object.
            */
            function VertexClipNode() {
                _super.call(this);
                this._frames = new Array();
                this._translations = new Array();

                this._pStateClass = away.animators.VertexClipState;
            }
            Object.defineProperty(VertexClipNode.prototype, "frames", {
                get: /**
                * Returns a vector of geometry frames representing the vertex values of each animation frame in the clip.
                */
                function () {
                    return this._frames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds a geometry object to the internal timeline of the animation node.
            *
            * @param geometry The geometry object to add to the timeline of the node.
            * @param duration The specified duration of the frame in milliseconds.
            * @param translation The absolute translation of the frame, used in root delta calculations for mesh movement.
            */
            VertexClipNode.prototype.addFrame = function (geometry, duration/*uint*/ , translation) {
                if (typeof translation === "undefined") { translation = null; }
                this._frames.push(geometry);
                this._pDurations.push(duration);
                this._translations.push(translation || new away.geom.Vector3D());

                this._pNumFrames = this._pDurations.length;

                this._pStitchDirty = true;
            };

            /**
            * @inheritDoc
            */
            VertexClipNode.prototype._pUpdateStitch = function () {
                _super.prototype._pUpdateStitch.call(this);

                var i = this._pNumFrames - 1;
                var p1, p2, delta;
                while (i--) {
                    this._pTotalDuration += this._pDurations[i];
                    p1 = this._translations[i];
                    p2 = this._translations[i + 1];
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }

                if (this._pNumFrames > 1 && (this._pStitchFinalFrame || !this._pLooping)) {
                    this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
                    p1 = this._translations[0];
                    p2 = this._translations[1];
                    delta = p2.subtract(p1);
                    this._pTotalDelta.x += delta.x;
                    this._pTotalDelta.y += delta.y;
                    this._pTotalDelta.z += delta.z;
                }
            };
            return VertexClipNode;
        })(animators.AnimationClipNodeBase);
        animators.VertexClipNode = VertexClipNode;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        *
        */
        var AnimationStateBase = (function () {
            function AnimationStateBase(animator, animationNode) {
                this._rootDelta = new away.geom.Vector3D();
                this._positionDeltaDirty = true;
                this._pAnimator = animator;
                this._animationNode = animationNode;
            }
            Object.defineProperty(AnimationStateBase.prototype, "positionDelta", {
                get: /**
                * Returns a 3d vector representing the translation delta of the animating entity for the current timestep of animation
                */
                function () {
                    if (this._positionDeltaDirty) {
                        this._pUpdatePositionDelta();
                    }

                    return this._rootDelta;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Resets the start time of the node to a  new value.
            *
            * @param startTime The absolute start time (in milliseconds) of the node's starting time.
            */
            AnimationStateBase.prototype.offset = function (startTime) {
                this._pStartTime = startTime;

                this._positionDeltaDirty = true;
            };

            /**
            * Updates the configuration of the node to its current state.
            *
            * @param time The absolute time (in milliseconds) of the animator's play head position.
            *
            * @see away.animators.AnimatorBase#update()
            */
            AnimationStateBase.prototype.update = function (time) {
                if (this._pTime == time - this._pStartTime) {
                    return;
                }

                this._pUpdateTime(time);
            };

            /**
            * Sets the animation phase of the node.
            *
            * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
            */
            AnimationStateBase.prototype.phase = function (value) {
            };

            /**
            * Updates the node's internal playhead position.
            *
            * @param time The local time (in milliseconds) of the node's playhead position.
            */
            AnimationStateBase.prototype._pUpdateTime = function (time) {
                this._pTime = time - this._pStartTime;

                this._positionDeltaDirty = true;
            };

            /**
            * Updates the node's root delta position
            */
            AnimationStateBase.prototype._pUpdatePositionDelta = function () {
            };
            return AnimationStateBase;
        })();
        animators.AnimationStateBase = AnimationStateBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        *
        */
        var AnimationClipState = (function (_super) {
            __extends(AnimationClipState, _super);
            function AnimationClipState(animator, animationClipNode) {
                _super.call(this, animator, animationClipNode);
                this._pFramesDirty = true;

                this._animationClipNode = animationClipNode;
            }
            Object.defineProperty(AnimationClipState.prototype, "blendWeight", {
                get: /**
                * Returns a fractional value between 0 and 1 representing the blending ratio of the current playhead position
                * between the current frame (0) and next frame (1) of the animation.
                *
                * @see #currentFrame
                * @see #nextFrame
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pBlendWeight;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipState.prototype, "currentFrame", {
                get: /**
                * Returns the current frame of animation in the clip based on the internal playhead position.
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pCurrentFrame;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationClipState.prototype, "nextFrame", {
                get: /**
                * Returns the next frame of animation in the clip based on the internal playhead position.
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._pNextFrame;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype.update = function (time/*int*/ ) {
                if (!this._animationClipNode.looping) {
                    if (time > this._pStartTime + this._animationClipNode.totalDuration)
                        time = this._pStartTime + this._animationClipNode.totalDuration;
else if (time < this._pStartTime)
                        time = this._pStartTime;
                }

                if (this._pTime == time - this._pStartTime)
                    return;

                this._pUpdateTime(time);
            };

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype.phase = function (value) {
                var time = value * this._animationClipNode.totalDuration + this._pStartTime;

                if (this._pTime == time - this._pStartTime)
                    return;

                this._pUpdateTime(time);
            };

            /**
            * @inheritDoc
            */
            AnimationClipState.prototype._pUpdateTime = function (time/*int*/ ) {
                this._pFramesDirty = true;

                this._pTimeDir = (time - this._pStartTime > this._pTime) ? 1 : -1;

                _super.prototype._pUpdateTime.call(this, time);
            };

            /**
            * Updates the nodes internal playhead to determine the current and next animation frame, and the blendWeight between the two.
            *
            * @see #currentFrame
            * @see #nextFrame
            * @see #blendWeight
            */
            AnimationClipState.prototype._pUpdateFrames = function () {
                this._pFramesDirty = false;

                var looping = this._animationClipNode.looping;
                var totalDuration = this._animationClipNode.totalDuration;
                var lastFrame = this._animationClipNode.lastFrame;
                var time = this._pTime;

                if (looping && (time >= totalDuration || time < 0)) {
                    time %= totalDuration;
                    if (time < 0)
                        time += totalDuration;
                }

                if (!looping && time >= totalDuration) {
                    this.notifyPlaybackComplete();
                    this._pCurrentFrame = lastFrame;
                    this._pNextFrame = lastFrame;
                    this._pBlendWeight = 0;
                } else if (!looping && time <= 0) {
                    this._pCurrentFrame = 0;
                    this._pNextFrame = 0;
                    this._pBlendWeight = 0;
                } else if (this._animationClipNode.fixedFrameRate) {
                    var t = time / totalDuration * lastFrame;
                    this._pCurrentFrame = Math.floor(t);
                    this._pBlendWeight = t - this._pCurrentFrame;
                    this._pNextFrame = this._pCurrentFrame + 1;
                } else {
                    this._pCurrentFrame = 0;
                    this._pNextFrame = 0;

                    var dur = 0/*uint*/ , frameTime;
                    var durations = this._animationClipNode.durations;

                    do {
                        frameTime = dur;
                        dur += durations[this._pNextFrame];
                        this._pCurrentFrame = this._pNextFrame++;
                    } while(time > dur);

                    if (this._pCurrentFrame == lastFrame) {
                        this._pCurrentFrame = 0;
                        this._pNextFrame = 1;
                    }

                    this._pBlendWeight = (time - frameTime) / durations[this._pCurrentFrame];
                }
            };

            AnimationClipState.prototype.notifyPlaybackComplete = function () {
                if (this._animationStatePlaybackComplete == null)
                    this._animationStatePlaybackComplete = new away.events.AnimationStateEvent(away.events.AnimationStateEvent.PLAYBACK_COMPLETE, this._pAnimator, this, this._animationClipNode);

                this._animationClipNode.dispatchEvent(this._animationStatePlaybackComplete);
            };
            return AnimationClipState;
        })(animators.AnimationStateBase);
        animators.AnimationClipState = AnimationClipState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (animators) {
        /**
        *
        */
        var VertexClipState = (function (_super) {
            __extends(VertexClipState, _super);
            function VertexClipState(animator, vertexClipNode) {
                _super.call(this, animator, vertexClipNode);

                this._vertexClipNode = vertexClipNode;
                this._frames = this._vertexClipNode.frames;
            }
            Object.defineProperty(VertexClipState.prototype, "currentGeometry", {
                get: /**
                * @inheritDoc
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._currentGeometry;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexClipState.prototype, "nextGeometry", {
                get: /**
                * @inheritDoc
                */
                function () {
                    if (this._pFramesDirty)
                        this._pUpdateFrames();

                    return this._nextGeometry;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            VertexClipState.prototype._pUpdateFrames = function () {
                _super.prototype._pUpdateFrames.call(this);

                this._currentGeometry = this._frames[this._pCurrentFrame];

                if (this._vertexClipNode.looping && this._pNextFrame >= this._vertexClipNode.lastFrame) {
                    this._nextGeometry = this._frames[0];
                    (this._pAnimator).dispatchCycleEvent();
                } else
                    this._nextGeometry = this._frames[this._pNextFrame];
            };

            /**
            * @inheritDoc
            */
            VertexClipState.prototype._pUpdatePositionDelta = function () {
                //TODO:implement positiondelta functionality for vertex animations
            };
            return VertexClipState;
        })(animators.AnimationClipState);
        animators.VertexClipState = VertexClipState;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var GeometryUtils = (function () {
            function GeometryUtils() {
            }
            GeometryUtils.fromVectors = /**
            * Build a list of sub-geometries from raw data vectors, splitting them up in
            * such a way that they won't exceed buffer length limits.
            */
            function (verts, indices/*uint*/ , uvs, normals, tangents, weights, jointIndices, triangleOffset) {
                if (typeof triangleOffset === "undefined") { triangleOffset = 0; }
                var LIMIT_VERTS = 3 * 0xffff;
                var LIMIT_INDICES = 15 * 0xffff;

                var subs = new Array();

                if (uvs && !uvs.length)
                    uvs = null;

                if (normals && !normals.length)
                    normals = null;

                if (tangents && !tangents.length)
                    tangents = null;

                if (weights && !weights.length)
                    weights = null;

                if (jointIndices && !jointIndices.length)
                    jointIndices = null;

                if ((indices.length >= LIMIT_INDICES) || (verts.length >= LIMIT_VERTS)) {
                    var i;
                    var len;
                    var outIndex;
                    var j;
                    var splitVerts = new Array();
                    var splitIndices = new Array();
                    var splitUvs = (uvs != null) ? new Array() : null;
                    var splitNormals = (normals != null) ? new Array() : null;
                    var splitTangents = (tangents != null) ? new Array() : null;
                    var splitWeights = (weights != null) ? new Array() : null;
                    var splitJointIndices = (jointIndices != null) ? new Array() : null;

                    var mappings = new Array(verts.length / 3);

                    i = mappings.length;

                    while (i-- > 0) {
                        mappings[i] = -1;
                    }

                    var originalIndex;
                    var splitIndex;
                    var o0;
                    var o1;
                    var o2;
                    var s0;
                    var s1;
                    var s2;
                    var su;
                    var ou;
                    var sv;
                    var ov;

                    // Loop over all triangles
                    outIndex = 0;
                    len = indices.length;

                    for (i = 0; i < len; i += 3) {
                        splitIndex = splitVerts.length + 6;

                        if (((outIndex + 2) >= LIMIT_INDICES) || (splitIndex >= LIMIT_VERTS)) {
                            subs.push(GeometryUtils.constructSubGeometry(splitVerts, splitIndices, splitUvs, splitNormals, splitTangents, splitWeights, splitJointIndices, triangleOffset));
                            splitVerts = new Array();
                            splitIndices = new Array();
                            splitUvs = (uvs != null) ? new Array() : null;
                            splitNormals = (normals != null) ? new Array() : null;
                            splitTangents = (tangents != null) ? new Array() : null;
                            splitWeights = (weights != null) ? new Array() : null;
                            splitJointIndices = (jointIndices != null) ? new Array() : null;
                            splitIndex = 0;
                            j = mappings.length;

                            while (j-- > 0) {
                                mappings[j] = -1;
                            }

                            outIndex = 0;
                        }

                        for (j = 0; j < 3; j++) {
                            originalIndex = indices[i + j];

                            if (mappings[originalIndex] >= 0) {
                                splitIndex = mappings[originalIndex];
                            } else {
                                o0 = originalIndex * 3 + 0;
                                o1 = originalIndex * 3 + 1;
                                o2 = originalIndex * 3 + 2;

                                // This vertex does not yet exist in the split list and
                                // needs to be copied from the long list.
                                splitIndex = splitVerts.length / 3;

                                s0 = splitIndex * 3 + 0;
                                s1 = splitIndex * 3 + 1;
                                s2 = splitIndex * 3 + 2;

                                splitVerts[s0] = verts[o0];
                                splitVerts[s1] = verts[o1];
                                splitVerts[s2] = verts[o2];

                                if (uvs) {
                                    su = splitIndex * 2 + 0;
                                    sv = splitIndex * 2 + 1;
                                    ou = originalIndex * 2 + 0;
                                    ov = originalIndex * 2 + 1;

                                    splitUvs[su] = uvs[ou];
                                    splitUvs[sv] = uvs[ov];
                                }

                                if (normals) {
                                    splitNormals[s0] = normals[o0];
                                    splitNormals[s1] = normals[o1];
                                    splitNormals[s2] = normals[o2];
                                }

                                if (tangents) {
                                    splitTangents[s0] = tangents[o0];
                                    splitTangents[s1] = tangents[o1];
                                    splitTangents[s2] = tangents[o2];
                                }

                                if (weights) {
                                    splitWeights[s0] = weights[o0];
                                    splitWeights[s1] = weights[o1];
                                    splitWeights[s2] = weights[o2];
                                }

                                if (jointIndices) {
                                    splitJointIndices[s0] = jointIndices[o0];
                                    splitJointIndices[s1] = jointIndices[o1];
                                    splitJointIndices[s2] = jointIndices[o2];
                                }

                                mappings[originalIndex] = splitIndex;
                            }

                            // Store new index, which may have come from the mapping look-up,
                            // or from copying a new set of vertex data from the original vector
                            splitIndices[outIndex + j] = splitIndex;
                        }

                        outIndex += 3;
                    }

                    if (splitVerts.length > 0) {
                        // More was added in the last iteration of the loop.
                        subs.push(GeometryUtils.constructSubGeometry(splitVerts, splitIndices, splitUvs, splitNormals, splitTangents, splitWeights, splitJointIndices, triangleOffset));
                    }
                } else {
                    subs.push(GeometryUtils.constructSubGeometry(verts, indices, uvs, normals, tangents, weights, jointIndices, triangleOffset));
                }

                return subs;
            };

            GeometryUtils.constructSubGeometry = /**
            * Build a sub-geometry from data vectors.
            */
            function (verts, indices/*uint*/ , uvs, normals, tangents, weights, jointIndices, triangleOffset) {
                var sub;

                if (weights && jointIndices) {
                    // If there were weights and joint indices defined, this
                    // is a skinned mesh and needs to be built from skinned
                    // sub-geometries.
                    //TODO: implement dependency: SkinnedSubGeometry
                    away.Debug.throwPIR('GeometryUtils', 'constructSubGeometry', 'Dependency: SkinnedSubGeometry');

                    //*
                    sub = new away.base.SkinnedSubGeometry(weights.length / (verts.length / 3));

                    var ssg = sub;
                    //ssg.updateJointWeightsData(weights);
                    //ssg.updateJointWeightsData(weights);
                    //ssg.updateJointIndexData(jointIndices);
                    //*/
                } else {
                    sub = new away.base.CompactSubGeometry();
                }

                sub.updateIndexData(indices);
                sub.fromVectors(verts, uvs, normals, tangents);

                return sub;
            };

            GeometryUtils.interleaveBuffers = /*
            * Combines a set of separate raw buffers into an interleaved one, compatible
            * with CompactSubGeometry. SubGeometry uses separate buffers, whereas CompactSubGeometry
            * uses a single, combined buffer.
            * */
            function (numVertices, vertices, normals, tangents, uvs, suvs) {
                if (typeof vertices === "undefined") { vertices = null; }
                if (typeof normals === "undefined") { normals = null; }
                if (typeof tangents === "undefined") { tangents = null; }
                if (typeof uvs === "undefined") { uvs = null; }
                if (typeof suvs === "undefined") { suvs = null; }
                var i, compIndex, uvCompIndex, interleavedCompIndex;
                var interleavedBuffer;

                interleavedBuffer = new Array();

                for (i = 0; i < numVertices; ++i) {
                    uvCompIndex = i * 2;
                    compIndex = i * 3;
                    interleavedCompIndex = i * 13;

                    interleavedBuffer[interleavedCompIndex] = vertices ? vertices[compIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 1] = vertices ? vertices[compIndex + 1] : 0;
                    interleavedBuffer[interleavedCompIndex + 2] = vertices ? vertices[compIndex + 2] : 0;
                    interleavedBuffer[interleavedCompIndex + 3] = normals ? normals[compIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 4] = normals ? normals[compIndex + 1] : 0;
                    interleavedBuffer[interleavedCompIndex + 5] = normals ? normals[compIndex + 2] : 0;
                    interleavedBuffer[interleavedCompIndex + 6] = tangents ? tangents[compIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 7] = tangents ? tangents[compIndex + 1] : 0;
                    interleavedBuffer[interleavedCompIndex + 8] = tangents ? tangents[compIndex + 2] : 0;
                    interleavedBuffer[interleavedCompIndex + 9] = uvs ? uvs[uvCompIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 10] = uvs ? uvs[uvCompIndex + 1] : 0;
                    interleavedBuffer[interleavedCompIndex + 11] = suvs ? suvs[uvCompIndex] : 0;
                    interleavedBuffer[interleavedCompIndex + 12] = suvs ? suvs[uvCompIndex + 1] : 0;
                }

                return interleavedBuffer;
            };

            GeometryUtils.getMeshSubgeometryIndex = /*
            * returns the subGeometry index in its parent mesh subgeometries vector
            */
            function (subGeometry) {
                var index;
                var subGeometries = subGeometry.parentGeometry.subGeometries;

                for (var i = 0; i < subGeometries.length; ++i) {
                    if (subGeometries[i] == subGeometry) {
                        index = i;
                        break;
                    }
                }

                return index;
            };

            GeometryUtils.getMeshSubMeshIndex = /*
            * returns the subMesh index in its parent mesh subMeshes vector
            */
            function (subMesh) {
                var index;
                var subMeshes = subMesh.iParentMesh.subMeshes;

                for (var i = 0; i < subMeshes.length; ++i) {
                    if (subMeshes[i] == subMesh) {
                        index = i;
                        break;
                    }
                }

                return index;
            };
            return GeometryUtils;
        })();
        utils.GeometryUtils = GeometryUtils;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        /**
        * Provides an abstract base class for data set classes that hold animation data for use in animator classes.
        *
        * @see away.animators.AnimatorBase
        */
        var AnimationSetBase = (function (_super) {
            __extends(AnimationSetBase, _super);
            function AnimationSetBase() {
                _super.call(this);
                this._animations = new Array();
                this._animationNames = new Array();
                this._animationDictionary = new Object();
            }
            /**
            * Retrieves a temporary GPU register that's still free.
            *
            * @param exclude An array of non-free temporary registers.
            * @param excludeAnother An additional register that's not free.
            * @return A temporary register that can be used.
            */
            AnimationSetBase.prototype._pFindTempReg = function (exclude, excludeAnother) {
                if (typeof excludeAnother === "undefined") { excludeAnother = null; }
                var i = 0;
                var reg;

                while (true) {
                    reg = "vt" + i;
                    if (exclude.indexOf(reg) == -1 && excludeAnother != reg)
                        return reg;
                    ++i;
                }

                // can't be reached
                return null;
            };

            Object.defineProperty(AnimationSetBase.prototype, "usesCPU", {
                get: /**
                * Indicates whether the properties of the animation data contained within the set combined with
                * the vertex registers aslready in use on shading materials allows the animation data to utilise
                * GPU calls.
                */
                function () {
                    return this._usesCPU;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called by the material to reset the GPU indicator before testing whether register space in the shader
            * is available for running GPU-based animation code.
            *
            * @private
            */
            AnimationSetBase.prototype.resetGPUCompatibility = function () {
                this._usesCPU = false;
            };

            AnimationSetBase.prototype.cancelGPUCompatibility = function () {
                this._usesCPU = true;
            };

            Object.defineProperty(AnimationSetBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.ANIMATION_SET;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSetBase.prototype, "animations", {
                get: /**
                * Returns a vector of animation state objects that make up the contents of the animation data set.
                */
                function () {
                    return this._animations;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationSetBase.prototype, "animationNames", {
                get: /**
                * Returns a vector of animation state objects that make up the contents of the animation data set.
                */
                function () {
                    return this._animationNames;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Check to determine whether a state is registered in the animation set under the given name.
            *
            * @param stateName The name of the animation state object to be checked.
            */
            AnimationSetBase.prototype.hasAnimation = function (name) {
                return this._animationDictionary[name] != null;
            };

            /**
            * Retrieves the animation state object registered in the animation data set under the given name.
            *
            * @param stateName The name of the animation state object to be retrieved.
            */
            AnimationSetBase.prototype.getAnimation = function (name) {
                return this._animationDictionary[name];
            };

            /**
            * Adds an animation state object to the aniamtion data set under the given name.
            *
            * @param stateName The name under which the animation state object will be stored.
            * @param animationState The animation state object to be staored in the set.
            */
            AnimationSetBase.prototype.addAnimation = function (node) {
                if (this._animationDictionary[node.name])
                    throw new away.errors.AnimationSetError("root node name '" + node.name + "' already exists in the set");

                this._animationDictionary[node.name] = node;

                this._animations.push(node);

                this._animationNames.push(node.name);
            };

            /**
            * Cleans up any resources used by the current object.
            */
            AnimationSetBase.prototype.dispose = function () {
            };
            return AnimationSetBase;
        })(away.library.NamedAssetBase);
        animators.AnimationSetBase = AnimationSetBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        /**
        * The animation data set used by vertex-based animators, containing vertex animation state data.
        *
        * @see away.animators.VertexAnimator
        */
        var VertexAnimationSet = (function (_super) {
            __extends(VertexAnimationSet, _super);
            /**
            * Creates a new <code>VertexAnimationSet</code> object.
            *
            * @param numPoses The number of poses made available at once to the GPU animation code.
            * @param blendMode Optional value for setting the animation mode of the vertex animator object.
            *
            * @see away3d.animators.data.VertexAnimationMode
            */
            function VertexAnimationSet(numPoses, blendMode) {
                if (typeof numPoses === "undefined") { numPoses = 2; }
                if (typeof blendMode === "undefined") { blendMode = "absolute"; }
                _super.call(this);
                this._streamIndices = new Object();
                this._useNormals = new Object();
                this._useTangents = new Object();
                this._numPoses = numPoses;
                this._blendMode = blendMode;
            }
            Object.defineProperty(VertexAnimationSet.prototype, "numPoses", {
                get: /**
                * Returns the number of poses made available at once to the GPU animation code.
                */
                function () {
                    return this._numPoses;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexAnimationSet.prototype, "blendMode", {
                get: /**
                * Returns the active blend mode of the vertex animator object.
                */
                function () {
                    return this._blendMode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(VertexAnimationSet.prototype, "useNormals", {
                get: /**
                * Returns whether or not normal data is used in last set GPU pass of the vertex shader.
                */
                function () {
                    return this._uploadNormals;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALVertexCode = function (pass, sourceRegisters, targetRegisters, profile) {
                if (this._blendMode == away.animators.VertexAnimationMode.ABSOLUTE)
                    return this.getAbsoluteAGALCode(pass, sourceRegisters, targetRegisters);
else
                    return this.getAdditiveAGALCode(pass, sourceRegisters, targetRegisters);
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.activate = function (stage3DProxy, pass) {
                var uID = pass._iUniqueId;
                this._uploadNormals = this._useNormals[uID];
                this._uploadTangents = this._useTangents[uID];
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.deactivate = function (stage3DProxy, pass) {
                var uID = pass._iUniqueId;
                var index = this._streamIndices[uID];
                var context = stage3DProxy._iContext3D;
                context.setVertexBufferAt(index, null);
                if (this._uploadNormals)
                    context.setVertexBufferAt(index + 1, null);
                if (this._uploadTangents)
                    context.setVertexBufferAt(index + 2, null);
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALFragmentCode = function (pass, shadedTarget, profile) {
                return "";
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.getAGALUVCode = function (pass, UVSource, UVTarget) {
                return "mov " + UVTarget + "," + UVSource + "\n";
            };

            /**
            * @inheritDoc
            */
            VertexAnimationSet.prototype.doneAGALCode = function (pass) {
            };

            /**
            * Generates the vertex AGAL code for absolute blending.
            */
            VertexAnimationSet.prototype.getAbsoluteAGALCode = function (pass, sourceRegisters, targetRegisters) {
                var code = "";
                var uID = pass._iUniqueId;
                var temp1 = this._pFindTempReg(targetRegisters);
                var temp2 = this._pFindTempReg(targetRegisters, temp1);
                var regs = new Array("x", "y", "z", "w");
                var len = sourceRegisters.length;
                var constantReg = "vc" + pass.numUsedVertexConstants;
                var useTangents = this._useTangents[uID] = (len > 2);
                this._useNormals[uID] = (len > 1);

                if (len > 2)
                    len = 2;
                var streamIndex = this._streamIndices[uID] = pass.numUsedStreams;

                for (var i = 0; i < len; ++i) {
                    code += "mul " + temp1 + ", " + sourceRegisters[i] + ", " + constantReg + "." + regs[0] + "\n";

                    for (var j = 1; j < this._numPoses; ++j) {
                        code += "mul " + temp2 + ", va" + streamIndex + ", " + constantReg + "." + regs[j] + "\n";

                        if (j < this._numPoses - 1)
                            code += "add " + temp1 + ", " + temp1 + ", " + temp2 + "\n";

                        ++streamIndex;
                    }

                    code += "add " + targetRegisters[i] + ", " + temp1 + ", " + temp2 + "\n";
                }

                if (useTangents) {
                    code += "dp3 " + temp1 + ".x, " + sourceRegisters[2] + ", " + targetRegisters[1] + "\n" + "mul " + temp1 + ", " + targetRegisters[1] + ", " + temp1 + ".x			 \n" + "sub " + targetRegisters[2] + ", " + sourceRegisters[2] + ", " + temp1 + "\n";
                }
                return code;
            };

            /**
            * Generates the vertex AGAL code for additive blending.
            */
            VertexAnimationSet.prototype.getAdditiveAGALCode = function (pass, sourceRegisters, targetRegisters) {
                var code = "";
                var uID = pass._iUniqueId;
                var len = sourceRegisters.length;
                var regs = ["x", "y", "z", "w"];
                var temp1 = this._pFindTempReg(targetRegisters);
                var k/*uint*/ ;
                var useTangents = this._useTangents[uID] = (len > 2);
                var useNormals = this._useNormals[uID] = (len > 1);
                var streamIndex = this._streamIndices[uID] = pass.numUsedStreams;

                if (len > 2)
                    len = 2;

                code += "mov  " + targetRegisters[0] + ", " + sourceRegisters[0] + "\n";
                if (useNormals)
                    code += "mov " + targetRegisters[1] + ", " + sourceRegisters[1] + "\n";

                for (var i = 0; i < len; ++i) {
                    for (var j = 0; j < this._numPoses; ++j) {
                        code += "mul " + temp1 + ", va" + (streamIndex + k) + ", vc" + pass.numUsedVertexConstants + "." + regs[j] + "\n" + "add " + targetRegisters[i] + ", " + targetRegisters[i] + ", " + temp1 + "\n";
                        k++;
                    }
                }

                if (useTangents) {
                    code += "dp3 " + temp1 + ".x, " + sourceRegisters[2] + ", " + targetRegisters[1] + "\n" + "mul " + temp1 + ", " + targetRegisters[1] + ", " + temp1 + ".x			 \n" + "sub " + targetRegisters[2] + ", " + sourceRegisters[2] + ", " + temp1 + "\n";
                }

                return code;
            };
            return VertexAnimationSet;
        })(animators.AnimationSetBase);
        animators.VertexAnimationSet = VertexAnimationSet;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        /**
        * Dispatched when playback of an animation inside the animator object starts.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="start", type="away3d.events.AnimatorEvent")]
        /**
        * Dispatched when playback of an animation inside the animator object stops.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="stop", type="away3d.events.AnimatorEvent")]
        /**
        * Dispatched when playback of an animation reaches the end of an animation.
        *
        * @eventType away3d.events.AnimatorEvent
        */
        //[Event(name="cycle_complete", type="away3d.events.AnimatorEvent")]
        /**
        * Provides an abstract base class for animator classes that control animation output from a data set subtype of <code>AnimationSetBase</code>.
        *
        * @see away.animators.AnimationSetBase
        */
        var AnimatorBase = (function (_super) {
            __extends(AnimatorBase, _super);
            /**
            * Creates a new <code>AnimatorBase</code> object.
            *
            * @param animationSet The animation data set to be used by the animator object.
            */
            function AnimatorBase(animationSet) {
                _super.call(this);
                this._autoUpdate = true;
                this._playbackSpeed = 1;
                this._pOwners = new Array();
                this._pAbsoluteTime = 0;
                this._animationStates = new Object();
                /**
                * Enables translation of the animated mesh from data returned per frame via the positionDelta property of the active animation node. Defaults to true.
                *
                * @see away.animators.states.IAnimationState#positionDelta
                */
                this.updatePosition = true;

                this._pAnimationSet = animationSet;

                this._broadcaster = new away.utils.RequestAnimationFrame(this.onEnterFrame, this);
            }
            AnimatorBase.prototype.getAnimationState = function (node) {
                var className = node.stateClass;
                var uID = node._iUniqueId;

                if (this._animationStates[uID] == null)
                    this._animationStates[uID] = new className(this, node);

                return this._animationStates[uID];
            };

            AnimatorBase.prototype.getAnimationStateByName = function (name) {
                return this.getAnimationState(this._pAnimationSet.getAnimation(name));
            };

            Object.defineProperty(AnimatorBase.prototype, "absoluteTime", {
                get: /**
                * Returns the internal absolute time of the animator, calculated by the current time and the playback speed.
                *
                * @see #time
                * @see #playbackSpeed
                */
                function () {
                    return this._pAbsoluteTime;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "animationSet", {
                get: /**
                * Returns the animation data set in use by the animator.
                */
                function () {
                    return this._pAnimationSet;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeState", {
                get: /**
                * Returns the current active animation state.
                */
                function () {
                    return this._pActiveState;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeAnimation", {
                get: /**
                * Returns the current active animation node.
                */
                function () {
                    return this._pAnimationSet.getAnimation(this._pActiveAnimationName);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "activeAnimationName", {
                get: /**
                * Returns the current active animation node.
                */
                function () {
                    return this._pActiveAnimationName;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimatorBase.prototype, "autoUpdate", {
                get: /**
                * Determines whether the animators internal update mechanisms are active. Used in cases
                * where manual updates are required either via the <code>time</code> property or <code>update()</code> method.
                * Defaults to true.
                *
                * @see #time
                * @see #update()
                */
                function () {
                    return this._autoUpdate;
                },
                set: function (value) {
                    if (this._autoUpdate == value)
                        return;

                    this._autoUpdate = value;

                    if (this._autoUpdate)
                        this.start();
else
                        this.stop();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(AnimatorBase.prototype, "time", {
                get: /**
                * Gets and sets the internal time clock of the animator.
                */
                function () {
                    return this._time;
                },
                set: function (value/*int*/ ) {
                    if (this._time == value)
                        return;

                    this.update(value);
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Sets the animation phase of the current active state's animation clip(s).
            *
            * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
            */
            AnimatorBase.prototype.phase = function (value) {
                this._pActiveState.phase(value);
            };

            Object.defineProperty(AnimatorBase.prototype, "playbackSpeed", {
                get: /**
                * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
                */
                function () {
                    return this._playbackSpeed;
                },
                set: function (value) {
                    this._playbackSpeed = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Resumes the automatic playback clock controling the active state of the animator.
            */
            AnimatorBase.prototype.start = function () {
                if (this._isPlaying || !this._autoUpdate)
                    return;

                this._time = this._pAbsoluteTime = away.utils.getTimer();

                this._isPlaying = true;

                this._broadcaster.start();

                if (!this.hasEventListener(away.events.AnimatorEvent.START))
                    return;

                if (this._startEvent == null)
                    this._startEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.START, this);

                this.dispatchEvent(this._startEvent);
            };

            /**
            * Pauses the automatic playback clock of the animator, in case manual updates are required via the
            * <code>time</code> property or <code>update()</code> method.
            *
            * @see #time
            * @see #update()
            */
            AnimatorBase.prototype.stop = function () {
                if (!this._isPlaying)
                    return;

                this._isPlaying = false;

                this._broadcaster.stop();

                if (!this.hasEventListener(away.events.AnimatorEvent.STOP))
                    return;

                if (this._stopEvent == null)
                    this._stopEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.STOP, this);

                this.dispatchEvent(this._stopEvent);
            };

            /**
            * Provides a way to manually update the active state of the animator when automatic
            * updates are disabled.
            *
            * @see #stop()
            * @see #autoUpdate
            */
            AnimatorBase.prototype.update = function (time/*int*/ ) {
                var dt = (time - this._time) * this.playbackSpeed;

                this._pUpdateDeltaTime(dt);

                this._time = time;
            };

            AnimatorBase.prototype.reset = function (name, offset) {
                if (typeof offset === "undefined") { offset = 0; }
                this.getAnimationState(this._pAnimationSet.getAnimation(name)).offset(offset + this._pAbsoluteTime);
            };

            /**
            * Used by the mesh object to which the animator is applied, registers the owner for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.addOwner = function (mesh) {
                this._pOwners.push(mesh);
            };

            /**
            * Used by the mesh object from which the animator is removed, unregisters the owner for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.removeOwner = function (mesh) {
                this._pOwners.splice(this._pOwners.indexOf(mesh), 1);
            };

            /**
            * Internal abstract method called when the time delta property of the animator's contents requires updating.
            *
            * @private
            */
            AnimatorBase.prototype._pUpdateDeltaTime = function (dt) {
                this._pAbsoluteTime += dt;

                this._pActiveState.update(this._pAbsoluteTime);

                if (this.updatePosition)
                    this.applyPositionDelta();
            };

            /**
            * Enter frame event handler for automatically updating the active state of the animator.
            */
            AnimatorBase.prototype.onEnterFrame = function (event) {
                if (typeof event === "undefined") { event = null; }
                this.update(away.utils.getTimer());
            };

            AnimatorBase.prototype.applyPositionDelta = function () {
                var delta = this._pActiveState.positionDelta;
                var dist = delta.length;
                var len/*uint*/ ;
                if (dist > 0) {
                    len = this._pOwners.length;
                    for (var i = 0; i < len; ++i)
                        this._pOwners[i].translateLocal(delta, dist);
                }
            };

            /**
            *  for internal use.
            *
            * @private
            */
            AnimatorBase.prototype.dispatchCycleEvent = function () {
                if (this.hasEventListener(away.events.AnimatorEvent.CYCLE_COMPLETE)) {
                    if (this._cycleEvent == null)
                        this._cycleEvent = new away.events.AnimatorEvent(away.events.AnimatorEvent.CYCLE_COMPLETE, this);

                    this.dispatchEvent(this._cycleEvent);
                }
            };

            /**
            * @inheritDoc
            */
            AnimatorBase.prototype.dispose = function () {
            };

            Object.defineProperty(AnimatorBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.ANIMATOR;
                },
                enumerable: true,
                configurable: true
            });
            return AnimatorBase;
        })(away.library.NamedAssetBase);
        animators.AnimatorBase = AnimatorBase;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (animators) {
        /**
        * Provides an interface for assigning vertex-based animation data sets to mesh-based entity objects
        * and controlling the various available states of animation through an interative playhead that can be
        * automatically updated or manually triggered.
        */
        var VertexAnimator = (function (_super) {
            __extends(VertexAnimator, _super);
            /**
            * Creates a new <code>VertexAnimator</code> object.
            *
            * @param vertexAnimationSet The animation data set containing the vertex animations used by the animator.
            */
            function VertexAnimator(vertexAnimationSet) {
                _super.call(this, vertexAnimationSet);
                this._poses = new Array();
                this._weights = Array(1, 0, 0, 0);

                this._vertexAnimationSet = vertexAnimationSet;
                this._numPoses = vertexAnimationSet.numPoses;
                this._blendMode = vertexAnimationSet.blendMode;
            }
            /**
            * @inheritDoc
            */
            VertexAnimator.prototype.clone = function () {
                return new VertexAnimator(this._vertexAnimationSet);
            };

            /**
            * Plays a sequence with a given name. If the sequence is not found, it may not be loaded yet, and it will retry every frame.
            * @param sequenceName The name of the clip to be played.
            */
            VertexAnimator.prototype.play = function (name, transition, offset) {
                if (typeof transition === "undefined") { transition = null; }
                if (typeof offset === "undefined") { offset = NaN; }
                if (this._pActiveAnimationName == name)
                    return;

                this._pActiveAnimationName = name;

                if (!this._pAnimationSet.hasAnimation(name))
                    throw new Error("Animation root node " + name + " not found!");

                this._pActiveNode = this._pAnimationSet.getAnimation(name);

                this._pActiveState = this.getAnimationState(this._pActiveNode);

                if (this.updatePosition) {
                    //update straight away to reset position deltas
                    this._pActiveState.update(this._pAbsoluteTime);
                    this._pActiveState.positionDelta;
                }

                this._activeVertexState = this._pActiveState;

                this.start();

                if (!isNaN(offset))
                    this.reset(name, offset);
            };

            /**
            * @inheritDoc
            */
            VertexAnimator.prototype._pUpdateDeltaTime = function (dt) {
                _super.prototype._pUpdateDeltaTime.call(this, dt);

                this._poses[0] = this._activeVertexState.currentGeometry;
                this._poses[1] = this._activeVertexState.nextGeometry;
                this._weights[0] = 1 - (this._weights[1] = this._activeVertexState.blendWeight);
            };

            /**
            * @inheritDoc
            */
            VertexAnimator.prototype.setRenderState = function (stage3DProxy, renderable, vertexConstantOffset/*int*/ , vertexStreamOffset/*int*/ , camera) {
                if (!this._poses.length) {
                    this.setNullPose(stage3DProxy, renderable, vertexConstantOffset, vertexStreamOffset);
                    return;
                }

                // this type of animation can only be SubMesh
                var subMesh = renderable;
                var subGeom;
                var i/*uint*/ ;
                var len = this._numPoses;

                stage3DProxy._iContext3D.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, vertexConstantOffset, this._weights, 1);

                if (this._blendMode == animators.VertexAnimationMode.ABSOLUTE) {
                    i = 1;
                    subGeom = this._poses[0].subGeometries[subMesh._iIndex];

                    if (subGeom)
                        subMesh.subGeometry = subGeom;
                } else
                    i = 0;

                for (; i < len; ++i) {
                    subGeom = this._poses[i].subGeometries[subMesh._iIndex] || subMesh.subGeometry;

                    subGeom.activateVertexBuffer(vertexStreamOffset++, stage3DProxy);

                    if (this._vertexAnimationSet.useNormals)
                        subGeom.activateVertexNormalBuffer(vertexStreamOffset++, stage3DProxy);
                }
            };

            VertexAnimator.prototype.setNullPose = function (stage3DProxy, renderable, vertexConstantOffset/*int*/ , vertexStreamOffset/*int*/ ) {
                stage3DProxy._iContext3D.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, vertexConstantOffset, this._weights, 1);

                if (this._blendMode == animators.VertexAnimationMode.ABSOLUTE) {
                    var len = this._numPoses;
                    for (var i = 1; i < len; ++i) {
                        renderable.activateVertexBuffer(vertexStreamOffset++, stage3DProxy);

                        if (this._vertexAnimationSet.useNormals)
                            renderable.activateVertexNormalBuffer(vertexStreamOffset++, stage3DProxy);
                    }
                }
                // todo: set temp data for additive?
            };

            /**
            * Verifies if the animation will be used on cpu. Needs to be true for all passes for a material to be able to use it on gpu.
            * Needs to be called if gpu code is potentially required.
            */
            VertexAnimator.prototype.testGPUCompatibility = function (pass) {
            };
            return VertexAnimator;
        })(animators.AnimatorBase);
        animators.VertexAnimator = VertexAnimator;
    })(away.animators || (away.animators = {}));
    var animators = away.animators;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (events) {
        /**
        * Dispatched to notify changes in an animation state's state.
        */
        var AnimationStateEvent = (function (_super) {
            __extends(AnimationStateEvent, _super);
            /**
            * Create a new <code>AnimatonStateEvent</code>
            *
            * @param type The event type.
            * @param animator The animation state object that is the subject of this event.
            * @param animationNode The animation node inside the animation state from which the event originated.
            */
            function AnimationStateEvent(type, animator, animationState, animationNode) {
                _super.call(this, type);

                this._animator = animator;
                this._animationState = animationState;
                this._animationNode = animationNode;
            }
            Object.defineProperty(AnimationStateEvent.prototype, "animator", {
                get: /**
                * The animator object that is the subject of this event.
                */
                function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationStateEvent.prototype, "animationState", {
                get: /**
                * The animation state object that is the subject of this event.
                */
                function () {
                    return this._animationState;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationStateEvent.prototype, "animationNode", {
                get: /**
                * The animation node inside the animation state from which the event originated.
                */
                function () {
                    return this._animationNode;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the event.
            *
            * @return An exact duplicate of the current object.
            */
            AnimationStateEvent.prototype.clone = function () {
                return new AnimationStateEvent(this.type, this._animator, this._animationState, this._animationNode);
            };
            AnimationStateEvent.PLAYBACK_COMPLETE = "playbackComplete";

            AnimationStateEvent.TRANSITION_COMPLETE = "transitionComplete";
            return AnimationStateEvent;
        })(events.Event);
        events.AnimationStateEvent = AnimationStateEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (events) {
        /**
        * Dispatched to notify changes in an animator's state.
        */
        var AnimatorEvent = (function (_super) {
            __extends(AnimatorEvent, _super);
            /**
            * Create a new <code>AnimatorEvent</code> object.
            *
            * @param type The event type.
            * @param animator The animator object that is the subject of this event.
            */
            function AnimatorEvent(type, animator) {
                _super.call(this, type);
                this._animator = animator;
            }
            Object.defineProperty(AnimatorEvent.prototype, "animator", {
                get: function () {
                    return this._animator;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clones the event.
            *
            * @return An exact duplicate of the current event object.
            */
            AnimatorEvent.prototype.clone = function () {
                return new AnimatorEvent(this.type, this._animator);
            };
            AnimatorEvent.START = "start";

            AnimatorEvent.STOP = "stop";

            AnimatorEvent.CYCLE_COMPLETE = "cycle_complete";
            return AnimatorEvent;
        })(events.Event);
        events.AnimatorEvent = AnimatorEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    /**
    * @module away.events
    */
    (function (events) {
        //import flash.events.Event;
        var ShadingMethodEvent = (function (_super) {
            __extends(ShadingMethodEvent, _super);
            function ShadingMethodEvent(type) {
                _super.call(this, type);
            }
            ShadingMethodEvent.SHADER_INVALIDATED = "ShaderInvalidated";
            return ShadingMethodEvent;
        })(away.events.Event);
        events.ShadingMethodEvent = ShadingMethodEvent;
    })(away.events || (away.events = {}));
    var events = away.events;
})(away || (away = {}));
var away;
(function (away) {
    (function (errors) {
        var AnimationSetError = (function (_super) {
            __extends(AnimationSetError, _super);
            function AnimationSetError(message) {
                _super.call(this, message);
            }
            return AnimationSetError;
        })(errors.Error);
        errors.AnimationSetError = AnimationSetError;
    })(away.errors || (away.errors = {}));
    var errors = away.errors;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * MaterialPassBase provides an abstract base class for material shader passes. A material pass constitutes at least
        * a render call per required renderable.
        */
        var MaterialPassBase = (function (_super) {
            __extends(MaterialPassBase, _super);
            //public animationRegisterCache:AnimationRegisterCache; TODO: implement dependency AnimationRegisterCache
            /**
            * Creates a new MaterialPassBase object.
            *
            * @param renderToTexture Indicates whether this pass is a render-to-texture pass.
            */
            function MaterialPassBase(renderToTexture) {
                if (typeof renderToTexture === "undefined") { renderToTexture = false; }
                _super.call(this);
                this._iProgram3Ds = new Array(8);
                this._iProgram3Dids = new Array(-1, -1, -1, -1, -1, -1, -1, -1);
                this._context3Ds = new Array(8);
                this._pSmooth = true;
                this._pRepeat = false;
                this._pMipmap = true;
                this._depthCompareMode = away.display3D.Context3DCompareMode.LESS_EQUAL;
                this._blendFactorSource = away.display3D.Context3DBlendFactor.ONE;
                this._blendFactorDest = away.display3D.Context3DBlendFactor.ZERO;
                this._pEnableBlending = false;
                // TODO: AGAL conversion
                this._pAnimatableAttributes = new Array("va0");
                // TODO: AGAL conversion
                this._pAnimationTargetRegisters = new Array("vt0");
                // TODO: AGAL conversion
                this._pShadedTarget = "ft0";
                this._defaultCulling = away.display3D.Context3DTriangleFace.BACK;
                this._pAlphaPremultiplied = false;
                this._writeDepth = true;

                this._renderToTexture = renderToTexture;
                this._pNumUsedStreams = 1;
                this._pNumUsedVertexConstants = 5;

                this._iUniqueId = away.materials.MaterialPassBase.MATERIALPASS_ID_COUNT++;
            }
            Object.defineProperty(MaterialPassBase.prototype, "material", {
                get: /**
                * The material to which this pass belongs.
                */
                function () {
                    return this._pMaterial;
                },
                set: function (value) {
                    this._pMaterial = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "writeDepth", {
                get: /**
                * Indicate whether this pass should write to the depth buffer or not. Ignored when blending is enabled.
                */
                function () {
                    return this._writeDepth;
                },
                set: function (value) {
                    this._writeDepth = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "mipmap", {
                get: /**
                * Defines whether any used textures should use mipmapping.
                */
                function () {
                    return this._pMipmap;
                },
                set: function (value) {
                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });


            MaterialPassBase.prototype.setMipMap = function (value) {
                if (this._pMipmap == value) {
                    return;
                }

                this._pMipmap = value;
                this.iInvalidateShaderProgram();
            };

            Object.defineProperty(MaterialPassBase.prototype, "smooth", {
                get: /**
                * Defines whether smoothing should be applied to any used textures.
                */
                function () {
                    return this._pSmooth;
                },
                set: function (value) {
                    if (this._pSmooth == value) {
                        return;
                    }

                    this._pSmooth = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "repeat", {
                get: /**
                * Defines whether textures should be tiled.
                */
                function () {
                    return this._pRepeat;
                },
                set: function (value) {
                    if (this._pRepeat == value) {
                        return;
                    }

                    this._pRepeat = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "bothSides", {
                get: /**
                * Defines whether or not the material should perform backface culling.
                */
                function () {
                    return this._pBothSides;
                },
                set: function (value) {
                    this._pBothSides = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "depthCompareMode", {
                get: /**
                * The depth compare mode used to render the renderables using this material.
                *
                * @see flash.display3D.Context3DCompareMode
                */
                function () {
                    return this._depthCompareMode;
                },
                set: function (value) {
                    this._depthCompareMode = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MaterialPassBase.prototype, "animationSet", {
                get: /**
                * Returns the animation data set adding animations to the material.
                */
                function () {
                    return this._animationSet;
                },
                set: function (value) {
                    if (this._animationSet == value) {
                        return;
                    }

                    this._animationSet = value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            MaterialPassBase.prototype.setAnimationSet = function (value) {
                if (this._animationSet == value) {
                    return;
                }

                this._animationSet = value;

                this.iInvalidateShaderProgram();
            };

            Object.defineProperty(MaterialPassBase.prototype, "renderToTexture", {
                get: /**
                * Specifies whether this pass renders to texture
                */
                function () {
                    return this._renderToTexture;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Cleans up any resources used by the current object.
            * @param deep Indicates whether other resources should be cleaned up, that could potentially be shared across different instances.
            */
            MaterialPassBase.prototype.dispose = function () {
                if (this._pLightPicker) {
                    this._pLightPicker.removeEventListener(away.events.Event.CHANGE, this.onLightsChange, this);
                }

                for (var i = 0; i < 8; ++i) {
                    if (this._iProgram3Ds[i]) {
                        //away.Debug.throwPIR( 'away.materials.MaterialPassBase' , 'dispose' , 'required dependency: AGALProgram3DCache');
                        away.managers.AGALProgram3DCache.getInstanceFromIndex(i).freeProgram3D(this._iProgram3Dids[i]);
                        this._iProgram3Ds[i] = null;
                    }
                }
            };

            Object.defineProperty(MaterialPassBase.prototype, "numUsedStreams", {
                get: /**
                * The amount of used vertex streams in the vertex code. Used by the animation code generation to know from which index on streams are available.
                */
                function () {
                    return this._pNumUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedVertexConstants", {
                get: /**
                * The amount of used vertex constants in the vertex code. Used by the animation code generation to know from which index on registers are available.
                */
                function () {
                    return this._pNumUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedVaryings", {
                get: function () {
                    return this._pNumUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "numUsedFragmentConstants", {
                get: /**
                * The amount of used fragment constants in the fragment code. Used by the animation code generation to know from which index on registers are available.
                */
                function () {
                    return this._pNumUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "needFragmentAnimation", {
                get: function () {
                    return this._pNeedFragmentAnimation;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MaterialPassBase.prototype, "needUVAnimation", {
                get: /**
                * Indicates whether the pass requires any UV animatin code.
                */
                function () {
                    return this._pNeedUVAnimation;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Sets up the animation state. This needs to be called before render()
            *
            * @private
            */
            MaterialPassBase.prototype.iUpdateAnimationState = function (renderable, stage3DProxy, camera) {
                renderable.animator.setRenderState(stage3DProxy, renderable, this._pNumUsedVertexConstants, this._pNumUsedStreams, camera);
            };

            /**
            * Renders an object to the current render target.
            *
            * @private
            */
            MaterialPassBase.prototype.iRender = function (renderable, stage3DProxy, camera, viewProjection) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Returns the vertex AGAL code for the material.
            */
            MaterialPassBase.prototype.iGetVertexCode = function () {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Returns the fragment AGAL code for the material.
            */
            MaterialPassBase.prototype.iGetFragmentCode = function (fragmentAnimatorCode) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * The blend mode to use when drawing this renderable. The following blend modes are supported:
            * <ul>
            * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
            * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
            * <li>BlendMode.MULTIPLY</li>
            * <li>BlendMode.ADD</li>
            * <li>BlendMode.ALPHA</li>
            * </ul>
            */
            MaterialPassBase.prototype.setBlendMode = function (value) {
                switch (value) {
                    case away.display.BlendMode.NORMAL:
                        this._blendFactorSource = away.display3D.Context3DBlendFactor.ONE;
                        this._blendFactorDest = away.display3D.Context3DBlendFactor.ZERO;
                        this._pEnableBlending = false;

                        break;

                    case away.display.BlendMode.LAYER:
                        this._blendFactorSource = away.display3D.Context3DBlendFactor.SOURCE_ALPHA;
                        this._blendFactorDest = away.display3D.Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA;
                        this._pEnableBlending = true;

                        break;

                    case away.display.BlendMode.MULTIPLY:
                        this._blendFactorSource = away.display3D.Context3DBlendFactor.ZERO;
                        this._blendFactorDest = away.display3D.Context3DBlendFactor.SOURCE_COLOR;
                        this._pEnableBlending = true;

                        break;

                    case away.display.BlendMode.ADD:
                        this._blendFactorSource = away.display3D.Context3DBlendFactor.SOURCE_ALPHA;
                        this._blendFactorDest = away.display3D.Context3DBlendFactor.ONE;
                        this._pEnableBlending = true;

                        break;

                    case away.display.BlendMode.ALPHA:
                        this._blendFactorSource = away.display3D.Context3DBlendFactor.ZERO;
                        this._blendFactorDest = away.display3D.Context3DBlendFactor.SOURCE_ALPHA;
                        this._pEnableBlending = true;

                        break;

                    default:
                        throw new away.errors.ArgumentError("Unsupported blend mode!");
                }
            };

            /**
            * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
            * calling renderPass. Before activating a pass, the previously used pass needs to be deactivated.
            * @param stage3DProxy The Stage3DProxy object which is currently used for rendering.
            * @param camera The camera from which the scene is viewed.
            * @private
            */
            MaterialPassBase.prototype.iActivate = function (stage3DProxy, camera) {
                var contextIndex = stage3DProxy._iStage3DIndex;
                var context = stage3DProxy._iContext3D;

                context.setDepthTest((this._writeDepth && !this._pEnableBlending), this._depthCompareMode);

                if (this._pEnableBlending) {
                    context.setBlendFactors(this._blendFactorSource, this._blendFactorDest);
                }

                if (this._context3Ds[contextIndex] != context || !this._iProgram3Ds[contextIndex]) {
                    this._context3Ds[contextIndex] = context;

                    this.iUpdateProgram(stage3DProxy);
                    this.dispatchEvent(new away.events.Event(away.events.Event.CHANGE));
                }

                var prevUsed = MaterialPassBase._previousUsedStreams[contextIndex];
                var i;

                for (i = this._pNumUsedStreams; i < prevUsed; ++i) {
                    context.setVertexBufferAt(i, null);
                }

                prevUsed = MaterialPassBase._previousUsedTexs[contextIndex];

                for (i = this._pNumUsedTextures; i < prevUsed; ++i) {
                    context.setTextureAt(i, null);
                }

                if (this._animationSet && !this._animationSet.usesCPU) {
                    this._animationSet.activate(stage3DProxy, this);
                }

                context.setProgram(this._iProgram3Ds[contextIndex]);

                context.setCulling(this._pBothSides ? away.display3D.Context3DTriangleFace.NONE : this._defaultCulling);

                if (this._renderToTexture) {
                    this._oldTarget = stage3DProxy.renderTarget;
                    this._oldSurface = stage3DProxy.renderSurfaceSelector;
                    this._oldDepthStencil = stage3DProxy.enableDepthAndStencil;
                    this._oldRect = stage3DProxy.scissorRect;
                }
            };

            /**
            * Clears the render state for the pass. This needs to be called before activating another pass.
            * @param stage3DProxy The Stage3DProxy used for rendering
            *
            * @private
            */
            MaterialPassBase.prototype.iDeactivate = function (stage3DProxy) {
                var index = stage3DProxy._iStage3DIndex;
                MaterialPassBase._previousUsedStreams[index] = this._pNumUsedStreams;
                MaterialPassBase._previousUsedTexs[index] = this._pNumUsedTextures;

                if (this._animationSet && !this._animationSet.usesCPU) {
                    this._animationSet.deactivate(stage3DProxy, this);
                }

                if (this._renderToTexture) {
                    // kindly restore state
                    stage3DProxy.setRenderTarget(this._oldTarget, this._oldDepthStencil, this._oldSurface);
                    stage3DProxy.scissorRect = this._oldRect;
                }

                stage3DProxy._iContext3D.setDepthTest(true, away.display3D.Context3DCompareMode.LESS_EQUAL);
            };

            /**
            * Marks the shader program as invalid, so it will be recompiled before the next render.
            *
            * @param updateMaterial Indicates whether the invalidation should be performed on the entire material. Should always pass "true" unless it's called from the material itself.
            */
            MaterialPassBase.prototype.iInvalidateShaderProgram = function (updateMaterial) {
                if (typeof updateMaterial === "undefined") { updateMaterial = true; }
                for (var i = 0; i < 8; ++i) {
                    this._iProgram3Ds[i] = null;
                }

                if (this._pMaterial && updateMaterial) {
                    this._pMaterial.iInvalidatePasses(this);
                }
            };

            /**
            * Compiles the shader program.
            * @param polyOffsetReg An optional register that contains an amount by which to inflate the model (used in single object depth map rendering).
            */
            MaterialPassBase.prototype.iUpdateProgram = function (stage3DProxy) {
                var animatorCode = "";
                var UVAnimatorCode = "";
                var fragmentAnimatorCode = "";
                var vertexCode = this.iGetVertexCode();

                if (this._animationSet && !this._animationSet.usesCPU) {
                    animatorCode = this._animationSet.getAGALVertexCode(this, this._pAnimatableAttributes, this._pAnimationTargetRegisters, stage3DProxy.profile);

                    if (this._pNeedFragmentAnimation) {
                        fragmentAnimatorCode = this._animationSet.getAGALFragmentCode(this, this._pShadedTarget, stage3DProxy.profile);
                    }

                    if (this._pNeedUVAnimation) {
                        UVAnimatorCode = this._animationSet.getAGALUVCode(this, this._pUVSource, this._pUVTarget);
                    }

                    this._animationSet.doneAGALCode(this);
                } else {
                    var len = this._pAnimatableAttributes.length;

                    for (var i = 0; i < len; ++i) {
                        // TODO: AGAL <> GLSL conversion:
                        //away.Debug.throwPIR( 'away.materials.MaterialPassBase' , 'iUpdateProgram' , 'AGAL <> GLSL Conversion');
                        animatorCode += "mov " + this._pAnimationTargetRegisters[i] + ", " + this._pAnimatableAttributes[i] + "\n";
                    }

                    if (this._pNeedUVAnimation) {
                        //away.Debug.throwPIR( 'away.materials.MaterialPassBase' , 'iUpdateProgram' , 'AGAL <> GLSL Conversion');
                        // TODO: AGAL <> GLSL conversion
                        UVAnimatorCode = "mov " + this._pUVTarget + "," + this._pUVSource + "\n";
                    }
                }

                vertexCode = animatorCode + UVAnimatorCode + vertexCode;

                var fragmentCode = this.iGetFragmentCode(fragmentAnimatorCode);

                /*
                if (this.Debug.active) {
                trace("Compiling AGAL Code:");
                trace("--------------------");
                trace(vertexCode);
                trace("--------------------");
                trace(fragmentCode);
                }
                */
                away.managers.AGALProgram3DCache.getInstance(stage3DProxy).setProgram3D(this, vertexCode, fragmentCode);
            };

            Object.defineProperty(MaterialPassBase.prototype, "lightPicker", {
                get: /**
                * The light picker used by the material to provide lights to the material if it supports lighting.
                *
                * @see away3d.materials.lightpickers.LightPickerBase
                * @see away3d.materials.lightpickers.StaticLightPicker
                */
                function () {
                    return this._pLightPicker;
                },
                set: function (value) {
                    if (this._pLightPicker) {
                        this._pLightPicker.removeEventListener(away.events.Event.CHANGE, this.onLightsChange, this);
                    }

                    this._pLightPicker = value;

                    if (this._pLightPicker) {
                        this._pLightPicker.addEventListener(away.events.Event.CHANGE, this.onLightsChange, this);
                    }

                    this.pUpdateLights();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Called when the light picker's configuration changes.
            */
            MaterialPassBase.prototype.onLightsChange = function (event) {
                this.pUpdateLights();
            };

            /**
            * Implemented by subclasses if the pass uses lights to update the shader.
            */
            MaterialPassBase.prototype.pUpdateLights = function () {
            };

            Object.defineProperty(MaterialPassBase.prototype, "alphaPremultiplied", {
                get: /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied. Toggle this if you are seeing black halos around your
                * blended alpha edges.
                */
                function () {
                    return this._pAlphaPremultiplied;
                },
                set: function (value) {
                    this._pAlphaPremultiplied = value;
                    this.iInvalidateShaderProgram(false);
                },
                enumerable: true,
                configurable: true
            });

            MaterialPassBase._previousUsedStreams = new Array(0, 0, 0, 0, 0, 0, 0, 0);
            MaterialPassBase._previousUsedTexs = new Array(0, 0, 0, 0, 0, 0, 0, 0);
            return MaterialPassBase;
        })(away.events.EventDispatcher);
        materials.MaterialPassBase = MaterialPassBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var CompiledPass = (function (_super) {
            __extends(CompiledPass, _super);
            /**
            * Creates a new CompiledPass object.
            * @param material The material to which this pass belongs.
            */
            function CompiledPass(material) {
                _super.call(this);
                this._pSpecularLightSources = 0x01;
                this._pDiffuseLightSources = 0x03;
                this._pVertexConstantData = new Array();
                this._pFragmentConstantData = new Array();
                this._preserveAlpha = true;
                this._animateUVs = false;
                this._enableLightFallOff = true;
                this._forceSeparateMVP = false;

                //away.Debug.throwPIR( "away.materials.CompiledaPass" , 'normalMethod' , 'implement dependency: BasicNormalMethod, BasicAmbientMethod, BasicDiffuseMethod, BasicSpecularMethod');
                this._pMaterial = material;

                this.init();
            }
            Object.defineProperty(CompiledPass.prototype, "enableLightFallOff", {
                get: /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                function () {
                    return this._enableLightFallOff;
                },
                set: function (value) {
                    if (value != this._enableLightFallOff) {
                        this.iInvalidateShaderProgram(true);
                    }

                    this._enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "forceSeparateMVP", {
                get: /**
                * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
                * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
                * projection code.
                */
                function () {
                    return this._forceSeparateMVP;
                },
                set: function (value) {
                    this._forceSeparateMVP = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "iNumPointLights", {
                get: /**
                * The amount of point lights that need to be supported.
                */
                function () {
                    return this._pNumPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "iNumDirectionalLights", {
                get: /**
                * The amount of directional lights that need to be supported.
                */
                function () {
                    return this._pNumDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "iNumLightProbes", {
                get: /**
                * The amount of light probes that need to be supported.
                */
                function () {
                    return this._pNumLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iUpdateProgram = function (stage3DProxy) {
                this.reset(stage3DProxy.profile);
                _super.prototype.iUpdateProgram.call(this, stage3DProxy);
            };

            /**
            * Resets the compilation state.
            *
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.reset = function (profile) {
                this.iInitCompiler(profile);

                this.pUpdateShaderProperties();
                this.initConstantData();

                this.pCleanUp();
            };

            /**
            * Updates the amount of used register indices.
            */
            CompiledPass.prototype.updateUsedOffsets = function () {
                this._pNumUsedVertexConstants = this._pCompiler.numUsedVertexConstants;
                this._pNumUsedFragmentConstants = this._pCompiler.numUsedFragmentConstants;
                this._pNumUsedStreams = this._pCompiler.numUsedStreams;
                this._pNumUsedTextures = this._pCompiler.numUsedTextures;
                this._pNumUsedVaryings = this._pCompiler.numUsedVaryings;
                this._pNumUsedFragmentConstants = this._pCompiler.numUsedFragmentConstants;
            };

            /**
            * Initializes the unchanging constant data for this material.
            */
            CompiledPass.prototype.initConstantData = function () {
                this._pVertexConstantData.length = this._pNumUsedVertexConstants * 4;
                this._pFragmentConstantData.length = this._pNumUsedFragmentConstants * 4;

                this.pInitCommonsData();

                if (this._uvTransformIndex >= 0) {
                    this.pInitUVTransformData();
                }

                if (this._pCameraPositionIndex >= 0) {
                    this._pVertexConstantData[this._pCameraPositionIndex + 3] = 1;
                }

                this.pUpdateMethodConstants();
            };

            /**
            * Initializes the compiler for this pass.
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.iInitCompiler = function (profile) {
                this._pCompiler = this.pCreateCompiler(profile);
                this._pCompiler.forceSeperateMVP = this._forceSeparateMVP;
                this._pCompiler.numPointLights = this._pNumPointLights;
                this._pCompiler.numDirectionalLights = this._pNumDirectionalLights;
                this._pCompiler.numLightProbes = this._pNumLightProbes;
                this._pCompiler.methodSetup = this._pMethodSetup;
                this._pCompiler.diffuseLightSources = this._pDiffuseLightSources;
                this._pCompiler.specularLightSources = this._pSpecularLightSources;
                this._pCompiler.setTextureSampling(this._pSmooth, this._pRepeat, this._pMipmap);
                this._pCompiler.setConstantDataBuffers(this._pVertexConstantData, this._pFragmentConstantData);
                this._pCompiler.animateUVs = this._animateUVs;
                this._pCompiler.alphaPremultiplied = this._pAlphaPremultiplied && this._pEnableBlending;
                this._pCompiler.preserveAlpha = this._preserveAlpha && this._pEnableBlending;
                this._pCompiler.enableLightFallOff = this._enableLightFallOff;
                this._pCompiler.compile();
            };

            /**
            * Factory method to create a concrete compiler object for this pass.
            * @param profile The compatibility profile used by the renderer.
            */
            CompiledPass.prototype.pCreateCompiler = function (profile) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Copies the shader's properties from the compiler.
            */
            CompiledPass.prototype.pUpdateShaderProperties = function () {
                this._pAnimatableAttributes = this._pCompiler.animatableAttributes;
                this._pAnimationTargetRegisters = this._pCompiler.animationTargetRegisters;
                this._vertexCode = this._pCompiler.vertexCode;
                this._fragmentLightCode = this._pCompiler.fragmentLightCode;
                this._framentPostLightCode = this._pCompiler.fragmentPostLightCode;
                this._pShadedTarget = this._pCompiler.shadedTarget;
                this._usingSpecularMethod = this._pCompiler.usingSpecularMethod;
                this._usesNormals = this._pCompiler.usesNormals;
                this._pNeedUVAnimation = this._pCompiler.needUVAnimation;
                this._pUVSource = this._pCompiler.UVSource;
                this._pUVTarget = this._pCompiler.UVTarget;

                this.pUpdateRegisterIndices();
                this.updateUsedOffsets();
            };

            /**
            * Updates the indices for various registers.
            */
            CompiledPass.prototype.pUpdateRegisterIndices = function () {
                this._uvBufferIndex = this._pCompiler.uvBufferIndex;
                this._uvTransformIndex = this._pCompiler.uvTransformIndex;
                this._secondaryUVBufferIndex = this._pCompiler.secondaryUVBufferIndex;
                this._normalBufferIndex = this._pCompiler.normalBufferIndex;
                this._tangentBufferIndex = this._pCompiler.tangentBufferIndex;
                this._pLightFragmentConstantIndex = this._pCompiler.lightFragmentConstantIndex;
                this._pCameraPositionIndex = this._pCompiler.cameraPositionIndex;
                this._commonsDataIndex = this._pCompiler.commonsDataIndex;
                this._sceneMatrixIndex = this._pCompiler.sceneMatrixIndex;
                this._sceneNormalMatrixIndex = this._pCompiler.sceneNormalMatrixIndex;
                this._pProbeWeightsIndex = this._pCompiler.probeWeightsIndex;
                this._pLightProbeDiffuseIndices = this._pCompiler.lightProbeDiffuseIndices;
                this._pLightProbeSpecularIndices = this._pCompiler.lightProbeSpecularIndices;
            };

            Object.defineProperty(CompiledPass.prototype, "preserveAlpha", {
                get: /**
                * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
                */
                function () {
                    return this._preserveAlpha;
                },
                set: function (value) {
                    if (this._preserveAlpha == value) {
                        return;
                    }

                    this._preserveAlpha = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "animateUVs", {
                get: /**
                * Indicate whether UV coordinates need to be animated using the renderable's transformUV matrix.
                */
                function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;

                    if ((value && !this._animateUVs) || (!value && this._animateUVs)) {
                        this.iInvalidateShaderProgram();
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "mipmap", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (this._pMipmap == value)
                        return;

                    _super.prototype.setMipMap.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompiledPass.prototype, "normalMap", {
                get: /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                function () {
                    return this._pMethodSetup._iNormalMethod.normalMap;
                },
                set: function (value) {
                    this._pMethodSetup._iNormalMethod.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "normalMethod", {
                get: /**
                * The method used to generate the per-pixel normals. Defaults to BasicNormalMethod.
                */
                function () {
                    return this._pMethodSetup.normalMethod;
                },
                set: function (value) {
                    this._pMethodSetup.normalMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "ambientMethod", {
                get: /**
                * The method that provides the ambient lighting contribution. Defaults to BasicAmbientMethod.
                */
                function () {
                    return this._pMethodSetup.ambientMethod;
                },
                set: function (value) {
                    this._pMethodSetup.ambientMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "shadowMethod", {
                get: /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                function () {
                    return this._pMethodSetup.shadowMethod;
                },
                set: function (value) {
                    this._pMethodSetup.shadowMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "diffuseMethod", {
                get: /**
                * The method that provides the diffuse lighting contribution. Defaults to BasicDiffuseMethod.
                */
                function () {
                    return this._pMethodSetup.diffuseMethod;
                },
                set: function (value) {
                    this._pMethodSetup.diffuseMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "specularMethod", {
                get: /**
                * The method that provides the specular lighting contribution. Defaults to BasicSpecularMethod.
                */
                function () {
                    return this._pMethodSetup.specularMethod;
                },
                set: function (value) {
                    this._pMethodSetup.specularMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Initializes the pass.
            */
            CompiledPass.prototype.init = function () {
                this._pMethodSetup = new away.materials.ShaderMethodSetup();

                this._pMethodSetup.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this._pMethodSetup.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                this._pMethodSetup.dispose();
                this._pMethodSetup = null;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iInvalidateShaderProgram = function (updateMaterial) {
                if (typeof updateMaterial === "undefined") { updateMaterial = true; }
                var oldPasses = this._iPasses;
                this._iPasses = new Array();

                if (this._pMethodSetup) {
                    this.pAddPassesFromMethods();
                }

                if (!oldPasses || this._iPasses.length != oldPasses.length) {
                    this._iPassesDirty = true;
                    return;
                }

                for (var i = 0; i < this._iPasses.length; ++i) {
                    if (this._iPasses[i] != oldPasses[i]) {
                        this._iPassesDirty = true;
                        return;
                    }
                }

                _super.prototype.iInvalidateShaderProgram.call(this, updateMaterial);
            };

            /**
            * Adds any possible passes needed by the used methods.
            */
            CompiledPass.prototype.pAddPassesFromMethods = function () {
                if (this._pMethodSetup._iNormalMethod && this._pMethodSetup._iNormalMethod.iHasOutput)
                    this.pAddPasses(this._pMethodSetup._iNormalMethod.passes);

                if (this._pMethodSetup._iAmbientMethod)
                    this.pAddPasses(this._pMethodSetup._iAmbientMethod.passes);

                if (this._pMethodSetup._iShadowMethod)
                    this.pAddPasses(this._pMethodSetup._iShadowMethod.passes);

                if (this._pMethodSetup._iDiffuseMethod)
                    this.pAddPasses(this._pMethodSetup._iDiffuseMethod.passes);

                if (this._pMethodSetup._iSpecularMethod)
                    this.pAddPasses(this._pMethodSetup._iSpecularMethod.passes);
            };

            /**
            * Adds internal passes to the material.
            *
            * @param passes The passes to add.
            */
            CompiledPass.prototype.pAddPasses = function (passes) {
                if (!passes) {
                    return;
                }

                var len = passes.length;

                for (var i = 0; i < len; ++i) {
                    passes[i].material = this.material;
                    passes[i].lightPicker = this._pLightPicker;
                    this._iPasses.push(passes[i]);
                }
            };

            /**
            * Initializes the default UV transformation matrix.
            */
            CompiledPass.prototype.pInitUVTransformData = function () {
                this._pVertexConstantData[this._uvTransformIndex] = 1;
                this._pVertexConstantData[this._uvTransformIndex + 1] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 2] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 3] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 4] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 5] = 1;
                this._pVertexConstantData[this._uvTransformIndex + 6] = 0;
                this._pVertexConstantData[this._uvTransformIndex + 7] = 0;
            };

            /**
            * Initializes commonly required constant values.
            */
            CompiledPass.prototype.pInitCommonsData = function () {
                this._pFragmentConstantData[this._commonsDataIndex] = .5;
                this._pFragmentConstantData[this._commonsDataIndex + 1] = 0;
                this._pFragmentConstantData[this._commonsDataIndex + 2] = 1 / 255;
                this._pFragmentConstantData[this._commonsDataIndex + 3] = 1;
            };

            /**
            * Cleans up the after compiling.
            */
            CompiledPass.prototype.pCleanUp = function () {
                this._pCompiler.dispose();
                this._pCompiler = null;
            };

            /**
            * Updates method constants if they have changed.
            */
            CompiledPass.prototype.pUpdateMethodConstants = function () {
                if (this._pMethodSetup._iNormalMethod)
                    this._pMethodSetup._iNormalMethod.iInitConstants(this._pMethodSetup._iNormalMethodVO);

                if (this._pMethodSetup._iDiffuseMethod)
                    this._pMethodSetup._iDiffuseMethod.iInitConstants(this._pMethodSetup._iDiffuseMethodVO);

                if (this._pMethodSetup._iAmbientMethod)
                    this._pMethodSetup._iAmbientMethod.iInitConstants(this._pMethodSetup._iAmbientMethodVO);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iInitConstants(this._pMethodSetup._iSpecularMethodVO);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iInitConstants(this._pMethodSetup._iShadowMethodVO);
            };

            /**
            * Updates constant data render state used by the lights. This method is optional for subclasses to implement.
            */
            CompiledPass.prototype.pUpdateLightConstants = function () {
                // up to subclasses to optionally implement
            };

            /**
            * Updates constant data render state used by the light probes. This method is optional for subclasses to implement.
            */
            CompiledPass.prototype.pUpdateProbes = function (stage3DProxy) {
            };

            /**
            * Called when any method's shader code is invalidated.
            */
            CompiledPass.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iGetVertexCode = function () {
                return this._vertexCode;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iGetFragmentCode = function (animatorCode) {
                //TODO: AGAL <> GLSL conversion
                return this._fragmentLightCode + animatorCode + this._framentPostLightCode;
            };

            // RENDER LOOP
            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iActivate = function (stage3DProxy, camera) {
                _super.prototype.iActivate.call(this, stage3DProxy, camera);

                if (this._usesNormals) {
                    this._pMethodSetup._iNormalMethod.iActivate(this._pMethodSetup._iNormalMethodVO, stage3DProxy);
                }

                this._pMethodSetup._iAmbientMethod.iActivate(this._pMethodSetup._iAmbientMethodVO, stage3DProxy);

                if (this._pMethodSetup._iShadowMethod) {
                    this._pMethodSetup._iShadowMethod.iActivate(this._pMethodSetup._iShadowMethodVO, stage3DProxy);
                }

                this._pMethodSetup._iDiffuseMethod.iActivate(this._pMethodSetup._iDiffuseMethodVO, stage3DProxy);

                if (this._usingSpecularMethod) {
                    this._pMethodSetup._iSpecularMethod.iActivate(this._pMethodSetup._iSpecularMethodVO, stage3DProxy);
                }
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iRender = function (renderable, stage3DProxy, camera, viewProjection) {
                var i;
                var context = stage3DProxy._iContext3D;
                if (this._uvBufferIndex >= 0)
                    renderable.activateUVBuffer(this._uvBufferIndex, stage3DProxy);

                if (this._secondaryUVBufferIndex >= 0)
                    renderable.activateSecondaryUVBuffer(this._secondaryUVBufferIndex, stage3DProxy);

                if (this._normalBufferIndex >= 0)
                    renderable.activateVertexNormalBuffer(this._normalBufferIndex, stage3DProxy);

                if (this._tangentBufferIndex >= 0)
                    renderable.activateVertexTangentBuffer(this._tangentBufferIndex, stage3DProxy);

                if (this._animateUVs) {
                    var uvTransform = renderable.uvTransform;

                    if (uvTransform) {
                        this._pVertexConstantData[this._uvTransformIndex] = uvTransform.a;
                        this._pVertexConstantData[this._uvTransformIndex + 1] = uvTransform.b;
                        this._pVertexConstantData[this._uvTransformIndex + 3] = uvTransform.tx;
                        this._pVertexConstantData[this._uvTransformIndex + 4] = uvTransform.c;
                        this._pVertexConstantData[this._uvTransformIndex + 5] = uvTransform.d;
                        this._pVertexConstantData[this._uvTransformIndex + 7] = uvTransform.ty;
                    } else {
                        this._pVertexConstantData[this._uvTransformIndex] = 1;
                        this._pVertexConstantData[this._uvTransformIndex + 1] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 3] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 4] = 0;
                        this._pVertexConstantData[this._uvTransformIndex + 5] = 1;
                        this._pVertexConstantData[this._uvTransformIndex + 7] = 0;
                    }
                }

                this._pAmbientLightR = this._pAmbientLightG = this._pAmbientLightB = 0;

                if (this.pUsesLights()) {
                    this.pUpdateLightConstants();
                }

                if (this.pUsesProbes()) {
                    this.pUpdateProbes(stage3DProxy);
                }

                if (this._sceneMatrixIndex >= 0) {
                    renderable.getRenderSceneTransform(camera).copyRawDataTo(this._pVertexConstantData, this._sceneMatrixIndex, true);
                    viewProjection.copyRawDataTo(this._pVertexConstantData, 0, true);
                    //this._pVertexConstantData = renderable.getRenderSceneTransform(camera).copyRawDataTo( this._sceneMatrixIndex, true);
                    //this._pVertexConstantData = viewProjection.copyRawDataTo( 0, true);
                } else {
                    var matrix3D = away.math.Matrix3DUtils.CALCULATION_MATRIX;

                    matrix3D.copyFrom(renderable.getRenderSceneTransform(camera));
                    matrix3D.append(viewProjection);

                    matrix3D.copyRawDataTo(this._pVertexConstantData, 0, true);
                    //this._pVertexConstantData = matrix3D.copyRawDataTo( 0, true);
                }

                if (this._sceneNormalMatrixIndex >= 0) {
                    renderable.inverseSceneTransform.copyRawDataTo(this._pVertexConstantData, this._sceneNormalMatrixIndex, false);
                    //this._pVertexConstantData = renderable.inverseSceneTransform.copyRawDataTo(this._sceneNormalMatrixIndex, false);
                }

                if (this._usesNormals) {
                    this._pMethodSetup._iNormalMethod.iSetRenderState(this._pMethodSetup._iNormalMethodVO, renderable, stage3DProxy, camera);
                }

                //away.Debug.throwPIR( 'away.materials.CompiledPass' , 'iRender' , 'implement dependency: BasicAmbientMethod');
                var ambientMethod = this._pMethodSetup._iAmbientMethod;
                ambientMethod._iLightAmbientR = this._pAmbientLightR;
                ambientMethod._iLightAmbientG = this._pAmbientLightG;
                ambientMethod._iLightAmbientB = this._pAmbientLightB;
                ambientMethod.iSetRenderState(this._pMethodSetup._iAmbientMethodVO, renderable, stage3DProxy, camera);

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iSetRenderState(this._pMethodSetup._iShadowMethodVO, renderable, stage3DProxy, camera);

                this._pMethodSetup._iDiffuseMethod.iSetRenderState(this._pMethodSetup._iDiffuseMethodVO, renderable, stage3DProxy, camera);

                if (this._usingSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iSetRenderState(this._pMethodSetup._iSpecularMethodVO, renderable, stage3DProxy, camera);

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iSetRenderState(this._pMethodSetup._iColorTransformMethodVO, renderable, stage3DProxy, camera);

                //away.Debug.throwPIR( 'away.materials.CompiledPass' , 'iRender' , 'implement dependency: MethodVOSet');
                //Vector.<MethodVOSet>
                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (i = 0; i < len; ++i) {
                    var aset = methods[i];

                    aset.method.iSetRenderState(aset.data, renderable, stage3DProxy, camera);
                }

                context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, 0, this._pVertexConstantData, this._pNumUsedVertexConstants);
                context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.FRAGMENT, 0, this._pFragmentConstantData, this._pNumUsedFragmentConstants);

                renderable.activateVertexBuffer(0, stage3DProxy);
                context.drawTriangles(renderable.getIndexBuffer(stage3DProxy), 0, renderable.numTriangles);
            };

            /**
            * Indicates whether the shader uses any light probes.
            */
            CompiledPass.prototype.pUsesProbes = function () {
                return this._pNumLightProbes > 0 && ((this._pDiffuseLightSources | this._pSpecularLightSources) & away.materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether the shader uses any lights.
            */
            CompiledPass.prototype.pUsesLights = function () {
                return (this._pNumPointLights > 0 || this._pNumDirectionalLights > 0) && ((this._pDiffuseLightSources | this._pSpecularLightSources) & away.materials.LightSources.LIGHTS) != 0;
            };

            /**
            * @inheritDoc
            */
            CompiledPass.prototype.iDeactivate = function (stage3DProxy) {
                _super.prototype.iDeactivate.call(this, stage3DProxy);

                if (this._usesNormals) {
                    this._pMethodSetup._iNormalMethod.iDeactivate(this._pMethodSetup._iNormalMethodVO, stage3DProxy);
                }

                this._pMethodSetup._iAmbientMethod.iDeactivate(this._pMethodSetup._iAmbientMethodVO, stage3DProxy);

                if (this._pMethodSetup._iShadowMethod) {
                    this._pMethodSetup._iShadowMethod.iDeactivate(this._pMethodSetup._iShadowMethodVO, stage3DProxy);
                }

                this._pMethodSetup._iDiffuseMethod.iDeactivate(this._pMethodSetup._iDiffuseMethodVO, stage3DProxy);

                if (this._usingSpecularMethod) {
                    this._pMethodSetup._iSpecularMethod.iDeactivate(this._pMethodSetup._iSpecularMethodVO, stage3DProxy);
                }
            };

            Object.defineProperty(CompiledPass.prototype, "specularLightSources", {
                get: /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._pSpecularLightSources;
                },
                set: function (value) {
                    this._pSpecularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompiledPass.prototype, "diffuseLightSources", {
                get: /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._pDiffuseLightSources;
                },
                set: function (value) {
                    this._pDiffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });

            return CompiledPass;
        })(away.materials.MaterialPassBase);
        materials.CompiledPass = CompiledPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SuperShaderPass is a shader pass that uses shader methods to compile a complete program. It includes all methods
        * associated with a material.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var SuperShaderPass = (function (_super) {
            __extends(SuperShaderPass, _super);
            /**
            * Creates a new SuperShaderPass objects.
            *
            * @param material The material to which this material belongs.
            */
            function SuperShaderPass(material) {
                _super.call(this, material);
                this._includeCasters = true;
                this._pNeedFragmentAnimation = true;
            }
            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pCreateCompiler = function (profile) {
                return new away.materials.SuperShaderCompiler(profile);
            };

            Object.defineProperty(SuperShaderPass.prototype, "includeCasters", {
                get: /**
                * Indicates whether lights that cast shadows should be included in the pass.
                */
                function () {
                    return this._includeCasters;
                },
                set: function (value) {
                    if (this._includeCasters == value)
                        return;
                    this._includeCasters = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SuperShaderPass.prototype, "colorTransform", {
                get: /**
                * The ColorTransform object to transform the colour of the material with. Defaults to null.
                */
                function () {
                    return this._pMethodSetup._iColorTransformMethod ? this._pMethodSetup._iColorTransformMethod.colorTransform : null;
                },
                set: function (value) {
                    if (value) {
                        if (this.colorTransformMethod == null) {
                            this.colorTransformMethod = new away.materials.ColorTransformMethod();
                        }

                        this._pMethodSetup._iColorTransformMethod.colorTransform = value;
                    } else if (!value) {
                        if (this._pMethodSetup._iColorTransformMethod) {
                            this.colorTransformMethod = null;
                        }

                        this.colorTransformMethod = this._pMethodSetup._iColorTransformMethod = null;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SuperShaderPass.prototype, "colorTransformMethod", {
                get: /**
                * The ColorTransformMethod object to transform the colour of the material with. Defaults to null.
                */
                function () {
                    return this._pMethodSetup._iColorTransformMethod;
                },
                set: function (value) {
                    this._pMethodSetup.iColorTransformMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            SuperShaderPass.prototype.addMethod = function (method) {
                this._pMethodSetup.addMethod(method);
            };

            Object.defineProperty(SuperShaderPass.prototype, "numMethods", {
                get: /**
                * The number of "effect" methods added to the material.
                */
                function () {
                    return this._pMethodSetup.numMethods;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            SuperShaderPass.prototype.hasMethod = function (method) {
                return this._pMethodSetup.hasMethod(method);
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            SuperShaderPass.prototype.getMethodAt = function (index) {
                return this._pMethodSetup.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            SuperShaderPass.prototype.addMethodAt = function (method, index) {
                this._pMethodSetup.addMethodAt(method, index);
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            SuperShaderPass.prototype.removeMethod = function (method) {
                this._pMethodSetup.removeMethod(method);
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateLights = function () {
                if (this._pLightPicker && !this._ignoreLights) {
                    this._pNumPointLights = this._pLightPicker.numPointLights;
                    this._pNumDirectionalLights = this._pLightPicker.numDirectionalLights;
                    this._pNumLightProbes = this._pLightPicker.numLightProbes;

                    if (this._includeCasters) {
                        this._pNumPointLights += this._pLightPicker.numCastingPointLights;
                        this._pNumDirectionalLights += this._pLightPicker.numCastingDirectionalLights;
                    }
                } else {
                    this._pNumPointLights = 0;
                    this._pNumDirectionalLights = 0;
                    this._pNumLightProbes = 0;
                }

                this.iInvalidateShaderProgram();
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.iActivate = function (stage3DProxy, camera) {
                _super.prototype.iActivate.call(this, stage3DProxy, camera);

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iActivate(this._pMethodSetup._iColorTransformMethodVO, stage3DProxy);

                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    var aset = methods[i];
                    aset.method.iActivate(aset.data, stage3DProxy);
                }

                if (this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;

                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.iDeactivate = function (stage3DProxy) {
                _super.prototype.iDeactivate.call(this, stage3DProxy);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pMethodSetup._iColorTransformMethod.iDeactivate(this._pMethodSetup._iColorTransformMethodVO, stage3DProxy);
                }

                var aset;
                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    aset = methods[i];
                    aset.method.iDeactivate(aset.data, stage3DProxy);
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pAddPassesFromMethods = function () {
                _super.prototype.pAddPassesFromMethods.call(this);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this.pAddPasses(this._pMethodSetup._iColorTransformMethod.passes);
                }
                var methods = this._pMethodSetup._iMethods;

                for (var i = 0; i < methods.length; ++i) {
                    this.pAddPasses(methods[i].method.passes);
                }
            };

            /**
            * Indicates whether any light probes are used to contribute to the specular shading.
            */
            SuperShaderPass.prototype.usesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._pSpecularLightSources & away.materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used to contribute to the diffuse shading.
            */
            SuperShaderPass.prototype.usesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._pDiffuseLightSources & away.materials.LightSources.PROBES) != 0;
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateMethodConstants = function () {
                _super.prototype.pUpdateMethodConstants.call(this);

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pMethodSetup._iColorTransformMethod.iInitConstants(this._pMethodSetup._iColorTransformMethodVO);
                }

                var methods = this._pMethodSetup._iMethods;
                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iInitConstants(methods[i].data);
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateLightConstants = function () {
                // first dirs, then points
                var dirLight;

                var pointLight;

                var i, k;

                var len;

                var dirPos;

                var total = 0;

                var numLightTypes = this._includeCasters ? 2 : 1;

                k = this._pLightFragmentConstantIndex;

                for (var cast = 0; cast < numLightTypes; ++cast) {
                    var dirLights = cast ? this._pLightPicker.castingDirectionalLights : this._pLightPicker.directionalLights;
                    len = dirLights.length;
                    total += len;

                    for (i = 0; i < len; ++i) {
                        dirLight = dirLights[i];
                        dirPos = dirLight.sceneDirection;

                        this._pAmbientLightR += dirLight._iAmbientR;
                        this._pAmbientLightG += dirLight._iAmbientG;
                        this._pAmbientLightB += dirLight._iAmbientB;

                        this._pFragmentConstantData[k++] = -dirPos.x;
                        this._pFragmentConstantData[k++] = -dirPos.y;
                        this._pFragmentConstantData[k++] = -dirPos.z;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                        this._pFragmentConstantData[k++] = 1;
                    }
                }

                if (this._pNumDirectionalLights > total) {
                    i = k + (this._pNumDirectionalLights - total) * 12;

                    while (k < i) {
                        this._pFragmentConstantData[k++] = 0;
                    }
                }

                total = 0;
                for (cast = 0; cast < numLightTypes; ++cast) {
                    var pointLights = cast ? this._pLightPicker.castingPointLights : this._pLightPicker.pointLights;

                    len = pointLights.length;

                    for (i = 0; i < len; ++i) {
                        pointLight = pointLights[i];
                        dirPos = pointLight.scenePosition;

                        this._pAmbientLightR += pointLight._iAmbientR;
                        this._pAmbientLightG += pointLight._iAmbientG;
                        this._pAmbientLightB += pointLight._iAmbientB;

                        this._pFragmentConstantData[k++] = dirPos.x;
                        this._pFragmentConstantData[k++] = dirPos.y;
                        this._pFragmentConstantData[k++] = dirPos.z;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = pointLight._pRadius * pointLight._pRadius;

                        this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                        this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;
                    }
                }

                if (this._pNumPointLights > total) {
                    i = k + (total - this._pNumPointLights) * 12;

                    for (; k < i; ++k) {
                        this._pFragmentConstantData[k] = 0;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            SuperShaderPass.prototype.pUpdateProbes = function (stage3DProxy) {
                var probe;
                var lightProbes = this._pLightPicker.lightProbes;
                var weights = this._pLightPicker.lightProbeWeights;
                var len = lightProbes.length;
                var addDiff = this.usesProbesForDiffuse();
                var addSpec = (this._pMethodSetup._iSpecularMethod && this.usesProbesForSpecular());
                var context = stage3DProxy._iContext3D;

                if (!(addDiff || addSpec)) {
                    return;
                }

                for (var i = 0; i < len; ++i) {
                    probe = lightProbes[i];

                    if (addDiff) {
                        context.setTextureAt(this._pLightProbeSpecularIndices[i], probe.diffuseMap.getTextureForStage3D(stage3DProxy));
                    }

                    if (addSpec) {
                        context.setTextureAt(this._pLightProbeSpecularIndices[i], probe.specularMap.getTextureForStage3D(stage3DProxy));
                    }
                }

                this._pFragmentConstantData[this._pProbeWeightsIndex] = weights[0];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 1] = weights[1];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 2] = weights[2];
                this._pFragmentConstantData[this._pProbeWeightsIndex + 3] = weights[3];
            };


            Object.defineProperty(SuperShaderPass.prototype, "iIgnoreLights", {
                get: function () {
                    return this._ignoreLights;
                },
                set: /**
                * Indicates whether lights should be ignored in this pass. This is used when only effect methods are rendered in
                * a multipass material.
                */
                function (ignoreLights) {
                    this._ignoreLights = ignoreLights;
                },
                enumerable: true,
                configurable: true
            });
            return SuperShaderPass;
        })(away.materials.CompiledPass);
        materials.SuperShaderPass = SuperShaderPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //use namespace arcane;
        /**
        * DepthMapPass is a pass that writes depth values to a depth map as a 32-bit value exploded over the 4 texture channels.
        * This is used to render shadow maps, depth maps, etc.
        */
        var DepthMapPass = (function (_super) {
            __extends(DepthMapPass, _super);
            /**
            * Creates a new DepthMapPass object.
            */
            function DepthMapPass() {
                _super.call(this);
                this._alphaThreshold = 0;

                this._data = new Array(1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0, 0.0, 0.0, 0.0, 0.0);
            }
            Object.defineProperty(DepthMapPass.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0) {
                        value = 0;
                    } else if (value > 1) {
                        value = 1;
                    }

                    if (value == this._alphaThreshold) {
                        return;
                    }

                    if (value == 0 || this._alphaThreshold == 0) {
                        this.iInvalidateShaderProgram();
                    }

                    this._alphaThreshold = value;
                    this._data[8] = this._alphaThreshold;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DepthMapPass.prototype, "alphaMask", {
                get: /**
                * A texture providing alpha data to be able to prevent semi-transparent pixels to write to the alpha mask.
                * Usually the diffuse texture when alphaThreshold is used.
                */
                function () {
                    return this._alphaMask;
                },
                set: function (value) {
                    this._alphaMask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iGetVertexCode = function () {
                var code = "";

                // project
                //TODO: AGAL <> GLSL conversion
                code = "m44 vt1, vt0, vc0		\n" + "mov op, vt1	\n";

                if (this._alphaThreshold > 0) {
                    this._pNumUsedTextures = 1;
                    this._pNumUsedStreams = 2;
                    code += "mov v0, vt1\n" + "mov v1, va1\n";
                } else {
                    this._pNumUsedTextures = 0;
                    this._pNumUsedStreams = 1;
                    code += "mov v0, vt1\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iGetFragmentCode = function (code) {
                var wrap = this._pRepeat ? "wrap" : "clamp";
                var filter;

                if (this._pSmooth) {
                    filter = this._pMipmap ? "linear,miplinear" : "linear";
                } else {
                    filter = this._pMipmap ? "nearest,mipnearest" : "nearest";
                }

                // TODO: AGAL<>GLSL
                var codeF = "div ft2, v0, v0.w		\n" + "mul ft0, fc0, ft2.z	\n" + "frc ft0, ft0			\n" + "mul ft1, ft0.yzww, fc1	\n";

                if (this._alphaThreshold > 0) {
                    var format;

                    switch (this._alphaMask.format) {
                        case away.display3D.Context3DTextureFormat.COMPRESSED:
                            format = "dxt1,";
                            break;

                        case "compressedAlpha":
                            format = "dxt5,";
                            break;

                        default:
                            format = "";
                    }

                    codeF += "tex ft3, v1, fs0 <2d," + filter + "," + format + wrap + ">\n" + "sub ft3.w, ft3.w, fc2.x\n" + "kil ft3.w\n";
                }

                codeF += "sub oc, ft0, ft1		\n";

                return codeF;
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iRender = function (renderable, stage3DProxy, camera, viewProjection) {
                if (this._alphaThreshold > 0) {
                    renderable.activateUVBuffer(1, stage3DProxy);
                }

                var context = stage3DProxy._iContext3D;
                var matrix = away.math.Matrix3DUtils.CALCULATION_MATRIX;

                matrix.copyFrom(renderable.getRenderSceneTransform(camera));
                matrix.append(viewProjection);
                context.setProgramConstantsFromMatrix(away.display3D.Context3DProgramType.VERTEX, 0, matrix, true);
                renderable.activateVertexBuffer(0, stage3DProxy);
                context.drawTriangles(renderable.getIndexBuffer(stage3DProxy), 0, renderable.numTriangles);
            };

            /**
            * @inheritDoc
            */
            DepthMapPass.prototype.iActivate = function (stage3DProxy, camera) {
                var context = stage3DProxy._iContext3D;

                _super.prototype.iActivate.call(this, stage3DProxy, camera);

                if (this._alphaThreshold > 0) {
                    context.setTextureAt(0, this._alphaMask.getTextureForStage3D(stage3DProxy));
                    context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.FRAGMENT, 0, this._data, 3);
                } else {
                    context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.FRAGMENT, 0, this._data, 2);
                }
            };
            return DepthMapPass;
        })(away.materials.MaterialPassBase);
        materials.DepthMapPass = DepthMapPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.cameras.Camera3D;
        //import away3d.core.base.IRenderable;
        //import away3d.managers.Stage3DProxy;
        //import away3d.core.math.Matrix3DUtils;
        //import away3d.textures.Texture2DBase;
        //import flash.display3D.Context3D;
        //import flash.display3D.Context3DProgramType;
        //import flash.display3D.Context3DTextureFormat;
        //import flash.geom.Matrix3D;
        //import flash.geom.Vector3D;
        //use namespace arcane;
        /**
        * DistanceMapPass is a pass that writes distance values to a depth map as a 32-bit value exploded over the 4 texture channels.
        * This is used to render omnidirectional shadow maps.
        */
        var DistanceMapPass = (function (_super) {
            __extends(DistanceMapPass, _super);
            /**
            * Creates a new DistanceMapPass object.
            */
            function DistanceMapPass() {
                _super.call(this);

                this._fragmentData = new Array(1.0, 255.0, 65025.0, 16581375.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0, 0.0, 0.0, 0.0, 0.0);
                this._vertexData = new Array(4);
                this._vertexData[3] = 1;
                this._pNumUsedVertexConstants = 9;
            }
            Object.defineProperty(DistanceMapPass.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0) {
                        value = 0;
                    } else if (value > 1) {
                        value = 1;
                    }

                    if (value == this._alphaThreshold) {
                        return;
                    }

                    if (value == 0 || this._alphaThreshold == 0) {
                        this.iInvalidateShaderProgram();
                    }

                    this._alphaThreshold = value;
                    this._fragmentData[8] = this._alphaThreshold;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(DistanceMapPass.prototype, "alphaMask", {
                get: /**
                * A texture providing alpha data to be able to prevent semi-transparent pixels to write to the alpha mask.
                * Usually the diffuse texture when alphaThreshold is used.
                */
                function () {
                    return this._alphaMask;
                },
                set: function (value) {
                    this._alphaMask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iGetVertexCode = function () {
                //TODO: AGAL<> GLSL
                var code;
                code = "m44 op, vt0, vc0		\n" + "m44 vt1, vt0, vc5		\n" + "sub v0, vt1, vc9		\n";

                if (this._alphaThreshold > 0) {
                    code += "mov v1, va1\n";

                    this._pNumUsedTextures = 1;
                    this._pNumUsedStreams = 2;
                } else {
                    this._pNumUsedTextures = 0;
                    this._pNumUsedStreams = 1;
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iGetFragmentCode = function (animationCode) {
                // TODO: not used
                animationCode = animationCode;
                var code;
                var wrap = this._pRepeat ? "wrap" : "clamp";
                var filter;

                if (this._pSmooth) {
                    filter = this._pMipmap ? "linear,miplinear" : "linear";
                } else {
                    filter = this._pMipmap ? "nearest,mipnearest" : "nearest";
                }

                //TODO: AGAL<> GLSL
                // squared distance to view
                code = "dp3 ft2.z, v0.xyz, v0.xyz	\n" + "mul ft0, fc0, ft2.z	\n" + "frc ft0, ft0			\n" + "mul ft1, ft0.yzww, fc1	\n";

                if (this._alphaThreshold > 0) {
                    var format;

                    switch (this._alphaMask.format) {
                        case away.display3D.Context3DTextureFormat.COMPRESSED:
                            format = "dxt1,";

                            break;

                        case "compressedAlpha":
                            format = "dxt5,";

                            break;

                        default:
                            format = "";
                    }

                    code += "tex ft3, v1, fs0 <2d," + filter + "," + format + wrap + ">\n" + "sub ft3.w, ft3.w, fc2.x\n" + "kil ft3.w\n";
                }

                code += "sub oc, ft0, ft1		\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iRender = function (renderable, stage3DProxy, camera, viewProjection) {
                var context = stage3DProxy._iContext3D;
                var pos = camera.scenePosition;

                this._vertexData[0] = pos.x;
                this._vertexData[1] = pos.y;
                this._vertexData[2] = pos.z;
                this._vertexData[3] = 1;

                var sceneTransform = renderable.getRenderSceneTransform(camera);

                context.setProgramConstantsFromMatrix(away.display3D.Context3DProgramType.VERTEX, 5, sceneTransform, true);

                context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, 9, this._vertexData, 1);

                if (this._alphaThreshold > 0) {
                    renderable.activateUVBuffer(1, stage3DProxy);
                }

                var matrix = away.math.Matrix3DUtils.CALCULATION_MATRIX;

                matrix.copyFrom(sceneTransform);
                matrix.append(viewProjection);

                context.setProgramConstantsFromMatrix(away.display3D.Context3DProgramType.VERTEX, 0, matrix, true);
                renderable.activateVertexBuffer(0, stage3DProxy);
                context.drawTriangles(renderable.getIndexBuffer(stage3DProxy), 0, renderable.numTriangles);
            };

            /**
            * @inheritDoc
            */
            DistanceMapPass.prototype.iActivate = function (stage3DProxy, camera) {
                var context = stage3DProxy._iContext3D;
                _super.prototype.iActivate.call(this, stage3DProxy, camera);

                var f = camera.lens.far;

                f = 1 / (2 * f * f);

                // sqrt(f*f+f*f) is largest possible distance for any frustum, so we need to divide by it. Rarely a tight fit, but with 32 bits precision, it's enough.
                this._fragmentData[0] = 1 * f;
                this._fragmentData[1] = 255.0 * f;
                this._fragmentData[2] = 65025.0 * f;
                this._fragmentData[3] = 16581375.0 * f;

                if (this._alphaThreshold > 0) {
                    context.setTextureAt(0, this._alphaMask.getTextureForStage3D(stage3DProxy));
                    context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.FRAGMENT, 0, this._fragmentData, 3);
                } else {
                    context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.FRAGMENT, 0, this._fragmentData, 2);
                }
            };
            return DistanceMapPass;
        })(away.materials.MaterialPassBase);
        materials.DistanceMapPass = DistanceMapPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.cameras.Camera3D;
        //import away3d.core.base.IRenderable;
        //import away3d.managers.Stage3DProxy;
        //import away3d.lights.DirectionalLight;
        //import away3d.lights.LightProbe;
        //import away3d.lights.PointLight;
        //import away3d.materials.LightSources;
        //import away3d.materials.MaterialBase;
        //import away3d.materials.compilation.LightingShaderCompiler;
        //import away3d.materials.compilation.ShaderCompiler;
        //import flash.display3D.Context3D;
        //import flash.geom.Matrix3D;
        //import flash.geom.Vector3D;
        //use namespace arcane;
        /**
        * LightingPass is a shader pass that uses shader methods to compile a complete program. It only includes the lighting
        * methods. It's used by multipass materials to accumulate lighting passes.
        *
        * @see away3d.materials.MultiPassMaterialBase
        */
        var LightingPass = (function (_super) {
            __extends(LightingPass, _super);
            /**
            * Creates a new LightingPass objects.
            *
            * @param material The material to which this pass belongs.
            */
            function LightingPass(material) {
                _super.call(this, material);
                this._includeCasters = true;
                this._inverseSceneMatrix = new Array();
                this._maxLights = 3;
            }
            Object.defineProperty(LightingPass.prototype, "directionalLightsOffset", {
                get: /**
                * Indicates the offset in the light picker's directional light vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                function () {
                    return this._directionalLightsOffset;
                },
                set: function (value) {
                    this._directionalLightsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightingPass.prototype, "pointLightsOffset", {
                get: /**
                * Indicates the offset in the light picker's point light vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                function () {
                    return this._pointLightsOffset;
                },
                set: function (value) {
                    this._pointLightsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(LightingPass.prototype, "lightProbesOffset", {
                get: /**
                * Indicates the offset in the light picker's light probes vector for which to start including lights.
                * This needs to be set before the light picker is assigned.
                */
                function () {
                    return this._lightProbesOffset;
                },
                set: function (value) {
                    this._lightProbesOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            LightingPass.prototype.pCreateCompiler = function (profile) {
                this._maxLights = profile == "baselineConstrained" ? 1 : 3;
                return new away.materials.LightingShaderCompiler(profile);
            };

            Object.defineProperty(LightingPass.prototype, "includeCasters", {
                get: /**
                * Indicates whether or not shadow casting lights need to be included.
                */
                function () {
                    return this._includeCasters;
                },
                set: function (value) {
                    if (this._includeCasters == value)
                        return;
                    this._includeCasters = value;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateLights = function () {
                _super.prototype.pUpdateLights.call(this);
                var numDirectionalLights;
                var numPointLights = 0;
                var numLightProbes = 0;

                if (this._pLightPicker) {
                    numDirectionalLights = this.calculateNumDirectionalLights(this._pLightPicker.numDirectionalLights);
                    numPointLights = this.calculateNumPointLights(this._pLightPicker.numPointLights);
                    numLightProbes = this.calculateNumProbes(this._pLightPicker.numLightProbes);

                    if (this._includeCasters) {
                        numPointLights += this._pLightPicker.numCastingPointLights;
                        numDirectionalLights += this._pLightPicker.numCastingDirectionalLights;
                    }
                } else {
                    numDirectionalLights = 0;
                    numPointLights = 0;
                    numLightProbes = 0;
                }

                if (numPointLights != this._pNumPointLights || numDirectionalLights != this._pNumDirectionalLights || numLightProbes != this._pNumLightProbes) {
                    this._pNumPointLights = numPointLights;
                    this._pNumDirectionalLights = numDirectionalLights;
                    this._pNumLightProbes = numLightProbes;
                    this.iInvalidateShaderProgram();
                }
            };

            /**
            * Calculates the amount of directional lights this material will support.
            * @param numDirectionalLights The maximum amount of directional lights to support.
            * @return The amount of directional lights this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {
                return Math.min(numDirectionalLights - this._directionalLightsOffset, this._maxLights);
            };

            /**
            * Calculates the amount of point lights this material will support.
            * @param numDirectionalLights The maximum amount of point lights to support.
            * @return The amount of point lights this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumPointLights = function (numPointLights) {
                var numFree = this._maxLights - this._pNumDirectionalLights;
                return Math.min(numPointLights - this._pointLightsOffset, numFree);
            };

            /**
            * Calculates the amount of light probes this material will support.
            * @param numDirectionalLights The maximum amount of light probes to support.
            * @return The amount of light probes this material will support, bounded by the amount necessary.
            */
            LightingPass.prototype.calculateNumProbes = function (numLightProbes) {
                var numChannels = 0;
                if ((this._pSpecularLightSources & away.materials.LightSources.PROBES) != 0) {
                    ++numChannels;
                }
                if ((this._pDiffuseLightSources & away.materials.LightSources.PROBES) != 0)
                    ++numChannels;

                // 4 channels available
                return Math.min(numLightProbes - this._lightProbesOffset, (4 / numChannels) | 0);
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateShaderProperties = function () {
                _super.prototype.pUpdateShaderProperties.call(this);

                var compilerV = this._pCompiler;
                this._tangentSpace = compilerV.tangentSpace;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateRegisterIndices = function () {
                _super.prototype.pUpdateRegisterIndices.call(this);

                var compilerV = this._pCompiler;
                this._lightVertexConstantIndex = compilerV.lightVertexConstantIndex;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.iRender = function (renderable, stage3DProxy, camera, viewProjection) {
                renderable.inverseSceneTransform.copyRawDataTo(this._inverseSceneMatrix);

                if (this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    var x = pos.x;
                    var y = pos.y;
                    var z = pos.z;

                    this._pVertexConstantData[this._pCameraPositionIndex] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                }

                _super.prototype.iRender.call(this, renderable, stage3DProxy, camera, viewProjection);
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.iActivate = function (stage3DProxy, camera) {
                _super.prototype.iActivate.call(this, stage3DProxy, camera);

                if (!this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;

                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * Indicates whether any light probes are used to contribute to the specular shading.
            */
            LightingPass.prototype.usesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._pSpecularLightSources & away.materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used to contribute to the diffuse shading.
            */
            LightingPass.prototype.usesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._pDiffuseLightSources & away.materials.LightSources.PROBES) != 0;
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateLightConstants = function () {
                var dirLight;
                var pointLight;
                var i = 0;
                var k = 0;
                var len;
                var dirPos;
                var total = 0;
                var numLightTypes = this._includeCasters ? 2 : 1;
                var l;
                var offset;

                l = this._lightVertexConstantIndex;
                k = this._pLightFragmentConstantIndex;

                var cast = 0;
                var dirLights = this._pLightPicker.directionalLights;
                offset = this._directionalLightsOffset;
                len = this._pLightPicker.directionalLights.length;

                if (offset > len) {
                    cast = 1;
                    offset -= len;
                }

                for (; cast < numLightTypes; ++cast) {
                    if (cast)
                        dirLights = this._pLightPicker.castingDirectionalLights;
                    len = dirLights.length;
                    if (len > this._pNumDirectionalLights)
                        len = this._pNumDirectionalLights;

                    for (i = 0; i < len; ++i) {
                        dirLight = dirLights[offset + i];
                        dirPos = dirLight.sceneDirection;

                        this._pAmbientLightR += dirLight._iAmbientR;
                        this._pAmbientLightG += dirLight._iAmbientG;
                        this._pAmbientLightB += dirLight._iAmbientB;

                        if (this._tangentSpace) {
                            var x = -dirPos.x;
                            var y = -dirPos.y;
                            var z = -dirPos.z;

                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z;
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z;
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z;
                            this._pVertexConstantData[l++] = 1;
                        } else {
                            this._pFragmentConstantData[k++] = -dirPos.x;
                            this._pFragmentConstantData[k++] = -dirPos.y;
                            this._pFragmentConstantData[k++] = -dirPos.z;
                            this._pFragmentConstantData[k++] = 1;
                        }

                        this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                        this._pFragmentConstantData[k++] = 1;

                        this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                        this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                        this._pFragmentConstantData[k++] = 1;

                        if (++total == this._pNumDirectionalLights) {
                            // break loop
                            i = len;
                            cast = numLightTypes;
                        }
                    }
                }

                if (this._pNumDirectionalLights > total) {
                    i = k + (this._pNumDirectionalLights - total) * 12;

                    while (k < i) {
                        this._pFragmentConstantData[k++] = 0;
                    }
                }

                total = 0;

                var pointLights = this._pLightPicker.pointLights;
                offset = this._pointLightsOffset;
                len = this._pLightPicker.pointLights.length;

                if (offset > len) {
                    cast = 1;
                    offset -= len;
                } else {
                    cast = 0;
                }

                for (; cast < numLightTypes; ++cast) {
                    if (cast) {
                        pointLights = this._pLightPicker.castingPointLights;
                    }

                    len = pointLights.length;

                    for (i = 0; i < len; ++i) {
                        pointLight = pointLights[offset + i];
                        dirPos = pointLight.scenePosition;

                        this._pAmbientLightR += pointLight._iAmbientR;
                        this._pAmbientLightG += pointLight._iAmbientG;
                        this._pAmbientLightB += pointLight._iAmbientB;

                        if (this._tangentSpace) {
                            x = dirPos.x;
                            y = dirPos.y;
                            z = dirPos.z;

                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                            this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                        } else {
                            this._pVertexConstantData[l++] = dirPos.x;
                            this._pVertexConstantData[l++] = dirPos.y;
                            this._pVertexConstantData[l++] = dirPos.z;
                        }
                        this._pVertexConstantData[l++] = 1;

                        this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                        this._pFragmentConstantData[k++] = pointLight._iDiffuseB;

                        var radius = pointLight._pRadius;
                        this._pFragmentConstantData[k++] = radius * radius;

                        this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                        this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                        this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;

                        if (++total == this._pNumPointLights) {
                            // break loop
                            i = len;
                            cast = numLightTypes;
                        }
                    }
                }

                if (this._pNumPointLights > total) {
                    i = k + (total - this._pNumPointLights) * 12;
                    for (; k < i; ++k) {
                        this._pFragmentConstantData[k] = 0;
                    }
                }
            };

            /**
            * @inheritDoc
            */
            LightingPass.prototype.pUpdateProbes = function (stage3DProxy) {
                var context = stage3DProxy._iContext3D;
                var probe;
                var lightProbes = this._pLightPicker.lightProbes;
                var weights = this._pLightPicker.lightProbeWeights;
                var len = lightProbes.length - this._lightProbesOffset;
                var addDiff = this.usesProbesForDiffuse();
                var addSpec = (this._pMethodSetup._iSpecularMethod && this.usesProbesForSpecular());

                if (!(addDiff || addSpec))
                    return;

                if (len > this._pNumLightProbes) {
                    len = this._pNumLightProbes;
                }

                for (var i = 0; i < len; ++i) {
                    probe = lightProbes[this._lightProbesOffset + i];

                    if (addDiff) {
                        context.setTextureAt(this._pLightProbeDiffuseIndices[i], probe.diffuseMap.getTextureForStage3D(stage3DProxy));
                    }
                    if (addSpec) {
                        context.setTextureAt(this._pLightProbeSpecularIndices[i], probe.specularMap.getTextureForStage3D(stage3DProxy));
                    }
                }

                for (i = 0; i < len; ++i)
                    this._pFragmentConstantData[this._pProbeWeightsIndex + i] = weights[this._lightProbesOffset + i];
            };
            return LightingPass;
        })(away.materials.CompiledPass);
        materials.LightingPass = LightingPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShadowCasterPass is a shader pass that uses shader methods to compile a complete program. It only draws the lighting
        * contribution for a single shadow-casting light.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var ShadowCasterPass = (function (_super) {
            __extends(ShadowCasterPass, _super);
            /**
            * Creates a new ShadowCasterPass objects.
            *
            * @param material The material to which this pass belongs.
            */
            function ShadowCasterPass(material) {
                _super.call(this, material);
                this._inverseSceneMatrix = new Array();
            }
            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pCreateCompiler = function (profile) {
                return new away.materials.LightingShaderCompiler(profile);
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateLights = function () {
                _super.prototype.pUpdateLights.call(this);

                var numPointLights = 0;
                var numDirectionalLights = 0;

                if (this._pLightPicker) {
                    numPointLights = this._pLightPicker.numCastingPointLights > 0 ? 1 : 0;
                    numDirectionalLights = this._pLightPicker.numCastingDirectionalLights > 0 ? 1 : 0;
                } else {
                    numPointLights = 0;
                    numDirectionalLights = 0;
                }

                this._pNumLightProbes = 0;

                if (numPointLights + numDirectionalLights > 1) {
                    throw new Error("Must have exactly one light!");
                }

                if (numPointLights != this._pNumPointLights || numDirectionalLights != this._pNumDirectionalLights) {
                    this._pNumPointLights = numPointLights;
                    this._pNumDirectionalLights = numDirectionalLights;
                    this.iInvalidateShaderProgram();
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateShaderProperties = function () {
                _super.prototype.pUpdateShaderProperties.call(this);

                var c = this._pCompiler;
                this._tangentSpace = c.tangentSpace;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateRegisterIndices = function () {
                _super.prototype.pUpdateRegisterIndices.call(this);

                var c = this._pCompiler;

                this._lightVertexConstantIndex = c.lightVertexConstantIndex;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.iRender = function (renderable, stage3DProxy, camera, viewProjection) {
                renderable.inverseSceneTransform.copyRawDataTo(this._inverseSceneMatrix);

                if (this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    var x = pos.x;
                    var y = pos.y;
                    var z = pos.z;
                    this._pVertexConstantData[this._pCameraPositionIndex] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                }

                _super.prototype.iRender.call(this, renderable, stage3DProxy, camera, viewProjection);
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.iActivate = function (stage3DProxy, camera) {
                _super.prototype.iActivate.call(this, stage3DProxy, camera);

                if (!this._tangentSpace && this._pCameraPositionIndex >= 0) {
                    var pos = camera.scenePosition;
                    this._pVertexConstantData[this._pCameraPositionIndex] = pos.x;
                    this._pVertexConstantData[this._pCameraPositionIndex + 1] = pos.y;
                    this._pVertexConstantData[this._pCameraPositionIndex + 2] = pos.z;
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateLightConstants = function () {
                // first dirs, then points
                var dirLight;
                var pointLight;
                var k = 0;
                var l = 0;
                var dirPos;

                l = this._lightVertexConstantIndex;
                k = this._pLightFragmentConstantIndex;

                if (this._pNumDirectionalLights > 0) {
                    dirLight = this._pLightPicker.castingDirectionalLights[0];
                    dirPos = dirLight.sceneDirection;

                    this._pAmbientLightR += dirLight._iAmbientR;
                    this._pAmbientLightG += dirLight._iAmbientG;
                    this._pAmbientLightB += dirLight._iAmbientB;

                    if (this._tangentSpace) {
                        var x = -dirPos.x;
                        var y = -dirPos.y;
                        var z = -dirPos.z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z;
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z;
                        this._pVertexConstantData[l++] = 1;
                    } else {
                        this._pFragmentConstantData[k++] = -dirPos.x;
                        this._pFragmentConstantData[k++] = -dirPos.y;
                        this._pFragmentConstantData[k++] = -dirPos.z;
                        this._pFragmentConstantData[k++] = 1;
                    }

                    this._pFragmentConstantData[k++] = dirLight._iDiffuseR;
                    this._pFragmentConstantData[k++] = dirLight._iDiffuseG;
                    this._pFragmentConstantData[k++] = dirLight._iDiffuseB;
                    this._pFragmentConstantData[k++] = 1;

                    this._pFragmentConstantData[k++] = dirLight._iSpecularR;
                    this._pFragmentConstantData[k++] = dirLight._iSpecularG;
                    this._pFragmentConstantData[k++] = dirLight._iSpecularB;
                    this._pFragmentConstantData[k++] = 1;

                    return;
                }

                if (this._pNumPointLights > 0) {
                    pointLight = this._pLightPicker.castingPointLights[0];

                    dirPos = pointLight.scenePosition;

                    this._pAmbientLightR += pointLight._iAmbientR;
                    this._pAmbientLightG += pointLight._iAmbientG;
                    this._pAmbientLightB += pointLight._iAmbientB;

                    if (this._tangentSpace) {
                        x = dirPos.x;
                        y = dirPos.y;
                        z = dirPos.z;

                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[0] * x + this._inverseSceneMatrix[4] * y + this._inverseSceneMatrix[8] * z + this._inverseSceneMatrix[12];
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[1] * x + this._inverseSceneMatrix[5] * y + this._inverseSceneMatrix[9] * z + this._inverseSceneMatrix[13];
                        this._pVertexConstantData[l++] = this._inverseSceneMatrix[2] * x + this._inverseSceneMatrix[6] * y + this._inverseSceneMatrix[10] * z + this._inverseSceneMatrix[14];
                    } else {
                        this._pVertexConstantData[l++] = dirPos.x;
                        this._pVertexConstantData[l++] = dirPos.y;
                        this._pVertexConstantData[l++] = dirPos.z;
                    }
                    this._pVertexConstantData[l++] = 1;

                    this._pFragmentConstantData[k++] = pointLight._iDiffuseR;
                    this._pFragmentConstantData[k++] = pointLight._iDiffuseG;
                    this._pFragmentConstantData[k++] = pointLight._iDiffuseB;
                    this._pFragmentConstantData[k++] = pointLight._pRadius * pointLight._pRadius;

                    this._pFragmentConstantData[k++] = pointLight._iSpecularR;
                    this._pFragmentConstantData[k++] = pointLight._iSpecularG;
                    this._pFragmentConstantData[k++] = pointLight._iSpecularB;
                    this._pFragmentConstantData[k++] = pointLight._pFallOffFactor;
                }
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUsesProbes = function () {
                return false;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUsesLights = function () {
                return true;
            };

            /**
            * @inheritDoc
            */
            ShadowCasterPass.prototype.pUpdateProbes = function (stage3DProxy) {
            };
            return ShadowCasterPass;
        })(away.materials.CompiledPass);
        materials.ShadowCasterPass = ShadowCasterPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SegmentPass is a material pass that draws wireframe segments.
        */
        var SegmentPass = (function (_super) {
            __extends(SegmentPass, _super);
            /**
            * Creates a new SegmentPass object.
            *
            * @param thickness the thickness of the segments to be drawn.
            */
            function SegmentPass(thickness) {
                _super.call(this);
                this._constants = new Array(0, 0, 0, 0);

                this._calcMatrix = new away.geom.Matrix3D();

                this._thickness = thickness;
                this._constants[1] = 1 / 255;
            }
            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iGetVertexCode = function () {
                return "m44 vt0, va0, vc8			\n" + "m44 vt1, va1, vc8			\n" + "sub vt2, vt1, vt0 			\n" + "slt vt5.x, vt0.z, vc7.z			\n" + "sub vt5.y, vc5.x, vt5.x			\n" + "add vt4.x, vt0.z, vc7.z			\n" + "sub vt4.y, vt0.z, vt1.z			\n" + "seq vt4.z, vt4.y vc6.x			\n" + "add vt4.y, vt4.y, vt4.z			\n" + "div vt4.z, vt4.x, vt4.y			\n" + "mul vt4.xyz, vt4.zzz, vt2.xyz	\n" + "add vt3.xyz, vt0.xyz, vt4.xyz	\n" + "mov vt3.w, vc5.x			\n" + "mul vt0, vt0, vt5.yyyy			\n" + "mul vt3, vt3, vt5.xxxx			\n" + "add vt0, vt0, vt3				\n" + "sub vt2, vt1, vt0 			\n" + "nrm vt2.xyz, vt2.xyz			\n" + "nrm vt5.xyz, vt0.xyz			\n" + "mov vt5.w, vc5.x				\n" + "crs vt3.xyz, vt2, vt5			\n" + "nrm vt3.xyz, vt3.xyz			\n" + "mul vt3.xyz, vt3.xyz, va2.xxx	\n" + "mov vt3.w, vc5.x			\n" + "dp3 vt4.x, vt0, vc6			\n" + "mul vt4.x, vt4.x, vc7.x			\n" + "mul vt3.xyz, vt3.xyz, vt4.xxx	\n" + "add vt0.xyz, vt0.xyz, vt3.xyz	\n" + "m44 op, vt0, vc0			\n" + "mov v0, va3				\n";
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iGetFragmentCode = function (animationCode) {
                return "mov oc, v0\n";
            };

            /**
            * @inheritDoc
            * todo: keep maps in dictionary per renderable
            */
            SegmentPass.prototype.iRender = function (renderable, stage3DProxy, camera, viewProjection) {
                var context = stage3DProxy._iContext3D;
                this._calcMatrix.copyFrom(renderable.sourceEntity.sceneTransform);
                this._calcMatrix.append(camera.inverseSceneTransform);

                var ss = renderable;

                var subSetCount = ss.iSubSetCount;

                if (ss.hasData) {
                    for (var i = 0; i < subSetCount; ++i) {
                        renderable.activateVertexBuffer(i, stage3DProxy);
                        context.setProgramConstantsFromMatrix(away.display3D.Context3DProgramType.VERTEX, 8, this._calcMatrix, true);
                        context.drawTriangles(renderable.getIndexBuffer(stage3DProxy), 0, renderable.numTriangles);
                    }
                }
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.iActivate = function (stage3DProxy, camera) {
                var context = stage3DProxy._iContext3D;
                _super.prototype.iActivate.call(this, stage3DProxy, camera);

                if (stage3DProxy.scissorRect)
                    this._constants[0] = this._thickness / Math.min(stage3DProxy.scissorRect.width, stage3DProxy.scissorRect.height);
else
                    this._constants[0] = this._thickness / Math.min(stage3DProxy.width, stage3DProxy.height);

                // value to convert distance from camera to model length per pixel width
                this._constants[2] = camera.lens.near;

                context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, 5, SegmentPass.pONE_VECTOR, 1);
                context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, 6, SegmentPass.pFRONT_VECTOR, 1);
                context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, 7, this._constants, 1);

                // projection matrix
                context.setProgramConstantsFromMatrix(away.display3D.Context3DProgramType.VERTEX, 0, camera.lens.matrix, true);
            };

            /**
            * @inheritDoc
            */
            SegmentPass.prototype.pDeactivate = function (stage3DProxy) {
                var context = stage3DProxy._iContext3D;
                context.setVertexBufferAt(0, null);
                context.setVertexBufferAt(1, null);
                context.setVertexBufferAt(2, null);
                context.setVertexBufferAt(3, null);
            };
            SegmentPass.pONE_VECTOR = Array(1, 1, 1, 1);
            SegmentPass.pFRONT_VECTOR = Array(0, 0, -1, 0);
            return SegmentPass;
        })(materials.MaterialPassBase);
        materials.SegmentPass = SegmentPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SkyBoxPass provides a material pass exclusively used to render sky boxes from a cube texture.
        */
        var SkyBoxPass = (function (_super) {
            __extends(SkyBoxPass, _super);
            /**
            * Creates a new SkyBoxPass object.
            */
            function SkyBoxPass() {
                _super.call(this);
                this.mipmap = false;
                this._pNumUsedTextures = 1;
                this._vertexData = new Array(0, 0, 0, 0, 1, 1, 1, 1);
            }
            Object.defineProperty(SkyBoxPass.prototype, "cubeTexture", {
                get: /**
                * The cube texture to use as the skybox.
                */
                function () {
                    return this._cubeTexture;
                },
                set: function (value) {
                    this._cubeTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SkyBoxPass.prototype.iGetVertexCode = function () {
                return "mul vt0, va0, vc5		\n" + "add vt0, vt0, vc4		\n" + "m44 op, vt0, vc0		\n" + "mov v0, va0\n";
            };

            /**
            * @inheritDoc
            */
            SkyBoxPass.prototype.iGetFragmentCode = function (animationCode) {
                var format;
                switch (this._cubeTexture.format) {
                    case away.display3D.Context3DTextureFormat.COMPRESSED:
                        format = "dxt1,";
                        break;
                    case "compressedAlpha":
                        format = "dxt5,";
                        break;
                    default:
                        format = "";
                }

                var mip = ",mipnone";

                if (this._cubeTexture.hasMipMaps) {
                    mip = ",miplinear";
                }
                return "tex ft0, v0, fs0 <cube," + format + "linear,clamp" + mip + ">	\n" + "mov oc, ft0							\n";
            };

            /**
            * @inheritDoc
            */
            SkyBoxPass.prototype.iRender = function (renderable, stage3DProxy, camera, viewProjection) {
                var context = stage3DProxy._iContext3D;
                var pos = camera.scenePosition;
                this._vertexData[0] = pos.x;
                this._vertexData[1] = pos.y;
                this._vertexData[2] = pos.z;
                this._vertexData[4] = this._vertexData[5] = this._vertexData[6] = camera.lens.far / Math.sqrt(3);
                context.setProgramConstantsFromMatrix(away.display3D.Context3DProgramType.VERTEX, 0, viewProjection, true);
                context.setProgramConstantsFromArray(away.display3D.Context3DProgramType.VERTEX, 4, this._vertexData, 2);
                renderable.activateVertexBuffer(0, stage3DProxy);
                context.drawTriangles(renderable.getIndexBuffer(stage3DProxy), 0, renderable.numTriangles);
            };

            /**
            * @inheritDoc
            */
            SkyBoxPass.prototype.iActivate = function (stage3DProxy, camera) {
                _super.prototype.iActivate.call(this, stage3DProxy, camera);
                var context = stage3DProxy._iContext3D;
                context.setDepthTest(false, away.display3D.Context3DCompareMode.LESS);
                context.setTextureAt(0, this._cubeTexture.getTextureForStage3D(stage3DProxy));
            };
            return SkyBoxPass;
        })(away.materials.MaterialPassBase);
        materials.SkyBoxPass = SkyBoxPass;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * SinglePassMaterialBase forms an abstract base class for the default single-pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var SinglePassMaterialBase = (function (_super) {
            __extends(SinglePassMaterialBase, _super);
            /**
            * Creates a new SinglePassMaterialBase object.
            */
            function SinglePassMaterialBase() {
                _super.call(this);
                this._alphaBlending = false;

                this.pAddPass(this._pScreenPass = new away.materials.SuperShaderPass(this));
            }
            Object.defineProperty(SinglePassMaterialBase.prototype, "enableLightFallOff", {
                get: /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                function () {
                    return this._pScreenPass.enableLightFallOff;
                },
                set: function (value) {
                    this._pScreenPass.enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._pScreenPass.diffuseMethod.alphaThreshold;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.alphaThreshold = value;

                    this._pDepthPass.alphaThreshold = value;
                    this._pDistancePass.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "blendMode", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setBlendMode.call(this, value);
                    this._pScreenPass.setBlendMode((this._pBlendMode == away.display.BlendMode.NORMAL) && this.requiresBlending ? away.display.BlendMode.LAYER : this._pBlendMode);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SinglePassMaterialBase.prototype, "depthCompareMode", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this._pDepthCompareMode = value;
                    this._pScreenPass.depthCompareMode = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            SinglePassMaterialBase.prototype.iActivateForDepth = function (stage3DProxy, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                if (distanceBased) {
                    this._pDistancePass.alphaMask = this._pScreenPass.diffuseMethod.texture;
                } else {
                    this._pDepthPass.alphaMask = this._pScreenPass.diffuseMethod.texture;
                }

                _super.prototype.iActivateForDepth.call(this, stage3DProxy, camera, distanceBased);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "specularLightSources", {
                get: /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._pScreenPass.specularLightSources;
                },
                set: function (value) {
                    this._pScreenPass.specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "diffuseLightSources", {
                get: /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._pScreenPass.diffuseLightSources;
                },
                set: function (value) {
                    this._pScreenPass.diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "requiresBlending", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.getRequiresBlending();
                },
                enumerable: true,
                configurable: true
            });

            SinglePassMaterialBase.prototype.getRequiresBlending = function () {
                var ct = this._pScreenPass.colorTransform;

                if (ct) {
                    return (this._pBlendMode != away.display.BlendMode.NORMAL) || this._alphaBlending || (ct.alphaMultiplier < 1);
                }
                return (this._pBlendMode != away.display.BlendMode.NORMAL) || this._alphaBlending;
                //return super.getRequiresBlending() || this._alphaBlending || ( this._pScreenPass.colorTransform && this._pScreenPass.colorTransform.alphaMultiplier < 1);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "colorTransform", {
                get: /**
                * The ColorTransform object to transform the colour of the material with. Defaults to null.
                */
                function () {
                    return this._pScreenPass.colorTransform;
                },
                set: function (value) {
                    this.setColorTransform(value);
                },
                enumerable: true,
                configurable: true
            });


            SinglePassMaterialBase.prototype.setColorTransform = function (value) {
                this._pScreenPass.colorTransform = value;
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "ambientMethod", {
                get: /**
                * The method that provides the ambient lighting contribution. Defaults to BasicAmbientMethod.
                */
                function () {
                    return this._pScreenPass.ambientMethod;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "shadowMethod", {
                get: /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                function () {
                    return this._pScreenPass.shadowMethod;
                },
                set: function (value) {
                    this._pScreenPass.shadowMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "diffuseMethod", {
                get: /**
                * The method that provides the diffuse lighting contribution. Defaults to BasicDiffuseMethod.
                */
                function () {
                    return this._pScreenPass.diffuseMethod;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "normalMethod", {
                get: /**
                * The method used to generate the per-pixel normals. Defaults to BasicNormalMethod.
                */
                function () {
                    return this._pScreenPass.normalMethod;
                },
                set: function (value) {
                    this._pScreenPass.normalMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularMethod", {
                get: /**
                * The method that provides the specular lighting contribution. Defaults to BasicSpecularMethod.
                */
                function () {
                    return this._pScreenPass.specularMethod;
                },
                set: function (value) {
                    this._pScreenPass.specularMethod = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            SinglePassMaterialBase.prototype.addMethod = function (method) {
                this._pScreenPass.addMethod(method);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "numMethods", {
                get: /**
                * The number of "effect" methods added to the material.
                */
                function () {
                    return this._pScreenPass.numMethods;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            SinglePassMaterialBase.prototype.hasMethod = function (method) {
                return this._pScreenPass.hasMethod(method);
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            SinglePassMaterialBase.prototype.getMethodAt = function (index) {
                return this._pScreenPass.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            SinglePassMaterialBase.prototype.addMethodAt = function (method, index) {
                this._pScreenPass.addMethodAt(method, index);
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            SinglePassMaterialBase.prototype.removeMethod = function (method) {
                this._pScreenPass.removeMethod(method);
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "mipmap", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (this._pMipmap == value)
                        return;

                    this.setMipMap(value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SinglePassMaterialBase.prototype, "normalMap", {
                get: /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                function () {
                    return this._pScreenPass.normalMap;
                },
                set: function (value) {
                    this._pScreenPass.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularMap", {
                get: /**
                * A specular map that defines the strength of specular reflections for each texel in the red channel,
                * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
                * specular and gloss maps from grayscale images, but correctly authored images are preferred.
                */
                function () {
                    return this._pScreenPass.specularMethod.texture;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod) {
                        this._pScreenPass.specularMethod.texture = value;
                    } else {
                        throw new away.errors.Error("No specular method was set to assign the specularGlossMap to");
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "gloss", {
                get: /**
                * The glossiness of the material (sharpness of the specular highlight).
                */
                function () {
                    return this._pScreenPass.specularMethod ? this._pScreenPass.specularMethod.gloss : 0;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod)
                        this._pScreenPass.specularMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "ambient", {
                get: /**
                * The strength of the ambient reflection.
                */
                function () {
                    return this._pScreenPass.ambientMethod.ambient;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specular", {
                get: /**
                * The overall strength of the specular reflection.
                */
                function () {
                    return this._pScreenPass.specularMethod ? this._pScreenPass.specularMethod.specular : 0;
                },
                set: function (value) {
                    if (this._pScreenPass.specularMethod)
                        this._pScreenPass.specularMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "ambientColor", {
                get: /**
                * The colour of the ambient reflection.
                */
                function () {
                    return this._pScreenPass.ambientMethod.ambientColor;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "specularColor", {
                get: /**
                * The colour of the specular reflection.
                */
                function () {
                    return this._pScreenPass.specularMethod.specularColor;
                },
                set: function (value) {
                    this._pScreenPass.specularMethod.specularColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SinglePassMaterialBase.prototype, "alphaBlending", {
                get: /**
                * Indicates whether or not the material has transparency. If binary transparency is sufficient, for
                * example when using textures of foliage, consider using alphaThreshold instead.
                */
                function () {
                    return this._alphaBlending;
                },
                set: function (value) {
                    this._alphaBlending = value;
                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.display.BlendMode.NORMAL && this.requiresBlending ? away.display.BlendMode.LAYER : this.getBlendMode());
                    this._pScreenPass.preserveAlpha = this.requiresBlending;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SinglePassMaterialBase.prototype.iUpdateMaterial = function (context) {
                if (this._pScreenPass._iPassesDirty) {
                    this.pClearPasses();

                    if (this._pScreenPass._iPasses) {
                        var len = this._pScreenPass._iPasses.length;

                        for (var i = 0; i < len; ++i) {
                            this.pAddPass(this._pScreenPass._iPasses[i]);
                        }
                    }

                    this.pAddPass(this._pScreenPass);
                    this._pScreenPass._iPassesDirty = false;
                }
            };

            Object.defineProperty(SinglePassMaterialBase.prototype, "lightPicker", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setLightPicker.call(this, value);
                    this._pScreenPass.lightPicker = value;
                },
                enumerable: true,
                configurable: true
            });
            return SinglePassMaterialBase;
        })(away.materials.MaterialBase);
        materials.SinglePassMaterialBase = SinglePassMaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * MultiPassMaterialBase forms an abstract base class for the default multi-pass materials provided by Away3D,
        * using material methods to define their appearance.
        */
        var MultiPassMaterialBase = (function (_super) {
            __extends(MultiPassMaterialBase, _super);
            /**
            * Creates a new MultiPassMaterialBase object.
            */
            function MultiPassMaterialBase() {
                _super.call(this);
                this._alphaThreshold = 0;
                this._specularLightSources = 0x01;
                this._diffuseLightSources = 0x03;
                this._ambientMethod = new away.materials.BasicAmbientMethod();
                this._diffuseMethod = new away.materials.BasicDiffuseMethod();
                this._normalMethod = new away.materials.BasicNormalMethod();
                this._specularMethod = new away.materials.BasicSpecularMethod();
                this._screenPassesInvalid = true;
                this._enableLightFallOff = true;
            }
            Object.defineProperty(MultiPassMaterialBase.prototype, "enableLightFallOff", {
                get: /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                function () {
                    return this._enableLightFallOff;
                },
                set: function (value) {
                    if (this._enableLightFallOff != value)
                        this.pInvalidateScreenPasses();
                    this._enableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    this._alphaThreshold = value;
                    this._diffuseMethod.alphaThreshold = value;
                    this._pDepthPass.alphaThreshold = value;
                    this._pDistancePass.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "depthCompareMode", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setDepthCompareMode.call(this, value);
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "blendMode", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setBlendMode.call(this, value);
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iActivateForDepth = function (stage3DProxy, camera, distanceBased) {
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                if (distanceBased) {
                    this._pDistancePass.alphaMask = this._diffuseMethod.texture;
                } else {
                    this._pDepthPass.alphaMask = this._diffuseMethod.texture;
                }

                _super.prototype.iActivateForDepth.call(this, stage3DProxy, camera, distanceBased);
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "specularLightSources", {
                get: /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._specularLightSources;
                },
                set: function (value) {
                    this._specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "diffuseLightSources", {
                get: /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._diffuseLightSources;
                },
                set: function (value) {
                    this._diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "lightPicker", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (this._pLightPicker)
                        this._pLightPicker.removeEventListener(away.events.Event.CHANGE, this.onLightsChange, this);

                    _super.prototype.setLightPicker.call(this, value);

                    if (this._pLightPicker)
                        this._pLightPicker.addEventListener(away.events.Event.CHANGE, this.onLightsChange, this);
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "requiresBlending", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "ambientMethod", {
                get: /**
                * The method that provides the ambient lighting contribution. Defaults to BasicAmbientMethod.
                */
                function () {
                    return this._ambientMethod;
                },
                set: function (value) {
                    value.copyFrom(this._ambientMethod);
                    this._ambientMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "shadowMethod", {
                get: /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
                */
                function () {
                    return this._shadowMethod;
                },
                set: function (value) {
                    if (value && this._shadowMethod)
                        value.copyFrom(this._shadowMethod);
                    this._shadowMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "diffuseMethod", {
                get: /**
                * The method that provides the diffuse lighting contribution. Defaults to BasicDiffuseMethod.
                */
                function () {
                    return this._diffuseMethod;
                },
                set: function (value) {
                    value.copyFrom(this._diffuseMethod);
                    this._diffuseMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularMethod", {
                get: /**
                * The method that provides the specular lighting contribution. Defaults to BasicSpecularMethod.
                */
                function () {
                    return this._specularMethod;
                },
                set: function (value) {
                    if (value && this._specularMethod)
                        value.copyFrom(this._specularMethod);
                    this._specularMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "normalMethod", {
                get: /**
                * The method used to generate the per-pixel normals. Defaults to BasicNormalMethod.
                */
                function () {
                    return this._normalMethod;
                },
                set: function (value) {
                    value.copyFrom(this._normalMethod);
                    this._normalMethod = value;
                    this.pInvalidateScreenPasses();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
            * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
            * methods added prior.
            */
            MultiPassMaterialBase.prototype.addMethod = function (method) {
                if (this._pEffectsPass == null) {
                    this._pEffectsPass = new away.materials.SuperShaderPass(this);
                }

                this._pEffectsPass.addMethod(method);
                this.pInvalidateScreenPasses();
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "numMethods", {
                get: /**
                * The number of "effect" methods added to the material.
                */
                function () {
                    return this._pEffectsPass ? this._pEffectsPass.numMethods : 0;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            MultiPassMaterialBase.prototype.hasMethod = function (method) {
                return this._pEffectsPass ? this._pEffectsPass.hasMethod(method) : false;
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            MultiPassMaterialBase.prototype.getMethodAt = function (index) {
                return this._pEffectsPass.getMethodAt(index);
            };

            /**
            * Adds an effect method at the specified index amongst the methods already added to the material. Effect
            * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
            * etc. The method will be applied to the result of the methods with a lower index.
            */
            MultiPassMaterialBase.prototype.addMethodAt = function (method, index) {
                if (this._pEffectsPass == null) {
                    this._pEffectsPass = new away.materials.SuperShaderPass(this);
                }

                this._pEffectsPass.addMethodAt(method, index);
                this.pInvalidateScreenPasses();
            };

            /**
            * Removes an effect method from the material.
            * @param method The method to be removed.
            */
            MultiPassMaterialBase.prototype.removeMethod = function (method) {
                if (this._pEffectsPass)
                    return;
                this._pEffectsPass.removeMethod(method);

                if (this._pEffectsPass.numMethods == 0)
                    this.pInvalidateScreenPasses();
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "mipmap", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (this._pMipmap == value)
                        return;

                    _super.prototype.setMipMap.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "normalMap", {
                get: /**
                * The normal map to modulate the direction of the surface for each texel. The default normal method expects
                * tangent-space normal maps, but others could expect object-space maps.
                */
                function () {
                    return this._normalMethod.normalMap;
                },
                set: function (value) {
                    this._normalMethod.normalMap = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularMap", {
                get: /**
                * A specular map that defines the strength of specular reflections for each texel in the red channel,
                * and the gloss factor in the green channel. You can use SpecularBitmapTexture if you want to easily set
                * specular and gloss maps from grayscale images, but correctly authored images are preferred.
                */
                function () {
                    return this._specularMethod.texture;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.texture = value;
else
                        throw new Error("No specular method was set to assign the specularGlossMap to");
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "gloss", {
                get: /**
                * The glossiness of the material (sharpness of the specular highlight).
                */
                function () {
                    return this._specularMethod ? this._specularMethod.gloss : 0;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "ambient", {
                get: /**
                * The strength of the ambient reflection.
                */
                function () {
                    return this._ambientMethod.ambient;
                },
                set: function (value) {
                    this._ambientMethod.ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specular", {
                get: /**
                * The overall strength of the specular reflection.
                */
                function () {
                    return this._specularMethod ? this._specularMethod.specular : 0;
                },
                set: function (value) {
                    if (this._specularMethod)
                        this._specularMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "ambientColor", {
                get: /**
                * The colour of the ambient reflection.
                */
                function () {
                    return this._ambientMethod.ambientColor;
                },
                set: function (value) {
                    this._ambientMethod.ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(MultiPassMaterialBase.prototype, "specularColor", {
                get: /**
                * The colour of the specular reflection.
                */
                function () {
                    return this._specularMethod.specularColor;
                },
                set: function (value) {
                    this._specularMethod.specularColor = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iUpdateMaterial = function (context) {
                var passesInvalid;

                if (this._screenPassesInvalid) {
                    this.pUpdateScreenPasses();
                    passesInvalid = true;
                }

                if (passesInvalid || this.isAnyScreenPassInvalid()) {
                    this.pClearPasses();

                    this.addChildPassesFor(this._casterLightPass);

                    if (this._nonCasterLightPasses) {
                        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
                            this.addChildPassesFor(this._nonCasterLightPasses[i]);
                    }

                    this.addChildPassesFor(this._pEffectsPass);

                    this.addScreenPass(this._casterLightPass);

                    if (this._nonCasterLightPasses) {
                        for (i = 0; i < this._nonCasterLightPasses.length; ++i) {
                            this.addScreenPass(this._nonCasterLightPasses[i]);
                        }
                    }

                    this.addScreenPass(this._pEffectsPass);
                }
            };

            /**
            * Adds a compiled pass that renders to the screen.
            * @param pass The pass to be added.
            */
            MultiPassMaterialBase.prototype.addScreenPass = function (pass) {
                if (pass) {
                    this.pAddPass(pass);
                    pass._iPassesDirty = false;
                }
            };

            /**
            * Tests if any pass that renders to the screen is invalid. This would trigger a new setup of the multiple passes.
            * @return
            */
            MultiPassMaterialBase.prototype.isAnyScreenPassInvalid = function () {
                if ((this._casterLightPass && this._casterLightPass._iPassesDirty) || (this._pEffectsPass && this._pEffectsPass._iPassesDirty)) {
                    return true;
                }

                if (this._nonCasterLightPasses) {
                    for (var i = 0; i < this._nonCasterLightPasses.length; ++i) {
                        if (this._nonCasterLightPasses[i]._iPassesDirty)
                            return true;
                    }
                }

                return false;
            };

            /**
            * Adds any additional passes on which the given pass is dependent.
            * @param pass The pass that my need additional passes.
            */
            MultiPassMaterialBase.prototype.addChildPassesFor = function (pass) {
                if (!pass)
                    return;

                if (pass._iPasses) {
                    var len = pass._iPasses.length;

                    for (var i = 0; i < len; ++i) {
                        this.pAddPass(pass._iPasses[i]);
                    }
                }
            };

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iActivatePass = function (index, stage3DProxy, camera) {
                if (index == 0) {
                    stage3DProxy._iContext3D.setBlendFactors(away.display3D.Context3DBlendFactor.ONE, away.display3D.Context3DBlendFactor.ZERO);
                }
                _super.prototype.iActivatePass.call(this, index, stage3DProxy, camera);
            };

            /**
            * @inheritDoc
            */
            MultiPassMaterialBase.prototype.iDeactivate = function (stage3DProxy) {
                _super.prototype.iDeactivate.call(this, stage3DProxy);
                stage3DProxy._iContext3D.setBlendFactors(away.display3D.Context3DBlendFactor.ONE, away.display3D.Context3DBlendFactor.ZERO);
            };

            /**
            * Updates screen passes when they were found to be invalid.
            */
            MultiPassMaterialBase.prototype.pUpdateScreenPasses = function () {
                this.initPasses();
                this.setBlendAndCompareModes();

                this._screenPassesInvalid = false;
            };

            /**
            * Initializes all the passes and their dependent passes.
            */
            MultiPassMaterialBase.prototype.initPasses = function () {
                if (this.numLights == 0 || this.numMethods > 0) {
                    this.initEffectsPass();
                } else if (this._pEffectsPass && this.numMethods == 0) {
                    this.removeEffectsPass();
                }

                if (this._shadowMethod) {
                    this.initCasterLightPass();
                } else {
                    this.removeCasterLightPass();
                }

                if (this.numNonCasters > 0)
                    this.initNonCasterLightPasses();
else
                    this.removeNonCasterLightPasses();
            };

            /**
            * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.
            */
            MultiPassMaterialBase.prototype.setBlendAndCompareModes = function () {
                var forceSeparateMVP = (this._casterLightPass || this._pEffectsPass);

                if (this._casterLightPass) {
                    this._casterLightPass.setBlendMode(away.display.BlendMode.NORMAL);
                    this._casterLightPass.depthCompareMode = this._pDepthCompareMode;
                    this._casterLightPass.forceSeparateMVP = forceSeparateMVP;
                }

                if (this._nonCasterLightPasses) {
                    var firstAdditiveIndex = 0;

                    if (!this._casterLightPass) {
                        this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;
                        this._nonCasterLightPasses[0].setBlendMode(away.display.BlendMode.NORMAL);
                        this._nonCasterLightPasses[0].depthCompareMode = this._pDepthCompareMode;
                        firstAdditiveIndex = 1;
                    }

                    for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {
                        this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;
                        this._nonCasterLightPasses[i].setBlendMode(away.display.BlendMode.ADD);
                        this._nonCasterLightPasses[i].depthCompareMode = away.display3D.Context3DCompareMode.LESS_EQUAL;
                    }
                }

                if (this._casterLightPass || this._nonCasterLightPasses) {
                    if (this._pEffectsPass) {
                        this._pEffectsPass.iIgnoreLights = true;
                        this._pEffectsPass.depthCompareMode = away.display3D.Context3DCompareMode.LESS_EQUAL;
                        this._pEffectsPass.setBlendMode(away.display.BlendMode.LAYER);
                        this._pEffectsPass.forceSeparateMVP = forceSeparateMVP;
                    }
                } else if (this._pEffectsPass) {
                    // effects pass is the only pass, so it should just blend normally
                    this._pEffectsPass.iIgnoreLights = false;
                    this._pEffectsPass.depthCompareMode = this._pDepthCompareMode;

                    this.depthCompareMode;

                    this._pEffectsPass.setBlendMode(away.display.BlendMode.NORMAL);
                    this._pEffectsPass.forceSeparateMVP = false;
                }
            };

            MultiPassMaterialBase.prototype.initCasterLightPass = function () {
                if (this._casterLightPass == null) {
                    this._casterLightPass = new away.materials.ShadowCasterPass(this);
                }

                this._casterLightPass.diffuseMethod = null;
                this._casterLightPass.ambientMethod = null;
                this._casterLightPass.normalMethod = null;
                this._casterLightPass.specularMethod = null;
                this._casterLightPass.shadowMethod = null;
                this._casterLightPass.enableLightFallOff = this._enableLightFallOff;
                this._casterLightPass.lightPicker = new away.materials.StaticLightPicker([this._shadowMethod.castingLight]);
                this._casterLightPass.shadowMethod = this._shadowMethod;
                this._casterLightPass.diffuseMethod = this._diffuseMethod;
                this._casterLightPass.ambientMethod = this._ambientMethod;
                this._casterLightPass.normalMethod = this._normalMethod;
                this._casterLightPass.specularMethod = this._specularMethod;
                this._casterLightPass.diffuseLightSources = this._diffuseLightSources;
                this._casterLightPass.specularLightSources = this._specularLightSources;
            };

            MultiPassMaterialBase.prototype.removeCasterLightPass = function () {
                if (!this._casterLightPass)
                    return;
                this._casterLightPass.dispose();
                this.pRemovePass(this._casterLightPass);
                this._casterLightPass = null;
            };

            MultiPassMaterialBase.prototype.initNonCasterLightPasses = function () {
                this.removeNonCasterLightPasses();
                var pass;
                var numDirLights = this._pLightPicker.numDirectionalLights;
                var numPointLights = this._pLightPicker.numPointLights;
                var numLightProbes = this._pLightPicker.numLightProbes;
                var dirLightOffset = 0;
                var pointLightOffset = 0;
                var probeOffset = 0;

                if (!this._casterLightPass) {
                    numDirLights += this._pLightPicker.numCastingDirectionalLights;
                    numPointLights += this._pLightPicker.numCastingPointLights;
                }

                this._nonCasterLightPasses = new Array();

                while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {
                    pass = new materials.LightingPass(this);
                    pass.enableLightFallOff = this._enableLightFallOff;
                    pass.includeCasters = this._shadowMethod == null;
                    pass.directionalLightsOffset = dirLightOffset;
                    pass.pointLightsOffset = pointLightOffset;
                    pass.lightProbesOffset = probeOffset;
                    pass.diffuseMethod = null;
                    pass.ambientMethod = null;
                    pass.normalMethod = null;
                    pass.specularMethod = null;
                    pass.lightPicker = this._pLightPicker;
                    pass.diffuseMethod = this._diffuseMethod;
                    pass.ambientMethod = this._ambientMethod;
                    pass.normalMethod = this._normalMethod;
                    pass.specularMethod = this._specularMethod;
                    pass.diffuseLightSources = this._diffuseLightSources;
                    pass.specularLightSources = this._specularLightSources;
                    this._nonCasterLightPasses.push(pass);

                    dirLightOffset += pass.iNumDirectionalLights;
                    pointLightOffset += pass.iNumPointLights;
                    probeOffset += pass.iNumLightProbes;
                }
            };

            MultiPassMaterialBase.prototype.removeNonCasterLightPasses = function () {
                if (!this._nonCasterLightPasses)
                    return;

                for (var i = 0; i < this._nonCasterLightPasses.length; ++i) {
                    this.pRemovePass(this._nonCasterLightPasses[i]);
                    this._nonCasterLightPasses[i].dispose();
                }
                this._nonCasterLightPasses = null;
            };

            MultiPassMaterialBase.prototype.removeEffectsPass = function () {
                if (this._pEffectsPass.diffuseMethod != this._diffuseMethod)
                    this._pEffectsPass.diffuseMethod.dispose();

                this.pRemovePass(this._pEffectsPass);
                this._pEffectsPass.dispose();
                this._pEffectsPass = null;
            };

            MultiPassMaterialBase.prototype.initEffectsPass = function () {
                if (this._pEffectsPass == null) {
                    this._pEffectsPass = new away.materials.SuperShaderPass(this);
                }

                this._pEffectsPass.enableLightFallOff = this._enableLightFallOff;
                if (this.numLights == 0) {
                    this._pEffectsPass.diffuseMethod = null;
                    this._pEffectsPass.diffuseMethod = this._diffuseMethod;
                } else {
                    this._pEffectsPass.diffuseMethod = null;
                    this._pEffectsPass.diffuseMethod = new away.materials.BasicDiffuseMethod();
                    this._pEffectsPass.diffuseMethod.diffuseColor = 0x000000;
                    this._pEffectsPass.diffuseMethod.diffuseAlpha = 0;
                }

                this._pEffectsPass.preserveAlpha = false;
                this._pEffectsPass.normalMethod = null;
                this._pEffectsPass.normalMethod = this._normalMethod;

                return this._pEffectsPass;
            };

            Object.defineProperty(MultiPassMaterialBase.prototype, "numLights", {
                get: /**
                * The maximum total number of lights provided by the light picker.
                */
                function () {
                    return this._pLightPicker ? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights + this._pLightPicker.numCastingDirectionalLights + this._pLightPicker.numCastingPointLights : 0;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MultiPassMaterialBase.prototype, "numNonCasters", {
                get: /**
                * The amount of lights that don't cast shadows.
                */
                function () {
                    return this._pLightPicker ? this._pLightPicker.numLightProbes + this._pLightPicker.numDirectionalLights + this._pLightPicker.numPointLights : 0;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Flags that the screen passes have become invalid.
            */
            MultiPassMaterialBase.prototype.pInvalidateScreenPasses = function () {
                this._screenPassesInvalid = true;
            };

            /**
            * Called when the light picker's configuration changed.
            */
            MultiPassMaterialBase.prototype.onLightsChange = function (event) {
                this.pInvalidateScreenPasses();
            };
            return MultiPassMaterialBase;
        })(away.materials.MaterialBase);
        materials.MultiPassMaterialBase = MultiPassMaterialBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * TextureMultiPassMaterial is a multi-pass material that uses a texture to define the surface's diffuse reflection colour (albedo).
        */
        var TextureMultiPassMaterial = (function (_super) {
            __extends(TextureMultiPassMaterial, _super);
            /**
            * Creates a new TextureMultiPassMaterial.
            * @param texture The texture used for the material's albedo color.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to true.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to true.
            */
            function TextureMultiPassMaterial(texture, smooth, repeat, mipmap) {
                if (typeof texture === "undefined") { texture = null; }
                if (typeof smooth === "undefined") { smooth = true; }
                if (typeof repeat === "undefined") { repeat = false; }
                if (typeof mipmap === "undefined") { mipmap = true; }
                _super.call(this);
                this._animateUVs = false;
                this.texture = texture;
                this.smooth = smooth;
                this.repeat = repeat;
                this.mipmap = mipmap;
            }
            Object.defineProperty(TextureMultiPassMaterial.prototype, "animateUVs", {
                get: /**
                * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
                */
                function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMultiPassMaterial.prototype, "texture", {
                get: /**
                * The texture object to use for the albedo colour.
                */
                function () {
                    return this.diffuseMethod.texture;
                },
                set: function (value) {
                    this.diffuseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMultiPassMaterial.prototype, "ambientTexture", {
                get: /**
                * The texture object to use for the ambient colour.
                */
                function () {
                    return this.ambientMethod.texture;
                },
                set: function (value) {
                    this.ambientMethod.texture = value;
                    this.diffuseMethod.iUseAmbientTexture = (value != null);
                },
                enumerable: true,
                configurable: true
            });


            TextureMultiPassMaterial.prototype.pUpdateScreenPasses = function () {
                _super.prototype.pUpdateScreenPasses.call(this);

                if (this._pEffectsPass)
                    this._pEffectsPass.animateUVs = this._animateUVs;
            };
            return TextureMultiPassMaterial;
        })(away.materials.MultiPassMaterialBase);
        materials.TextureMultiPassMaterial = TextureMultiPassMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * ColorMultiPassMaterial is a multi-pass material that uses a flat color as the surface's diffuse reflection value.
        */
        var ColorMultiPassMaterial = (function (_super) {
            __extends(ColorMultiPassMaterial, _super);
            /**
            * Creates a new ColorMultiPassMaterial object.
            *
            * @param color The material's diffuse surface color.
            */
            function ColorMultiPassMaterial(color) {
                if (typeof color === "undefined") { color = 0xcccccc; }
                _super.call(this);
                this.color = color;
            }
            Object.defineProperty(ColorMultiPassMaterial.prototype, "color", {
                get: /**
                * The diffuse reflectivity color of the surface.
                */
                function () {
                    return this.diffuseMethod.diffuseColor;
                },
                set: function (value) {
                    this.diffuseMethod.diffuseColor = value;
                },
                enumerable: true,
                configurable: true
            });

            return ColorMultiPassMaterial;
        })(away.materials.MultiPassMaterialBase);
        materials.ColorMultiPassMaterial = ColorMultiPassMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * MethodVO contains data for a given method for the use within a single material.
        * This allows methods to be shared across materials while their non-public state differs.
        */
        var MethodVO = (function () {
            /**
            * Creates a new MethodVO object.
            */
            function MethodVO() {
                this.useLightFallOff = true;
            }
            /**
            * Resets the values of the value object to their "unused" state.
            */
            MethodVO.prototype.reset = function () {
                this.texturesIndex = -1;
                this.vertexConstantsIndex = -1;
                this.fragmentConstantsIndex = -1;

                this.useMipmapping = true;
                this.useSmoothTextures = true;
                this.repeatTextures = false;

                this.needsProjection = false;
                this.needsView = false;
                this.needsNormals = false;
                this.needsTangents = false;
                this.needsUV = false;
                this.needsSecondaryUV = false;
                this.needsGlobalVertexPos = false;
                this.needsGlobalFragmentPos = false;

                this.numLights = 0;
                this.useLightFallOff = true;
            };
            return MethodVO;
        })();
        materials.MethodVO = MethodVO;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.*;
        //import away3d.cameras.*;
        //import away3d.core.base.*;
        //import away3d.managers.*;
        //import away3d.events.*;
        //import away3d.library.assets.*;
        //import away3d.materials.compilation.*;
        //import away3d.materials.passes.*;
        //import away3d.textures.*;
        //import flash.display3D.*;
        //use namespace arcane;
        /**
        * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile
        * the final shading program.
        */
        var ShadingMethodBase = (function (_super) {
            __extends(ShadingMethodBase, _super);
            /**
            * Create a new ShadingMethodBase object.
            * @param needsNormals Defines whether or not the method requires normals.
            * @param needsView Defines whether or not the method requires the view direction.
            */
            function ShadingMethodBase() {
                _super.call(this);
            }
            /**
            * Initializes the properties for a MethodVO, including register and texture indices.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            */
            ShadingMethodBase.prototype.iInitVO = function (vo) {
            };

            /**
            * Initializes unchanging shader constants using the data from a MethodVO.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            */
            ShadingMethodBase.prototype.iInitConstants = function (vo) {
            };

            Object.defineProperty(ShadingMethodBase.prototype, "iSharedRegisters", {
                get: /**
                * The shared registers created by the compiler and possibly used by methods.
                */
                function () {
                    return this._sharedRegisters;
                },
                set: function (value) {
                    this._sharedRegisters = value;
                },
                enumerable: true,
                configurable: true
            });


            ShadingMethodBase.prototype.setISharedRegisters = function (value) {
                this._sharedRegisters = value;
            };

            Object.defineProperty(ShadingMethodBase.prototype, "passes", {
                get: /**
                * Any passes required that render to a texture used by this method.
                */
                function () {
                    return this._passes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Cleans up any resources used by the current object.
            */
            ShadingMethodBase.prototype.dispose = function () {
            };

            /**
            * Creates a data container that contains material-dependent data. Provided as a factory method so a custom subtype can be overridden when needed.
            */
            ShadingMethodBase.prototype.iCreateMethodVO = function () {
                return new away.materials.MethodVO();
            };

            /**
            * Resets the compilation state of the method.
            */
            ShadingMethodBase.prototype.iReset = function () {
                this.iCleanCompilationData();
            };

            /**
            * Resets the method's state for compilation.
            * @private
            */
            ShadingMethodBase.prototype.iCleanCompilationData = function () {
            };

            /**
            * Get the vertex shader code for this method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @private
            */
            ShadingMethodBase.prototype.iGetVertexCode = function (vo, regCache) {
                return "";
            };

            /**
            * Sets the render state for this method.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param stage3DProxy The Stage3DProxy object currently used for rendering.
            * @private
            */
            ShadingMethodBase.prototype.iActivate = function (vo, stage3DProxy) {
            };

            /**
            * Sets the render state for a single renderable.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param renderable The renderable currently being rendered.
            * @param stage3DProxy The Stage3DProxy object currently used for rendering.
            * @param camera The camera from which the scene is currently rendered.
            */
            ShadingMethodBase.prototype.iSetRenderState = function (vo, renderable, stage3DProxy, camera) {
            };

            /**
            * Clears the render state for this method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param stage3DProxy The Stage3DProxy object currently used for rendering.
            */
            ShadingMethodBase.prototype.iDeactivate = function (vo, stage3DProxy) {
            };

            /**
            * A helper method that generates standard code for sampling from a texture using the normal uv coordinates.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param targetReg The register in which to store the sampled colour.
            * @param inputReg The texture stream register.
            * @param texture The texture which will be assigned to the given slot.
            * @param uvReg An optional uv register if coordinates different from the primary uv coordinates are to be used.
            * @param forceWrap If true, texture wrapping is enabled regardless of the material setting.
            * @return The fragment code that performs the sampling.
            */
            ShadingMethodBase.prototype.pGetTex2DSampleCode = function (vo, targetReg, inputReg, texture, uvReg, forceWrap) {
                if (typeof uvReg === "undefined") { uvReg = null; }
                if (typeof forceWrap === "undefined") { forceWrap = null; }
                var wrap = forceWrap || (vo.repeatTextures ? "wrap" : "clamp");
                var filter;

                var format = this.getFormatStringForTexture(texture);
                var enableMipMaps = vo.useMipmapping && texture.hasMipMaps;

                if (vo.useSmoothTextures)
                    filter = enableMipMaps ? "linear,miplinear" : "linear";
else
                    filter = enableMipMaps ? "nearest,mipnearest" : "nearest";

                if (uvReg == null) {
                    uvReg = this._sharedRegisters.uvVarying;
                }

                return "tex " + targetReg.toString() + ", " + uvReg.toString() + ", " + inputReg.toString() + " <2d," + filter + "," + format + wrap + ">\n";
            };

            /**
            * A helper method that generates standard code for sampling from a cube texture.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param targetReg The register in which to store the sampled colour.
            * @param inputReg The texture stream register.
            * @param texture The cube map which will be assigned to the given slot.
            * @param uvReg The direction vector with which to sample the cube map.
            */
            ShadingMethodBase.prototype.pGetTexCubeSampleCode = function (vo, targetReg, inputReg, texture, uvReg) {
                var filter;
                var format = this.getFormatStringForTexture(texture);
                var enableMipMaps = vo.useMipmapping && texture.hasMipMaps;

                if (vo.useSmoothTextures)
                    filter = enableMipMaps ? "linear,miplinear" : "linear";
else
                    filter = enableMipMaps ? "nearest,mipnearest" : "nearest";

                return "tex " + targetReg.toString() + ", " + uvReg.toString() + ", " + inputReg.toString() + " <cube," + format + filter + ">\n";
            };

            /**
            * Generates a texture format string for the sample instruction.
            * @param texture The texture for which to get the format string.
            * @return
            */
            ShadingMethodBase.prototype.getFormatStringForTexture = function (texture) {
                switch (texture.format) {
                    case away.display3D.Context3DTextureFormat.COMPRESSED:
                        return "dxt1,";
                        break;
                    case "compressedAlpha":
                        return "dxt5,";
                        break;
                    default:
                        return "";
                }
            };

            /**
            * Marks the shader program as invalid, so it will be recompiled before the next render.
            */
            ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {
                this.dispatchEvent(new away.events.ShadingMethodEvent(away.events.ShadingMethodEvent.SHADER_INVALIDATED));
            };

            /**
            * Copies the state from a ShadingMethodBase object into the current object.
            */
            ShadingMethodBase.prototype.copyFrom = function (method) {
            };
            return ShadingMethodBase;
        })(away.library.NamedAssetBase);
        materials.ShadingMethodBase = ShadingMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,
        * and are in essence post-process effects on the materials.
        */
        var EffectMethodBase = (function (_super) {
            __extends(EffectMethodBase, _super);
            function EffectMethodBase() {
                _super.call(this);
            }
            Object.defineProperty(EffectMethodBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.EFFECTS_METHOD;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register that will be containing the method's output.
            * @private
            */
            EffectMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };
            return EffectMethodBase;
        })(away.materials.ShadingMethodBase);
        materials.EffectMethodBase = EffectMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        /**
        * MethodVOSet provides a EffectMethodBase and MethodVO combination to be used by a material, allowing methods
        * to be shared across different materials while their internal state changes.
        */
        var MethodVOSet = (function () {
            /**
            * Creates a new MethodVOSet object.
            * @param method The method for which we need to store a MethodVO object.
            */
            function MethodVOSet(method) {
                this.method = method;
                this.data = method.iCreateMethodVO();
            }
            return MethodVOSet;
        })();
        materials.MethodVOSet = MethodVOSet;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShaderMethodSetup contains the method configuration for an entire material.
        */
        var ShaderMethodSetup = (function (_super) {
            __extends(ShaderMethodSetup, _super);
            /**
            * Creates a new ShaderMethodSetup object.
            */
            function ShaderMethodSetup() {
                _super.call(this);

                this._iMethods = new Array();
                this._iNormalMethod = new away.materials.BasicNormalMethod();
                this._iAmbientMethod = new away.materials.BasicAmbientMethod();
                this._iDiffuseMethod = new away.materials.BasicDiffuseMethod();
                this._iSpecularMethod = new away.materials.BasicSpecularMethod();
                this._iNormalMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                this._iDiffuseMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                this._iSpecularMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                this._iAmbientMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                this._iNormalMethodVO = this._iNormalMethod.iCreateMethodVO();
                this._iAmbientMethodVO = this._iAmbientMethod.iCreateMethodVO();
                this._iDiffuseMethodVO = this._iDiffuseMethod.iCreateMethodVO();
                this._iSpecularMethodVO = this._iSpecularMethod.iCreateMethodVO();
            }
            /**
            * Called when any method's code is invalidated.
            */
            ShaderMethodSetup.prototype.onShaderInvalidated = function (event) {
                this.invalidateShaderProgram();
            };

            /**
            * Invalidates the material's shader code.
            */
            ShaderMethodSetup.prototype.invalidateShaderProgram = function () {
                this.dispatchEvent(new away.events.ShadingMethodEvent(away.events.ShadingMethodEvent.SHADER_INVALIDATED));
            };

            Object.defineProperty(ShaderMethodSetup.prototype, "normalMethod", {
                get: /**
                *  The method used to generate the per-pixel normals.
                */
                function () {
                    return this._iNormalMethod;
                },
                set: function (value) {
                    if (this._iNormalMethod) {
                        this._iNormalMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                    }

                    if (value) {
                        if (this._iNormalMethod) {
                            value.copyFrom(this._iNormalMethod);
                        }

                        this._iNormalMethodVO = value.iCreateMethodVO();
                        value.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                    }

                    this._iNormalMethod = value;

                    if (value)
                        this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "ambientMethod", {
                get: /**
                * The method that provides the ambient lighting contribution.
                */
                function () {
                    return this._iAmbientMethod;
                },
                set: function (value) {
                    if (this._iAmbientMethod)
                        this._iAmbientMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);

                    if (value) {
                        if (this._iAmbientMethod)
                            value.copyFrom(this._iAmbientMethod);

                        value.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                        this._iAmbientMethodVO = value.iCreateMethodVO();
                    }
                    this._iAmbientMethod = value;

                    if (value)
                        this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "shadowMethod", {
                get: /**
                * The method used to render shadows cast on this surface, or null if no shadows are to be rendered.
                */
                function () {
                    return this._iShadowMethod;
                },
                set: function (value) {
                    if (this._iShadowMethod) {
                        this._iShadowMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                    }

                    this._iShadowMethod = value;

                    if (this._iShadowMethod) {
                        this._iShadowMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                        this._iShadowMethodVO = this._iShadowMethod.iCreateMethodVO();
                    } else {
                        this._iShadowMethodVO = null;
                    }

                    this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "diffuseMethod", {
                get: /**
                * The method that provides the diffuse lighting contribution.
                */
                function () {
                    return this._iDiffuseMethod;
                },
                set: function (value) {
                    if (this._iDiffuseMethod)
                        this._iDiffuseMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);

                    if (value) {
                        if (this._iDiffuseMethod)
                            value.copyFrom(this._iDiffuseMethod);

                        value.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);

                        this._iDiffuseMethodVO = value.iCreateMethodVO();
                    }

                    this._iDiffuseMethod = value;

                    if (value)
                        this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "specularMethod", {
                get: /**
                * The method to perform specular shading.
                */
                function () {
                    return this._iSpecularMethod;
                },
                set: function (value) {
                    if (this._iSpecularMethod) {
                        this._iSpecularMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);

                        if (value)
                            value.copyFrom(this._iSpecularMethod);
                    }

                    this._iSpecularMethod = value;
                    if (this._iSpecularMethod) {
                        this._iSpecularMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                        this._iSpecularMethodVO = this._iSpecularMethod.iCreateMethodVO();
                    } else {
                        this._iSpecularMethodVO = null;
                    }

                    this.invalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderMethodSetup.prototype, "iColorTransformMethod", {
                get: /**
                * @private
                */
                function () {
                    return this._iColorTransformMethod;
                },
                set: function (value) {
                    if (this._iColorTransformMethod == value)
                        return;

                    if (this._iColorTransformMethod)
                        this._iColorTransformMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);

                    if (!this._iColorTransformMethod || !value) {
                        this.invalidateShaderProgram();
                    }

                    this._iColorTransformMethod = value;

                    if (this._iColorTransformMethod) {
                        this._iColorTransformMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                        this._iColorTransformMethodVO = this._iColorTransformMethod.iCreateMethodVO();
                    } else {
                        this._iColorTransformMethodVO = null;
                    }
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Disposes the object.
            */
            ShaderMethodSetup.prototype.dispose = function () {
                this.clearListeners(this._iNormalMethod);
                this.clearListeners(this._iDiffuseMethod);
                this.clearListeners(this._iShadowMethod);
                this.clearListeners(this._iAmbientMethod);
                this.clearListeners(this._iSpecularMethod);

                for (var i = 0; i < this._iMethods.length; ++i) {
                    this.clearListeners(this._iMethods[i].method);
                }

                this._iMethods = null;
            };

            /**
            * Removes all listeners from a method.
            */
            ShaderMethodSetup.prototype.clearListeners = function (method) {
                if (method)
                    method.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
            };

            /**
            * Adds a method to change the material after all lighting is performed.
            * @param method The method to be added.
            */
            ShaderMethodSetup.prototype.addMethod = function (method) {
                this._iMethods.push(new away.materials.MethodVOSet(method));

                method.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);

                this.invalidateShaderProgram();
            };

            /**
            * Queries whether a given effect method was added to the material.
            *
            * @param method The method to be queried.
            * @return true if the method was added to the material, false otherwise.
            */
            ShaderMethodSetup.prototype.hasMethod = function (method) {
                return this.getMethodSetForMethod(method) != null;
            };

            /**
            * Inserts a method to change the material after all lighting is performed at the given index.
            * @param method The method to be added.
            * @param index The index of the method's occurrence
            */
            ShaderMethodSetup.prototype.addMethodAt = function (method, index) {
                this._iMethods.splice(index, 0, new away.materials.MethodVOSet(method));

                method.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);

                this.invalidateShaderProgram();
            };

            /**
            * Returns the method added at the given index.
            * @param index The index of the method to retrieve.
            * @return The method at the given index.
            */
            ShaderMethodSetup.prototype.getMethodAt = function (index) {
                if (index > this._iMethods.length - 1)
                    return null;

                return this._iMethods[index].method;
            };

            Object.defineProperty(ShaderMethodSetup.prototype, "numMethods", {
                get: /**
                * The number of "effect" methods added to the material.
                */
                function () {
                    return this._iMethods.length;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Removes a method from the pass.
            * @param method The method to be removed.
            */
            ShaderMethodSetup.prototype.removeMethod = function (method) {
                var methodSet = this.getMethodSetForMethod(method);

                if (methodSet != null) {
                    var index = this._iMethods.indexOf(methodSet);

                    this._iMethods.splice(index, 1);

                    method.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);

                    this.invalidateShaderProgram();
                }
            };

            ShaderMethodSetup.prototype.getMethodSetForMethod = function (method) {
                var len = this._iMethods.length;

                for (var i = 0; i < len; ++i) {
                    if (this._iMethods[i].method == method)
                        return this._iMethods[i];
                }

                return null;
            };
            return ShaderMethodSetup;
        })(away.events.EventDispatcher);
        materials.ShaderMethodSetup = ShaderMethodSetup;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.materials.compilation.ShaderRegisterCache;
        //import away3d.materials.compilation.ShaderRegisterElement;
        //use namespace arcane;
        /**
        * LightingMethodBase provides an abstract base method for shading methods that uses lights.
        * Used for diffuse and specular shaders only.
        */
        var LightingMethodBase = (function (_super) {
            __extends(LightingMethodBase, _super);
            /**
            * Creates a new LightingMethodBase.
            */
            function LightingMethodBase() {
                _super.call(this);
            }
            /**
            * Get the fragment shader code that will be needed before any per-light code is added.
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @private
            */
            LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that will generate the code relevant to a single light.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param lightDirReg The register containing the light direction vector.
            * @param lightColReg The register containing the light colour.
            * @param regCache The register cache used during the compilation.
            */
            LightingMethodBase.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that will generate the code relevant to a single light probe object.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param cubeMapReg The register containing the cube map for the current probe
            * @param weightRegister A string representation of the register + component containing the current weight
            * @param regCache The register cache providing any necessary registers to the shader
            */
            LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                return "";
            };

            /**
            * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register containing the final shading output.
            * @private
            */
            LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return "";
            };
            return LightingMethodBase;
        })(away.materials.ShadingMethodBase);
        materials.LightingMethodBase = LightingMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.*;
        //import away3d.errors.*;
        //import away3d.library.assets.*;
        //import away3d.lights.*;
        //import away3d.lights.shadowmaps.*;
        //import away3d.materials.compilation.*;
        //use namespace arcane;
        /**
        * ShadowMapMethodBase provides an abstract base method for shadow map methods.
        */
        var ShadowMapMethodBase = (function (_super) {
            __extends(ShadowMapMethodBase, _super);
            /**
            * Creates a new ShadowMapMethodBase object.
            * @param castingLight The light used to cast shadows.
            */
            function ShadowMapMethodBase(castingLight) {
                _super.call(this);
                this._pEpsilon = .02;
                this._pAlpha = 1;
                this._pCastingLight = castingLight;
                castingLight.castsShadows = true;
                this._pShadowMapper = castingLight.shadowMapper;
            }
            Object.defineProperty(ShadowMapMethodBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.SHADOW_MAP_METHOD;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapMethodBase.prototype, "alpha", {
                get: /**
                * The "transparency" of the shadows. This allows making shadows less strong.
                */
                function () {
                    return this._pAlpha;
                },
                set: function (value) {
                    this._pAlpha = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShadowMapMethodBase.prototype, "castingLight", {
                get: /**
                * The light casting the shadows.
                */
                function () {
                    return this._pCastingLight;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShadowMapMethodBase.prototype, "epsilon", {
                get: /**
                * A small value to counter floating point precision errors when comparing values in the shadow map with the
                * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.
                */
                function () {
                    return this._pEpsilon;
                },
                set: function (value) {
                    this._pEpsilon = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ShadowMapMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return null;
            };
            return ShadowMapMethodBase;
        })(away.materials.ShadingMethodBase);
        materials.ShadowMapMethodBase = ShadowMapMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SimpleShadowMapMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.
        */
        var SimpleShadowMapMethodBase = (function (_super) {
            __extends(SimpleShadowMapMethodBase, _super);
            /**
            * Creates a new SimpleShadowMapMethodBase object.
            * @param castingLight The light used to cast shadows.
            */
            function SimpleShadowMapMethodBase(castingLight) {
                this._pUsePoint = (castingLight instanceof away.lights.PointLight);
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iInitVO = function (vo) {
                vo.needsView = true;
                vo.needsGlobalVertexPos = true;
                vo.needsGlobalFragmentPos = this._pUsePoint;
                vo.needsNormals = vo.numLights > 0;
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iInitConstants = function (vo) {
                var fragmentData = vo.fragmentData;
                var vertexData = vo.vertexData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index] = 1.0;
                fragmentData[index + 1] = 1 / 255.0;
                fragmentData[index + 2] = 1 / 65025.0;
                fragmentData[index + 3] = 1 / 16581375.0;

                fragmentData[index + 6] = 0;
                fragmentData[index + 7] = 1;

                if (this._pUsePoint) {
                    fragmentData[index + 8] = 0;
                    fragmentData[index + 9] = 0;
                    fragmentData[index + 10] = 0;
                    fragmentData[index + 11] = 1;
                }

                index = vo.vertexConstantsIndex;
                if (index != -1) {
                    vertexData[index] = .5;
                    vertexData[index + 1] = .5;
                    vertexData[index + 2] = 0.0;
                    vertexData[index + 3] = 1.0;
                }
            };

            Object.defineProperty(SimpleShadowMapMethodBase.prototype, "_iDepthMapCoordReg", {
                get: /**
                * Wrappers that override the vertex shader need to set this explicitly
                */
                function () {
                    return this._pDepthMapCoordReg;
                },
                set: function (value) {
                    this._pDepthMapCoordReg = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);

                this._pDepthMapCoordReg = null;
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iGetVertexCode = function (vo, regCache) {
                return this._pUsePoint ? this._pGetPointVertexCode(vo, regCache) : this.pGetPlanarVertexCode(vo, regCache);
            };

            /**
            * Gets the vertex code for shadow mapping with a point light.
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            */
            SimpleShadowMapMethodBase.prototype._pGetPointVertexCode = function (vo, regCache) {
                vo.vertexConstantsIndex = -1;
                return "";
            };

            /**
            * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).
            *
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            */
            SimpleShadowMapMethodBase.prototype.pGetPlanarVertexCode = function (vo, regCache) {
                var code = "";
                var temp = regCache.getFreeVertexVectorTemp();
                var dataReg = regCache.getFreeVertexConstant();
                var depthMapProj = regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                regCache.getFreeVertexConstant();
                this._pDepthMapCoordReg = regCache.getFreeVarying();
                vo.vertexConstantsIndex = dataReg.index * 4;

                // todo: can epsilon be applied here instead of fragment shader?
                code += "m44 " + temp + ", " + this._sharedRegisters.globalPositionVertex + ", " + depthMapProj + "\n" + "div " + temp + ", " + temp + ", " + temp + ".w\n" + "mul " + temp + ".xy, " + temp + ".xy, " + dataReg + ".xy\n" + "add " + this._pDepthMapCoordReg + ", " + temp + ", " + dataReg + ".xxwz\n";

                //"sub " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".w\n";
                return code;
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = this._pUsePoint ? this._pGetPointFragmentCode(vo, regCache, targetReg) : this._pGetPlanarFragmentCode(vo, regCache, targetReg);
                code += "add " + targetReg + ".w, " + targetReg + ".w, fc" + (vo.fragmentConstantsIndex / 4 + 1) + ".y\n" + "sat " + targetReg + ".w, " + targetReg + ".w\n";
                return code;
            };

            /**
            * Gets the fragment code for shadow mapping with a planar shadow map.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register to contain the shadow coverage
            * @return
            */
            SimpleShadowMapMethodBase.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };

            /**
            * Gets the fragment code for shadow mapping with a point light.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param targetReg The register to contain the shadow coverage
            * @return
            */
            SimpleShadowMapMethodBase.prototype._pGetPointFragmentCode = function (vo, regCache, targetReg) {
                throw new away.errors.AbstractMethodError();
                return "";
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iSetRenderState = function (vo, renderable, stage3DProxy, camera) {
                if (!this._pUsePoint)
                    (this._pShadowMapper).iDepthProjection.copyRawDataTo(vo.vertexData, vo.vertexConstantsIndex + 4, true);
            };

            /**
            * Gets the fragment code for combining this method with a cascaded shadow map method.
            * @param vo The MethodVO object linking this method with the pass currently being compiled.
            * @param regCache The register cache used during the compilation.
            * @param decodeRegister The register containing the data to decode the shadow map depth value.
            * @param depthTexture The texture containing the shadow map.
            * @param depthProjection The projection of the fragment relative to the light.
            * @param targetRegister The register to contain the shadow coverage
            * @return
            */
            SimpleShadowMapMethodBase.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                throw new Error("This shadow method is incompatible with cascade shadows");
            };

            /**
            * @inheritDoc
            */
            SimpleShadowMapMethodBase.prototype.iActivate = function (vo, stage3DProxy) {
                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;

                if (this._pUsePoint)
                    fragmentData[index + 4] = -Math.pow(1 / ((this._pCastingLight).fallOff * this._pEpsilon), 2);
else
                    vo.vertexData[vo.vertexConstantsIndex + 3] = -1 / ((this._pShadowMapper).depth * this._pEpsilon);

                fragmentData[index + 5] = 1 - this._pAlpha;
                if (this._pUsePoint) {
                    var pos = this._pCastingLight.scenePosition;
                    fragmentData[index + 8] = pos.x;
                    fragmentData[index + 9] = pos.y;
                    fragmentData[index + 10] = pos.z;

                    // used to decompress distance
                    var f = (this._pCastingLight).fallOff;
                    fragmentData[index + 11] = 1 / (2 * f * f);
                }
                stage3DProxy._iContext3D.setTextureAt(vo.texturesIndex, this._pCastingLight.shadowMapper.depthMap.getTextureForStage3D(stage3DProxy));
            };

            /**
            * Sets the method state for cascade shadow mapping.
            */
            SimpleShadowMapMethodBase.prototype.iActivateForCascade = function (vo, stage3DProxy) {
                throw new Error("This shadow method is incompatible with cascade shadows");
            };
            return SimpleShadowMapMethodBase;
        })(away.materials.ShadowMapMethodBase);
        materials.SimpleShadowMapMethodBase = SimpleShadowMapMethodBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * DitheredShadowMapMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison
        * results of neighbouring pixels.
        */
        var FilteredShadowMapMethod = (function (_super) {
            __extends(FilteredShadowMapMethod, _super);
            /**
            * Creates a new BasicDiffuseMethod object.
            *
            * @param castingLight The light casting the shadow
            */
            function FilteredShadowMapMethod(castingLight) {
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            FilteredShadowMapMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index + 8] = .5;
                var size = this.castingLight.shadowMapper.depthMapSize;
                fragmentData[index + 9] = size;
                fragmentData[index + 10] = 1 / size;
            };

            /**
            * @inheritDoc
            */
            FilteredShadowMapMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();

                // TODO: not used
                dataReg = dataReg;
                var customDataReg = regCache.getFreeFragmentConstant();
                var depthCol = regCache.getFreeFragmentVectorTemp();
                var uvReg;
                var code = "";
                vo.fragmentConstantsIndex = decReg.index * 4;

                regCache.addFragmentTempUsages(depthCol, 1);

                uvReg = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(uvReg, 1);

                code += "mov " + uvReg + ", " + this._pDepthMapCoordReg + "\n" + "tex " + depthCol + ", " + this._pDepthMapCoordReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + targetReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" + "mov " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x\n" + "add " + uvReg + ".y, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" + "tex " + depthCol + ", " + uvReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + uvReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" + "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".y\n" + "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + targetReg + ".w\n" + "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + uvReg + ".w\n";

                regCache.removeFragmentTempUsage(depthCol);
                regCache.removeFragmentTempUsage(uvReg);

                vo.texturesIndex = depthMapRegister.index;

                return code;
            };

            /**
            * @inheritDoc
            */
            FilteredShadowMapMethod.prototype.iActivateForCascade = function (vo, stage3DProxy) {
                var size = this.castingLight.shadowMapper.depthMapSize;
                var index = vo.secondaryFragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = size;
                data[index + 1] = 1 / size;
            };

            /**
            * @inheritDoc
            */
            FilteredShadowMapMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                var code;
                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;
                var temp = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(temp, 1);
                var predicate = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(predicate, 1);

                code = "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".x, " + depthProjection + ".z, " + temp + ".z\n" + "add " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".z, " + depthProjection + ".z, " + temp + ".z\n" + "add " + depthProjection + ".y, " + depthProjection + ".y, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".w, " + depthProjection + ".z, " + temp + ".z\n" + "sub " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" + "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + predicate + ".y, " + depthProjection + ".z, " + temp + ".z\n" + "mul " + temp + ".xy, " + depthProjection + ".xy, " + dataReg + ".x\n" + "frc " + temp + ".xy, " + temp + ".xy\n" + "sub " + depthProjection + ", " + predicate + ".xyzw, " + predicate + ".zwxy\n" + "mul " + depthProjection + ", " + depthProjection + ", " + temp + ".x\n" + "add " + predicate + ".xy, " + predicate + ".xy, " + depthProjection + ".zw\n" + "sub " + predicate + ".y, " + predicate + ".y, " + predicate + ".x\n" + "mul " + predicate + ".y, " + predicate + ".y, " + temp + ".y\n" + "add " + targetRegister + ".w, " + predicate + ".x, " + predicate + ".y\n";

                regCache.removeFragmentTempUsage(temp);
                regCache.removeFragmentTempUsage(predicate);
                return code;
            };
            return FilteredShadowMapMethod;
        })(away.materials.SimpleShadowMapMethodBase);
        materials.FilteredShadowMapMethod = FilteredShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * HardShadowMapMethod provides the cheapest shadow map method by using a single tap without any filtering.
        */
        var HardShadowMapMethod = (function (_super) {
            __extends(HardShadowMapMethod, _super);
            /**
            * Creates a new HardShadowMapMethod object.
            */
            function HardShadowMapMethod(castingLight) {
                _super.call(this, castingLight);
            }
            /**
            * @inheritDoc
            */
            HardShadowMapMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();

                // needs to be reserved anyway. DO NOT REMOVE
                var dataReg = regCache.getFreeFragmentConstant();

                // TODO not used
                dataReg = dataReg;
                var depthCol = regCache.getFreeFragmentVectorTemp();
                var code = "";

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                code += "tex " + depthCol + ", " + this._pDepthMapCoordReg + ", " + depthMapRegister + " <2d, nearest, clamp>\n" + "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" + "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            HardShadowMapMethod.prototype._pGetPointFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var epsReg = regCache.getFreeFragmentConstant();
                var posReg = regCache.getFreeFragmentConstant();
                var depthSampleCol = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(depthSampleCol, 1);
                var lightDir = regCache.getFreeFragmentVectorTemp();
                var code = "";

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                code += "sub " + lightDir + ", " + this._sharedRegisters.globalPositionVarying + ", " + posReg + "\n" + "dp3 " + lightDir + ".w, " + lightDir + ".xyz, " + lightDir + ".xyz\n" + "mul " + lightDir + ".w, " + lightDir + ".w, " + posReg + ".w\n" + "nrm " + lightDir + ".xyz, " + lightDir + ".xyz\n" + "tex " + depthSampleCol + ", " + lightDir + ", " + depthMapRegister + " <cube, nearest, clamp>\n" + "dp4 " + depthSampleCol + ".z, " + depthSampleCol + ", " + decReg + "\n" + "add " + targetReg + ".w, " + lightDir + ".w, " + epsReg + ".x\n" + "slt " + targetReg + ".w, " + targetReg + ".w, " + depthSampleCol + ".z\n";

                regCache.removeFragmentTempUsage(depthSampleCol);

                return code;
            };

            /**
            * @inheritDoc
            */
            HardShadowMapMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + depthProjection + ", " + depthTexture + " <2d, nearest, clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + targetRegister + ".w, " + depthProjection + ".z, " + temp + ".z\n";
            };

            /**
            * @inheritDoc
            */
            HardShadowMapMethod.prototype.iActivateForCascade = function (vo, stage3DProxy) {
            };
            return HardShadowMapMethod;
        })(materials.SimpleShadowMapMethodBase);
        materials.HardShadowMapMethod = HardShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SoftShadowMapMethod provides a soft shadowing technique by randomly distributing sample points.
        */
        var SoftShadowMapMethod = (function (_super) {
            __extends(SoftShadowMapMethod, _super);
            /**
            * Creates a new BasicDiffuseMethod object.
            *
            * @param castingLight The light casting the shadows
            * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.
            */
            function SoftShadowMapMethod(castingLight, numSamples, range) {
                if (typeof numSamples === "undefined") { numSamples = 5; }
                if (typeof range === "undefined") { range = 1; }
                _super.call(this, castingLight);
                this._range = 1;

                this.numSamples = numSamples;
                this.range = range;
            }
            Object.defineProperty(SoftShadowMapMethod.prototype, "numSamples", {
                get: /**
                * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the
                * complexity of the shader.
                */
                function () {
                    return this._numSamples;
                },
                set: function (value/*int*/ ) {
                    this._numSamples = value;
                    if (this._numSamples < 1)
                        this._numSamples = 1;
else if (this._numSamples > 32)
                        this._numSamples = 32;

                    this._offsets = away.math.PoissonLookup.getDistribution(this._numSamples);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SoftShadowMapMethod.prototype, "range", {
                get: /**
                * The range in the shadow map in which to distribute the samples.
                */
                function () {
                    return this._range;
                },
                set: function (value) {
                    this._range = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                vo.fragmentData[vo.fragmentConstantsIndex + 8] = 1 / this._numSamples;
                vo.fragmentData[vo.fragmentConstantsIndex + 9] = 0;
            };

            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype.iActivate = function (vo, stage3DProxy) {
                _super.prototype.iActivate.call(this, vo, stage3DProxy);
                var texRange = .5 * this._range / this._pCastingLight.shadowMapper.depthMapSize;
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex + 10;
                var len = this._numSamples << 1;

                for (var i = 0; i < len; ++i)
                    data[index + i] = this._offsets[i] * texRange;
            };

            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                // todo: move some things to super
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();
                var customDataReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                return this.getSampleCode(regCache, depthMapRegister, decReg, targetReg, customDataReg);
            };

            /**
            * Adds the code for another tap to the shader code.
            * @param uv The uv register for the tap.
            * @param texture The texture register containing the depth map.
            * @param decode The register containing the depth map decoding data.
            * @param target The target register to add the tap comparison result.
            * @param regCache The register cache managing the registers.
            * @return
            */
            SoftShadowMapMethod.prototype.addSample = function (uv, texture, decode, target, regCache) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + uv + ", " + texture + " <2d,nearest,clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decode + "\n" + "slt " + uv + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" + "add " + target + ".w, " + target + ".w, " + uv + ".w\n";
            };

            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype.iActivateForCascade = function (vo, stage3DProxy) {
                _super.prototype.iActivate.call(this, vo, stage3DProxy);
                var texRange = this._range / this._pCastingLight.shadowMapper.depthMapSize;
                var data = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                var len = this._numSamples << 1;
                data[index] = 1 / this._numSamples;
                data[index + 1] = 0;
                index += 2;
                for (var i = 0; i < len; ++i)
                    data[index + i] = this._offsets[i] * texRange;

                if (len % 4 == 0) {
                    data[index + len] = 0;
                    data[index + len + 1] = 0;
                }
            };

            /**
            * @inheritDoc
            */
            SoftShadowMapMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                this._pDepthMapCoordReg = depthProjection;

                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;

                return this.getSampleCode(regCache, depthTexture, decodeRegister, targetRegister, dataReg);
            };

            /**
            * Get the actual shader code for shadow mapping
            * @param regCache The register cache managing the registers.
            * @param depthTexture The texture register containing the depth map.
            * @param decodeRegister The register containing the depth map decoding data.
            * @param targetReg The target register to add the shadow coverage.
            * @param dataReg The register containing additional data.
            */
            SoftShadowMapMethod.prototype.getSampleCode = function (regCache, depthTexture, decodeRegister, targetRegister, dataReg) {
                var uvReg;
                var code;
                var offsets = new Array(dataReg + ".zw");
                uvReg = regCache.getFreeFragmentVectorTemp();
                regCache.addFragmentTempUsages(uvReg, 1);

                var temp = regCache.getFreeFragmentVectorTemp();

                var numRegs = this._numSamples >> 1;
                for (var i = 0; i < numRegs; ++i) {
                    var reg = regCache.getFreeFragmentConstant();
                    offsets.push(reg + ".xy");
                    offsets.push(reg + ".zw");
                }

                for (i = 0; i < this._numSamples; ++i) {
                    if (i == 0) {
                        code = "add " + uvReg + ", " + this._pDepthMapCoordReg + ", " + dataReg + ".zwyy\n";
                        code += "tex " + temp + ", " + uvReg + ", " + depthTexture + " <2d,nearest,clamp>\n" + "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" + "slt " + targetRegister + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n";
                    } else {
                        code += "add " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + offsets[i] + "\n";
                        code += this.addSample(uvReg, depthTexture, decodeRegister, targetRegister, regCache);
                    }
                }

                regCache.removeFragmentTempUsage(uvReg);
                code += "mul " + targetRegister + ".w, " + targetRegister + ".w, " + dataReg + ".x\n";
                return code;
            };
            return SoftShadowMapMethod;
        })(materials.SimpleShadowMapMethodBase);
        materials.SoftShadowMapMethod = SoftShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * DitheredShadowMapMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.
        */
        var DitheredShadowMapMethod = (function (_super) {
            __extends(DitheredShadowMapMethod, _super);
            /**
            * Creates a new DitheredShadowMapMethod object.
            * @param castingLight The light casting the shadows
            * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.
            */
            function DitheredShadowMapMethod(castingLight, numSamples, range) {
                if (typeof numSamples === "undefined") { numSamples = 4; }
                if (typeof range === "undefined") { range = 1; }
                _super.call(this, castingLight);

                this._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;

                this.numSamples = numSamples;
                this.range = range;

                ++away.materials.DitheredShadowMapMethod._grainUsages;

                if (!away.materials.DitheredShadowMapMethod._grainTexture)
                    this.initGrainTexture();
            }
            Object.defineProperty(DitheredShadowMapMethod.prototype, "numSamples", {
                get: /**
                * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the
                * complexity of the shader.
                */
                function () {
                    return this._numSamples;
                },
                set: function (value/*int*/ ) {
                    this._numSamples = value;
                    if (this._numSamples < 1)
                        this._numSamples = 1;
else if (this._numSamples > 24)
                        this._numSamples = 24;
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.iInitVO = function (vo) {
                _super.prototype.iInitVO.call(this, vo);
                vo.needsProjection = true;
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.iInitConstants = function (vo) {
                _super.prototype.iInitConstants.call(this, vo);

                var fragmentData = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                fragmentData[index + 8] = 1 / this._numSamples;
            };

            Object.defineProperty(DitheredShadowMapMethod.prototype, "range", {
                get: /**
                * The range in the shadow map in which to distribute the samples.
                */
                function () {
                    return this._range * 2;
                },
                set: function (value) {
                    this._range = value / 2;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Creates a texture containing the dithering noise texture.
            */
            DitheredShadowMapMethod.prototype.initGrainTexture = function () {
                away.materials.DitheredShadowMapMethod._grainBitmapData = new away.display.BitmapData(64, 64, false);
                var vec = new Array();
                var len = 4096;
                var step = 1 / (this._depthMapSize * this._range);
                var r, g;

                for (var i = 0; i < len; ++i) {
                    r = 2 * (Math.random() - .5);
                    g = 2 * (Math.random() - .5);
                    if (r < 0)
                        r -= step;
else
                        r += step;
                    if (g < 0)
                        g -= step;
else
                        g += step;
                    if (r > 1)
                        r = 1;
else if (r < -1)
                        r = -1;
                    if (g > 1)
                        g = 1;
else if (g < -1)
                        g = -1;
                    vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);
                }

                away.materials.DitheredShadowMapMethod._grainBitmapData.setVector(away.materials.DitheredShadowMapMethod._grainBitmapData.rect, vec);
                away.materials.DitheredShadowMapMethod._grainTexture = new away.textures.BitmapTexture(away.materials.DitheredShadowMapMethod._grainBitmapData);
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.dispose = function () {
                if (--away.materials.DitheredShadowMapMethod._grainUsages == 0) {
                    away.materials.DitheredShadowMapMethod._grainTexture.dispose();
                    away.materials.DitheredShadowMapMethod._grainBitmapData.dispose();
                    away.materials.DitheredShadowMapMethod._grainTexture = null;
                }
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.iActivate = function (vo, stage3DProxy) {
                _super.prototype.iActivate.call(this, vo, stage3DProxy);
                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;
                data[index + 9] = (stage3DProxy.width - 1) / 63;
                data[index + 10] = (stage3DProxy.height - 1) / 63;
                data[index + 11] = 2 * this._range / this._depthMapSize;
                stage3DProxy._iContext3D.setTextureAt(vo.texturesIndex + 1, away.materials.DitheredShadowMapMethod._grainTexture.getTextureForStage3D(stage3DProxy));
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype._pGetPlanarFragmentCode = function (vo, regCache, targetReg) {
                var depthMapRegister = regCache.getFreeTextureReg();
                var decReg = regCache.getFreeFragmentConstant();
                var dataReg = regCache.getFreeFragmentConstant();
                var customDataReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = decReg.index * 4;
                vo.texturesIndex = depthMapRegister.index;

                return this.getSampleCode(regCache, customDataReg, depthMapRegister, decReg, targetReg);
            };

            /**
            * Get the actual shader code for shadow mapping
            * @param regCache The register cache managing the registers.
            * @param depthMapRegister The texture register containing the depth map.
            * @param decReg The register containing the depth map decoding data.
            * @param targetReg The target register to add the shadow coverage.
            */
            DitheredShadowMapMethod.prototype.getSampleCode = function (regCache, customDataReg, depthMapRegister, decReg, targetReg) {
                var code = "";
                var grainRegister = regCache.getFreeTextureReg();
                var uvReg = regCache.getFreeFragmentVectorTemp();
                var numSamples = this._numSamples;
                regCache.addFragmentTempUsages(uvReg, 1);

                var temp = regCache.getFreeFragmentVectorTemp();

                var projectionReg = this._sharedRegisters.projectionFragment;

                code += "div " + uvReg + ", " + projectionReg + ", " + projectionReg + ".w\n" + "mul " + uvReg + ".xy, " + uvReg + ".xy, " + customDataReg + ".yz\n";

                while (numSamples > 0) {
                    if (numSamples == this._numSamples)
                        code += "tex " + uvReg + ", " + uvReg + ", " + grainRegister + " <2d,nearest,repeat,mipnone>\n";
else
                        code += "tex " + uvReg + ", " + uvReg + ".zwxy, " + grainRegister + " <2d,nearest,repeat,mipnone>\n";

                    // keep grain in uvReg.zw
                    code += "sub " + uvReg + ".zw, " + uvReg + ".xy, fc0.xx\n" + "mul " + uvReg + ".zw, " + uvReg + ".zw, " + customDataReg + ".w\n";

                    if (numSamples == this._numSamples) {
                        // first sample
                        code += "add " + uvReg + ".xy, " + uvReg + ".zw, " + this._pDepthMapCoordReg + ".xy\n" + "tex " + temp + ", " + uvReg + ", " + depthMapRegister + " <2d,nearest,clamp,mipnone>\n" + "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" + "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n";
                    } else
                        code += this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);

                    if (numSamples > 4) {
                        code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 1) {
                        code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 5) {
                        code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 2) {
                        code += "neg " + uvReg + ".w, " + uvReg + ".w\n";

                        code += "add " + uvReg + ".xy, " + uvReg + ".wz, " + this._pDepthMapCoordReg + ".xy\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 6) {
                        code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 3) {
                        code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    if (numSamples > 7) {
                        code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(uvReg, depthMapRegister, decReg, targetReg, regCache);
                    }

                    numSamples -= 8;
                }

                regCache.removeFragmentTempUsage(uvReg);
                code += "mul " + targetReg + ".w, " + targetReg + ".w, " + customDataReg + ".x\n";
                return code;
            };

            /**
            * Adds the code for another tap to the shader code.
            * @param uvReg The uv register for the tap.
            * @param depthMapRegister The texture register containing the depth map.
            * @param decReg The register containing the depth map decoding data.
            * @param targetReg The target register to add the tap comparison result.
            * @param regCache The register cache managing the registers.
            * @return
            */
            DitheredShadowMapMethod.prototype.addSample = function (uvReg, depthMapRegister, decReg, targetReg, regCache) {
                var temp = regCache.getFreeFragmentVectorTemp();
                return "tex " + temp + ", " + uvReg + ", " + depthMapRegister + " <2d,nearest,clamp,mipnone>\n" + "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" + "slt " + temp + ".z, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + temp + ".z\n";
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype.iActivateForCascade = function (vo, stage3DProxy) {
                var data = vo.fragmentData;
                var index = vo.secondaryFragmentConstantsIndex;
                data[index] = 1 / this._numSamples;
                data[index + 1] = (stage3DProxy.width - 1) / 63;
                data[index + 2] = (stage3DProxy.height - 1) / 63;
                data[index + 3] = 2 * this._range / this._depthMapSize;
                stage3DProxy._iContext3D.setTextureAt(vo.texturesIndex + 1, away.materials.DitheredShadowMapMethod._grainTexture.getTextureForStage3D(stage3DProxy));
            };

            /**
            * @inheritDoc
            */
            DitheredShadowMapMethod.prototype._iGetCascadeFragmentCode = function (vo, regCache, decodeRegister, depthTexture, depthProjection, targetRegister) {
                this._pDepthMapCoordReg = depthProjection;

                var dataReg = regCache.getFreeFragmentConstant();
                vo.secondaryFragmentConstantsIndex = dataReg.index * 4;

                return this.getSampleCode(regCache, dataReg, depthTexture, decodeRegister, targetRegister);
            };
            return DitheredShadowMapMethod;
        })(materials.SimpleShadowMapMethodBase);
        materials.DitheredShadowMapMethod = DitheredShadowMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        //import away3d.*;
        //import away3d.textures.*;
        //import flash.display.*;
        //import flash.geom.*;
        //use namespace arcane;
        /**
        * TextureMaterial is a single-pass material that uses a texture to define the surface's diffuse reflection colour (albedo).
        */
        var TextureMaterial = (function (_super) {
            __extends(TextureMaterial, _super);
            /**
            * Creates a new TextureMaterial.
            * @param texture The texture used for the material's albedo color.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to true.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to true.
            */
            function TextureMaterial(texture, smooth, repeat, mipmap) {
                if (typeof texture === "undefined") { texture = null; }
                if (typeof smooth === "undefined") { smooth = true; }
                if (typeof repeat === "undefined") { repeat = false; }
                if (typeof mipmap === "undefined") { mipmap = false; }
                _super.call(this);

                this.texture = texture;

                this.smooth = smooth;
                this.repeat = repeat;
                this.mipmap = mipmap;
            }
            Object.defineProperty(TextureMaterial.prototype, "animateUVs", {
                get: /**
                * Specifies whether or not the UV coordinates should be animated using IRenderable's uvTransform matrix.
                *
                * @see IRenderable.uvTransform
                */
                function () {
                    return this._pScreenPass.animateUVs;
                },
                set: function (value) {
                    this._pScreenPass.animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "alpha", {
                get: /**
                * The alpha of the surface.
                */
                function () {
                    return this._pScreenPass.colorTransform ? this._pScreenPass.colorTransform.alphaMultiplier : 1;
                },
                set: function (value) {
                    if (value > 1)
                        value = 1;
else if (value < 0)
                        value = 0;

                    if (this.colorTransform == null) {
                        //colorTransform ||= new ColorTransform();
                        this.colorTransform = new away.geom.ColorTransform();
                    }

                    this.colorTransform.alphaMultiplier = value;

                    this._pScreenPass.preserveAlpha = this.getRequiresBlending();

                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.display.BlendMode.NORMAL && this.getRequiresBlending() ? away.display.BlendMode.LAYER : this.getBlendMode());
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "texture", {
                get: /**
                * The texture object to use for the albedo colour.
                */
                function () {
                    return this._pScreenPass.diffuseMethod.texture;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(TextureMaterial.prototype, "ambientTexture", {
                get: /**
                * The texture object to use for the ambient colour.
                */
                function () {
                    return this._pScreenPass.ambientMethod.texture;
                },
                set: function (value) {
                    this._pScreenPass.ambientMethod.texture = value;
                    this._pScreenPass.diffuseMethod.iUseAmbientTexture = !(value == null);
                },
                enumerable: true,
                configurable: true
            });

            return TextureMaterial;
        })(away.materials.SinglePassMaterialBase);
        materials.TextureMaterial = TextureMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * LightPickerBase provides an abstract base clase for light picker classes. These classes are responsible for
        * feeding materials with relevant lights. Usually, StaticLightPicker can be used, but LightPickerBase can be
        * extended to provide more application-specific dynamic selection of lights.
        *
        * @see StaticLightPicker
        */
        var LightPickerBase = (function (_super) {
            __extends(LightPickerBase, _super);
            /**
            * Creates a new LightPickerBase object.
            */
            function LightPickerBase() {
                _super.call(this);
                this._pNumPointLights = 0;
                this._pNumDirectionalLights = 0;
                this._pNumCastingPointLights = 0;
                this._pNumCastingDirectionalLights = 0;
                this._pNumLightProbes = 0;
            }
            /**
            * Disposes resources used by the light picker.
            */
            LightPickerBase.prototype.dispose = function () {
            };

            Object.defineProperty(LightPickerBase.prototype, "assetType", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return away.library.AssetType.LIGHT_PICKER;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
                get: /**
                * The maximum amount of directional lights that will be provided.
                */
                function () {
                    return this._pNumDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
                get: /**
                * The maximum amount of point lights that will be provided.
                */
                function () {
                    return this._pNumPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numCastingDirectionalLights", {
                get: /**
                * The maximum amount of directional lights that cast shadows.
                */
                function () {
                    return this._pNumCastingDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numCastingPointLights", {
                get: /**
                * The amount of point lights that cast shadows.
                */
                function () {
                    return this._pNumCastingPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "numLightProbes", {
                get: /**
                * The maximum amount of light probes that will be provided.
                */
                function () {
                    return this._pNumLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "pointLights", {
                get: /**
                * The collected point lights to be used for shading.
                */
                function () {
                    return this._pPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
                get: /**
                * The collected directional lights to be used for shading.
                */
                function () {
                    return this._pDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "castingPointLights", {
                get: /**
                * The collected point lights that cast shadows to be used for shading.
                */
                function () {
                    return this._pCastingPointLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "castingDirectionalLights", {
                get: /**
                * The collected directional lights that cast shadows to be used for shading.
                */
                function () {
                    return this._pCastingDirectionalLights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "lightProbes", {
                get: /**
                * The collected light probes to be used for shading.
                */
                function () {
                    return this._pLightProbes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "lightProbeWeights", {
                get: /**
                * The weights for each light probe, defining their influence on the object.
                */
                function () {
                    return this._pLightProbeWeights;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
                get: /**
                * A collection of all the collected lights.
                */
                function () {
                    return this._pAllPickedLights;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Updates set of lights for a given renderable and EntityCollector. Always call super.collectLights() after custom overridden code.
            */
            LightPickerBase.prototype.collectLights = function (renderable, entityCollector) {
                this.updateProbeWeights(renderable);
            };

            /**
            * Updates the weights for the light probes, based on the renderable's position relative to them.
            * @param renderable The renderble for which to calculate the light probes' influence.
            */
            LightPickerBase.prototype.updateProbeWeights = function (renderable) {
                // todo: this will cause the same calculations to occur per SubMesh. See if this can be improved.
                var objectPos = renderable.sourceEntity.scenePosition;
                var lightPos;

                var rx = objectPos.x, ry = objectPos.y, rz = objectPos.z;
                var dx, dy, dz;
                var w, total = 0;
                var i;

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    lightPos = this._pLightProbes[i].scenePosition;
                    dx = rx - lightPos.x;
                    dy = ry - lightPos.y;
                    dz = rz - lightPos.z;

                    // weight is inversely proportional to square of distance
                    w = dx * dx + dy * dy + dz * dz;

                    // just... huge if at the same spot
                    w = w > .00001 ? 1 / w : 50000000;
                    this._pLightProbeWeights[i] = w;
                    total += w;
                }

                // normalize
                total = 1 / total;

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    this._pLightProbeWeights[i] *= total;
                }
            };
            return LightPickerBase;
        })(away.library.NamedAssetBase);
        materials.LightPickerBase = LightPickerBase;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import flash.events.Event;
        //import away3d.events.LightEvent;
        //import away3d.lights.DirectionalLight;
        //import away3d.lights.LightBase;
        //import away3d.lights.LightProbe;
        //import away3d.lights.PointLight;
        /**
        * StaticLightPicker is a light picker that provides a static set of lights. The lights can be reassigned, but
        * if the configuration changes (number of directional lights, point lights, etc), a material recompilation may
        * occur.
        */
        var StaticLightPicker = (function (_super) {
            __extends(StaticLightPicker, _super);
            /**
            * Creates a new StaticLightPicker object.
            * @param lights The lights to be used for shading.
            */
            function StaticLightPicker(lights) {
                _super.call(this);
                this.lights = lights;
            }
            Object.defineProperty(StaticLightPicker.prototype, "lights", {
                get: /**
                * The lights used for shading.
                */
                function () {
                    return this._lights;
                },
                set: function (value) {
                    var numPointLights = 0;
                    var numDirectionalLights = 0;
                    var numCastingPointLights = 0;
                    var numCastingDirectionalLights = 0;
                    var numLightProbes = 0;
                    var light;

                    if (this._lights)
                        this.clearListeners();

                    this._lights = value;
                    this._pAllPickedLights = value;
                    this._pPointLights = new Array();
                    this._pCastingPointLights = new Array();
                    this._pDirectionalLights = new Array();
                    this._pCastingDirectionalLights = new Array();
                    this._pLightProbes = new Array();

                    var len = value.length;

                    for (var i = 0; i < len; ++i) {
                        light = value[i];
                        light.addEventListener(away.events.LightEvent.CASTS_SHADOW_CHANGE, this.onCastShadowChange, this);

                        if (light instanceof away.lights.PointLight) {
                            if (light.castsShadows)
                                this._pCastingPointLights[numCastingPointLights++] = light;
else
                                this._pPointLights[numPointLights++] = light;
                        } else if (light instanceof away.lights.DirectionalLight) {
                            if (light.castsShadows)
                                this._pCastingDirectionalLights[numCastingDirectionalLights++] = light;
else
                                this._pDirectionalLights[numDirectionalLights++] = light;
                        } else if (light instanceof away.lights.LightProbe) {
                            this._pLightProbes[numLightProbes++] = light;
                        }
                    }

                    if (this._pNumDirectionalLights == numDirectionalLights && this._pNumPointLights == numPointLights && this._pNumLightProbes == numLightProbes && this._pNumCastingPointLights == numCastingPointLights && this._pNumCastingDirectionalLights == numCastingDirectionalLights) {
                        return;
                    }

                    this._pNumDirectionalLights = numDirectionalLights;
                    this._pNumCastingDirectionalLights = numCastingDirectionalLights;
                    this._pNumPointLights = numPointLights;
                    this._pNumCastingPointLights = numCastingPointLights;
                    this._pNumLightProbes = numLightProbes;

                    // MUST HAVE MULTIPLE OF 4 ELEMENTS!
                    this._pLightProbeWeights = new Array(Math.ceil(numLightProbes / 4) * 4);

                    // notify material lights have changed
                    this.dispatchEvent(new away.events.Event(away.events.Event.CHANGE));
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Remove configuration change listeners on the lights.
            */
            StaticLightPicker.prototype.clearListeners = function () {
                var len = this._lights.length;
                for (var i = 0; i < len; ++i)
                    this._lights[i].removeEventListener(away.events.LightEvent.CASTS_SHADOW_CHANGE, this.onCastShadowChange, this);
            };

            /**
            * Notifies the material of a configuration change.
            */
            StaticLightPicker.prototype.onCastShadowChange = function (event) {
                // TODO: Assign to special caster collections, just append it to the lights in SinglePass
                // But keep seperated in multipass
                var light = event.target;

                if (light instanceof away.lights.PointLight) {
                    var pl = light;
                    this.updatePointCasting(pl);
                } else if (light instanceof away.lights.DirectionalLight) {
                    var dl = light;
                    this.updateDirectionalCasting(dl);
                }

                this.dispatchEvent(new away.events.Event(away.events.Event.CHANGE));
            };

            /**
            * Called when a directional light's shadow casting configuration changes.
            */
            StaticLightPicker.prototype.updateDirectionalCasting = function (light) {
                var dl = light;

                if (light.castsShadows) {
                    --this._pNumDirectionalLights;
                    ++this._pNumCastingDirectionalLights;

                    this._pDirectionalLights.splice(this._pDirectionalLights.indexOf(dl), 1);
                    this._pCastingDirectionalLights.push(light);
                } else {
                    ++this._pNumDirectionalLights;
                    --this._pNumCastingDirectionalLights;

                    this._pCastingDirectionalLights.splice(this._pCastingDirectionalLights.indexOf(dl), 1);
                    this._pDirectionalLights.push(light);
                }
            };

            /**
            * Called when a point light's shadow casting configuration changes.
            */
            StaticLightPicker.prototype.updatePointCasting = function (light) {
                var pl = light;

                if (light.castsShadows) {
                    --this._pNumPointLights;
                    ++this._pNumCastingPointLights;
                    this._pPointLights.splice(this._pPointLights.indexOf(pl), 1);
                    this._pCastingPointLights.push(light);
                } else {
                    ++this._pNumPointLights;
                    --this._pNumCastingPointLights;

                    this._pCastingPointLights.splice(this._pCastingPointLights.indexOf(pl), 1);
                    this._pPointLights.push(light);
                }
            };
            return StaticLightPicker;
        })(materials.LightPickerBase);
        materials.StaticLightPicker = StaticLightPicker;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShaderRegister Cache provides the usage management system for all registers during shading compilation.
        */
        var ShaderRegisterCache = (function () {
            /**
            * Create a new ShaderRegisterCache object.
            *
            * @param profile The compatibility profile used by the renderer.
            */
            function ShaderRegisterCache(profile) {
                this._numUsedVertexConstants = 0;
                this._numUsedFragmentConstants = 0;
                this._numUsedStreams = 0;
                this._numUsedTextures = 0;
                this._numUsedVaryings = 0;
                this._profile = profile;
            }
            /**
            * Resets all registers.
            */
            ShaderRegisterCache.prototype.reset = function () {
                //TODO: AGAL <> GLSL Conversion
                this._fragmentTempCache = new materials.RegisterPool("ft", 8, false);
                this._vertexTempCache = new materials.RegisterPool("vt", 8, false);
                this._varyingCache = new materials.RegisterPool("v", 8);
                this._textureCache = new materials.RegisterPool("fs", 8);
                this._vertexAttributesCache = new materials.RegisterPool("va", 8);
                this._fragmentConstantsCache = new materials.RegisterPool("fc", 28);
                this._vertexConstantsCache = new materials.RegisterPool("vc", 128);
                this._fragmentOutputRegister = new materials.ShaderRegisterElement("oc", -1);
                this._vertexOutputRegister = new materials.ShaderRegisterElement("op", -1);
                this._numUsedVertexConstants = 0;
                this._numUsedStreams = 0;
                this._numUsedTextures = 0;
                this._numUsedVaryings = 0;
                this._numUsedFragmentConstants = 0;

                var i;

                for (i = 0; i < this._vertexAttributesOffset; ++i)
                    this.getFreeVertexAttribute();

                for (i = 0; i < this._vertexConstantOffset; ++i)
                    this.getFreeVertexConstant();

                for (i = 0; i < this._varyingsOffset; ++i)
                    this.getFreeVarying();

                for (i = 0; i < this._fragmentConstantOffset; ++i)
                    this.getFreeFragmentConstant();
            };

            /**
            * Disposes all resources used.
            */
            ShaderRegisterCache.prototype.dispose = function () {
                this._fragmentTempCache.dispose();
                this._vertexTempCache.dispose();
                this._varyingCache.dispose();
                this._fragmentConstantsCache.dispose();
                this._vertexAttributesCache.dispose();

                this._fragmentTempCache = null;
                this._vertexTempCache = null;
                this._varyingCache = null;
                this._fragmentConstantsCache = null;
                this._vertexAttributesCache = null;
                this._fragmentOutputRegister = null;
                this._vertexOutputRegister = null;
            };

            /**
            * Marks a fragment temporary register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            ShaderRegisterCache.prototype.addFragmentTempUsages = function (register, usageCount) {
                this._fragmentTempCache.addUsage(register, usageCount);
            };

            /**
            * Removes a usage from a fragment temporary register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            ShaderRegisterCache.prototype.removeFragmentTempUsage = function (register) {
                this._fragmentTempCache.removeUsage(register);
            };

            /**
            * Marks a vertex temporary register as used, so it cannot be retrieved. The register won't be able to be used
            * until removeUsage has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            ShaderRegisterCache.prototype.addVertexTempUsages = function (register, usageCount) {
                this._vertexTempCache.addUsage(register, usageCount);
            };

            /**
            * Removes a usage from a vertex temporary register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            ShaderRegisterCache.prototype.removeVertexTempUsage = function (register) {
                this._vertexTempCache.removeUsage(register);
            };

            /**
            * Retrieve an entire fragment temporary register that's still available. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            */
            ShaderRegisterCache.prototype.getFreeFragmentVectorTemp = function () {
                return this._fragmentTempCache.requestFreeVectorReg();
            };

            /**
            * Retrieve a single component from a fragment temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeFragmentSingleTemp = function () {
                return this._fragmentTempCache.requestFreeRegComponent();
            };

            /**
            * Retrieve an available varying register
            */
            ShaderRegisterCache.prototype.getFreeVarying = function () {
                ++this._numUsedVaryings;
                return this._varyingCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available fragment constant register
            */
            ShaderRegisterCache.prototype.getFreeFragmentConstant = function () {
                ++this._numUsedFragmentConstants;
                return this._fragmentConstantsCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available vertex constant register
            */
            ShaderRegisterCache.prototype.getFreeVertexConstant = function () {
                ++this._numUsedVertexConstants;
                return this._vertexConstantsCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an entire vertex temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeVertexVectorTemp = function () {
                return this._vertexTempCache.requestFreeVectorReg();
            };

            /**
            * Retrieve a single component from a vertex temporary register that's still available.
            */
            ShaderRegisterCache.prototype.getFreeVertexSingleTemp = function () {
                return this._vertexTempCache.requestFreeRegComponent();
            };

            /**
            * Retrieve an available vertex attribute register
            */
            ShaderRegisterCache.prototype.getFreeVertexAttribute = function () {
                ++this._numUsedStreams;
                return this._vertexAttributesCache.requestFreeVectorReg();
            };

            /**
            * Retrieve an available texture register
            */
            ShaderRegisterCache.prototype.getFreeTextureReg = function () {
                ++this._numUsedTextures;
                return this._textureCache.requestFreeVectorReg();
            };

            Object.defineProperty(ShaderRegisterCache.prototype, "vertexConstantOffset", {
                get: /**
                * Indicates the start index from which to retrieve vertex constants.
                */
                function () {
                    return this._vertexConstantOffset;
                },
                set: function (vertexConstantOffset) {
                    this._vertexConstantOffset = vertexConstantOffset;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "vertexAttributesOffset", {
                get: /**
                * Indicates the start index from which to retrieve vertex attributes.
                */
                function () {
                    return this._vertexAttributesOffset;
                },
                set: function (value) {
                    this._vertexAttributesOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "varyingsOffset", {
                get: /**
                * Indicates the start index from which to retrieve varying registers.
                */
                function () {
                    return this._varyingsOffset;
                },
                set: function (value) {
                    this._varyingsOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "fragmentConstantOffset", {
                get: /**
                * Indicates the start index from which to retrieve fragment constants.
                */
                function () {
                    return this._fragmentConstantOffset;
                },
                set: function (value) {
                    this._fragmentConstantOffset = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderRegisterCache.prototype, "fragmentOutputRegister", {
                get: /**
                * The fragment output register.
                */
                function () {
                    return this._fragmentOutputRegister;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVertexConstants", {
                get: /**
                * The amount of used vertex constant registers.
                */
                function () {
                    return this._numUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedFragmentConstants", {
                get: /**
                * The amount of used fragment constant registers.
                */
                function () {
                    return this._numUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedStreams", {
                get: /**
                * The amount of used vertex streams.
                */
                function () {
                    return this._numUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedTextures", {
                get: /**
                * The amount of used texture slots.
                */
                function () {
                    return this._numUsedTextures;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVaryings", {
                get: /**
                * The amount of used varying registers.
                */
                function () {
                    return this._numUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });
            return ShaderRegisterCache;
        })();
        materials.ShaderRegisterCache = ShaderRegisterCache;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * A single register element (an entire register or a single register's component) used by the RegisterPool.
        */
        var ShaderRegisterElement = (function () {
            /**
            * Creates a new ShaderRegisterElement object.
            * @param regName The name of the register.
            * @param index The index of the register.
            * @param component The register's component, if not the entire register is represented.
            */
            function ShaderRegisterElement(regName, index, component) {
                if (typeof component === "undefined") { component = -1; }
                this._component = component;
                this._regName = regName;
                this._index = index;

                this._toStr = this._regName;

                if (this._index >= 0) {
                    this._toStr += this._index;
                }

                if (component > -1) {
                    this._toStr += "." + ShaderRegisterElement.COMPONENTS[component];
                }
            }
            /**
            * Converts the register or the components AGAL string representation.
            */
            ShaderRegisterElement.prototype.toString = function () {
                return this._toStr;
            };

            Object.defineProperty(ShaderRegisterElement.prototype, "regName", {
                get: /**
                * The register's name.
                */
                function () {
                    return this._regName;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderRegisterElement.prototype, "index", {
                get: /**
                * The register's index.
                */
                function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            ShaderRegisterElement.COMPONENTS = ["x", "y", "z", "w"];
            return ShaderRegisterElement;
        })();
        materials.ShaderRegisterElement = ShaderRegisterElement;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShaderRegisterData contains the "named" registers, generated by the compiler and to be passed on to the methods.
        */
        var ShaderRegisterData = (function () {
            function ShaderRegisterData() {
            }
            return ShaderRegisterData;
        })();
        materials.ShaderRegisterData = ShaderRegisterData;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.materials.LightSources;
        //import away3d.materials.methods.MethodVO;
        /**
        * MethodDependencyCounter keeps track of the number of dependencies for "named registers" used across methods.
        * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
        * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
        * each time a method has been compiled into the shader.
        *
        * @see RegisterPool.addUsage
        */
        var MethodDependencyCounter = (function () {
            /**
            * Creates a new MethodDependencyCounter object.
            */
            function MethodDependencyCounter() {
                this._usesGlobalPosFragment = false;
            }
            /**
            * Clears dependency counts for all registers. Called when recompiling a pass.
            */
            MethodDependencyCounter.prototype.reset = function () {
                this._projectionDependencies = 0;
                this._normalDependencies = 0;
                this._viewDirDependencies = 0;
                this._uvDependencies = 0;
                this._secondaryUVDependencies = 0;
                this._globalPosDependencies = 0;
                this._tangentDependencies = 0;
                this._usesGlobalPosFragment = false;
            };

            /**
            * Sets the amount of lights that have a position associated with them.
            * @param numPointLights The amount of point lights.
            * @param lightSourceMask The light source types used by the material.
            */
            MethodDependencyCounter.prototype.setPositionedLights = function (numPointLights, lightSourceMask) {
                this._numPointLights = numPointLights;
                this._lightSourceMask = lightSourceMask;
            };

            /**
            * Increases dependency counters for the named registers listed as required by the given MethodVO.
            * @param methodVO the MethodVO object for which to include dependencies.
            */
            MethodDependencyCounter.prototype.includeMethodVO = function (methodVO) {
                if (methodVO.needsProjection) {
                    ++this._projectionDependencies;
                }

                if (methodVO.needsGlobalVertexPos) {
                    ++this._globalPosDependencies;

                    if (methodVO.needsGlobalFragmentPos) {
                        this._usesGlobalPosFragment = true;
                    }
                } else if (methodVO.needsGlobalFragmentPos) {
                    ++this._globalPosDependencies;
                    this._usesGlobalPosFragment = true;
                }

                if (methodVO.needsNormals) {
                    ++this._normalDependencies;
                }

                if (methodVO.needsTangents) {
                    ++this._tangentDependencies;
                }

                if (methodVO.needsView) {
                    ++this._viewDirDependencies;
                }

                if (methodVO.needsUV) {
                    ++this._uvDependencies;
                }

                if (methodVO.needsSecondaryUV) {
                    ++this._secondaryUVDependencies;
                }
            };

            Object.defineProperty(MethodDependencyCounter.prototype, "tangentDependencies", {
                get: /**
                * The amount of tangent vector dependencies (fragment shader).
                */
                function () {
                    return this._tangentDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "usesGlobalPosFragment", {
                get: /**
                * Indicates whether there are any dependencies on the world-space position vector.
                */
                function () {
                    return this._usesGlobalPosFragment;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "projectionDependencies", {
                get: /**
                * The amount of dependencies on the projected position.
                */
                function () {
                    return this._projectionDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "normalDependencies", {
                get: /**
                * The amount of dependencies on the normal vector.
                */
                function () {
                    return this._normalDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "viewDirDependencies", {
                get: /**
                * The amount of dependencies on the view direction.
                */
                function () {
                    return this._viewDirDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "uvDependencies", {
                get: /**
                * The amount of dependencies on the primary UV coordinates.
                */
                function () {
                    return this._uvDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "secondaryUVDependencies", {
                get: /**
                * The amount of dependencies on the secondary UV coordinates.
                */
                function () {
                    return this._secondaryUVDependencies;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(MethodDependencyCounter.prototype, "globalPosDependencies", {
                get: /**
                * The amount of dependencies on the global position. This can be 0 while hasGlobalPosDependencies is true when
                * the global position is used as a temporary value (fe to calculate the view direction)
                */
                function () {
                    return this._globalPosDependencies;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds any external world space dependencies, used to force world space calculations.
            */
            MethodDependencyCounter.prototype.addWorldSpaceDependencies = function (fragmentLights) {
                if (this._viewDirDependencies > 0) {
                    ++this._globalPosDependencies;
                }

                if (this._numPointLights > 0 && (this._lightSourceMask & away.materials.LightSources.LIGHTS)) {
                    ++this._globalPosDependencies;

                    if (fragmentLights) {
                        this._usesGlobalPosFragment = true;
                    }
                }
            };
            return MethodDependencyCounter;
        })();
        materials.MethodDependencyCounter = MethodDependencyCounter;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import flash.utils.Dictionary;
        /**
        * RegisterPool is used by the shader compilation process to keep track of which registers of a certain type are
        * currently used and should not be allowed to be written to. Either entire registers can be requested and locked,
        * or single components (x, y, z, w) of a single register.
        * It is used by ShaderRegisterCache to track usages of individual register types.
        *
        * @see away3d.materials.compilation.ShaderRegisterCache
        */
        var RegisterPool = (function () {
            /**
            * Creates a new RegisterPool object.
            * @param regName The base name of the register type ("ft" for fragment temporaries, "vc" for vertex constants, etc)
            * @param regCount The amount of available registers of this type.
            * @param persistent Whether or not registers, once reserved, can be freed again. For example, temporaries are not persistent, but constants are.
            */
            function RegisterPool(regName, regCount, persistent) {
                if (typeof persistent === "undefined") { persistent = true; }
                this._regName = regName;
                this._regCount = regCount;
                this._persistent = persistent;
                this.initRegisters(regName, regCount);
            }
            /**
            * Retrieve an entire vector register that's still available.
            */
            RegisterPool.prototype.requestFreeVectorReg = function () {
                for (var i = 0; i < this._regCount; ++i) {
                    if (!this.isRegisterUsed(i)) {
                        if (this._persistent)
                            this._usedVectorCount[i]++;

                        return this._vectorRegisters[i];
                    }
                }

                throw new Error("Register overflow!");
            };

            /**
            * Retrieve a single vector component that's still available.
            */
            RegisterPool.prototype.requestFreeRegComponent = function () {
                for (var i = 0; i < this._regCount; ++i) {
                    if (this._usedVectorCount[i] > 0)
                        continue;

                    for (var j = 0; j < 4; ++j) {
                        if (this._usedSingleCount[j][i] == 0) {
                            if (this._persistent) {
                                this._usedSingleCount[j][i]++;
                            }

                            return this._registerComponents[j][i];
                        }
                    }
                }

                throw new Error("Register overflow!");
            };

            /**
            * Marks a register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
            * has been called usageCount times again.
            * @param register The register to mark as used.
            * @param usageCount The amount of usages to add.
            */
            RegisterPool.prototype.addUsage = function (register, usageCount) {
                if (register._component > -1) {
                    this._usedSingleCount[register._component][register.index] += usageCount;
                } else {
                    this._usedVectorCount[register.index] += usageCount;
                }
            };

            /**
            * Removes a usage from a register. When usages reach 0, the register is freed again.
            * @param register The register for which to remove a usage.
            */
            RegisterPool.prototype.removeUsage = function (register) {
                if (register._component > -1) {
                    if (--this._usedSingleCount[register._component][register.index] < 0) {
                        throw new Error("More usages removed than exist!");
                    }
                } else {
                    if (--this._usedVectorCount[register.index] < 0) {
                        throw new Error("More usages removed than exist!");
                    }
                }
            };

            /**
            * Disposes any resources used by the current RegisterPool object.
            */
            RegisterPool.prototype.dispose = function () {
                this._vectorRegisters = null;
                this._registerComponents = null;
                this._usedSingleCount = null;
                this._usedVectorCount = null;
            };

            /**
            * Indicates whether or not any registers are in use.
            */
            RegisterPool.prototype.hasRegisteredRegs = function () {
                for (var i = 0; i < this._regCount; ++i) {
                    if (this.isRegisterUsed(i))
                        return true;
                }

                return false;
            };

            /**
            * Initializes all registers.
            */
            RegisterPool.prototype.initRegisters = function (regName, regCount) {
                var hash = RegisterPool._initPool(regName, regCount);

                this._vectorRegisters = RegisterPool._regPool[hash];
                this._registerComponents = RegisterPool._regCompsPool[hash];

                this._usedVectorCount = this._initArray(Array(regCount), 0);

                this._usedSingleCount = new Array(4);
                this._usedSingleCount[0] = this._initArray(new Array(regCount), 0);
                this._usedSingleCount[1] = this._initArray(new Array(regCount), 0);
                this._usedSingleCount[2] = this._initArray(new Array(regCount), 0);
                this._usedSingleCount[3] = this._initArray(new Array(regCount), 0);
                //console.log( 'this._usedVectorCount: ' , this._usedVectorCount );
                //console.log( 'this._usedSingleCount: ' , this._usedSingleCount );
            };

            RegisterPool._initPool = function (regName, regCount) {
                var hash = regName + regCount;

                if (RegisterPool._regPool[hash] != undefined) {
                    return hash;
                }

                var vectorRegisters = new Array(regCount);
                RegisterPool._regPool[hash] = vectorRegisters;

                var registerComponents = [
                    [],
                    [],
                    [],
                    []
                ];
                RegisterPool._regCompsPool[hash] = registerComponents;

                for (var i = 0; i < regCount; ++i) {
                    vectorRegisters[i] = new away.materials.ShaderRegisterElement(regName, i);

                    for (var j = 0; j < 4; ++j) {
                        registerComponents[j][i] = new away.materials.ShaderRegisterElement(regName, i, j);
                    }
                }

                //console.log ( 'RegisterPool._regCompsPool[hash] : ' , RegisterPool._regCompsPool[hash]  );
                //console.log ( 'RegisterPool._regPool[hash] : ' , RegisterPool._regPool[hash]  );
                return hash;
            };

            /**
            * Check if the temp register is either used for single or vector use
            */
            RegisterPool.prototype.isRegisterUsed = function (index) {
                if (this._usedVectorCount[index] > 0) {
                    return true;
                }

                for (var i = 0; i < 4; ++i) {
                    if (this._usedSingleCount[i][index] > 0) {
                        return true;
                    }
                }

                return false;
            };

            RegisterPool.prototype._initArray = function (a, val) {
                var l = a.length;

                for (var c = 0; c < l; c++) {
                    a[c] = val;
                }

                return a;
            };
            RegisterPool._regPool = new Object();
            RegisterPool._regCompsPool = new Object();
            return RegisterPool;
        })();
        materials.RegisterPool = RegisterPool;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * ShaderCompiler is an abstract base class for shader compilers that use modular shader methods to assemble a
        * material. Concrete subclasses are used by the default materials.
        *
        * @see away3d.materials.methods.ShadingMethodBase
        */
        var ShaderCompiler = (function () {
            /**
            * Creates a new ShaderCompiler object.
            * @param profile The compatibility profile of the renderer.
            */
            function ShaderCompiler(profile) {
                this._preserveAlpha = true;
                this._pVertexCode = '';
                this._pFragmentCode = '';
                this._commonsDataIndex = -1;
                this._uvBufferIndex = -1;
                this._uvTransformIndex = -1;
                this._secondaryUVBufferIndex = -1;
                this._pNormalBufferIndex = -1;
                this._pTangentBufferIndex = -1;
                this._pLightFragmentConstantIndex = -1;
                this._sceneMatrixIndex = -1;
                this._pSceneNormalMatrixIndex = -1;
                this._pCameraPositionIndex = -1;
                this._pProbeWeightsIndex = -1;
                this._pSharedRegisters = new away.materials.ShaderRegisterData();
                this._pDependencyCounter = new away.materials.MethodDependencyCounter();
                this._pProfile = profile;
                this.initRegisterCache(profile);
            }
            Object.defineProperty(ShaderCompiler.prototype, "enableLightFallOff", {
                get: /**
                * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
                * compatibility for constrained mode.
                */
                function () {
                    return this._pEnableLightFallOff;
                },
                set: function (value) {
                    this._pEnableLightFallOff = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "needUVAnimation", {
                get: /**
                * Indicates whether the compiled code needs UV animation.
                */
                function () {
                    return this._needUVAnimation;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "UVTarget", {
                get: /**
                * The target register to place the animated UV coordinate.
                */
                function () {
                    return this._UVTarget;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "UVSource", {
                get: /**
                * The souce register providing the UV coordinate to animate.
                */
                function () {
                    return this._UVSource;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "forceSeperateMVP", {
                get: /**
                * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
                * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
                * projection code.
                */
                function () {
                    return this._forceSeperateMVP;
                },
                set: function (value) {
                    this._forceSeperateMVP = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Initialized the register cache.
            * @param profile The compatibility profile of the renderer.
            */
            ShaderCompiler.prototype.initRegisterCache = function (profile) {
                this._pRegisterCache = new away.materials.ShaderRegisterCache(profile);
                this._pRegisterCache.vertexAttributesOffset = 1;
                this._pRegisterCache.reset();
            };

            Object.defineProperty(ShaderCompiler.prototype, "animateUVs", {
                get: /**
                * Indicate whether UV coordinates need to be animated using the renderable's transformUV matrix.
                */
                function () {
                    return this._animateUVs;
                },
                set: function (value) {
                    this._animateUVs = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "alphaPremultiplied", {
                get: /**
                * Indicates whether visible textures (or other pixels) used by this material have
                * already been premultiplied.
                */
                function () {
                    return this._pAlphaPremultiplied;
                },
                set: function (value) {
                    this._pAlphaPremultiplied = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "preserveAlpha", {
                get: /**
                * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
                */
                function () {
                    return this._preserveAlpha;
                },
                set: function (value) {
                    this._preserveAlpha = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Sets the default texture sampling properties.
            * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.
            * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to true.
            * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to true.
            */
            ShaderCompiler.prototype.setTextureSampling = function (smooth, repeat, mipmap) {
                this._smooth = smooth;
                this._repeat = repeat;
                this._mipmap = mipmap;
            };

            /**
            * Sets the constant buffers allocated by the material. This allows setting constant data during compilation.
            * @param vertexConstantData The vertex constant data buffer.
            * @param fragmentConstantData The fragment constant data buffer.
            */
            ShaderCompiler.prototype.setConstantDataBuffers = function (vertexConstantData, fragmentConstantData) {
                this._vertexConstantData = vertexConstantData;
                this._fragmentConstantData = fragmentConstantData;
            };

            Object.defineProperty(ShaderCompiler.prototype, "methodSetup", {
                get: /**
                * The shader method setup object containing the method configuration and their value objects for the material being compiled.
                */
                function () {
                    return this._pMethodSetup;
                },
                set: function (value) {
                    this._pMethodSetup = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Compiles the code after all setup on the compiler has finished.
            */
            ShaderCompiler.prototype.compile = function () {
                this.pInitRegisterIndices();
                this.pInitLightData();

                this._pAnimatableAttributes = new Array("va0");
                this._pAnimationTargetRegisters = new Array("vt0");
                this._pVertexCode = "";
                this._pFragmentCode = "";

                this._pSharedRegisters.localPosition = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.localPosition, 1);

                this.createCommons();
                this.pCalculateDependencies();
                this.updateMethodRegisters();

                for (var i = 0; i < 4; ++i)
                    this._pRegisterCache.getFreeVertexConstant();

                this.pCreateNormalRegisters();

                if (this._pDependencyCounter.globalPosDependencies > 0 || this._forceSeperateMVP)
                    this.pCompileGlobalPositionCode();

                this.compileProjectionCode();
                this.pCompileMethodsCode();
                this.compileFragmentOutput();
                this._fragmentPostLightCode = this.fragmentCode;
            };

            /**
            * Creates the registers to contain the normal data.
            */
            ShaderCompiler.prototype.pCreateNormalRegisters = function () {
            };

            /**
            * Compile the code for the methods.
            */
            ShaderCompiler.prototype.pCompileMethodsCode = function () {
                if (this._pDependencyCounter.uvDependencies > 0)
                    this.compileUVCode();

                if (this._pDependencyCounter.secondaryUVDependencies > 0)
                    this.compileSecondaryUVCode();

                if (this._pDependencyCounter.normalDependencies > 0)
                    this.pCompileNormalCode();

                if (this._pDependencyCounter.viewDirDependencies > 0)
                    this.pCompileViewDirCode();

                this.pCompileLightingCode();
                this._fragmentLightCode = this._pFragmentCode;
                this._pFragmentCode = "";
                this.pCompileMethods();
            };

            /**
            * Compile the lighting code.
            */
            ShaderCompiler.prototype.pCompileLightingCode = function () {
            };

            /**
            * Calculate the view direction.
            */
            ShaderCompiler.prototype.pCompileViewDirCode = function () {
            };

            /**
            * Calculate the normal.
            */
            ShaderCompiler.prototype.pCompileNormalCode = function () {
            };

            /**
            * Calculate the (possibly animated) UV coordinates.
            */
            ShaderCompiler.prototype.compileUVCode = function () {
                var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
                this._uvBufferIndex = uvAttributeReg.index;

                var varying = this._pRegisterCache.getFreeVarying();

                this._pSharedRegisters.uvVarying = varying;

                if (this.animateUVs) {
                    // a, b, 0, tx
                    // c, d, 0, ty
                    var uvTransform1 = this._pRegisterCache.getFreeVertexConstant();
                    var uvTransform2 = this._pRegisterCache.getFreeVertexConstant();
                    this._uvTransformIndex = uvTransform1.index * 4;

                    // TODO: AGAL <> GLSL
                    this._pVertexCode += "dp4 " + varying.toString() + ".x, " + uvAttributeReg.toString() + ", " + uvTransform1.toString() + "\n" + "dp4 " + varying.toString() + ".y, " + uvAttributeReg.toString() + ", " + uvTransform2.toString() + "\n" + "mov " + varying.toString() + ".zw, " + uvAttributeReg.toString() + ".zw \n";
                } else {
                    this._uvTransformIndex = -1;
                    this._needUVAnimation = true;
                    this._UVTarget = varying.toString();
                    this._UVSource = uvAttributeReg.toString();
                }
            };

            /**
            * Provide the secondary UV coordinates.
            */
            ShaderCompiler.prototype.compileSecondaryUVCode = function () {
                // TODO: AGAL <> GLSL
                var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
                this._secondaryUVBufferIndex = uvAttributeReg.index;
                this._pSharedRegisters.secondaryUVVarying = this._pRegisterCache.getFreeVarying();
                this._pVertexCode += "mov " + this._pSharedRegisters.secondaryUVVarying.toString() + ", " + uvAttributeReg.toString() + "\n";
            };

            /**
            * Compile the world-space position.
            */
            ShaderCompiler.prototype.pCompileGlobalPositionCode = function () {
                // TODO: AGAL <> GLSL
                this._pSharedRegisters.globalPositionVertex = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.globalPositionVertex, this._pDependencyCounter.globalPosDependencies);
                var positionMatrixReg = this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._pRegisterCache.getFreeVertexConstant();
                this._sceneMatrixIndex = positionMatrixReg.index * 4;

                this._pVertexCode += "m44 " + this._pSharedRegisters.globalPositionVertex.toString() + ", " + this._pSharedRegisters.localPosition.toString() + ", " + positionMatrixReg.toString() + "\n";

                if (this._pDependencyCounter.usesGlobalPosFragment) {
                    this._pSharedRegisters.globalPositionVarying = this._pRegisterCache.getFreeVarying();
                    this._pVertexCode += "mov " + this._pSharedRegisters.globalPositionVarying.toString() + ", " + this._pSharedRegisters.globalPositionVertex.toString() + "\n";
                }
            };

            /**
            * Get the projection coordinates.
            */
            ShaderCompiler.prototype.compileProjectionCode = function () {
                var pos = this._pDependencyCounter.globalPosDependencies > 0 || this._forceSeperateMVP ? this._pSharedRegisters.globalPositionVertex.toString() : this._pAnimationTargetRegisters[0];
                var code;

                if (this._pDependencyCounter.projectionDependencies > 0) {
                    this._pSharedRegisters.projectionFragment = this._pRegisterCache.getFreeVarying();

                    code = "m44 vt5, " + pos + ", vc0		\n" + "mov " + this._pSharedRegisters.projectionFragment.toString() + ", vt5\n" + "mov op, vt5\n";
                } else {
                    code = "m44 op, " + pos + ", vc0		\n";
                }

                this._pVertexCode += code;
            };

            /**
            * Assign the final output colour the the output register.
            */
            ShaderCompiler.prototype.compileFragmentOutput = function () {
                // TODO: AGAL <> GLSL
                this._pFragmentCode += "mov " + this._pRegisterCache.fragmentOutputRegister.toString() + ", " + this._pSharedRegisters.shadedTarget.toString() + "\n";
                this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.shadedTarget);
            };

            /**
            * Reset all the indices to "unused".
            */
            ShaderCompiler.prototype.pInitRegisterIndices = function () {
                this._commonsDataIndex = -1;
                this._pCameraPositionIndex = -1;
                this._uvBufferIndex = -1;
                this._uvTransformIndex = -1;
                this._secondaryUVBufferIndex = -1;
                this._pNormalBufferIndex = -1;
                this._pTangentBufferIndex = -1;
                this._pLightFragmentConstantIndex = -1;
                this._sceneMatrixIndex = -1;
                this._pSceneNormalMatrixIndex = -1;
                this._pProbeWeightsIndex = -1;
            };

            /**
            * Prepares the setup for the light code.
            */
            ShaderCompiler.prototype.pInitLightData = function () {
                this._pNumLights = this._pNumPointLights + this._pNumDirectionalLights;
                this._pNumProbeRegisters = Math.ceil(this._pNumLightProbes / 4);

                if (this._pMethodSetup._iSpecularMethod) {
                    this._combinedLightSources = this._specularLightSources | this._diffuseLightSources;
                } else {
                    this._combinedLightSources = this._diffuseLightSources;
                }

                this._usingSpecularMethod = Boolean(this._pMethodSetup._iSpecularMethod && (this.pUsesLightsForSpecular() || this.pUsesProbesForSpecular()));
            };

            /**
            * Create the commonly shared constant register.
            */
            ShaderCompiler.prototype.createCommons = function () {
                this._pSharedRegisters.commons = this._pRegisterCache.getFreeFragmentConstant();
                this._commonsDataIndex = this._pSharedRegisters.commons.index * 4;
            };

            /**
            * Figure out which named registers are required, and how often.
            */
            ShaderCompiler.prototype.pCalculateDependencies = function () {
                this._pDependencyCounter.reset();

                var methods = this._pMethodSetup._iMethods;
                var len;

                this.setupAndCountMethodDependencies(this._pMethodSetup._iDiffuseMethod, this._pMethodSetup._iDiffuseMethodVO);

                if (this._pMethodSetup._iShadowMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iShadowMethod, this._pMethodSetup._iShadowMethodVO);

                this.setupAndCountMethodDependencies(this._pMethodSetup._iAmbientMethod, this._pMethodSetup._iAmbientMethodVO);

                if (this._usingSpecularMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iSpecularMethod, this._pMethodSetup._iSpecularMethodVO);

                if (this._pMethodSetup._iColorTransformMethod)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iColorTransformMethod, this._pMethodSetup._iColorTransformMethodVO);

                len = methods.length;

                for (var i = 0; i < len; ++i)
                    this.setupAndCountMethodDependencies(methods[i].method, methods[i].data);

                if (this.usesNormals)
                    this.setupAndCountMethodDependencies(this._pMethodSetup._iNormalMethod, this._pMethodSetup._iNormalMethodVO);

                // todo: add spotlights to count check
                this._pDependencyCounter.setPositionedLights(this._pNumPointLights, this._combinedLightSources);
            };

            /**
            * Counts the dependencies for a given method.
            * @param method The method to count the dependencies for.
            * @param methodVO The method's data for this material.
            */
            ShaderCompiler.prototype.setupAndCountMethodDependencies = function (method, methodVO) {
                this.setupMethod(method, methodVO);
                this._pDependencyCounter.includeMethodVO(methodVO);
            };

            /**
            * Assigns all prerequisite data for the methods, so we can calculate dependencies for them.
            */
            ShaderCompiler.prototype.setupMethod = function (method, methodVO) {
                method.iReset();
                methodVO.reset();

                methodVO.vertexData = this._vertexConstantData;
                methodVO.fragmentData = this._fragmentConstantData;
                methodVO.useSmoothTextures = this._smooth;
                methodVO.repeatTextures = this._repeat;
                methodVO.useMipmapping = this._mipmap;
                methodVO.useLightFallOff = this._pEnableLightFallOff && this._pProfile != "baselineConstrained";
                methodVO.numLights = this._pNumLights + this._pNumLightProbes;

                method.iInitVO(methodVO);
            };

            Object.defineProperty(ShaderCompiler.prototype, "commonsDataIndex", {
                get: /**
                * The index for the common data register.
                */
                function () {
                    return this._commonsDataIndex;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Assigns the shared register data to all methods.
            */
            ShaderCompiler.prototype.updateMethodRegisters = function () {
                this._pMethodSetup._iNormalMethod.iSharedRegisters = this._pSharedRegisters;
                this._pMethodSetup._iDiffuseMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iSharedRegisters = this._pSharedRegisters;

                this._pMethodSetup._iAmbientMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iSharedRegisters = this._pSharedRegisters;

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iSharedRegisters = this._pSharedRegisters;

                var methods = this._pMethodSetup._iMethods;

                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iSharedRegisters = this._pSharedRegisters;
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "numUsedVertexConstants", {
                get: /**
                * The amount of vertex constants used by the material. Any animation code to be added can append its vertex
                * constant data after this.
                */
                function () {
                    return this._pRegisterCache.numUsedVertexConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedFragmentConstants", {
                get: /**
                * The amount of fragment constants used by the material. Any animation code to be added can append its vertex
                * constant data after this.
                */
                function () {
                    return this._pRegisterCache.numUsedFragmentConstants;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedStreams", {
                get: /**
                * The amount of vertex attribute streams used by the material. Any animation code to be added can add its
                * streams after this. Also used to automatically disable attribute slots on pass deactivation.
                */
                function () {
                    return this._pRegisterCache.numUsedStreams;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedTextures", {
                get: /**
                * The amount of textures used by the material. Used to automatically disable texture slots on pass deactivation.
                */
                function () {
                    return this._pRegisterCache.numUsedTextures;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numUsedVaryings", {
                get: /**
                * Number of used varyings. Any animation code to be added can add its used varyings after this.
                */
                function () {
                    return this._pRegisterCache.numUsedVaryings;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates whether lights are used for specular reflections.
            */
            ShaderCompiler.prototype.pUsesLightsForSpecular = function () {
                return this._pNumLights > 0 && (this._specularLightSources & away.materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Indicates whether lights are used for diffuse reflections.
            */
            ShaderCompiler.prototype.pUsesLightsForDiffuse = function () {
                return this._pNumLights > 0 && (this._diffuseLightSources & away.materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Disposes all resources used by the compiler.
            */
            ShaderCompiler.prototype.dispose = function () {
                this.cleanUpMethods();
                this._pRegisterCache.dispose();
                this._pRegisterCache = null;
                this._pSharedRegisters = null;
            };

            /**
            * Clean up method's compilation data after compilation finished.
            */
            ShaderCompiler.prototype.cleanUpMethods = function () {
                if (this._pMethodSetup._iNormalMethod)
                    this._pMethodSetup._iNormalMethod.iCleanCompilationData();

                if (this._pMethodSetup._iDiffuseMethod)
                    this._pMethodSetup._iDiffuseMethod.iCleanCompilationData();

                if (this._pMethodSetup._iAmbientMethod)
                    this._pMethodSetup._iAmbientMethod.iCleanCompilationData();

                if (this._pMethodSetup._iSpecularMethod)
                    this._pMethodSetup._iSpecularMethod.iCleanCompilationData();

                if (this._pMethodSetup._iShadowMethod)
                    this._pMethodSetup._iShadowMethod.iCleanCompilationData();

                if (this._pMethodSetup._iColorTransformMethod)
                    this._pMethodSetup._iColorTransformMethod.iCleanCompilationData();

                var methods = this._pMethodSetup._iMethods;

                var len = methods.length;

                for (var i = 0; i < len; ++i) {
                    methods[i].method.iCleanCompilationData();
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "specularLightSources", {
                get: /**
                * Define which light source types to use for specular reflections. This allows choosing between regular lights
                * and/or light probes for specular reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._specularLightSources;
                },
                set: function (value) {
                    this._specularLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "diffuseLightSources", {
                get: /**
                * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
                * and/or light probes for diffuse reflections.
                *
                * @see away3d.materials.LightSources
                */
                function () {
                    return this._diffuseLightSources;
                },
                set: function (value) {
                    this._diffuseLightSources = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Indicates whether light probes are being used for specular reflections.
            */
            ShaderCompiler.prototype.pUsesProbesForSpecular = function () {
                return this._pNumLightProbes > 0 && (this._specularLightSources & away.materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether light probes are being used for diffuse reflections.
            */
            ShaderCompiler.prototype.pUsesProbesForDiffuse = function () {
                return this._pNumLightProbes > 0 && (this._diffuseLightSources & away.materials.LightSources.PROBES) != 0;
            };

            /**
            * Indicates whether any light probes are used.
            */
            ShaderCompiler.prototype.pUsesProbes = function () {
                return this._pNumLightProbes > 0 && ((this._diffuseLightSources | this._specularLightSources) & away.materials.LightSources.PROBES) != 0;
            };

            Object.defineProperty(ShaderCompiler.prototype, "uvBufferIndex", {
                get: /**
                * The index for the UV vertex attribute stream.
                */
                function () {
                    return this._uvBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "uvTransformIndex", {
                get: /**
                * The index for the UV transformation matrix vertex constant.
                */
                function () {
                    return this._uvTransformIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "secondaryUVBufferIndex", {
                get: /**
                * The index for the secondary UV vertex attribute stream.
                */
                function () {
                    return this._secondaryUVBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "normalBufferIndex", {
                get: /**
                * The index for the vertex normal attribute stream.
                */
                function () {
                    return this._pNormalBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "tangentBufferIndex", {
                get: /**
                * The index for the vertex tangent attribute stream.
                */
                function () {
                    return this._pTangentBufferIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "lightFragmentConstantIndex", {
                get: /**
                * The first index for the fragment constants containing the light data.
                */
                function () {
                    return this._pLightFragmentConstantIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "cameraPositionIndex", {
                get: /**
                * The index of the vertex constant containing the camera position.
                */
                function () {
                    return this._pCameraPositionIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "sceneMatrixIndex", {
                get: /**
                * The index of the vertex constant containing the scene matrix.
                */
                function () {
                    return this._sceneMatrixIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "sceneNormalMatrixIndex", {
                get: /**
                * The index of the vertex constant containing the uniform scene matrix (the inverse transpose).
                */
                function () {
                    return this._pSceneNormalMatrixIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "probeWeightsIndex", {
                get: /**
                * The index of the fragment constant containing the weights for the light probes.
                */
                function () {
                    return this._pProbeWeightsIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "vertexCode", {
                get: /**
                * The generated vertex code.
                */
                function () {
                    return this._pVertexCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentCode", {
                get: /**
                * The generated fragment code.
                */
                function () {
                    return this._pFragmentCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentLightCode", {
                get: /**
                * The code containing the lighting calculations.
                */
                function () {
                    return this._fragmentLightCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "fragmentPostLightCode", {
                get: /**
                * The code containing the post-lighting calculations.
                */
                function () {
                    return this._fragmentPostLightCode;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "shadedTarget", {
                get: /**
                * The register name containing the final shaded colour.
                */
                function () {
                    return this._pSharedRegisters.shadedTarget.toString();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "numPointLights", {
                get: /**
                * The amount of point lights that need to be supported.
                */
                function () {
                    return this._pNumPointLights;
                },
                set: function (numPointLights) {
                    this._pNumPointLights = numPointLights;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "numDirectionalLights", {
                get: /**
                * The amount of directional lights that need to be supported.
                */
                function () {
                    return this._pNumDirectionalLights;
                },
                set: function (value) {
                    this._pNumDirectionalLights = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "numLightProbes", {
                get: /**
                * The amount of light probes that need to be supported.
                */
                function () {
                    return this._pNumLightProbes;
                },
                set: function (value) {
                    this._pNumLightProbes = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ShaderCompiler.prototype, "usingSpecularMethod", {
                get: /**
                * Indicates whether the specular method is used.
                */
                function () {
                    return this._usingSpecularMethod;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "animatableAttributes", {
                get: /**
                * The attributes that need to be animated by animators.
                */
                function () {
                    return this._pAnimatableAttributes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "animationTargetRegisters", {
                get: /**
                * The target registers for animated properties, written to by the animators.
                */
                function () {
                    return this._pAnimationTargetRegisters;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "usesNormals", {
                get: /**
                * Indicates whether the compiled shader uses normals.
                */
                function () {
                    return this._pDependencyCounter.normalDependencies > 0 && this._pMethodSetup._iNormalMethod.iHasOutput;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates whether the compiled shader uses lights.
            */
            ShaderCompiler.prototype.pUsesLights = function () {
                return this._pNumLights > 0 && (this._combinedLightSources & away.materials.LightSources.LIGHTS) != 0;
            };

            /**
            * Compiles the code for the methods.
            */
            ShaderCompiler.prototype.pCompileMethods = function () {
                var methods = this._pMethodSetup._iMethods;

                var numMethods = methods.length;
                var method;
                var data;
                var alphaReg;

                if (this._preserveAlpha) {
                    alphaReg = this._pRegisterCache.getFreeFragmentSingleTemp();
                    this._pRegisterCache.addFragmentTempUsages(alphaReg, 1);
                    this._pFragmentCode += "mov " + alphaReg.toString() + ", " + this._pSharedRegisters.shadedTarget.toString() + ".w\n";
                }

                for (var i = 0; i < numMethods; ++i) {
                    method = methods[i].method;
                    data = methods[i].data;

                    this._pVertexCode += method.iGetVertexCode(data, this._pRegisterCache);

                    if (data.needsGlobalVertexPos || data.needsGlobalFragmentPos)
                        this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);

                    this._pFragmentCode += method.iGetFragmentCode(data, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                    if (data.needsNormals)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);

                    if (data.needsView)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._preserveAlpha) {
                    this._pFragmentCode += "mov " + this._pSharedRegisters.shadedTarget.toString() + ".w, " + alphaReg.toString() + "\n";

                    this._pRegisterCache.removeFragmentTempUsage(alphaReg);
                }

                if (this._pMethodSetup._iColorTransformMethod) {
                    this._pVertexCode += this._pMethodSetup._iColorTransformMethod.iGetVertexCode(this._pMethodSetup._iColorTransformMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iColorTransformMethod.iGetFragmentCode(this._pMethodSetup._iColorTransformMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);
                }
            };

            Object.defineProperty(ShaderCompiler.prototype, "lightProbeDiffuseIndices", {
                get: /**
                * Indices for the light probe diffuse textures.
                */
                function () {
                    return this._pLightProbeDiffuseIndices;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(ShaderCompiler.prototype, "lightProbeSpecularIndices", {
                get: /**
                * Indices for the light probe specular textures.
                */
                function () {
                    return this._pLightProbeSpecularIndices;
                },
                enumerable: true,
                configurable: true
            });
            return ShaderCompiler;
        })();
        materials.ShaderCompiler = ShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        /**
        * SuperShaderCompiler is a compiler that generates shaders that perform both lighting and "effects" through methods.
        * This is used by the single-pass materials.
        */
        var SuperShaderCompiler = (function (_super) {
            __extends(SuperShaderCompiler, _super);
            /**
            * Creates a new SuperShaderCompiler object.
            * @param profile The compatibility profile used by the renderer.
            */
            function SuperShaderCompiler(profile) {
                _super.call(this, profile);
            }
            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pInitLightData = function () {
                _super.prototype.pInitLightData.call(this);

                this._pointLightRegisters = new Array(this._pNumPointLights * 3);
                this._dirLightRegisters = new Array(this._pNumDirectionalLights * 3);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCalculateDependencies = function () {
                _super.prototype.pCalculateDependencies.call(this);
                this._pDependencyCounter.addWorldSpaceDependencies(true);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileNormalCode = function () {
                var normalMatrix = new Array(3);

                this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pDependencyCounter.normalDependencies);

                if (this._pMethodSetup._iNormalMethod.iHasOutput && !this._pMethodSetup._iNormalMethod.iTangentSpace) {
                    this._pVertexCode += this._pMethodSetup._iNormalMethod.iGetVertexCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                    return;
                }

                this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();

                normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
                normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
                normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();

                this._pRegisterCache.getFreeVertexConstant();
                this._pSceneNormalMatrixIndex = normalMatrix[0].index * 4;

                if (this._pMethodSetup._iNormalMethod.iHasOutput) {
                    // tangent stream required
                    this.compileTangentVertexCode(normalMatrix);
                    this.compileTangentNormalMapFragmentCode();
                } else {
                    // TODO: AGAL <> GLSL
                    //*
                    this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying.toString() + ".xyz, " + this._pSharedRegisters.animatedNormal.toString() + ", " + normalMatrix[0].toString() + "\n" + "mov " + this._pSharedRegisters.normalVarying.toString() + ".w, " + this._pSharedRegisters.animatedNormal.toString() + ".w	\n";

                    this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment.toString() + ".xyz, " + this._pSharedRegisters.normalVarying.toString() + "\n" + "mov " + this._pSharedRegisters.normalFragment.toString() + ".w, " + this._pSharedRegisters.normalVarying.toString() + ".w		\n";

                    if (this._pDependencyCounter.tangentDependencies > 0) {
                        this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                        this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;
                        this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();

                        this._pVertexCode += "mov " + this._pSharedRegisters.tangentVarying.toString() + ", " + this._pSharedRegisters.tangentInput.toString() + "\n";
                    }
                    //*/
                }

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedNormal);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCreateNormalRegisters = function () {
                if (this._pDependencyCounter.normalDependencies > 0) {
                    this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pNormalBufferIndex = this._pSharedRegisters.normalInput.index;
                    this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);
                    this._pAnimatableAttributes.push(this._pSharedRegisters.normalInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedNormal.toString());
                }

                if (this._pMethodSetup._iNormalMethod.iHasOutput) {
                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;

                    this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);

                    this._pAnimatableAttributes.push(this._pSharedRegisters.tangentInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedTangent.toString());
                }
            };

            /**
            * Compiles the vertex shader code for tangent-space normal maps.
            * @param matrix The register containing the scene transformation matrix for normals.
            */
            SuperShaderCompiler.prototype.compileTangentVertexCode = function (matrix) {
                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.bitangentVarying = this._pRegisterCache.getFreeVarying();

                //TODO: AGAL <> GLSL
                this._pVertexCode += "m33 " + this._pSharedRegisters.animatedNormal.toString() + ".xyz, " + this._pSharedRegisters.animatedNormal.toString() + ", " + matrix[0].toString() + "\n" + "nrm " + this._pSharedRegisters.animatedNormal.toString() + ".xyz, " + this._pSharedRegisters.animatedNormal.toString() + "\n";

                this._pVertexCode += "m33 " + this._pSharedRegisters.animatedTangent.toString() + ".xyz, " + this._pSharedRegisters.animatedTangent.toString() + ", " + matrix[0].toString() + "\n" + "nrm " + this._pSharedRegisters.animatedTangent.toString() + ".xyz, " + this._pSharedRegisters.animatedTangent.toString() + "\n";

                var bitanTemp = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pVertexCode += "mov " + this._pSharedRegisters.tangentVarying.toString() + ".x, " + this._pSharedRegisters.animatedTangent.toString() + ".x  \n" + "mov " + this._pSharedRegisters.tangentVarying.toString() + ".z, " + this._pSharedRegisters.animatedNormal.toString() + ".x  \n" + "mov " + this._pSharedRegisters.tangentVarying.toString() + ".w, " + this._pSharedRegisters.normalInput.toString() + ".w  \n" + "mov " + this._pSharedRegisters.bitangentVarying.toString() + ".x, " + this._pSharedRegisters.animatedTangent.toString() + ".y  \n" + "mov " + this._pSharedRegisters.bitangentVarying.toString() + ".z, " + this._pSharedRegisters.animatedNormal.toString() + ".y  \n" + "mov " + this._pSharedRegisters.bitangentVarying.toString() + ".w, " + this._pSharedRegisters.normalInput.toString() + ".w  \n" + "mov " + this._pSharedRegisters.normalVarying.toString() + ".x, " + this._pSharedRegisters.animatedTangent.toString() + ".z  \n" + "mov " + this._pSharedRegisters.normalVarying.toString() + ".z, " + this._pSharedRegisters.animatedNormal.toString() + ".z  \n" + "mov " + this._pSharedRegisters.normalVarying.toString() + ".w, " + this._pSharedRegisters.normalInput.toString() + ".w  \n" + "crs " + bitanTemp.toString() + ".xyz, " + this._pSharedRegisters.animatedNormal.toString() + ", " + this._pSharedRegisters.animatedTangent.toString() + "\n" + "mov " + this._pSharedRegisters.tangentVarying.toString() + ".y, " + bitanTemp.toString() + ".x    \n" + "mov " + this._pSharedRegisters.bitangentVarying.toString() + ".y, " + bitanTemp.toString() + ".y  \n" + "mov " + this._pSharedRegisters.normalVarying.toString() + ".y, " + bitanTemp.toString() + ".z    \n";

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedTangent);
            };

            /**
            * Compiles the fragment shader code for tangent-space normal maps.
            */
            SuperShaderCompiler.prototype.compileTangentNormalMapFragmentCode = function () {
                var t;
                var b;
                var n;

                t = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(t, 1);
                b = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(b, 1);
                n = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(n, 1);

                //TODO: AGAL <> GLSL
                this._pFragmentCode += "nrm " + t.toString() + ".xyz, " + this._pSharedRegisters.tangentVarying.toString() + "\n" + "mov " + t.toString() + ".w, " + this._pSharedRegisters.tangentVarying.toString() + ".w	\n" + "nrm " + b.toString() + ".xyz, " + this._pSharedRegisters.bitangentVarying.toString() + "\n" + "nrm " + n.toString() + ".xyz, " + this._pSharedRegisters.normalVarying.toString() + "\n";

                var temp = this._pRegisterCache.getFreeFragmentVectorTemp();

                this._pRegisterCache.addFragmentTempUsages(temp, 1);

                //TODO: AGAL <> GLSL
                this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, temp) + "m33 " + this._pSharedRegisters.normalFragment.toString() + ".xyz, " + temp.toString() + ", " + t.toString() + "	\n" + "mov " + this._pSharedRegisters.normalFragment.toString() + ".w,   " + this._pSharedRegisters.normalVarying.toString() + ".w			\n";

                this._pRegisterCache.removeFragmentTempUsage(temp);

                if (this._pMethodSetup._iNormalMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iNormalMethodVO.needsGlobalVertexPos || this._pMethodSetup._iNormalMethodVO.needsGlobalFragmentPos) {
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }

                this._pRegisterCache.removeFragmentTempUsage(b);
                this._pRegisterCache.removeFragmentTempUsage(t);
                this._pRegisterCache.removeFragmentTempUsage(n);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileViewDirCode = function () {
                var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();

                this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pDependencyCounter.viewDirDependencies);

                this._pCameraPositionIndex = cameraPositionReg.index * 4;

                //TODO: AGAL <> GLSL
                this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying.toString() + ", " + cameraPositionReg.toString() + ", " + this._pSharedRegisters.globalPositionVertex.toString() + "\n";
                this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment.toString() + ".xyz, " + this._pSharedRegisters.viewDirVarying.toString() + "\n" + "mov " + this._pSharedRegisters.viewDirFragment.toString() + ".w,   " + this._pSharedRegisters.viewDirVarying.toString() + ".w 		\n";

                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
            };

            /**
            * @inheritDoc
            */
            SuperShaderCompiler.prototype.pCompileLightingCode = function () {
                var shadowReg;

                this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);

                this._pVertexCode += this._pMethodSetup._iDiffuseMethod.iGetVertexCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);

                if (this._usingSpecularMethod) {
                    this._pVertexCode += this._pMethodSetup._iSpecularMethod.iGetVertexCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                }

                if (this.pUsesLights()) {
                    this.initLightRegisters();
                    this.compileDirectionalLightCode();
                    this.compilePointLightCode();
                }

                if (this.pUsesProbes()) {
                    this.compileLightProbeCode();
                }

                // only need to create and reserve _shadedTargetReg here, no earlier?
                this._pVertexCode += this._pMethodSetup._iAmbientMethod.iGetVertexCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iAmbientMethod.iGetFragmentCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pMethodSetup._iAmbientMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iAmbientMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iShadowMethod) {
                    this._pVertexCode += this._pMethodSetup._iShadowMethod.iGetVertexCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache);

                    if (this._pDependencyCounter.normalDependencies == 0) {
                        shadowReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                        this._pRegisterCache.addFragmentTempUsages(shadowReg, 1);
                    } else {
                        shadowReg = this._pSharedRegisters.normalFragment;
                    }

                    this._pMethodSetup._iDiffuseMethod.iShadowRegister = shadowReg;
                    this._pFragmentCode += this._pMethodSetup._iShadowMethod.iGetFragmentCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache, shadowReg);
                }

                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pAlphaPremultiplied) {
                    //TODO: AGAL <> GLSL
                    this._pFragmentCode += "add " + this._pSharedRegisters.shadedTarget.toString() + ".w, " + this._pSharedRegisters.shadedTarget.toString() + ".w, " + this._pSharedRegisters.commons.toString() + ".z\n" + "div " + this._pSharedRegisters.shadedTarget.toString() + ".xyz, " + this._pSharedRegisters.shadedTarget.toString() + ", " + this._pSharedRegisters.shadedTarget.toString() + ".w\n" + "sub " + this._pSharedRegisters.shadedTarget.toString() + ".w, " + this._pSharedRegisters.shadedTarget.toString() + ".w, " + this._pSharedRegisters.commons.toString() + ".z\n" + "sat " + this._pSharedRegisters.shadedTarget.toString() + ".xyz, " + this._pSharedRegisters.shadedTarget.toString() + "\n";
                }

                if (this._pMethodSetup._iDiffuseMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iDiffuseMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._usingSpecularMethod) {
                    this._pMethodSetup._iSpecularMethod.iShadowRegister = shadowReg;
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                    if (this._pMethodSetup._iSpecularMethodVO.needsNormals) {
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                    }

                    if (this._pMethodSetup._iSpecularMethodVO.needsView) {
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                    }
                }
            };

            /**
            * Initializes the registers containing the lighting data.
            */
            SuperShaderCompiler.prototype.initLightRegisters = function () {
                // init these first so we're sure they're in sequence
                var i, len;

                len = this._dirLightRegisters.length;

                for (i = 0; i < len; ++i) {
                    this._dirLightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._dirLightRegisters[i].index * 4;
                    }
                }

                len = this._pointLightRegisters.length;

                for (i = 0; i < len; ++i) {
                    this._pointLightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._pointLightRegisters[i].index * 4;
                    }
                }
            };

            SuperShaderCompiler.prototype.compileDirectionalLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightDirReg;
                var regIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumDirectionalLights; ++i) {
                    lightDirReg = this._dirLightRegisters[regIndex++];

                    diffuseColorReg = this._dirLightRegisters[regIndex++];

                    specularColorReg = this._dirLightRegisters[regIndex++];

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }
                }
            };

            SuperShaderCompiler.prototype.compilePointLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightPosReg;
                var lightDirReg;
                var regIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();

                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumPointLights; ++i) {
                    lightPosReg = this._pointLightRegisters[regIndex++];
                    diffuseColorReg = this._pointLightRegisters[regIndex++];
                    specularColorReg = this._pointLightRegisters[regIndex++];
                    lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                    this._pRegisterCache.addFragmentTempUsages(lightDirReg, 1);

                    // calculate attenuation
                    this._pFragmentCode += "sub " + lightDirReg.toString() + ", " + lightPosReg.toString() + ", " + this._pSharedRegisters.globalPositionVarying.toString() + "\n" + "dp3 " + lightDirReg.toString() + ".w, " + lightDirReg.toString() + ", " + lightDirReg.toString() + "\n" + "sub " + lightDirReg.toString() + ".w, " + lightDirReg.toString() + ".w, " + diffuseColorReg.toString() + ".w\n" + "mul " + lightDirReg.toString() + ".w, " + lightDirReg.toString() + ".w, " + specularColorReg.toString() + ".w\n" + "sat " + lightDirReg.toString() + ".w, " + lightDirReg.toString() + ".w\n" + "sub " + lightDirReg.toString() + ".w, " + lightPosReg.toString() + ".w, " + lightDirReg.toString() + ".w\n" + "nrm " + lightDirReg.toString() + ".xyz, " + lightDirReg.toString() + "\n";

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = lightPosReg.index * 4;
                    }

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    this._pRegisterCache.removeFragmentTempUsage(lightDirReg);
                }
            };

            SuperShaderCompiler.prototype.compileLightProbeCode = function () {
                var weightReg;
                var weightComponents = [".x", ".y", ".z", ".w"];
                var weightRegisters = new Array();
                var i;
                var texReg;
                var addSpec = this._usingSpecularMethod && this.pUsesProbesForSpecular();
                var addDiff = this.pUsesProbesForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                if (addDiff) {
                    this._pLightProbeDiffuseIndices = new Array();
                }

                if (addSpec) {
                    this._pLightProbeSpecularIndices = new Array();
                }

                for (i = 0; i < this._pNumProbeRegisters; ++i) {
                    weightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (i == 0) {
                        this._pProbeWeightsIndex = weightRegisters[i].index * 4;
                    }
                }

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];

                    if (addDiff) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeDiffuseIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iDiffuseMethodVO, texReg, weightReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeSpecularIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iSpecularMethodVO, texReg, weightReg, this._pRegisterCache);
                    }
                }
            };
            return SuperShaderCompiler;
        })(away.materials.ShaderCompiler);
        materials.SuperShaderCompiler = SuperShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    (function (materials) {
        /**
        * Enumeration class for defining which lighting types affect the specific material
        * lighting component (diffuse and specular). This can be useful if, for example, you
        * want to use light probes for diffuse global lighting, but want specular reflections from
        * traditional light sources without those affecting the diffuse light.
        *
        * @see away3d.materials.ColorMaterial.diffuseLightSources
        * @see away3d.materials.ColorMaterial.specularLightSources
        * @see away3d.materials.TextureMaterial.diffuseLightSources
        * @see away3d.materials.TextureMaterial.specularLightSources
        */
        var LightSources = (function () {
            function LightSources() {
            }
            LightSources.LIGHTS = 0x01;

            LightSources.PROBES = 0x02;

            LightSources.ALL = 0x03;
            return LightSources;
        })();
        materials.LightSources = LightSources;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * BasicAmbientMethod provides the default shading method for uniform ambient lighting.
        */
        var BasicAmbientMethod = (function (_super) {
            __extends(BasicAmbientMethod, _super);
            /**
            * Creates a new BasicAmbientMethod object.
            */
            function BasicAmbientMethod() {
                _super.call(this);
                this._useTexture = false;
                this._ambientColor = 0xffffff;
                this._ambientR = 0;
                this._ambientG = 0;
                this._ambientB = 0;
                this._ambient = 1;
                this._iLightAmbientR = 0;
                this._iLightAmbientG = 0;
                this._iLightAmbientB = 0;
            }
            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._useTexture;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iInitConstants = function (vo) {
                vo.fragmentData[vo.fragmentConstantsIndex + 3] = 1;
            };

            Object.defineProperty(BasicAmbientMethod.prototype, "ambient", {
                get: /**
                * The strength of the ambient reflection of the surface.
                */
                function () {
                    return this._ambient;
                },
                set: function (value) {
                    this._ambient = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicAmbientMethod.prototype, "ambientColor", {
                get: /**
                * The colour of the ambient reflection of the surface.
                */
                function () {
                    return this._ambientColor;
                },
                set: function (value) {
                    this._ambientColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicAmbientMethod.prototype, "texture", {
                get: /**
                * The bitmapData to use to define the diffuse reflection color per texel.
                */
                function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._useTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }
                    this._useTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.copyFrom = function (method) {
                var m = method;
                var b = m;

                var diff = b;

                this.ambient = diff.ambient;
                this.ambientColor = diff.ambientColor;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._ambientInputRegister = null;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = "";

                if (this._useTexture) {
                    this._ambientInputRegister = regCache.getFreeTextureReg();

                    vo.texturesIndex = this._ambientInputRegister.index;

                    // TODO: AGAL <> GLSL
                    code += this.pGetTex2DSampleCode(vo, targetReg, this._ambientInputRegister, this._texture) + "div " + targetReg.toString() + ".xyz, " + targetReg.toString() + ".xyz, " + targetReg.toString() + ".w\n";
                } else {
                    this._ambientInputRegister = regCache.getFreeFragmentConstant();
                    vo.fragmentConstantsIndex = this._ambientInputRegister.index * 4;

                    code += "mov " + targetReg.toString() + ", " + this._ambientInputRegister.toString() + "\n";
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iActivate = function (vo, stage3DProxy) {
                if (this._useTexture) {
                    stage3DProxy._iContext3D.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.display3D.Context3DWrapMode.REPEAT : away.display3D.Context3DWrapMode.CLAMP, vo.useSmoothTextures ? away.display3D.Context3DTextureFilter.LINEAR : away.display3D.Context3DTextureFilter.NEAREST, vo.useMipmapping ? away.display3D.Context3DMipFilter.MIPLINEAR : away.display3D.Context3DMipFilter.MIPNONE);

                    stage3DProxy._iContext3D.setTextureAt(vo.texturesIndex, this._texture.getTextureForStage3D(stage3DProxy));
                }
            };

            /**
            * Updates the ambient color data used by the render state.
            */
            BasicAmbientMethod.prototype.updateAmbient = function () {
                this._ambientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient * this._iLightAmbientR;
                this._ambientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient * this._iLightAmbientG;
                this._ambientB = (this.ambientColor & 0xff) / 0xff * this._ambient * this._iLightAmbientB;
            };

            /**
            * @inheritDoc
            */
            BasicAmbientMethod.prototype.iSetRenderState = function (vo, renderable, stage3DProxy, camera) {
                this.updateAmbient();

                if (!this._useTexture) {
                    var index = vo.fragmentConstantsIndex;
                    var data = vo.fragmentData;
                    data[index] = this._ambientR;
                    data[index + 1] = this._ambientG;
                    data[index + 2] = this._ambientB;
                }
            };
            return BasicAmbientMethod;
        })(away.materials.ShadingMethodBase);
        materials.BasicAmbientMethod = BasicAmbientMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.managers.Stage3DProxy;
        //import away3d.materials.compilation.ShaderRegisterCache;
        //import away3d.materials.compilation.ShaderRegisterElement;
        //import away3d.textures.Texture2DBase;
        //use namespace arcane;
        /**
        * BasicDiffuseMethod provides the default shading method for Lambert (dot3) diffuse lighting.
        */
        var BasicDiffuseMethod = (function (_super) {
            __extends(BasicDiffuseMethod, _super);
            /**
            * Creates a new BasicDiffuseMethod object.
            */
            function BasicDiffuseMethod() {
                _super.call(this);
                this._diffuseColor = 0xffffff;
                this._diffuseR = 1;
                this._diffuseG = 1;
                this._diffuseB = 1;
                this._diffuseA = 1;
                this._alphaThreshold = 0;
            }
            Object.defineProperty(BasicDiffuseMethod.prototype, "iUseAmbientTexture", {
                get: /**
                * Set internally if the ambient method uses a texture.
                */
                function () {
                    return this._useAmbientTexture;
                },
                set: function (value) {
                    if (this._useAmbientTexture == value)
                        return;

                    this._useAmbientTexture = value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            BasicDiffuseMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._useTexture;
                vo.needsNormals = vo.numLights > 0;
            };

            /**
            * Forces the creation of the texture.
            * @param stage3DProxy The Stage3DProxy used by the renderer
            */
            BasicDiffuseMethod.prototype.generateMip = function (stage3DProxy) {
                if (this._useTexture)
                    this._texture.getTextureForStage3D(stage3DProxy);
            };

            Object.defineProperty(BasicDiffuseMethod.prototype, "diffuseAlpha", {
                get: /**
                * The alpha component of the diffuse reflection.
                */
                function () {
                    return this._diffuseA;
                },
                set: function (value) {
                    this._diffuseA = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicDiffuseMethod.prototype, "diffuseColor", {
                get: /**
                * The color of the diffuse reflection when not using a texture.
                */
                function () {
                    return this._diffuseColor;
                },
                set: function (diffuseColor) {
                    this._diffuseColor = diffuseColor;
                    this.updateDiffuse();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicDiffuseMethod.prototype, "texture", {
                get: /**
                * The bitmapData to use to define the diffuse reflection color per texel.
                */
                function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._useTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }

                    this._useTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicDiffuseMethod.prototype, "alphaThreshold", {
                get: /**
                * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
                * invisible or entirely opaque, often used with textures for foliage, etc.
                * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
                */
                function () {
                    return this._alphaThreshold;
                },
                set: function (value) {
                    if (value < 0)
                        value = 0;
else if (value > 1)
                        value = 1;
                    if (value == this._alphaThreshold)
                        return;

                    if (value == 0 || this._alphaThreshold == 0)
                        this.iInvalidateShaderProgram();

                    this._alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.dispose = function () {
                this._texture = null;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.copyFrom = function (method) {
                var m = method;

                var diff = m;

                this.alphaThreshold = diff.alphaThreshold;
                this.texture = diff.texture;
                this.iUseAmbientTexture = diff.iUseAmbientTexture;
                this.diffuseAlpha = diff.diffuseAlpha;
                this.diffuseColor = diff.diffuseColor;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);

                this._shadowRegister = null;
                this.pTotalLightColorReg = null;
                this._diffuseInputRegister = null;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                var code = "";

                this._isFirstLight = true;

                if (vo.numLights > 0) {
                    this.pTotalLightColorReg = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(this.pTotalLightColorReg, 1);
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                if (this._isFirstLight) {
                    t = this.pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                //TODO: AGAL <> GLSL
                //*
                code += "dp3 " + t + ".x, " + lightDirReg.toString() + ", " + this._sharedRegisters.normalFragment.toString() + "\n" + "max " + t.toString() + ".w, " + t.toString() + ".x, " + this._sharedRegisters.commons.toString() + ".y\n";

                if (vo.useLightFallOff) {
                    code += "mul " + t.toString() + ".w, " + t.toString() + ".w, " + lightDirReg.toString() + ".w\n";
                }

                if (this._iModulateMethod != null) {
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);
                }

                code += "mul " + t.toString() + ", " + t.toString() + ".w, " + lightColReg.toString() + "\n";

                if (!this._isFirstLight) {
                    code += "add " + this.pTotalLightColorReg.toString() + ".xyz, " + this.pTotalLightColorReg.toString() + ", " + t.toString() + "\n";
                    regCache.removeFragmentTempUsage(t);
                }

                //*/
                this._isFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = "";
                var t;

                if (this._isFirstLight) {
                    t = this.pTotalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                // TODO: AGAL <> GLSL
                code += "tex " + t.toString() + ", " + this._sharedRegisters.normalFragment.toString() + ", " + cubeMapReg.toString() + " <cube,linear,miplinear>\n" + "mul " + t.toString() + ".xyz, " + t.toString() + ".xyz, " + weightRegister + "\n";

                if (this._iModulateMethod != null) {
                    code += this._iModulateMethod(vo, t, regCache, this._sharedRegisters);
                }

                if (!this._isFirstLight) {
                    code += "add " + this.pTotalLightColorReg + ".xyz, " + this.pTotalLightColorReg + ", " + t.toString() + "\n";
                    regCache.removeFragmentTempUsage(t);
                }

                this._isFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code = "";
                var albedo;
                var cutOffReg;

                if (vo.numLights > 0) {
                    if (this._shadowRegister)
                        code += this.pApplyShadow(vo, regCache);

                    albedo = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(albedo, 1);
                } else {
                    albedo = targetReg;
                }

                if (this._useTexture) {
                    this._diffuseInputRegister = regCache.getFreeTextureReg();

                    vo.texturesIndex = this._diffuseInputRegister.index;

                    code += this.pGetTex2DSampleCode(vo, albedo, this._diffuseInputRegister, this._texture);

                    if (this._alphaThreshold > 0) {
                        //TODO: AGAL <> GLSL
                        cutOffReg = regCache.getFreeFragmentConstant();
                        vo.fragmentConstantsIndex = cutOffReg.index * 4;

                        code += "sub " + albedo.toString() + ".w, " + albedo.toString() + ".w, " + cutOffReg.toString() + ".x\n" + "kil " + albedo.toString() + ".w\n" + "add " + albedo.toString() + ".w, " + albedo.toString() + ".w, " + cutOffReg.toString() + ".x\n";
                    }
                } else {
                    //TODO: AGAL <> GLSL
                    this._diffuseInputRegister = regCache.getFreeFragmentConstant();

                    vo.fragmentConstantsIndex = this._diffuseInputRegister.index * 4;

                    code += "mov " + albedo.toString() + ", " + this._diffuseInputRegister.toString() + "\n";
                }

                if (vo.numLights == 0)
                    return code;

                //TODO: AGAL <> GLSL
                code += "sat " + this.pTotalLightColorReg.toString() + ", " + this.pTotalLightColorReg.toString() + "\n";

                if (this._useAmbientTexture) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + albedo.toString() + ".xyz, " + albedo.toString() + ", " + this.pTotalLightColorReg.toString() + "\n" + "mul " + this.pTotalLightColorReg.toString() + ".xyz, " + targetReg.toString() + ", " + this.pTotalLightColorReg.toString() + "\n" + "sub " + targetReg.toString() + ".xyz, " + targetReg.toString() + ", " + this.pTotalLightColorReg.toString() + "\n" + "add " + targetReg.toString() + ".xyz, " + albedo.toString() + ", " + targetReg.toString() + "\n";
                } else {
                    //TODO: AGAL <> GLSL
                    code += "add " + targetReg.toString() + ".xyz, " + this.pTotalLightColorReg.toString() + ", " + targetReg.toString() + "\n";

                    if (this._useTexture) {
                        code += "mul " + targetReg.toString() + ".xyz, " + albedo.toString() + ", " + targetReg.toString() + "\n" + "mov " + targetReg + ".w, " + albedo + ".w\n";
                    } else {
                        code += "mul " + targetReg.toString() + ".xyz, " + this._diffuseInputRegister.toString() + ", " + targetReg.toString() + "\n" + "mov " + targetReg.toString() + ".w, " + this._diffuseInputRegister.toString() + ".w\n";
                    }
                }

                regCache.removeFragmentTempUsage(this.pTotalLightColorReg);
                regCache.removeFragmentTempUsage(albedo);

                return code;
            };

            /**
            * Generate the code that applies the calculated shadow to the diffuse light
            * @param vo The MethodVO object for which the compilation is currently happening.
            * @param regCache The register cache the compiler is currently using for the register management.
            */
            BasicDiffuseMethod.prototype.pApplyShadow = function (vo, regCache) {
                //TODO: AGAL <> GLSL
                return "mul " + this.pTotalLightColorReg.toString() + ".xyz, " + this.pTotalLightColorReg.toString() + ", " + this._shadowRegister.toString() + ".w\n";
            };

            /**
            * @inheritDoc
            */
            BasicDiffuseMethod.prototype.iActivate = function (vo, stage3DProxy) {
                if (this._useTexture) {
                    stage3DProxy._iContext3D.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.display3D.Context3DWrapMode.REPEAT : away.display3D.Context3DWrapMode.CLAMP, vo.useSmoothTextures ? away.display3D.Context3DTextureFilter.LINEAR : away.display3D.Context3DTextureFilter.NEAREST, vo.useMipmapping ? away.display3D.Context3DMipFilter.MIPLINEAR : away.display3D.Context3DMipFilter.MIPNONE);

                    stage3DProxy._iContext3D.setTextureAt(vo.texturesIndex, this._texture.getTextureForStage3D(stage3DProxy));

                    if (this._alphaThreshold > 0)
                        vo.fragmentData[vo.fragmentConstantsIndex] = this._alphaThreshold;
                } else {
                    var index = vo.fragmentConstantsIndex;
                    var data = vo.fragmentData;
                    data[index] = this._diffuseR;
                    data[index + 1] = this._diffuseG;
                    data[index + 2] = this._diffuseB;
                    data[index + 3] = this._diffuseA;
                }
            };

            /**
            * Updates the diffuse color data used by the render state.
            */
            BasicDiffuseMethod.prototype.updateDiffuse = function () {
                this._diffuseR = ((this._diffuseColor >> 16) & 0xff) / 0xff;
                this._diffuseG = ((this._diffuseColor >> 8) & 0xff) / 0xff;
                this._diffuseB = (this._diffuseColor & 0xff) / 0xff;
            };

            Object.defineProperty(BasicDiffuseMethod.prototype, "iShadowRegister", {
                set: /**
                * Set internally by the compiler, so the method knows the register containing the shadow calculation.
                */
                function (value) {
                    this._shadowRegister = value;
                },
                enumerable: true,
                configurable: true
            });

            BasicDiffuseMethod.prototype.setIShadowRegister = function (value) {
                this._shadowRegister = value;
            };
            return BasicDiffuseMethod;
        })(away.materials.LightingMethodBase);
        materials.BasicDiffuseMethod = BasicDiffuseMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * BasicNormalMethod is the default method for standard tangent-space normal mapping.
        */
        var BasicNormalMethod = (function (_super) {
            __extends(BasicNormalMethod, _super);
            /**
            * Creates a new BasicNormalMethod object.
            */
            function BasicNormalMethod() {
                _super.call(this);
            }
            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.iInitVO = function (vo) {
                if (this._texture) {
                    vo.needsUV = true;
                } else {
                    vo.needsUV = false;
                }
                //vo.needsUV = Boolean(_texture);
            };

            Object.defineProperty(BasicNormalMethod.prototype, "iTangentSpace", {
                get: /**
                * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.
                */
                function () {
                    return true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(BasicNormalMethod.prototype, "iHasOutput", {
                get: /**
                * Indicates if the normal method output is not based on a texture (if not, it will usually always return true)
                * Override if subclasses are different.
                */
                function () {
                    return this._useTexture;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.copyFrom = function (method) {
                var s = method;
                var bnm = method;

                this.normalMap = bnm.normalMap;
            };

            Object.defineProperty(BasicNormalMethod.prototype, "normalMap", {
                get: /**
                * The texture containing the normals per pixel.
                */
                function () {
                    return this._texture;
                },
                set: function (value) {
                    this.setNormalMap(value);
                },
                enumerable: true,
                configurable: true
            });


            BasicNormalMethod.prototype.setNormalMap = function (value) {
                var b = (value != null);

                if (b != this._useTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                    this.iInvalidateShaderProgram();
                }
                this._useTexture = Boolean(value);
                this._texture = value;
            };

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._pNormalTextureRegister = null;
            };

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.dispose = function () {
                if (this._texture) {
                    this._texture = null;
                }
            };

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.iActivate = function (vo, stage3DProxy) {
                if (vo.texturesIndex >= 0) {
                    stage3DProxy._iContext3D.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.display3D.Context3DWrapMode.REPEAT : away.display3D.Context3DWrapMode.CLAMP, vo.useSmoothTextures ? away.display3D.Context3DTextureFilter.LINEAR : away.display3D.Context3DTextureFilter.NEAREST, vo.useMipmapping ? away.display3D.Context3DMipFilter.MIPLINEAR : away.display3D.Context3DMipFilter.MIPNONE);
                    stage3DProxy._iContext3D.setTextureAt(vo.texturesIndex, this._texture.getTextureForStage3D(stage3DProxy));
                }
            };

            /**
            * @inheritDoc
            */
            BasicNormalMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                this._pNormalTextureRegister = regCache.getFreeTextureReg();

                vo.texturesIndex = this._pNormalTextureRegister.index;

                // TODO: AGAL <> GLSL
                return this.pGetTex2DSampleCode(vo, targetReg, this._pNormalTextureRegister, this._texture) + "sub " + targetReg.toString() + ".xyz, " + targetReg.toString() + ".xyz, " + this._sharedRegisters.commons.toString() + ".xxx	\n" + "nrm " + targetReg.toString() + ".xyz, " + targetReg.toString() + ".xyz							\n";
            };
            return BasicNormalMethod;
        })(away.materials.ShadingMethodBase);
        materials.BasicNormalMethod = BasicNormalMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.*;
        //import away3d.managers.*;
        //import away3d.materials.compilation.*;
        //import away3d.textures.*;
        //use namespace arcane;
        /**
        * BasicSpecularMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated
        * version of Phong specularity).
        */
        var BasicSpecularMethod = (function (_super) {
            __extends(BasicSpecularMethod, _super);
            /**
            * Creates a new BasicSpecularMethod object.
            */
            function BasicSpecularMethod() {
                _super.call(this);
                this._gloss = 50;
                this._specular = 1;
                this._specularColor = 0xffffff;
                this._iSpecularR = 1;
                this._iSpecularG = 1;
                this._iSpecularB = 1;
            }
            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iInitVO = function (vo) {
                vo.needsUV = this._useTexture;
                vo.needsNormals = vo.numLights > 0;
                vo.needsView = vo.numLights > 0;
            };

            Object.defineProperty(BasicSpecularMethod.prototype, "gloss", {
                get: /**
                * The sharpness of the specular highlight.
                */
                function () {
                    return this._gloss;
                },
                set: function (value) {
                    this._gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicSpecularMethod.prototype, "specular", {
                get: /**
                * The overall strength of the specular highlights.
                */
                function () {
                    return this._specular;
                },
                set: function (value) {
                    if (value == this._specular)
                        return;

                    this._specular = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicSpecularMethod.prototype, "specularColor", {
                get: /**
                * The colour of the specular reflection of the surface.
                */
                function () {
                    return this._specularColor;
                },
                set: function (value) {
                    if (this._specularColor == value)
                        return;

                    if (this._specularColor == 0 || value == 0)
                        this.iInvalidateShaderProgram();

                    this._specularColor = value;
                    this.updateSpecular();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(BasicSpecularMethod.prototype, "texture", {
                get: /**
                * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness
                * in the green channel. You can use SpecularBitmapTexture if you want to easily set specular and gloss maps
                * from grayscale images, but prepared images are preferred.
                */
                function () {
                    return this._texture;
                },
                set: function (value) {
                    var b = (value != null);

                    if (b != this._useTexture || (value && this._texture && (value.hasMipMaps != this._texture.hasMipMaps || value.format != this._texture.format))) {
                        this.iInvalidateShaderProgram();
                    }
                    this._useTexture = b;
                    this._texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.copyFrom = function (method) {
                var m = method;
                var bsm = method;

                var spec = bsm;
                this.texture = spec.texture;
                this.specular = spec.specular;
                this.specularColor = spec.specularColor;
                this.gloss = spec.gloss;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._shadowRegister = null;
                this._totalLightColorReg = null;
                this._specularTextureRegister = null;
                this._specularTexData = null;
                this._specularDataRegister = null;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                var code = "";

                this._isFirstLight = true;

                if (vo.numLights > 0) {
                    this._specularDataRegister = regCache.getFreeFragmentConstant();
                    vo.fragmentConstantsIndex = this._specularDataRegister.index * 4;

                    if (this._useTexture) {
                        this._specularTexData = regCache.getFreeFragmentVectorTemp();
                        regCache.addFragmentTempUsages(this._specularTexData, 1);
                        this._specularTextureRegister = regCache.getFreeTextureReg();
                        vo.texturesIndex = this._specularTextureRegister.index;
                        code = this.pGetTex2DSampleCode(vo, this._specularTexData, this._specularTextureRegister, this._texture);
                    } else {
                        this._specularTextureRegister = null;
                    }

                    this._totalLightColorReg = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(this._totalLightColorReg, 1);
                }

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = "";
                var t;

                if (this._isFirstLight) {
                    t = this._totalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                var viewDirReg = this._sharedRegisters.viewDirFragment;
                var normalReg = this._sharedRegisters.normalFragment;

                // blinn-phong half vector model
                //TODO: AGAL <> GLSL
                code += "add " + t.toString() + ", " + lightDirReg.toString() + ", " + viewDirReg.toString() + "\n" + "nrm " + t.toString() + ".xyz, " + t.toString() + "\n" + "dp3 " + t.toString() + ".w, " + normalReg.toString() + ", " + t.toString() + "\n" + "sat " + t.toString() + ".w, " + t.toString() + ".w\n";

                if (this._useTexture) {
                    //TODO: AGAL <> GLSL
                    // apply gloss modulation from texture
                    code += "mul " + this._specularTexData.toString() + ".w, " + this._specularTexData.toString() + ".y, " + this._specularDataRegister.toString() + ".w\n" + "pow " + t + ".w, " + t + ".w, " + this._specularTexData.toString() + ".w\n";
                } else {
                    //TODO: AGAL <> GLSL
                    code += "pow " + t.toString() + ".w, " + t.toString() + ".w, " + this._specularDataRegister.toString() + ".w\n";
                }

                if (vo.useLightFallOff) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + t.toString() + ".w, " + t.toString() + ".w, " + lightDirReg.toString() + ".w\n";
                }

                if (this._iModulateMethod != null) {
                    if (this._iModulateMethodScope != null) {
                        code += this._iModulateMethod.apply(this._iModulateMethodScope, [vo, t, regCache, this._sharedRegisters]);
                    } else {
                        throw "Modulated methods needs a scope";
                    }
                    //code += this._iModulateMethod (vo, t, regCache, this._sharedRegisters);
                }

                //TODO: AGAL <> GLSL
                code += "mul " + t.toString() + ".xyz, " + lightColReg.toString() + ", " + t.toString() + ".w\n";

                if (!this._isFirstLight) {
                    //TODO: AGAL <> GLSL
                    code += "add " + this._totalLightColorReg.toString() + ".xyz, " + this._totalLightColorReg.toString() + ", " + t.toString() + "\n";

                    regCache.removeFragmentTempUsage(t);
                }

                this._isFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = "";
                var t;

                if (this._isFirstLight) {
                    t = this._totalLightColorReg;
                } else {
                    t = regCache.getFreeFragmentVectorTemp();
                    regCache.addFragmentTempUsages(t, 1);
                }

                var normalReg = this._sharedRegisters.normalFragment;
                var viewDirReg = this._sharedRegisters.viewDirFragment;

                //TODO: AGAL <> GLSL
                code += "dp3 " + t.toString() + ".w, " + normalReg.toString() + ", " + viewDirReg.toString() + "\n" + "add " + t.toString() + ".w, " + t.toString() + ".w, " + t.toString() + ".w\n" + "mul " + t.toString() + ", " + t.toString() + ".w, " + normalReg.toString() + "\n" + "sub " + t.toString() + ", " + t.toString() + ", " + viewDirReg.toString() + "\n" + "tex " + t.toString() + ", " + t.toString() + ", " + cubeMapReg.toString() + " <cube," + (vo.useSmoothTextures ? "linear" : "nearest") + ",miplinear>\n" + "mul " + t.toString() + ".xyz, " + t.toString() + ", " + weightRegister.toString() + "\n";

                if (this._iModulateMethod != null) {
                    if (this._iModulateMethodScope != null) {
                        code += this._iModulateMethod.apply(this._iModulateMethodScope, [vo, t, regCache, this._sharedRegisters]);
                    } else {
                        throw "Modulated methods needs a scope";
                    }
                    //code += this._iModulateMethod (vo, t, regCache, this._sharedRegisters);
                }

                if (!this._isFirstLight) {
                    //TODO: AGAL <> GLSL
                    code += "add " + this._totalLightColorReg.toString() + ".xyz, " + this._totalLightColorReg.toString() + ", " + t.toString() + "\n";

                    regCache.removeFragmentTempUsage(t);
                }

                this._isFirstLight = false;

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                var code = "";

                if (vo.numLights == 0)
                    return code;

                if (this._shadowRegister) {
                    //TODO: AGAL <> GLSL
                    code += "mul " + this._totalLightColorReg.toString() + ".xyz, " + this._totalLightColorReg.toString() + ", " + this._shadowRegister.toString() + ".w\n";
                }

                if (this._useTexture) {
                    // apply strength modulation from texture
                    //TODO: AGAL <> GLSL
                    code += "mul " + this._totalLightColorReg.toString() + ".xyz, " + this._totalLightColorReg.toString() + ", " + this._specularTexData.toString() + ".x\n";

                    regCache.removeFragmentTempUsage(this._specularTexData);
                }

                // apply material's specular reflection
                //TODO: AGAL <> GLSL
                code += "mul " + this._totalLightColorReg.toString() + ".xyz, " + this._totalLightColorReg.toString() + ", " + this._specularDataRegister.toString() + "\n" + "add " + targetReg.toString() + ".xyz, " + targetReg.toString() + ", " + this._totalLightColorReg.toString() + "\n";

                regCache.removeFragmentTempUsage(this._totalLightColorReg);

                return code;
            };

            /**
            * @inheritDoc
            */
            BasicSpecularMethod.prototype.iActivate = function (vo, stage3DProxy) {
                if (vo.numLights == 0)
                    return;

                if (this._useTexture) {
                    stage3DProxy._iContext3D.setSamplerStateAt(vo.texturesIndex, vo.repeatTextures ? away.display3D.Context3DWrapMode.REPEAT : away.display3D.Context3DWrapMode.CLAMP, vo.useSmoothTextures ? away.display3D.Context3DTextureFilter.LINEAR : away.display3D.Context3DTextureFilter.NEAREST, vo.useMipmapping ? away.display3D.Context3DMipFilter.MIPLINEAR : away.display3D.Context3DMipFilter.MIPNONE);
                    stage3DProxy._iContext3D.setTextureAt(vo.texturesIndex, this._texture.getTextureForStage3D(stage3DProxy));
                }

                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;
                data[index] = this._iSpecularR;
                data[index + 1] = this._iSpecularG;
                data[index + 2] = this._iSpecularB;
                data[index + 3] = this._gloss;
            };

            /**
            * Updates the specular color data used by the render state.
            */
            BasicSpecularMethod.prototype.updateSpecular = function () {
                this._iSpecularR = ((this._specularColor >> 16) & 0xff) / 0xff * this._specular;
                this._iSpecularG = ((this._specularColor >> 8) & 0xff) / 0xff * this._specular;
                this._iSpecularB = (this._specularColor & 0xff) / 0xff * this._specular;
            };

            Object.defineProperty(BasicSpecularMethod.prototype, "iShadowRegister", {
                set: /**
                * Set internally by the compiler, so the method knows the register containing the shadow calculation.
                */
                function (shadowReg) {
                    this._shadowRegister = shadowReg;
                },
                enumerable: true,
                configurable: true
            });

            BasicSpecularMethod.prototype.setIShadowRegister = function (shadowReg) {
                this._shadowRegister = shadowReg;
            };
            return BasicSpecularMethod;
        })(away.materials.LightingMethodBase);
        materials.BasicSpecularMethod = BasicSpecularMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        //import away3d.managers.Stage3DProxy;
        //import away3d.materials.compilation.ShaderRegisterCache;
        //import away3d.materials.compilation.ShaderRegisterElement;
        //import flash.geom.ColorTransform;
        //use namespace arcane;
        /**
        * ColorTransformMethod provides a shading method that changes the colour of a material analogous to a
        * ColorTransform object.
        */
        var ColorTransformMethod = (function (_super) {
            __extends(ColorTransformMethod, _super);
            /**
            * Creates a new ColorTransformMethod.
            */
            function ColorTransformMethod() {
                _super.call(this);
            }
            Object.defineProperty(ColorTransformMethod.prototype, "colorTransform", {
                get: /**
                * The ColorTransform object to transform the colour of the material with.
                */
                function () {
                    return this._colorTransform;
                },
                set: function (value) {
                    this._colorTransform = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            ColorTransformMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var code = "";
                var colorMultReg = regCache.getFreeFragmentConstant();
                var colorOffsReg = regCache.getFreeFragmentConstant();

                vo.fragmentConstantsIndex = colorMultReg.index * 4;

                //TODO: AGAL <> GLSL
                code += "mul " + targetReg.toString() + ", " + targetReg.toString() + ", " + colorMultReg.toString() + "\n" + "add " + targetReg.toString() + ", " + targetReg.toString() + ", " + colorOffsReg.toString() + "\n";

                return code;
            };

            /**
            * @inheritDoc
            */
            ColorTransformMethod.prototype.iActivate = function (vo, stage3DProxy) {
                var inv = 1 / 0xff;
                var index = vo.fragmentConstantsIndex;
                var data = vo.fragmentData;

                data[index] = this._colorTransform.redMultiplier;
                data[index + 1] = this._colorTransform.greenMultiplier;
                data[index + 2] = this._colorTransform.blueMultiplier;
                data[index + 3] = this._colorTransform.alphaMultiplier;
                data[index + 4] = this._colorTransform.redOffset * inv;
                data[index + 5] = this._colorTransform.greenOffset * inv;
                data[index + 6] = this._colorTransform.blueOffset * inv;
                data[index + 7] = this._colorTransform.alphaOffset * inv;
            };
            return ColorTransformMethod;
        })(away.materials.EffectMethodBase);
        materials.ColorTransformMethod = ColorTransformMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * CompositeDiffuseMethod provides a base class for diffuse methods that wrap a diffuse method to alter the
        * calculated diffuse reflection strength.
        */
        var CompositeDiffuseMethod = (function (_super) {
            __extends(CompositeDiffuseMethod, _super);
            /**
            * Creates a new WrapDiffuseMethod object.
            * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t : ShaderRegisterElement, regCache : ShaderRegisterCache) : string, in which t.w will contain the diffuse strength.
            * @param baseDiffuseMethod The base diffuse method on which this method's shading is based.
            */
            function CompositeDiffuseMethod(modulateMethod, baseDiffuseMethod) {
                if (typeof modulateMethod === "undefined") { modulateMethod = null; }
                if (typeof baseDiffuseMethod === "undefined") { baseDiffuseMethod = null; }
                _super.call(this);

                this.pBaseMethod = baseDiffuseMethod || new away.materials.BasicDiffuseMethod();
                this.pBaseMethod._iModulateMethod = modulateMethod;
                this.pBaseMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
            }
            Object.defineProperty(CompositeDiffuseMethod.prototype, "baseMethod", {
                get: /**
                * The base diffuse method on which this method's shading is based.
                */
                function () {
                    return this.pBaseMethod;
                },
                set: function (value) {
                    if (this.pBaseMethod == value)
                        return;
                    this.pBaseMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                    this.pBaseMethod = value;
                    this.pBaseMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iInitVO = function (vo) {
                this.pBaseMethod.iInitVO(vo);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iInitConstants = function (vo) {
                this.pBaseMethod.iInitConstants(vo);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.dispose = function () {
                this.pBaseMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                this.pBaseMethod.dispose();
            };

            Object.defineProperty(CompositeDiffuseMethod.prototype, "alphaThreshold", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.pBaseMethod.alphaThreshold;
                },
                set: function (value) {
                    this.pBaseMethod.alphaThreshold = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeDiffuseMethod.prototype, "texture", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.pBaseMethod.texture;
                },
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.pBaseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeDiffuseMethod.prototype, "diffuseAlpha", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.pBaseMethod.diffuseAlpha;
                },
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.pBaseMethod.diffuseAlpha = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(CompositeDiffuseMethod.prototype, "diffuseColor", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.pBaseMethod.diffuseColor;
                },
                set: /**
                * @inheritDoc
                */
                function (diffuseColor) {
                    this.pBaseMethod.diffuseColor = diffuseColor;
                },
                enumerable: true,
                configurable: true
            });



            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return this.pBaseMethod.iGetFragmentPreLightingCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                var code = this.pBaseMethod.iGetFragmentCodePerLight(vo, lightDirReg, lightColReg, regCache);
                this.pTotalLightColorReg = this.pBaseMethod.pTotalLightColorReg;
                return code;
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                var code = this.pBaseMethod.iGetFragmentCodePerProbe(vo, cubeMapReg, weightRegister, regCache);
                this.pTotalLightColorReg = this.pBaseMethod.pTotalLightColorReg;
                return code;
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iActivate = function (vo, stage3DProxy) {
                this.pBaseMethod.iActivate(vo, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iDeactivate = function (vo, stage3DProxy) {
                this.pBaseMethod.iDeactivate(vo, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetVertexCode = function (vo, regCache) {
                return this.pBaseMethod.iGetVertexCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return this.pBaseMethod.iGetFragmentPostLightingCode(vo, regCache, targetReg);
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iReset = function () {
                this.pBaseMethod.iReset();
            };

            /**
            * @inheritDoc
            */
            CompositeDiffuseMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this.pBaseMethod.iCleanCompilationData();
            };

            Object.defineProperty(CompositeDiffuseMethod.prototype, "iSharedRegisters", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.pBaseMethod.setISharedRegisters(value);
                    _super.prototype.setISharedRegisters.call(this, value);
                },
                enumerable: true,
                configurable: true
            });

            CompositeDiffuseMethod.prototype.setISharedRegisters = function (value) {
                this.pBaseMethod.setISharedRegisters(value);
                _super.prototype.setISharedRegisters.call(this, value);
            };

            Object.defineProperty(CompositeDiffuseMethod.prototype, "iShadowRegister", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setIShadowRegister.call(this, value);
                    this.pBaseMethod.setIShadowRegister(value);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called when the base method's shader code is invalidated.
            */
            CompositeDiffuseMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return CompositeDiffuseMethod;
        })(away.materials.BasicDiffuseMethod);
        materials.CompositeDiffuseMethod = CompositeDiffuseMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * CompositeSpecularMethod provides a base class for specular methods that wrap a specular method to alter the
        * calculated specular reflection strength.
        */
        var CompositeSpecularMethod = (function (_super) {
            __extends(CompositeSpecularMethod, _super);
            /**
            * Creates a new WrapSpecularMethod object.
            * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t : ShaderRegisterElement, regCache : ShaderRegisterCache) : string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.
            * @param baseSpecularMethod The base specular method on which this method's shading is based.
            */
            function CompositeSpecularMethod() {
                _super.call(this);
                /*
                this._baseMethod = baseSpecularMethod || new away.materials.BasicSpecularMethod();
                
                
                this._baseMethod._iModulateMethod = modulateMethod;
                this._baseMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated , this );
                */
            }
            CompositeSpecularMethod.prototype.initCompositeSpecularMethod = function (scope, modulateMethod, baseSpecularMethod) {
                if (typeof baseSpecularMethod === "undefined") { baseSpecularMethod = null; }
                this._baseMethod = baseSpecularMethod || new away.materials.BasicSpecularMethod();
                this._baseMethod._iModulateMethod = modulateMethod;
                this._baseMethod._iModulateMethodScope = scope;
                this._baseMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iInitVO = function (vo) {
                this._baseMethod.iInitVO(vo);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iInitConstants = function (vo) {
                this._baseMethod.iInitConstants(vo);
            };

            Object.defineProperty(CompositeSpecularMethod.prototype, "baseMethod", {
                get: /**
                * The base specular method on which this method's shading is based.
                */
                function () {
                    return this._baseMethod;
                },
                set: function (value) {
                    if (this._baseMethod == value)
                        return;
                    this._baseMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                    this._baseMethod = value;
                    this._baseMethod.addEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeSpecularMethod.prototype, "gloss", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.gloss;
                },
                set: function (value) {
                    this._baseMethod.gloss = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeSpecularMethod.prototype, "specular", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.specular;
                },
                set: function (value) {
                    this._baseMethod.specular = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(CompositeSpecularMethod.prototype, "passes", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.passes;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.dispose = function () {
                this._baseMethod.removeEventListener(away.events.ShadingMethodEvent.SHADER_INVALIDATED, this.onShaderInvalidated, this);
                this._baseMethod.dispose();
            };

            Object.defineProperty(CompositeSpecularMethod.prototype, "texture", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this._baseMethod.texture;
                },
                set: function (value) {
                    this._baseMethod.texture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iActivate = function (vo, stage3DProxy) {
                this._baseMethod.iActivate(vo, stage3DProxy);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iDeactivate = function (vo, stage3DProxy) {
                this._baseMethod.iDeactivate(vo, stage3DProxy);
            };

            Object.defineProperty(CompositeSpecularMethod.prototype, "iSharedRegisters", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    _super.prototype.setISharedRegisters.call(this, value);
                    this._baseMethod.setISharedRegisters(value);
                },
                enumerable: true,
                configurable: true
            });
            CompositeSpecularMethod.prototype.setISharedRegisters = function (value) {
                _super.prototype.setISharedRegisters.call(this, value);
                this._baseMethod.setISharedRegisters(value);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iGetVertexCode = function (vo, regCache) {
                return this._baseMethod.iGetVertexCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                return this._baseMethod.iGetFragmentPreLightingCode(vo, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iGetFragmentCodePerLight = function (vo, lightDirReg, lightColReg, regCache) {
                return this._baseMethod.iGetFragmentCodePerLight(vo, lightDirReg, lightColReg, regCache);
            };

            /**
            * @inheritDoc
            * @return
            */
            CompositeSpecularMethod.prototype.iGetFragmentCodePerProbe = function (vo, cubeMapReg, weightRegister, regCache) {
                return this._baseMethod.iGetFragmentCodePerProbe(vo, cubeMapReg, weightRegister, regCache);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iGetFragmentPostLightingCode = function (vo, regCache, targetReg) {
                return this._baseMethod.iGetFragmentPostLightingCode(vo, regCache, targetReg);
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iReset = function () {
                this._baseMethod.iReset();
            };

            /**
            * @inheritDoc
            */
            CompositeSpecularMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._baseMethod.iCleanCompilationData();
            };

            Object.defineProperty(CompositeSpecularMethod.prototype, "iShadowRegister", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    this.setIShadowRegister(value);
                    this._baseMethod.setIShadowRegister(value);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Called when the base method's shader code is invalidated.
            */
            CompositeSpecularMethod.prototype.onShaderInvalidated = function (event) {
                this.iInvalidateShaderProgram();
            };
            return CompositeSpecularMethod;
        })(away.materials.BasicSpecularMethod);
        materials.CompositeSpecularMethod = CompositeSpecularMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * EnvMapMethod provides a material method to perform reflection mapping using cube maps.
        */
        var EnvMapMethod = (function (_super) {
            __extends(EnvMapMethod, _super);
            /**
            * Creates an EnvMapMethod object.
            * @param envMap The environment map containing the reflected scene.
            * @param alpha The reflectivity of the surface.
            */
            function EnvMapMethod(envMap, alpha) {
                if (typeof alpha === "undefined") { alpha = 1; }
                _super.call(this);
                this._cubeTexture = envMap;
                this._alpha = alpha;
            }
            Object.defineProperty(EnvMapMethod.prototype, "mask", {
                get: /**
                * An optional texture to modulate the reflectivity of the surface.
                */
                function () {
                    return this._mask;
                },
                set: function (value) {
                    if (value != this._mask || (value && this._mask && (value.hasMipMaps != this._mask.hasMipMaps || value.format != this._mask.format))) {
                        this.iInvalidateShaderProgram();
                    }

                    /*
                    if (Boolean(value) != Boolean(_mask) ||
                    (value && _mask && (value.hasMipMaps != _mask.hasMipMaps || value.format != _mask.format))) {
                    invalidateShaderProgram();
                    }
                    */
                    this._mask = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EnvMapMethod.prototype.iInitVO = function (vo) {
                vo.needsNormals = true;
                vo.needsView = true;
                vo.needsUV = this._mask != null;
            };

            Object.defineProperty(EnvMapMethod.prototype, "envMap", {
                get: /**
                * The cubic environment map containing the reflected scene.
                */
                function () {
                    return this._cubeTexture;
                },
                set: function (value) {
                    this._cubeTexture = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EnvMapMethod.prototype.dispose = function () {
            };

            Object.defineProperty(EnvMapMethod.prototype, "alpha", {
                get: /**
                * The reflectivity of the surface.
                */
                function () {
                    return this._alpha;
                },
                set: function (value) {
                    this._alpha = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            EnvMapMethod.prototype.iActivate = function (vo, stage3DProxy) {
                var context = stage3DProxy._iContext3D;
                vo.fragmentData[vo.fragmentConstantsIndex] = this._alpha;

                context.setTextureAt(vo.texturesIndex, this._cubeTexture.getTextureForStage3D(stage3DProxy));
                if (this._mask) {
                    context.setTextureAt(vo.texturesIndex + 1, this._mask.getTextureForStage3D(stage3DProxy));
                }
            };

            /**
            * @inheritDoc
            */
            EnvMapMethod.prototype.iGetFragmentCode = function (vo, regCache, targetReg) {
                var dataRegister = regCache.getFreeFragmentConstant();
                var temp = regCache.getFreeFragmentVectorTemp();
                var code = "";
                var cubeMapReg = regCache.getFreeTextureReg();

                vo.texturesIndex = cubeMapReg.index;
                vo.fragmentConstantsIndex = dataRegister.index * 4;

                regCache.addFragmentTempUsages(temp, 1);
                var temp2 = regCache.getFreeFragmentVectorTemp();

                // r = I - 2(I.N)*N
                code += "dp3 " + temp + ".w, " + this._sharedRegisters.viewDirFragment + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz		\n" + "add " + temp + ".w, " + temp + ".w, " + temp + ".w											\n" + "mul " + temp + ".xyz, " + this._sharedRegisters.normalFragment + ".xyz, " + temp + ".w						\n" + "sub " + temp + ".xyz, " + temp + ".xyz, " + this._sharedRegisters.viewDirFragment + ".xyz					\n" + this.pGetTexCubeSampleCode(vo, temp, cubeMapReg, this._cubeTexture, temp) + "sub " + temp2 + ".w, " + temp + ".w, fc0.x									\n" + "kil " + temp2 + ".w\n" + "sub " + temp + ", " + temp + ", " + targetReg + "											\n";

                if (this._mask) {
                    var maskReg = regCache.getFreeTextureReg();
                    code += this.pGetTex2DSampleCode(vo, temp2, maskReg, this._mask, this._sharedRegisters.uvVarying) + "mul " + temp + ", " + temp2 + ", " + temp + "\n";
                }
                code += "mul " + temp + ", " + temp + ", " + dataRegister + ".x										\n" + "add " + targetReg + ", " + targetReg + ", " + temp + "										\n";

                regCache.removeFragmentTempUsage(temp);

                return code;
            };
            return EnvMapMethod;
        })(away.materials.EffectMethodBase);
        materials.EnvMapMethod = EnvMapMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * FresnelSpecularMethod provides a specular shading method that causes stronger highlights on grazing view angles.
        */
        var FresnelSpecularMethod = (function (_super) {
            __extends(FresnelSpecularMethod, _super);
            /**
            * Creates a new FresnelSpecularMethod object.
            * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
            * @param baseSpecularMethod The specular method to which the fresnel equation. Defaults to BasicSpecularMethod.
            */
            function FresnelSpecularMethod(basedOnSurface, baseSpecularMethod) {
                if (typeof basedOnSurface === "undefined") { basedOnSurface = true; }
                if (typeof baseSpecularMethod === "undefined") { baseSpecularMethod = null; }
                // may want to offer diff speculars
                _super.call(this);
                this._fresnelPower = 5;
                this._normalReflectance = .028;

                this.initCompositeSpecularMethod(this, this.modulateSpecular, baseSpecularMethod);
                this._incidentLight = !basedOnSurface;
            }
            /**
            * @inheritDoc
            */
            FresnelSpecularMethod.prototype.iInitConstants = function (vo) {
                var index = vo.secondaryFragmentConstantsIndex;
                vo.fragmentData[index + 2] = 1;
                vo.fragmentData[index + 3] = 0;
            };

            Object.defineProperty(FresnelSpecularMethod.prototype, "basedOnSurface", {
                get: /**
                * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
                */
                function () {
                    return !this._incidentLight;
                },
                set: function (value) {
                    if (this._incidentLight != value)
                        return;

                    this._incidentLight = !value;

                    this.iInvalidateShaderProgram();
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(FresnelSpecularMethod.prototype, "fresnelPower", {
                get: /**
                * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
                */
                function () {
                    return this._fresnelPower;
                },
                set: function (value) {
                    this._fresnelPower = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            FresnelSpecularMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._dataReg = null;
            };

            Object.defineProperty(FresnelSpecularMethod.prototype, "normalReflectance", {
                get: /**
                * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
                */
                function () {
                    return this._normalReflectance;
                },
                set: function (value) {
                    this._normalReflectance = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            FresnelSpecularMethod.prototype.iActivate = function (vo, stage3DProxy) {
                _super.prototype.iActivate.call(this, vo, stage3DProxy);
                var fragmentData = vo.fragmentData;

                var index = vo.secondaryFragmentConstantsIndex;
                fragmentData[index] = this._normalReflectance;
                fragmentData[index + 1] = this._fresnelPower;
            };

            /**
            * @inheritDoc
            */
            FresnelSpecularMethod.prototype.iGetFragmentPreLightingCode = function (vo, regCache) {
                this._dataReg = regCache.getFreeFragmentConstant();

                console.log('FresnelSpecularMethod', 'iGetFragmentPreLightingCode', this._dataReg);

                vo.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
                return _super.prototype.iGetFragmentPreLightingCode.call(this, vo, regCache);
            };

            /**
            * Applies the fresnel effect to the specular strength.
            *
            * @param vo The MethodVO object containing the method data for the currently compiled material pass.
            * @param target The register containing the specular strength in the "w" component, and the half-vector/reflection vector in "xyz".
            * @param regCache The register cache used for the shader compilation.
            * @param sharedRegisters The shared registers created by the compiler.
            * @return The AGAL fragment code for the method.
            */
            FresnelSpecularMethod.prototype.modulateSpecular = function (vo, target, regCache, sharedRegisters) {
                var code;

                code = "dp3 " + target + ".y, " + sharedRegisters.viewDirFragment + ".xyz, " + (this._incidentLight ? target + ".xyz\n" : sharedRegisters.normalFragment + ".xyz\n") + "sub " + target + ".y, " + this._dataReg + ".z, " + target + ".y\n" + "pow " + target + ".x, " + target + ".y, " + this._dataReg + ".y\n" + "sub " + target + ".y, " + this._dataReg + ".z, " + target + ".y\n" + "mul " + target + ".y, " + this._dataReg + ".x, " + target + ".y\n" + "add " + target + ".y, " + target + ".x, " + target + ".y\n" + "mul " + target + ".w, " + target + ".w, " + target + ".y\n";

                console.log('FresnelSpecularMethod', 'modulateSpecular', code);

                return code;
            };
            return FresnelSpecularMethod;
        })(away.materials.CompositeSpecularMethod);
        materials.FresnelSpecularMethod = FresnelSpecularMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        /**
        * SimpleWaterNormalMethod provides a basic normal map method to create water ripples by translating two wave normal maps.
        */
        var SimpleWaterNormalMethod = (function (_super) {
            __extends(SimpleWaterNormalMethod, _super);
            /**
            * Creates a new SimpleWaterNormalMethod object.
            * @param waveMap1 A normal map containing one layer of a wave structure.
            * @param waveMap2 A normal map containing a second layer of a wave structure.
            */
            function SimpleWaterNormalMethod(waveMap1, waveMap2) {
                _super.call(this);
                this._useSecondNormalMap = false;
                this._water1OffsetX = 0;
                this._water1OffsetY = 0;
                this._water2OffsetX = 0;
                this._water2OffsetY = 0;
                this.normalMap = waveMap1;
                this.secondaryNormalMap = waveMap2;
            }
            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.iInitConstants = function (vo) {
                var index = vo.fragmentConstantsIndex;
                vo.fragmentData[index] = .5;
                vo.fragmentData[index + 1] = 0;
                vo.fragmentData[index + 2] = 0;
                vo.fragmentData[index + 3] = 1;
            };

            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.iInitVO = function (vo) {
                _super.prototype.iInitVO.call(this, vo);

                this._useSecondNormalMap = this.normalMap != this.secondaryNormalMap;
            };

            Object.defineProperty(SimpleWaterNormalMethod.prototype, "water1OffsetX", {
                get: /**
                * The translation of the first wave layer along the X-axis.
                */
                function () {
                    return this._water1OffsetX;
                },
                set: function (value) {
                    this._water1OffsetX = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SimpleWaterNormalMethod.prototype, "water1OffsetY", {
                get: /**
                * The translation of the first wave layer along the Y-axis.
                */
                function () {
                    return this._water1OffsetY;
                },
                set: function (value) {
                    this._water1OffsetY = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SimpleWaterNormalMethod.prototype, "water2OffsetX", {
                get: /**
                * The translation of the second wave layer along the X-axis.
                */
                function () {
                    return this._water2OffsetX;
                },
                set: function (value) {
                    this._water2OffsetX = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SimpleWaterNormalMethod.prototype, "water2OffsetY", {
                get: /**
                * The translation of the second wave layer along the Y-axis.
                */
                function () {
                    return this._water2OffsetY;
                },
                set: function (value) {
                    this._water2OffsetY = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(SimpleWaterNormalMethod.prototype, "normalMap", {
                set: /**
                * @inheritDoc
                */
                function (value) {
                    if (!value) {
                        return;
                    }
                    this.setNormalMap(value);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SimpleWaterNormalMethod.prototype, "secondaryNormalMap", {
                get: /**
                * A second normal map that will be combined with the first to create a wave-like animation pattern.
                */
                function () {
                    return this._texture2;
                },
                set: function (value) {
                    this._texture2 = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.iCleanCompilationData = function () {
                _super.prototype.iCleanCompilationData.call(this);
                this._normalTextureRegister2 = null;
            };

            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                this._texture2 = null;
            };

            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.iActivate = function (vo, stage3DProxy) {
                _super.prototype.iActivate.call(this, vo, stage3DProxy);

                var data = vo.fragmentData;
                var index = vo.fragmentConstantsIndex;

                data[index + 4] = this._water1OffsetX;
                data[index + 5] = this._water1OffsetY;
                data[index + 6] = this._water2OffsetX;
                data[index + 7] = this._water2OffsetY;

                if (this._useSecondNormalMap)
                    stage3DProxy._iContext3D.setTextureAt(vo.texturesIndex + 1, this._texture2.getTextureForStage3D(stage3DProxy));
            };

            /**
            * @inheritDoc
            */
            SimpleWaterNormalMethod.prototype.getFragmentCode = function (vo, regCache, targetReg) {
                var temp = regCache.getFreeFragmentVectorTemp();
                var dataReg = regCache.getFreeFragmentConstant();
                var dataReg2 = regCache.getFreeFragmentConstant();
                this._pNormalTextureRegister = regCache.getFreeTextureReg();
                this._normalTextureRegister2 = this._useSecondNormalMap ? regCache.getFreeTextureReg() : this._pNormalTextureRegister;
                vo.texturesIndex = this._pNormalTextureRegister.index;

                vo.fragmentConstantsIndex = dataReg.index * 4;
                return "add " + temp + ", " + this._sharedRegisters.uvVarying + ", " + dataReg2 + ".xyxy\n" + this.pGetTex2DSampleCode(vo, targetReg, this._pNormalTextureRegister, this.normalMap, temp) + "add " + temp + ", " + this._sharedRegisters.uvVarying + ", " + dataReg2 + ".zwzw\n" + this.pGetTex2DSampleCode(vo, temp, this._normalTextureRegister2, this._texture2, temp) + "add " + targetReg + ", " + targetReg + ", " + temp + "		\n" + "mul " + targetReg + ", " + targetReg + ", " + dataReg + ".x	\n" + "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + this._sharedRegisters.commons + ".xxx	\n" + "nrm " + targetReg + ".xyz, " + targetReg + ".xyz							\n";
            };
            return SimpleWaterNormalMethod;
        })(away.materials.BasicNormalMethod);
        materials.SimpleWaterNormalMethod = SimpleWaterNormalMethod;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * ColorMaterial is a single-pass material that uses a flat color as the surface's diffuse reflection value.
        */
        var ColorMaterial = (function (_super) {
            __extends(ColorMaterial, _super);
            /**
            * Creates a new ColorMaterial object.
            * @param color The material's diffuse surface color.
            * @param alpha The material's surface alpha.
            */
            function ColorMaterial(color, alpha) {
                if (typeof color === "undefined") { color = 0xcccccc; }
                if (typeof alpha === "undefined") { alpha = 1; }
                _super.call(this);
                this._diffuseAlpha = 1;

                this.color = color;
                this.alpha = alpha;
            }
            Object.defineProperty(ColorMaterial.prototype, "alpha", {
                get: /**
                * The alpha of the surface.
                */
                function () {
                    return this._pScreenPass.diffuseMethod.diffuseAlpha;
                },
                set: function (value) {
                    if (value > 1) {
                        value = 1;
                    } else if (value < 0) {
                        value = 0;
                    }

                    this._pScreenPass.diffuseMethod.diffuseAlpha = this._diffuseAlpha = value;
                    this._pScreenPass.preserveAlpha = this.requiresBlending;
                    this._pScreenPass.setBlendMode(this.getBlendMode() == away.display.BlendMode.NORMAL && this.requiresBlending ? away.display.BlendMode.LAYER : this.getBlendMode());
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ColorMaterial.prototype, "color", {
                get: /**
                * The diffuse reflectivity color of the surface.
                */
                function () {
                    return this._pScreenPass.diffuseMethod.diffuseColor;
                },
                set: function (value) {
                    this._pScreenPass.diffuseMethod.diffuseColor = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(ColorMaterial.prototype, "requiresBlending", {
                get: /**
                * @inheritDoc
                */
                function () {
                    return this.getRequiresBlending() || this._diffuseAlpha < 1;
                },
                enumerable: true,
                configurable: true
            });
            return ColorMaterial;
        })(away.materials.SinglePassMaterialBase);
        materials.ColorMaterial = ColorMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        var DefaultMaterialManager = (function () {
            function DefaultMaterialManager() {
            }
            DefaultMaterialManager.getDefaultMaterial = function (renderable) {
                if (typeof renderable === "undefined") { renderable = null; }
                if (!DefaultMaterialManager._defaultTexture) {
                    DefaultMaterialManager.createDefaultTexture();
                }

                if (!DefaultMaterialManager._defaultMaterial) {
                    DefaultMaterialManager.createDefaultMaterial();
                }

                return DefaultMaterialManager._defaultMaterial;
            };

            DefaultMaterialManager.getDefaultTexture = function (renderable) {
                if (typeof renderable === "undefined") { renderable = null; }
                if (!DefaultMaterialManager._defaultTexture) {
                    DefaultMaterialManager.createDefaultTexture();
                }

                return DefaultMaterialManager._defaultTexture;
            };

            DefaultMaterialManager.createDefaultTexture = function () {
                DefaultMaterialManager._defaultTextureBitmapData = DefaultMaterialManager.createCheckeredBitmapData();

                //create chekerboard
                /*
                var i:number, j:number;
                for (i = 0; i < 8; i++)
                {
                for (j = 0; j < 8; j++)
                {
                if ((j & 1) ^ (i & 1))
                {
                DefaultMaterialManager._defaultTextureBitmapData.setPixel(i, j, 0XFFFFFF);
                }
                }
                }
                */
                DefaultMaterialManager._defaultTexture = new away.textures.BitmapTexture(DefaultMaterialManager._defaultTextureBitmapData, false);
                DefaultMaterialManager._defaultTexture.name = "defaultTexture";
            };

            DefaultMaterialManager.createCheckeredBitmapData = function () {
                var b = new away.display.BitmapData(8, 8, false, 0x000000);

                //create chekerboard
                var i, j;
                for (i = 0; i < 8; i++) {
                    for (j = 0; j < 8; j++) {
                        if ((j & 1) ^ (i & 1)) {
                            b.setPixel(i, j, 0XFFFFFF);
                        }
                    }
                }

                return b;
            };

            DefaultMaterialManager.createDefaultMaterial = function () {
                DefaultMaterialManager._defaultMaterial = new away.materials.TextureMaterial(DefaultMaterialManager._defaultTexture);
                DefaultMaterialManager._defaultMaterial.mipmap = false;
                DefaultMaterialManager._defaultMaterial.smooth = false;
                DefaultMaterialManager._defaultMaterial.name = "defaultMaterial";
            };
            return DefaultMaterialManager;
        })();
        materials.DefaultMaterialManager = DefaultMaterialManager;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (materials) {
        //import away3d.arcane;
        /**
        * LightingShaderCompiler is a ShaderCompiler that generates code for passes performing shading only (no effect passes)
        */
        var LightingShaderCompiler = (function (_super) {
            __extends(LightingShaderCompiler, _super);
            //use namespace arcane;
            /**
            * Create a new LightingShaderCompiler object.
            * @param profile The compatibility profile of the renderer.
            */
            function LightingShaderCompiler(profile) {
                _super.call(this, profile);
            }
            Object.defineProperty(LightingShaderCompiler.prototype, "lightVertexConstantIndex", {
                get: /**
                * The starting index if the vertex constant to which light data needs to be uploaded.
                */
                function () {
                    return this._lightVertexConstantIndex;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pInitRegisterIndices = function () {
                _super.prototype.pInitRegisterIndices.call(this);
                this._lightVertexConstantIndex = -1;
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCreateNormalRegisters = function () {
                if (this.tangentSpace) {
                    this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);
                    this._pSharedRegisters.bitangent = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.bitangent, 1);

                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;

                    this._pAnimatableAttributes.push(this._pSharedRegisters.tangentInput.toString());
                    this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedTangent.toString());
                }

                this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
                this._pNormalBufferIndex = this._pSharedRegisters.normalInput.index;

                this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);

                this._pAnimatableAttributes.push(this._pSharedRegisters.normalInput.toString());
                this._pAnimationTargetRegisters.push(this._pSharedRegisters.animatedNormal.toString());
            };

            Object.defineProperty(LightingShaderCompiler.prototype, "tangentSpace", {
                get: /**
                * Indicates whether or not lighting happens in tangent space. This is only the case if no world-space
                * dependencies exist.
                */
                function () {
                    return this._pNumLightProbes == 0 && this._pMethodSetup._iNormalMethod.iHasOutput && this._pMethodSetup._iNormalMethod.iTangentSpace;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pInitLightData = function () {
                _super.prototype.pInitLightData.call(this);

                this._pointLightVertexConstants = new Array(this._pNumPointLights);
                this._pointLightFragmentConstants = new Array(this._pNumPointLights * 2);

                if (this.tangentSpace) {
                    this._dirLightVertexConstants = new Array(this._pNumDirectionalLights);
                    this._dirLightFragmentConstants = new Array(this._pNumDirectionalLights * 2);
                } else {
                    this._dirLightFragmentConstants = new Array(this._pNumDirectionalLights * 3);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCalculateDependencies = function () {
                _super.prototype.pCalculateDependencies.call(this);

                if (!this.tangentSpace) {
                    this._pDependencyCounter.addWorldSpaceDependencies(false);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileNormalCode = function () {
                this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pDependencyCounter.normalDependencies);

                if (this._pMethodSetup._iNormalMethod.iHasOutput && !this._pMethodSetup._iNormalMethod.iTangentSpace) {
                    this._pVertexCode += this._pMethodSetup._iNormalMethod.iGetVertexCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                    return;
                }

                if (this.tangentSpace) {
                    this.compileTangentSpaceNormalMapCode();
                } else {
                    var normalMatrix = new Array(3);
                    normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
                    normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
                    normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();

                    this._pRegisterCache.getFreeVertexConstant();

                    this._pSceneNormalMatrixIndex = normalMatrix[0].index * 4;
                    this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();

                    // no output, world space is enough
                    this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" + "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.animatedNormal + ".w	\n";

                    this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalVarying + "\n" + "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w		\n";
                }

                if (this._pDependencyCounter.tangentDependencies > 0) {
                    this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
                    this._pTangentBufferIndex = this._pSharedRegisters.tangentInput.index;
                    this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
                }
            };

            /**
            * Generates code to retrieve the tangent space normal from the normal map
            */
            LightingShaderCompiler.prototype.compileTangentSpaceNormalMapCode = function () {
                // normalize normal + tangent vector and generate (approximated) bitangent
                this._pVertexCode += "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + this._pSharedRegisters.animatedNormal + "\n" + "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + this._pSharedRegisters.animatedTangent + "\n";
                this._pVertexCode += "crs " + this._pSharedRegisters.bitangent + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n";

                this._pFragmentCode += this._pMethodSetup._iNormalMethod.iGetFragmentCode(this._pMethodSetup._iNormalMethodVO, this._pRegisterCache, this._pSharedRegisters.normalFragment);

                if (this._pMethodSetup._iNormalMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iNormalMethodVO.needsGlobalFragmentPos || this._pMethodSetup._iNormalMethodVO.needsGlobalVertexPos) {
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileViewDirCode = function () {
                var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();
                this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
                this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pDependencyCounter.viewDirDependencies);

                this._pCameraPositionIndex = cameraPositionReg.index * 4;

                if (this.tangentSpace) {
                    var temp = this._pRegisterCache.getFreeVertexVectorTemp();
                    this._pVertexCode += "sub " + temp + ", " + cameraPositionReg + ", " + this._pSharedRegisters.localPosition + "\n" + "m33 " + this._pSharedRegisters.viewDirVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + this._pSharedRegisters.viewDirVarying + ".w, " + this._pSharedRegisters.localPosition + ".w\n";
                } else {
                    this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                    this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
                }

                this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment + ".xyz, " + this._pSharedRegisters.viewDirVarying + "\n" + "mov " + this._pSharedRegisters.viewDirFragment + ".w,   " + this._pSharedRegisters.viewDirVarying + ".w 		\n";
            };

            /**
            * @inheritDoc
            */
            LightingShaderCompiler.prototype.pCompileLightingCode = function () {
                if (this._pMethodSetup._iShadowMethod)
                    this.compileShadowCode();

                this._pMethodSetup._iDiffuseMethod.iShadowRegister = this._shadowRegister;

                this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
                this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);

                this._pVertexCode += this._pMethodSetup._iDiffuseMethod.iGetVertexCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache);

                if (this._usingSpecularMethod) {
                    this._pVertexCode += this._pMethodSetup._iSpecularMethod.iGetVertexCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPreLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache);
                }

                if (this.pUsesLights()) {
                    this.initLightRegisters();
                    this.compileDirectionalLightCode();
                    this.compilePointLightCode();
                }

                if (this.pUsesProbes())
                    this.compileLightProbeCode();

                // only need to create and reserve _shadedTargetReg here, no earlier?
                this._pVertexCode += this._pMethodSetup._iAmbientMethod.iGetVertexCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iAmbientMethod.iGetFragmentCode(this._pMethodSetup._iAmbientMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pMethodSetup._iAmbientMethodVO.needsNormals) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                }

                if (this._pMethodSetup._iAmbientMethodVO.needsView) {
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iDiffuseMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);

                if (this._pAlphaPremultiplied) {
                    this._pFragmentCode += "add " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "div " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ".w\n" + "sub " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".z\n" + "sat " + this._pSharedRegisters.shadedTarget + ".xyz, " + this._pSharedRegisters.shadedTarget + "\n";
                }

                if (this._pMethodSetup._iDiffuseMethodVO.needsNormals)
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                if (this._pMethodSetup._iDiffuseMethodVO.needsView)
                    this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);

                if (this._usingSpecularMethod) {
                    this._pMethodSetup._iSpecularMethod.iShadowRegister = this._shadowRegister;
                    this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentPostLightingCode(this._pMethodSetup._iSpecularMethodVO, this._pRegisterCache, this._pSharedRegisters.shadedTarget);
                    if (this._pMethodSetup._iSpecularMethodVO.needsNormals)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.normalFragment);
                    if (this._pMethodSetup._iSpecularMethodVO.needsView)
                        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.viewDirFragment);
                }

                if (this._pMethodSetup._iShadowMethod) {
                    this._pRegisterCache.removeFragmentTempUsage(this._shadowRegister);
                }
            };

            /**
            * Provides the code to provide shadow mapping.
            */
            LightingShaderCompiler.prototype.compileShadowCode = function () {
                if (this._pSharedRegisters.normalFragment)
                    this._shadowRegister = this._pSharedRegisters.normalFragment;
else
                    this._shadowRegister = this._pRegisterCache.getFreeFragmentVectorTemp();

                this._pRegisterCache.addFragmentTempUsages(this._shadowRegister, 1);

                this._pVertexCode += this._pMethodSetup._iShadowMethod.iGetVertexCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache);
                this._pFragmentCode += this._pMethodSetup._iShadowMethod.iGetFragmentCode(this._pMethodSetup._iShadowMethodVO, this._pRegisterCache, this._shadowRegister);
            };

            /**
            * Initializes constant registers to contain light data.
            */
            LightingShaderCompiler.prototype.initLightRegisters = function () {
                // init these first so we're sure they're in sequence
                var i, len;

                if (this._dirLightVertexConstants) {
                    len = this._dirLightVertexConstants.length;

                    for (i = 0; i < len; ++i) {
                        this._dirLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();

                        if (this._lightVertexConstantIndex == -1) {
                            this._lightVertexConstantIndex = this._dirLightVertexConstants[i].index * 4;
                        }
                    }
                }

                len = this._pointLightVertexConstants.length;
                for (i = 0; i < len; ++i) {
                    this._pointLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();

                    if (this._lightVertexConstantIndex == -1) {
                        this._lightVertexConstantIndex = this._pointLightVertexConstants[i].index * 4;
                    }
                }

                len = this._dirLightFragmentConstants.length;
                for (i = 0; i < len; ++i) {
                    this._dirLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._dirLightFragmentConstants[i].index * 4;
                    }
                }

                len = this._pointLightFragmentConstants.length;

                for (i = 0; i < len; ++i) {
                    this._pointLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = this._pointLightFragmentConstants[i].index * 4;
                    }
                }
            };

            /**
            * Compiles the shading code for directional lights.
            */
            LightingShaderCompiler.prototype.compileDirectionalLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightDirReg;
                var vertexRegIndex = 0;
                var fragmentRegIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff))
                    return;

                for (var i = 0; i < this._pNumDirectionalLights; ++i) {
                    if (this.tangentSpace) {
                        lightDirReg = this._dirLightVertexConstants[vertexRegIndex++];

                        var lightVarying = this._pRegisterCache.getFreeVarying();

                        this._pVertexCode += "m33 " + lightVarying + ".xyz, " + lightDirReg + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + lightVarying + ".w, " + lightDirReg + ".w\n";

                        lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
                        this._pRegisterCache.addVertexTempUsages(lightDirReg, 1);
                        this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
                        this._pFragmentCode += "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
                    } else {
                        lightDirReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    }

                    diffuseColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    specularColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    if (this.tangentSpace)
                        this._pRegisterCache.removeVertexTempUsage(lightDirReg);
                }
            };

            /**
            * Compiles the shading code for point lights.
            */
            LightingShaderCompiler.prototype.compilePointLightCode = function () {
                var diffuseColorReg;
                var specularColorReg;
                var lightPosReg;
                var lightDirReg;
                var vertexRegIndex = 0;
                var fragmentRegIndex = 0;
                var addSpec = this._usingSpecularMethod && this.pUsesLightsForSpecular();
                var addDiff = this.pUsesLightsForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                for (var i = 0; i < this._pNumPointLights; ++i) {
                    lightPosReg = this._pointLightVertexConstants[vertexRegIndex++];
                    diffuseColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
                    specularColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
                    lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();

                    this._pRegisterCache.addFragmentTempUsages(lightDirReg, 1);

                    var lightVarying = this._pRegisterCache.getFreeVarying();
                    if (this.tangentSpace) {
                        var temp = this._pRegisterCache.getFreeVertexVectorTemp();
                        this._pVertexCode += "sub " + temp + ", " + lightPosReg + ", " + this._pSharedRegisters.localPosition + "\n" + "m33 " + lightVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" + "mov " + lightVarying + ".w, " + this._pSharedRegisters.localPosition + ".w\n";
                    } else {
                        this._pVertexCode += "sub " + lightVarying + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
                    }

                    if (this._pEnableLightFallOff && this._pProfile != "baselineConstrained") {
                        // calculate attenuation
                        this._pFragmentCode += "dp3 " + lightDirReg + ".w, " + lightVarying + ", " + lightVarying + "\n" + "sub " + lightDirReg + ".w, " + lightDirReg + ".w, " + diffuseColorReg + ".w\n" + "mul " + lightDirReg + ".w, " + lightDirReg + ".w, " + specularColorReg + ".w\n" + "sat " + lightDirReg + ".w, " + lightDirReg + ".w\n" + "sub " + lightDirReg + ".w, " + this._pSharedRegisters.commons + ".w, " + lightDirReg + ".w\n" + "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
                    } else {
                        this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" + "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
                    }

                    if (this._pLightFragmentConstantIndex == -1) {
                        this._pLightFragmentConstantIndex = lightPosReg.index * 4;
                    }

                    if (addDiff) {
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerLight(this._pMethodSetup._iDiffuseMethodVO, lightDirReg, diffuseColorReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerLight(this._pMethodSetup._iSpecularMethodVO, lightDirReg, specularColorReg, this._pRegisterCache);
                    }

                    this._pRegisterCache.removeFragmentTempUsage(lightDirReg);
                }
            };

            /**
            * Compiles shading code for light probes.
            */
            LightingShaderCompiler.prototype.compileLightProbeCode = function () {
                var weightReg;
                var weightComponents = [".x", ".y", ".z", ".w"];
                var weightRegisters = new Array();
                var i;
                var texReg;
                var addSpec = this._usingSpecularMethod && this.pUsesProbesForSpecular();
                var addDiff = this.pUsesProbesForDiffuse();

                if (!(addSpec || addDiff)) {
                    return;
                }

                if (addDiff) {
                    this._pLightProbeDiffuseIndices = new Array();
                }
                if (addSpec) {
                    this._pLightProbeSpecularIndices = new Array();
                }

                for (i = 0; i < this._pNumProbeRegisters; ++i) {
                    weightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();
                    if (i == 0) {
                        this._pProbeWeightsIndex = weightRegisters[i].index * 4;
                    }
                }

                for (i = 0; i < this._pNumLightProbes; ++i) {
                    weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];

                    if (addDiff) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeDiffuseIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iDiffuseMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iDiffuseMethodVO, texReg, weightReg, this._pRegisterCache);
                    }

                    if (addSpec) {
                        texReg = this._pRegisterCache.getFreeTextureReg();
                        this._pLightProbeSpecularIndices[i] = texReg.index;
                        this._pFragmentCode += this._pMethodSetup._iSpecularMethod.iGetFragmentCodePerProbe(this._pMethodSetup._iSpecularMethodVO, texReg, weightReg, this._pRegisterCache);
                    }
                }
            };
            return LightingShaderCompiler;
        })(away.materials.ShaderCompiler);
        materials.LightingShaderCompiler = LightingShaderCompiler;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * SegmentMaterial is a material exclusively used to render wireframe objects
        *
        * @see away3d.entities.Lines
        */
        var SegmentMaterial = (function (_super) {
            __extends(SegmentMaterial, _super);
            /**
            * Creates a new SegmentMaterial object.
            *
            * @param thickness The thickness of the wireframe lines.
            */
            function SegmentMaterial(thickness) {
                if (typeof thickness === "undefined") { thickness = 1.25; }
                _super.call(this);

                this.bothSides = true;
                this.pAddPass(this._screenPass = new away.materials.SegmentPass(thickness));
                this._screenPass.material = this;
            }
            return SegmentMaterial;
        })(away.materials.MaterialBase);
        materials.SegmentMaterial = SegmentMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (materials) {
        /**
        * SkyBoxMaterial is a material exclusively used to render skyboxes
        *
        * @see away3d.primitives.SkyBox
        */
        var SkyBoxMaterial = (function (_super) {
            __extends(SkyBoxMaterial, _super);
            /**
            * Creates a new SkyBoxMaterial object.
            * @param cubeMap The CubeMap to use as the skybox.
            */
            function SkyBoxMaterial(cubeMap) {
                _super.call(this);

                this._cubeMap = cubeMap;
                this.pAddPass(this._skyboxPass = new away.materials.SkyBoxPass());
                this._skyboxPass.cubeTexture = this._cubeMap;
            }
            Object.defineProperty(SkyBoxMaterial.prototype, "cubeMap", {
                get: /**
                * The cube texture to use as the skybox.
                */
                function () {
                    return this._cubeMap;
                },
                set: function (value) {
                    if (value && this._cubeMap && (value.hasMipMaps != this._cubeMap.hasMipMaps || value.format != this._cubeMap.format))
                        this.iInvalidatePasses(null);

                    this._cubeMap = value;
                    this._skyboxPass.cubeTexture = this._cubeMap;
                },
                enumerable: true,
                configurable: true
            });

            return SkyBoxMaterial;
        })(away.materials.MaterialBase);
        materials.SkyBoxMaterial = SkyBoxMaterial;
    })(away.materials || (away.materials = {}));
    var materials = away.materials;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (sort) {
        var RenderableMergeSort = (function () {
            function RenderableMergeSort() {
            }
            RenderableMergeSort.prototype.sort = function (collector) {
                collector.opaqueRenderableHead = this.mergeSortByMaterial(collector.opaqueRenderableHead);
                collector.blendedRenderableHead = this.mergeSortByDepth(collector.blendedRenderableHead);
            };

            RenderableMergeSort.prototype.mergeSortByDepth = function (head) {
                var headB;
                var fast;
                var slow;

                if (!head || !head.next) {
                    return head;
                }

                // split in two sublists
                slow = head;
                fast = head.next;

                while (fast) {
                    fast = fast.next;
                    if (fast) {
                        slow = slow.next;
                        fast = fast.next;
                    }
                }

                headB = slow.next;
                slow.next = null;

                // recurse
                head = this.mergeSortByDepth(head);
                headB = this.mergeSortByDepth(headB);

                // merge sublists while respecting order
                var result;
                var curr;
                var l;

                if (!head)
                    return headB;
                if (!headB)
                    return head;

                while (head && headB) {
                    if (head.zIndex < headB.zIndex) {
                        l = head;
                        head = head.next;
                    } else {
                        l = headB;
                        headB = headB.next;
                    }

                    if (!result)
                        result = l;
else
                        curr.next = l;

                    curr = l;
                }

                if (head)
                    curr.next = head;
else if (headB)
                    curr.next = headB;

                return result;
            };

            RenderableMergeSort.prototype.mergeSortByMaterial = function (head) {
                var headB;
                var fast, slow;

                if (!head || !head.next) {
                    return head;
                }

                // split in two sublists
                slow = head;
                fast = head.next;

                while (fast) {
                    fast = fast.next;
                    if (fast) {
                        slow = slow.next;
                        fast = fast.next;
                    }
                }

                headB = slow.next;
                slow.next = null;

                // recurse
                head = this.mergeSortByMaterial(head);
                headB = this.mergeSortByMaterial(headB);

                // merge sublists while respecting order
                var result;
                var curr;
                var l;
                var cmp = 0;

                if (!head)
                    return headB;
                if (!headB)
                    return head;

                while (head && headB && head != null && headB != null) {
                    // first sort per render order id (reduces program3D switches),
                    // then on material id (reduces setting props),
                    // then on zIndex (reduces overdraw)
                    var aid = head.renderOrderId;
                    var bid = headB.renderOrderId;

                    if (aid == bid) {
                        var ma = head.materialId;
                        var mb = headB.materialId;

                        if (ma == mb) {
                            if (head.zIndex < headB.zIndex)
                                cmp = 1;
else
                                cmp = -1;
                        } else if (ma > mb)
                            cmp = 1;
else
                            cmp = -1;
                    } else if (aid > bid)
                        cmp = 1;
else
                        cmp = -1;

                    if (cmp < 0) {
                        l = head;
                        head = head.next;
                    } else {
                        l = headB;
                        headB = headB.next;
                    }

                    if (!result) {
                        result = l;
                        curr = l;
                    } else {
                        curr.next = l;
                        curr = l;
                    }
                }

                if (head)
                    curr.next = head;
else if (headB)
                    curr.next = headB;

                return result;
            };
            return RenderableMergeSort;
        })();
        sort.RenderableMergeSort = RenderableMergeSort;
    })(away.sort || (away.sort = {}));
    var sort = away.sort;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (render) {
        /**
        * RendererBase forms an abstract base class for classes that are used in the rendering pipeline to render geometry
        * to the back buffer or a texture.
        */
        var RendererBase = (function () {
            /**
            * Creates a new RendererBase object.
            */
            function RendererBase(renderToTexture) {
                if (typeof renderToTexture === "undefined") { renderToTexture = false; }
                this._backgroundR = 0;
                this._backgroundG = 0;
                this._backgroundB = 0;
                this._backgroundAlpha = 1;
                this._shareContext = false;
                this._textureRatioX = 1;
                this._textureRatioY = 1;
                this._clearOnRender = true;
                this._pRttViewProjectionMatrix = new away.geom.Matrix3D();
                this._pRenderableSorter = new away.sort.RenderableMergeSort();
                this._renderToTexture = renderToTexture;
            }
            RendererBase.prototype.iCreateEntityCollector = function () {
                return new away.traverse.EntityCollector();
            };

            Object.defineProperty(RendererBase.prototype, "iViewWidth", {
                get: function () {
                    return this._viewWidth;
                },
                set: function (value) {
                    this._viewWidth = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iViewHeight", {
                get: function () {
                    return this._viewHeight;
                },
                set: function (value) {
                    this._viewHeight = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iRenderToTexture", {
                get: function () {
                    return this._renderToTexture;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RendererBase.prototype, "renderableSorter", {
                get: function () {
                    return this._pRenderableSorter;
                },
                set: function (value) {
                    this._pRenderableSorter = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iClearOnRender", {
                get: function () {
                    return this._clearOnRender;
                },
                set: function (value) {
                    this._clearOnRender = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iBackgroundR", {
                get: /**
                * The background color's red component, used when clearing.
                *
                * @private
                */
                function () {
                    return this._backgroundR;
                },
                set: function (value) {
                    this._backgroundR = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iBackgroundG", {
                get: /**
                * The background color's green component, used when clearing.
                *
                * @private
                */
                function () {
                    return this._backgroundG;
                },
                set: function (value) {
                    this._backgroundG = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iBackgroundB", {
                get: /**
                * The background color's blue component, used when clearing.
                *
                * @private
                */
                function () {
                    return this._backgroundB;
                },
                set: function (value) {
                    this._backgroundB = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iStage3DProxy", {
                get: /**
                * The Stage3DProxy that will provide the Context3D used for rendering.
                *
                * @private
                */
                function () {
                    return this._pStage3DProxy;
                },
                set: function (value) {
                    this.iSetStage3DProxy(value);
                },
                enumerable: true,
                configurable: true
            });


            RendererBase.prototype.iSetStage3DProxy = function (value) {
                if (value == this._pStage3DProxy) {
                    return;
                }

                if (!value) {
                    if (this._pStage3DProxy) {
                        this._pStage3DProxy.removeEventListener(away.events.Stage3DEvent.CONTEXT3D_CREATED, this.onContextUpdate, this);
                        this._pStage3DProxy.removeEventListener(away.events.Stage3DEvent.CONTEXT3D_RECREATED, this.onContextUpdate, this);
                    }

                    this._pStage3DProxy = null;
                    this._pContext = null;

                    return;
                }

                //else if (_pStage3DProxy) throw new Error("A Stage3D instance was already assigned!");
                this._pStage3DProxy = value;
                this._pStage3DProxy.addEventListener(away.events.Stage3DEvent.CONTEXT3D_CREATED, this.onContextUpdate, this);
                this._pStage3DProxy.addEventListener(away.events.Stage3DEvent.CONTEXT3D_RECREATED, this.onContextUpdate, this);

                if (value.context3D)
                    this._pContext = value.context3D;
            };

            Object.defineProperty(RendererBase.prototype, "iShareContext", {
                get: /**
                * Defers control of Context3D clear() and present() calls to Stage3DProxy, enabling multiple Stage3D frameworks
                * to share the same Context3D object.
                *
                * @private
                */
                function () {
                    return this._shareContext;
                },
                set: function (value) {
                    this._shareContext = value;
                },
                enumerable: true,
                configurable: true
            });


            /**
            * Disposes the resources used by the RendererBase.
            *
            * @private
            */
            RendererBase.prototype.iDispose = function () {
                this._pStage3DProxy = null;
                /*
                if (_backgroundImageRenderer) {
                _backgroundImageRenderer.dispose();
                _backgroundImageRenderer = null;
                }
                */
            };

            /**
            * Renders the potentially visible geometry to the back buffer or texture.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            * @param target An option target texture to render to.
            * @param surfaceSelector The index of a CubeTexture's face to render to.
            * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
            */
            RendererBase.prototype.iRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                if (!this._pStage3DProxy || !this._pContext || !entityCollector.entityHead) {
                    return;
                }

                this._pRttViewProjectionMatrix.copyFrom(entityCollector.camera.viewProjection);
                this._pRttViewProjectionMatrix.appendScale(this._textureRatioX, this._textureRatioY, 1);

                this.pExecuteRender(entityCollector, target, scissorRect, surfaceSelector);

                if (target) {
                    (target).generateMipmaps();
                }

                for (var i = 0; i < 8; ++i) {
                    this._pContext.setVertexBufferAt(i, null);
                    this._pContext.setTextureAt(i, null);
                }
            };

            /**
            * Renders the potentially visible geometry to the back buffer or texture. Only executed if everything is set up.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            * @param target An option target texture to render to.
            * @param surfaceSelector The index of a CubeTexture's face to render to.
            * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
            */
            RendererBase.prototype.pExecuteRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                this._pRenderTarget = target;
                this._pRenderTargetSurface = surfaceSelector;

                if (this._pRenderableSorter) {
                    this._pRenderableSorter.sort(entityCollector);
                }

                if (this._renderToTexture) {
                    this.pExecuteRenderToTexturePass(entityCollector);
                }

                this._pStage3DProxy.setRenderTarget(target, true, surfaceSelector);

                if ((target || !this._shareContext) && this._clearOnRender) {
                    this._pContext.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);
                }

                this._pContext.setDepthTest(false, away.display3D.Context3DCompareMode.ALWAYS);

                this._pStage3DProxy.scissorRect = scissorRect;

                /*
                if (_backgroundImageRenderer)
                _backgroundImageRenderer.render();
                */
                this.pDraw(entityCollector, target);

                if (!this._shareContext) {
                    if (this._snapshotRequired && this._snapshotBitmapData) {
                        this._pContext.drawToBitmapData(this._snapshotBitmapData);
                        this._snapshotRequired = false;
                    }
                }
                this._pStage3DProxy.scissorRect = null;
            };

            /*
            * Will draw the renderer's output on next render to the provided bitmap data.
            * */
            RendererBase.prototype.queueSnapshot = function (bmd) {
                this._snapshotRequired = true;
                this._snapshotBitmapData = bmd;
            };

            RendererBase.prototype.pExecuteRenderToTexturePass = function (entityCollector) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Performs the actual drawing of geometry to the target.
            * @param entityCollector The EntityCollector object containing the potentially visible geometry.
            */
            RendererBase.prototype.pDraw = function (entityCollector, target) {
                throw new away.errors.AbstractMethodError();
            };

            /**
            * Assign the context once retrieved
            */
            RendererBase.prototype.onContextUpdate = function (event) {
                this._pContext = this._pStage3DProxy.context3D;
            };

            Object.defineProperty(RendererBase.prototype, "iBackgroundAlpha", {
                get: function () {
                    return this._backgroundAlpha;
                },
                set: function (value) {
                    this._backgroundAlpha = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "antiAlias", {
                get: /*
                public get iBackground():away.textures.Texture2DBase
                {
                return this._background;
                }
                */
                /*
                public set iBackground(value:away.textures.Texture2DBase)
                {
                if (this._backgroundImageRenderer && !value) {
                this._backgroundImageRenderer.dispose();
                this._backgroundImageRenderer = null;
                }
                
                if (!this._backgroundImageRenderer && value)
                {
                
                this._backgroundImageRenderer = new BackgroundImageRenderer(this._pStage3DProxy);
                
                }
                
                
                this._background = value;
                
                if (this._backgroundImageRenderer)
                this._backgroundImageRenderer.texture = value;
                }
                */
                /*
                public get backgroundImageRenderer():BackgroundImageRenderer
                {
                return _backgroundImageRenderer;
                }
                */
                function () {
                    return this._antiAlias;
                },
                set: function (antiAlias) {
                    this._antiAlias = antiAlias;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iTextureRatioX", {
                get: function () {
                    return this._textureRatioX;
                },
                set: function (value) {
                    this._textureRatioX = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RendererBase.prototype, "iTextureRatioY", {
                get: function () {
                    return this._textureRatioY;
                },
                set: function (value) {
                    this._textureRatioY = value;
                },
                enumerable: true,
                configurable: true
            });

            return RendererBase;
        })();
        render.RendererBase = RendererBase;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (render) {
        /**
        * The DepthRenderer class renders 32-bit depth information encoded as RGBA
        */
        var DepthRenderer = (function (_super) {
            __extends(DepthRenderer, _super);
            /**
            * Creates a new DepthRenderer object.
            * @param renderBlended Indicates whether semi-transparent objects should be rendered.
            * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
            */
            function DepthRenderer(renderBlended, distanceBased) {
                if (typeof renderBlended === "undefined") { renderBlended = false; }
                if (typeof distanceBased === "undefined") { distanceBased = false; }
                _super.call(this);

                this._renderBlended = renderBlended;
                this._distanceBased = distanceBased;
                this.iBackgroundR = 1;
                this.iBackgroundG = 1;
                this.iBackgroundB = 1;
            }
            Object.defineProperty(DepthRenderer.prototype, "disableColor", {
                get: function () {
                    return this._disableColor;
                },
                set: function (value) {
                    this._disableColor = value;
                },
                enumerable: true,
                configurable: true
            });


            DepthRenderer.prototype.iRenderCascades = function (entityCollector, target, numCascades, scissorRects, cameras) {
                this._pRenderTarget = target;
                this._pRenderTargetSurface = 0;

                this._pRenderableSorter.sort(entityCollector);

                this._pStage3DProxy.setRenderTarget(target, true, 0);
                this._pContext.clear(1, 1, 1, 1, 1, 0);

                this._pContext.setBlendFactors(away.display3D.Context3DBlendFactor.ONE, away.display3D.Context3DBlendFactor.ZERO);
                this._pContext.setDepthTest(true, away.display3D.Context3DCompareMode.LESS);

                var head = entityCollector.opaqueRenderableHead;

                var first = true;

                for (var i = numCascades - 1; i >= 0; --i) {
                    this._pStage3DProxy.scissorRect = scissorRects[i];
                    this.drawCascadeRenderables(head, cameras[i], first ? null : cameras[i].frustumPlanes);
                    first = false;
                }

                if (this._activeMaterial) {
                    this._activeMaterial.iDeactivateForDepth(this._pStage3DProxy);
                }

                this._activeMaterial = null;

                //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
                this._pContext.setDepthTest(false, away.display3D.Context3DCompareMode.LESS_EQUAL);

                this._pStage3DProxy.scissorRect = null;
            };

            DepthRenderer.prototype.drawCascadeRenderables = function (item, camera, cullPlanes) {
                var material;

                while (item) {
                    if (item.cascaded) {
                        item = item.next;
                        continue;
                    }

                    var renderable = item.renderable;

                    var entity = renderable.sourceEntity;

                    if (!cullPlanes || entity.worldBounds.isInFrustum(cullPlanes, 4)) {
                        material = renderable.material;

                        if (this._activeMaterial != material) {
                            if (this._activeMaterial) {
                                this._activeMaterial.iDeactivateForDepth(this._pStage3DProxy);
                            }

                            this._activeMaterial = material;
                            this._activeMaterial.iActivateForDepth(this._pStage3DProxy, camera, false);
                        }

                        this._activeMaterial.iRenderDepth(renderable, this._pStage3DProxy, camera, camera.viewProjection);
                    } else {
                        item.cascaded = true;
                    }

                    item = item.next;
                }
            };

            /**
            * @inheritDoc
            */
            DepthRenderer.prototype.pDraw = function (entityCollector, target) {
                this._pContext.setBlendFactors(away.display3D.Context3DBlendFactor.ONE, away.display3D.Context3DBlendFactor.ZERO);

                this._pContext.setDepthTest(true, away.display3D.Context3DCompareMode.LESS);

                this.drawRenderables(entityCollector.opaqueRenderableHead, entityCollector);

                if (this._disableColor)
                    this._pContext.setColorMask(false, false, false, false);

                if (this._renderBlended)
                    this.drawRenderables(entityCollector.blendedRenderableHead, entityCollector);

                if (this._activeMaterial)
                    this._activeMaterial.iDeactivateForDepth(this._pStage3DProxy);

                if (this._disableColor)
                    this._pContext.setColorMask(true, true, true, true);

                this._activeMaterial = null;
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DepthRenderer.prototype.drawRenderables = function (item, entityCollector) {
                var camera = entityCollector.camera;
                var item2;

                while (item) {
                    this._activeMaterial = item.renderable.material;

                    if (this._disableColor && this._activeMaterial.iHasDepthAlphaThreshold()) {
                        item2 = item;

                        do {
                            item2 = item2.next;
                        } while(item2 && item2.renderable.material == this._activeMaterial);
                    } else {
                        this._activeMaterial.iActivateForDepth(this._pStage3DProxy, camera, this._distanceBased);
                        item2 = item;
                        do {
                            this._activeMaterial.iRenderDepth(item2.renderable, this._pStage3DProxy, camera, this._pRttViewProjectionMatrix);
                            item2 = item2.next;
                        } while(item2 && item2.renderable.material == this._activeMaterial);

                        this._activeMaterial.iDeactivateForDepth(this._pStage3DProxy);
                    }

                    item = item2;
                }
            };
            return DepthRenderer;
        })(away.render.RendererBase);
        render.DepthRenderer = DepthRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (render) {
        /**
        * The DefaultRenderer class provides the default rendering method. It renders the scene graph objects using the
        * materials assigned to them.
        */
        var DefaultRenderer = (function (_super) {
            __extends(DefaultRenderer, _super);
            /**
            * Creates a new DefaultRenderer object.
            * @param antiAlias The amount of anti-aliasing to use.
            * @param renderMode The render mode to use.
            */
            function DefaultRenderer() {
                _super.call(this);
                this._skyboxProjection = new away.geom.Matrix3D();

                this._pDepthRenderer = new away.render.DepthRenderer();
                this._pDistanceRenderer = new away.render.DepthRenderer(false, true);
            }
            Object.defineProperty(DefaultRenderer.prototype, "iStage3DProxy", {
                set: function (value) {
                    _super.prototype.iSetStage3DProxy.call(this, value);
                    this._pDistanceRenderer.iStage3DProxy = this._pDepthRenderer.iStage3DProxy = value;
                },
                enumerable: true,
                configurable: true
            });

            DefaultRenderer.prototype.pExecuteRender = function (entityCollector, target, scissorRect, surfaceSelector) {
                if (typeof target === "undefined") { target = null; }
                if (typeof scissorRect === "undefined") { scissorRect = null; }
                if (typeof surfaceSelector === "undefined") { surfaceSelector = 0; }
                this.updateLights(entityCollector);

                if (target) {
                    this.drawRenderables(entityCollector.opaqueRenderableHead, entityCollector, DefaultRenderer.RTT_PASSES);
                    this.drawRenderables(entityCollector.blendedRenderableHead, entityCollector, DefaultRenderer.RTT_PASSES);
                }

                _super.prototype.pExecuteRender.call(this, entityCollector, target, scissorRect, surfaceSelector);
            };

            DefaultRenderer.prototype.updateLights = function (entityCollector) {
                var dirLights = entityCollector.directionalLights;
                var pointLights = entityCollector.pointLights;
                var len, i;
                var light;
                var shadowMapper;

                len = dirLights.length;

                for (i = 0; i < len; ++i) {
                    light = dirLights[i];

                    shadowMapper = light.shadowMapper;

                    if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid)) {
                        shadowMapper.iRenderDepthMap(this._pStage3DProxy, entityCollector, this._pDepthRenderer);
                    }
                }

                len = pointLights.length;

                for (i = 0; i < len; ++i) {
                    light = pointLights[i];

                    shadowMapper = light.shadowMapper;

                    if (light.castsShadows && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid)) {
                        shadowMapper.iRenderDepthMap(this._pStage3DProxy, entityCollector, this._pDistanceRenderer);
                    }
                }
            };

            /**
            * @inheritDoc
            */
            DefaultRenderer.prototype.pDraw = function (entityCollector, target) {
                this._pContext.setBlendFactors(away.display3D.Context3DBlendFactor.ONE, away.display3D.Context3DBlendFactor.ZERO);

                if (entityCollector.skyBox) {
                    if (this._activeMaterial) {
                        this._activeMaterial.iDeactivate(this._pStage3DProxy);
                    }

                    this._activeMaterial = null;

                    this._pContext.setDepthTest(false, away.display3D.Context3DCompareMode.ALWAYS);
                    this.drawSkyBox(entityCollector);
                }

                this._pContext.setDepthTest(true, away.display3D.Context3DCompareMode.LESS_EQUAL);

                var which = target ? DefaultRenderer.SCREEN_PASSES : DefaultRenderer.ALL_PASSES;

                this.drawRenderables(entityCollector.opaqueRenderableHead, entityCollector, which);
                this.drawRenderables(entityCollector.blendedRenderableHead, entityCollector, which);

                this._pContext.setDepthTest(false, away.display3D.Context3DCompareMode.LESS_EQUAL);

                if (this._activeMaterial) {
                    this._activeMaterial.iDeactivate(this._pStage3DProxy);
                }

                this._activeMaterial = null;
            };

            /**
            * Draw the skybox if present.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DefaultRenderer.prototype.drawSkyBox = function (entityCollector) {
                var skyBox = entityCollector.skyBox;

                var material = skyBox.material;

                var camera = entityCollector.camera;

                this.updateSkyBoxProjection(camera);

                material.iActivatePass(0, this._pStage3DProxy, camera);
                material.iRenderPass(0, skyBox, this._pStage3DProxy, entityCollector, this._skyboxProjection);
                material.iDeactivatePass(0, this._pStage3DProxy);
            };

            DefaultRenderer.prototype.updateSkyBoxProjection = function (camera) {
                var near = new away.geom.Vector3D();

                this._skyboxProjection.copyFrom(this._pRttViewProjectionMatrix);
                this._skyboxProjection.copyRowTo(2, near);

                var camPos = camera.scenePosition;

                var cx = near.x;
                var cy = near.y;
                var cz = near.z;
                var cw = -(near.x * camPos.x + near.y * camPos.y + near.z * camPos.z + Math.sqrt(cx * cx + cy * cy + cz * cz));

                var signX = cx >= 0 ? 1 : -1;
                var signY = cy >= 0 ? 1 : -1;

                var p = new away.geom.Vector3D(signX, signY, 1, 1);

                var inverse = this._skyboxProjection.clone();
                inverse.invert();

                var q = inverse.transformVector(p);

                this._skyboxProjection.copyRowTo(3, p);

                var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);

                this._skyboxProjection.copyRowFrom(2, new away.geom.Vector3D(cx * a, cy * a, cz * a, cw * a));
            };

            /**
            * Draw a list of renderables.
            * @param renderables The renderables to draw.
            * @param entityCollector The EntityCollector containing all potentially visible information.
            */
            DefaultRenderer.prototype.drawRenderables = function (item, entityCollector, which) {
                var numPasses;
                var j;
                var camera = entityCollector.camera;
                var item2;

                while (item) {
                    //console.log( 'DefaultRenderer' , 'drawRenderables' , item );
                    this._activeMaterial = item.renderable.material;

                    this._activeMaterial.iUpdateMaterial(this._pContext);

                    numPasses = this._activeMaterial._iNumPasses;

                    j = 0;

                    do {
                        item2 = item;

                        var rttMask = this._activeMaterial.iPassRendersToTexture(j) ? 1 : 2;

                        if ((rttMask & which) != 0) {
                            this._activeMaterial.iActivatePass(j, this._pStage3DProxy, camera);

                            do {
                                this._activeMaterial.iRenderPass(j, item2.renderable, this._pStage3DProxy, entityCollector, this._pRttViewProjectionMatrix);

                                item2 = item2.next;
                            } while(item2 && item2.renderable.material == this._activeMaterial);

                            this._activeMaterial.iDeactivatePass(j, this._pStage3DProxy);
                        } else {
                            do {
                                item2 = item2.next;
                            } while(item2 && item2.renderable.material == this._activeMaterial);
                        }
                    } while(++j < numPasses);

                    item = item2;
                }
            };

            DefaultRenderer.prototype.iDispose = function () {
                _super.prototype.iDispose.call(this);

                this._pDepthRenderer.iDispose();
                this._pDistanceRenderer.iDispose();
                this._pDepthRenderer = null;
                this._pDistanceRenderer = null;
            };
            DefaultRenderer.RTT_PASSES = 1;
            DefaultRenderer.SCREEN_PASSES = 2;
            DefaultRenderer.ALL_PASSES = 3;
            return DefaultRenderer;
        })(away.render.RendererBase);
        render.DefaultRenderer = DefaultRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (filters) {
        var Filter3DTaskBase = (function () {
            function Filter3DTaskBase(requireDepthRender) {
                if (typeof requireDepthRender === "undefined") { requireDepthRender = false; }
                this._scaledTextureWidth = -1;
                this._scaledTextureHeight = -1;
                this._textureWidth = -1;
                this._textureHeight = -1;
                this._textureDimensionsInvalid = true;
                this._program3DInvalid = true;
                this._textureScale = 0;
                this._requireDepthRender = requireDepthRender;
            }
            Object.defineProperty(Filter3DTaskBase.prototype, "textureScale", {
                get: /**
                * The texture scale for the input of this texture. This will define the output of the previous entry in the chain
                */
                function () {
                    return this._textureScale;
                },
                set: function (value) {
                    if (this._textureScale == value) {
                        return;
                    }

                    this._textureScale = value;
                    this._scaledTextureWidth = this._textureWidth >> this._textureScale;
                    this._scaledTextureHeight = this._textureHeight >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "target", {
                get: function () {
                    return this._target;
                },
                set: function (value) {
                    this._target = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "textureWidth", {
                get: function () {
                    return this._textureWidth;
                },
                set: function (value) {
                    if (this._textureWidth == value) {
                        return;
                    }

                    this._textureWidth = value;
                    this._scaledTextureWidth = this._textureWidth >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DTaskBase.prototype, "textureHeight", {
                get: function () {
                    return this._textureHeight;
                },
                set: function (value) {
                    if (this._textureHeight == value) {
                        return;
                    }

                    this._textureHeight = value;
                    this._scaledTextureHeight = this._textureHeight >> this._textureScale;
                    this._textureDimensionsInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Filter3DTaskBase.prototype.getMainInputTexture = function (stage) {
                if (this._textureDimensionsInvalid) {
                    this.pUpdateTextures(stage);
                }

                return this._mainInputTexture;
            };

            Filter3DTaskBase.prototype.dispose = function () {
                if (this._mainInputTexture) {
                    this._mainInputTexture.dispose();
                }

                if (this._program3D) {
                    this._program3D.dispose();
                }
            };

            Filter3DTaskBase.prototype.pInvalidateProgram3D = function () {
                this._program3DInvalid = true;
            };

            Filter3DTaskBase.prototype.pUpdateProgram3D = function (stage) {
                if (this._program3D) {
                    this._program3D.dispose();
                }

                this._program3D = stage._iContext3D.createProgram();

                //away.Debug.log( 'Filder3DTaskBase' , 'pUpdateProgram3D' , 'Program3D.upload / AGAL <> GLSL implementation' );
                // TODO: imeplement AGAL <> GLSL
                //this._program3D.upload(new AGALMiniAssembler(Debug.active).assemble(Context3DProgramType.VERTEX, getVertexCode()),new AGALMiniAssembler(Debug.active).assemble(Context3DProgramType.FRAGMENT, getFragmentCode()));
                //new AGALMiniAssembler(Debug.active).assemble(Context3DProgramType.VERTEX, getVertexCode()),
                //new AGALMiniAssembler(Debug.active).assemble(Context3DProgramType.FRAGMENT, getFragmentCode()));
                var vertCompiler = new aglsl.AGLSLCompiler();
                var fragCompiler = new aglsl.AGLSLCompiler();

                var vertString = vertCompiler.compile(away.display3D.Context3DProgramType.VERTEX, this.pGetVertexCode());
                var fragString = fragCompiler.compile(away.display3D.Context3DProgramType.FRAGMENT, this.pGetFragmentCode());

                this._program3D.upload(vertString, fragString);
                this._program3DInvalid = false;
            };

            Filter3DTaskBase.prototype.pGetVertexCode = function () {
                // TODO: imeplement AGAL <> GLSL
                return "mov op, va0\n" + "mov v0, va1\n";
            };

            Filter3DTaskBase.prototype.pGetFragmentCode = function () {
                throw new away.errors.AbstractMethodError();

                return null;
            };

            Filter3DTaskBase.prototype.pUpdateTextures = function (stage) {
                if (this._mainInputTexture) {
                    this._mainInputTexture.dispose();
                }

                this._mainInputTexture = stage._iContext3D.createTexture(this._scaledTextureWidth, this._scaledTextureHeight, away.display3D.Context3DTextureFormat.BGRA, true);

                this._textureDimensionsInvalid = false;
            };

            Filter3DTaskBase.prototype.getProgram3D = function (stage3DProxy) {
                if (this._program3DInvalid) {
                    this.pUpdateProgram3D(stage3DProxy);
                }

                return this._program3D;
            };

            Filter3DTaskBase.prototype.activate = function (stage3DProxy, camera, depthTexture) {
            };

            Filter3DTaskBase.prototype.deactivate = function (stage3DProxy) {
            };

            Object.defineProperty(Filter3DTaskBase.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });
            return Filter3DTaskBase;
        })();
        filters.Filter3DTaskBase = Filter3DTaskBase;
    })(away.filters || (away.filters = {}));
    var filters = away.filters;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (managers) {
        var RTTBufferManager = (function (_super) {
            __extends(RTTBufferManager, _super);
            function RTTBufferManager(se, stage3DProxy) {
                _super.call(this);
                this._viewWidth = -1;
                this._viewHeight = -1;
                this._textureWidth = -1;
                this._textureHeight = -1;
                this._buffersInvalid = true;

                if (!se) {
                    throw new Error("No cheating the multiton!");
                }

                this._renderToTextureRect = new away.geom.Rectangle();

                this._stage3DProxy = stage3DProxy;
            }
            RTTBufferManager.getInstance = function (stage3DProxy) {
                if (!stage3DProxy)
                    throw new Error("stage3DProxy key cannot be null!");

                if (RTTBufferManager._instances == null) {
                    RTTBufferManager._instances = new Array();
                }

                var rttBufferManager = RTTBufferManager.getRTTBufferManagerFromStage3DProxy(stage3DProxy);

                if (rttBufferManager == null) {
                    rttBufferManager = new away.managers.RTTBufferManager(new SingletonEnforcer(), stage3DProxy);

                    var vo = new RTTBufferManagerVO();

                    vo.stage3dProxy = stage3DProxy;
                    vo.rttbfm = rttBufferManager;

                    RTTBufferManager._instances.push(vo);
                }

                return rttBufferManager;
            };

            RTTBufferManager.getRTTBufferManagerFromStage3DProxy = function (stage3DProxy) {
                var l = RTTBufferManager._instances.length;
                var r;

                for (var c = 0; c < l; c++) {
                    r = RTTBufferManager._instances[c];

                    if (r.stage3dProxy === stage3DProxy) {
                        return r.rttbfm;
                    }
                }

                return null;
            };

            RTTBufferManager.deleteRTTBufferManager = function (stage3DProxy) {
                var l = RTTBufferManager._instances.length;
                var r;

                for (var c = 0; c < l; c++) {
                    r = RTTBufferManager._instances[c];

                    if (r.stage3dProxy === stage3DProxy) {
                        RTTBufferManager._instances.splice(c, 1);
                        return;
                    }
                }
            };

            Object.defineProperty(RTTBufferManager.prototype, "textureRatioX", {
                get: function () {
                    if (this._buffersInvalid) {
                        this.updateRTTBuffers();
                    }

                    return this._textureRatioX;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RTTBufferManager.prototype, "textureRatioY", {
                get: function () {
                    if (this._buffersInvalid) {
                        this.updateRTTBuffers();
                    }

                    return this._textureRatioY;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RTTBufferManager.prototype, "viewWidth", {
                get: function () {
                    return this._viewWidth;
                },
                set: function (value) {
                    if (value == this._viewWidth) {
                        return;
                    }

                    this._viewWidth = value;

                    this._buffersInvalid = true;

                    this._textureWidth = away.utils.TextureUtils.getBestPowerOf2(this._viewWidth);

                    if (this._textureWidth > this._viewWidth) {
                        this._renderToTextureRect.x = Math.floor((this._textureWidth - this._viewWidth) * .5);
                        this._renderToTextureRect.width = this._viewWidth;
                    } else {
                        this._renderToTextureRect.x = 0;
                        this._renderToTextureRect.width = this._textureWidth;
                    }

                    this.dispatchEvent(new away.events.Event(away.events.Event.RESIZE));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RTTBufferManager.prototype, "viewHeight", {
                get: function () {
                    return this._viewHeight;
                },
                set: function (value) {
                    if (value == this._viewHeight) {
                        return;
                    }

                    this._viewHeight = value;

                    this._buffersInvalid = true;

                    this._textureHeight = away.utils.TextureUtils.getBestPowerOf2(this._viewHeight);

                    if (this._textureHeight > this._viewHeight) {
                        this._renderToTextureRect.y = Math.floor((this._textureHeight - this._viewHeight) * .5);
                        this._renderToTextureRect.height = this._viewHeight;
                    } else {
                        this._renderToTextureRect.y = 0;
                        this._renderToTextureRect.height = this._textureHeight;
                    }

                    this.dispatchEvent(new away.events.Event(away.events.Event.RESIZE));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(RTTBufferManager.prototype, "renderToTextureVertexBuffer", {
                get: function () {
                    if (this._buffersInvalid) {
                        this.updateRTTBuffers();
                    }

                    return this._renderToTextureVertexBuffer;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RTTBufferManager.prototype, "renderToScreenVertexBuffer", {
                get: function () {
                    if (this._buffersInvalid) {
                        this.updateRTTBuffers();
                    }

                    return this._renderToScreenVertexBuffer;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RTTBufferManager.prototype, "indexBuffer", {
                get: function () {
                    return this._indexBuffer;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RTTBufferManager.prototype, "renderToTextureRect", {
                get: function () {
                    if (this._buffersInvalid) {
                        this.updateRTTBuffers();
                    }

                    return this._renderToTextureRect;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RTTBufferManager.prototype, "textureWidth", {
                get: function () {
                    return this._textureWidth;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(RTTBufferManager.prototype, "textureHeight", {
                get: function () {
                    return this._textureHeight;
                },
                enumerable: true,
                configurable: true
            });

            RTTBufferManager.prototype.dispose = function () {
                RTTBufferManager.deleteRTTBufferManager(this._stage3DProxy);

                if (this._indexBuffer) {
                    this._indexBuffer.dispose();
                    this._renderToScreenVertexBuffer.dispose();
                    this._renderToTextureVertexBuffer.dispose();
                    this._renderToScreenVertexBuffer = null;
                    this._renderToTextureVertexBuffer = null;
                    this._indexBuffer = null;
                }
            };

            // todo: place all this in a separate model, since it's used all over the place
            // maybe it even has a place in the core (together with screenRect etc)?
            // needs to be stored per view of course
            RTTBufferManager.prototype.updateRTTBuffers = function () {
                var context = this._stage3DProxy._iContext3D;
                var textureVerts;
                var screenVerts;

                var x;
                var y;

                if (this._renderToTextureVertexBuffer == null) {
                    this._renderToTextureVertexBuffer = context.createVertexBuffer(4, 5);
                }

                if (this._renderToScreenVertexBuffer == null) {
                    this._renderToScreenVertexBuffer = context.createVertexBuffer(4, 5);
                }

                if (!this._indexBuffer) {
                    this._indexBuffer = context.createIndexBuffer(6);

                    this._indexBuffer.uploadFromArray([2, 1, 0, 3, 2, 0], 0, 6);
                }

                this._textureRatioX = x = Math.min(this._viewWidth / this._textureWidth, 1);
                this._textureRatioY = y = Math.min(this._viewHeight / this._textureHeight, 1);

                var u1 = (1 - x) * .5;
                var u2 = (x + 1) * .5;
                var v1 = (y + 1) * .5;
                var v2 = (1 - y) * .5;

                // last element contains indices for data per vertex that can be passed to the vertex shader if necessary (ie: frustum corners for deferred rendering)
                textureVerts = [
                    -x,
                    -y,
                    u1,
                    v1,
                    0,
                    x,
                    -y,
                    u2,
                    v1,
                    1,
                    x,
                    y,
                    u2,
                    v2,
                    2,
                    -x,
                    y,
                    u1,
                    v2,
                    3
                ];

                screenVerts = [
                    -1,
                    -1,
                    u1,
                    v1,
                    0,
                    1,
                    -1,
                    u2,
                    v1,
                    1,
                    1,
                    1,
                    u2,
                    v2,
                    2,
                    -1,
                    1,
                    u1,
                    v2,
                    3
                ];

                this._renderToTextureVertexBuffer.uploadFromArray(textureVerts, 0, 4);
                this._renderToScreenVertexBuffer.uploadFromArray(screenVerts, 0, 4);

                this._buffersInvalid = false;
            };
            return RTTBufferManager;
        })(away.events.EventDispatcher);
        managers.RTTBufferManager = RTTBufferManager;
    })(away.managers || (away.managers = {}));
    var managers = away.managers;
})(away || (away = {}));

var RTTBufferManagerVO = (function () {
    function RTTBufferManagerVO() {
    }
    return RTTBufferManagerVO;
})();

var SingletonEnforcer = (function () {
    function SingletonEnforcer() {
    }
    return SingletonEnforcer;
})();
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (filters) {
        var Filter3DBase = (function () {
            function Filter3DBase() {
                this._tasks = new Array();
            }
            Object.defineProperty(Filter3DBase.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DBase.prototype.pAddTask = function (filter) {
                this._tasks.push(filter);

                if (this._requireDepthRender == null) {
                    this._requireDepthRender = filter.requireDepthRender;
                }
            };

            Object.defineProperty(Filter3DBase.prototype, "tasks", {
                get: function () {
                    return this._tasks;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DBase.prototype.getMainInputTexture = function (stage3DProxy) {
                return this._tasks[0].getMainInputTexture(stage3DProxy);
            };

            Object.defineProperty(Filter3DBase.prototype, "textureWidth", {
                get: function () {
                    return this._textureWidth;
                },
                set: function (value) {
                    this._textureWidth = value;

                    for (var i = 0; i < this._tasks.length; ++i) {
                        this._tasks[i].textureWidth = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Filter3DBase.prototype, "textureHeight", {
                get: function () {
                    return this._textureHeight;
                },
                set: function (value) {
                    this._textureHeight = value;

                    for (var i = 0; i < this._tasks.length; ++i) {
                        this._tasks[i].textureHeight = value;
                    }
                },
                enumerable: true,
                configurable: true
            });


            // link up the filters correctly with the next filter
            Filter3DBase.prototype.setRenderTargets = function (mainTarget, stage3DProxy) {
                this._tasks[this._tasks.length - 1].target = mainTarget;
            };

            Filter3DBase.prototype.dispose = function () {
                for (var i = 0; i < this._tasks.length; ++i) {
                    this._tasks[i].dispose();
                }
            };

            Filter3DBase.prototype.update = function (stage, camera) {
            };
            return Filter3DBase;
        })();
        filters.Filter3DBase = Filter3DBase;
    })(away.filters || (away.filters = {}));
    var filters = away.filters;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../../_definitions.ts"/>
    (function (render) {
        var Filter3DRenderer = (function () {
            function Filter3DRenderer(stage3DProxy) {
                this._filterSizesInvalid = true;
                this._stage3DProxy = stage3DProxy;
                this._rttManager = away.managers.RTTBufferManager.getInstance(stage3DProxy);
                this._rttManager.addEventListener(away.events.Event.RESIZE, this.onRTTResize, this);
            }
            Filter3DRenderer.prototype.onRTTResize = function (event) {
                this._filterSizesInvalid = true;
            };

            Object.defineProperty(Filter3DRenderer.prototype, "requireDepthRender", {
                get: function () {
                    return this._requireDepthRender;
                },
                enumerable: true,
                configurable: true
            });

            Filter3DRenderer.prototype.getMainInputTexture = function (stage3DProxy) {
                if (this._filterTasksInvalid) {
                    this.updateFilterTasks(stage3DProxy);
                }

                return this._mainInputTexture;
            };

            Object.defineProperty(Filter3DRenderer.prototype, "filters", {
                get: function () {
                    return this._filters;
                },
                set: function (value) {
                    this._filters = value;

                    this._filterTasksInvalid = true;

                    this._requireDepthRender = false;

                    if (!this._filters) {
                        return;
                    }

                    for (var i = 0; i < this._filters.length; ++i) {
                        // TODO: check logic:
                        // this._requireDepthRender ||=  Boolean ( this._filters[i].requireDepthRender )
                        var s = this._filters[i];
                        var b = (s.requireDepthRender == null) ? false : s.requireDepthRender;

                        this._requireDepthRender = this._requireDepthRender || b;
                    }

                    this._filterSizesInvalid = true;
                },
                enumerable: true,
                configurable: true
            });


            Filter3DRenderer.prototype.updateFilterTasks = function (stage3DProxy) {
                var len;

                if (this._filterSizesInvalid) {
                    this.updateFilterSizes();
                }

                if (!this._filters) {
                    this._tasks = null;
                    return;
                }

                this._tasks = new Array();

                len = this._filters.length - 1;

                var filter;

                for (var i = 0; i <= len; ++i) {
                    // make sure all internal tasks are linked together
                    filter = this._filters[i];

                    // TODO: check logic
                    // filter.setRenderTargets(i == len? null : Filter3DBase(_filters[i + 1]).getMainInputTexture(stage3DProxy), stage3DProxy);
                    filter.setRenderTargets(i == len ? null : this._filters[i + 1].getMainInputTexture(stage3DProxy), stage3DProxy);

                    this._tasks = this._tasks.concat(filter.tasks);
                }

                this._mainInputTexture = this._filters[0].getMainInputTexture(stage3DProxy);
            };

            Filter3DRenderer.prototype.render = function (stage3DProxy, camera3D, depthTexture) {
                var len;
                var i;
                var task;
                var context = stage3DProxy._iContext3D;

                var indexBuffer = this._rttManager.indexBuffer;

                var vertexBuffer = this._rttManager.renderToTextureVertexBuffer;

                if (!this._filters) {
                    return;
                }

                if (this._filterSizesInvalid) {
                    this.updateFilterSizes();
                }

                if (this._filterTasksInvalid) {
                    this.updateFilterTasks(stage3DProxy);
                }

                len = this._filters.length;

                for (i = 0; i < len; ++i) {
                    this._filters[i].update(stage3DProxy, camera3D);
                }

                len = this._tasks.length;

                if (len > 1) {
                    context.setVertexBufferAt(0, vertexBuffer, 0, away.display3D.Context3DVertexBufferFormat.FLOAT_2);
                    context.setVertexBufferAt(1, vertexBuffer, 2, away.display3D.Context3DVertexBufferFormat.FLOAT_2);
                }

                for (i = 0; i < len; ++i) {
                    task = this._tasks[i];

                    stage3DProxy.setRenderTarget(task.target);

                    if (!task.target) {
                        stage3DProxy.scissorRect = null;
                        vertexBuffer = this._rttManager.renderToScreenVertexBuffer;
                        context.setVertexBufferAt(0, vertexBuffer, 0, away.display3D.Context3DVertexBufferFormat.FLOAT_2);
                        context.setVertexBufferAt(1, vertexBuffer, 2, away.display3D.Context3DVertexBufferFormat.FLOAT_2);
                    }

                    context.setTextureAt(0, task.getMainInputTexture(stage3DProxy));
                    context.setProgram(task.getProgram3D(stage3DProxy));
                    context.clear(0.0, 0.0, 0.0, 0.0);

                    task.activate(stage3DProxy, camera3D, depthTexture);

                    context.setBlendFactors(away.display3D.Context3DBlendFactor.ONE, away.display3D.Context3DBlendFactor.ZERO);
                    context.drawTriangles(indexBuffer, 0, 2);

                    task.deactivate(stage3DProxy);
                }

                context.setTextureAt(0, null);
                context.setVertexBufferAt(0, null);
                context.setVertexBufferAt(1, null);
            };

            Filter3DRenderer.prototype.updateFilterSizes = function () {
                for (var i = 0; i < this._filters.length; ++i) {
                    this._filters[i].textureWidth = this._rttManager.textureWidth;
                    this._filters[i].textureHeight = this._rttManager.textureHeight;
                }

                this._filterSizesInvalid = true;
            };

            Filter3DRenderer.prototype.dispose = function () {
                this._rttManager.removeEventListener(away.events.Event.RESIZE, this.onRTTResize, this);
                this._rttManager = null;
                this._stage3DProxy = null;
            };
            return Filter3DRenderer;
        })();
        render.Filter3DRenderer = Filter3DRenderer;
    })(away.render || (away.render = {}));
    var render = away.render;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var ByteArrayBase = (function () {
            function ByteArrayBase() {
                this.position = 0;
                this.length = 0;
                this._mode = "";
                this.Base64Key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            }
            ByteArrayBase.prototype.writeByte = function (b) {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.readByte = function () {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.writeUnsignedByte = function (b) {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.readUnsignedByte = function () {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.writeUnsignedShort = function (b) {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.readUnsignedShort = function () {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.writeUnsignedInt = function (b) {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.readUnsignedInt = function () {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.writeFloat = function (b) {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.toFloatBits = function (x) {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.readFloat = function (b) {
                throw "Virtual method";
            };
            ByteArrayBase.prototype.fromFloatBits = function (x) {
                throw "Virtual method";
            };

            ByteArrayBase.prototype.getBytesAvailable = function () {
                throw new away.errors.AbstractMethodError('ByteArrayBase, getBytesAvailable() not implemented ');
            };

            ByteArrayBase.prototype.toString = function () {
                return "[ByteArray] ( " + this._mode + " ) position=" + this.position + " length=" + this.length;
            };

            ByteArrayBase.prototype.compareEqual = function (other, count) {
                if (count == undefined || count > this.length - this.position)
                    count = this.length - this.position;
                if (count > other.length - other.position)
                    count = other.length - other.position;
                var co0 = count;
                var r = true;
                while (r && count >= 4) {
                    count -= 4;
                    if (this.readUnsignedInt() != other.readUnsignedInt())
                        r = false;
                }
                while (r && count >= 1) {
                    count--;
                    if (this.readUnsignedByte() != other.readUnsignedByte())
                        r = false;
                }
                var c0;
                this.position -= (c0 - count);
                other.position -= (c0 - count);
                return r;
            };

            ByteArrayBase.prototype.writeBase64String = function (s) {
                for (var i = 0; i < s.length; i++) {
                    var v = s.charAt(i);
                }
            };

            ByteArrayBase.prototype.dumpToConsole = function () {
                var oldpos = this.position;
                this.position = 0;
                var nstep = 8;
                function asHexString(x, digits) {
                    var lut = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
                    var sh = "";
                    for (var d = 0; d < digits; d++) {
                        sh = lut[(x >> (d << 2)) & 0xf] + sh;
                    }
                    return sh;
                }

                for (var i = 0; i < this.length; i += nstep) {
                    var s = asHexString(i, 4) + ":";
                    for (var j = 0; j < nstep && i + j < this.length; j++) {
                        s += " " + asHexString(this.readUnsignedByte(), 2);
                    }
                    console.log(s);
                }
                this.position = oldpos;
            };

            ByteArrayBase.prototype.internalGetBase64String = function (count, getUnsignedByteFunc, self) {
                var r = "";
                var b0, b1, b2, enc1, enc2, enc3, enc4;
                var base64Key = this.Base64Key;
                while (count >= 3) {
                    b0 = getUnsignedByteFunc.apply(self);
                    b1 = getUnsignedByteFunc.apply(self);
                    b2 = getUnsignedByteFunc.apply(self);
                    enc1 = b0 >> 2;
                    enc2 = ((b0 & 3) << 4) | (b1 >> 4);
                    enc3 = ((b1 & 15) << 2) | (b2 >> 6);
                    enc4 = b2 & 63;
                    r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + base64Key.charAt(enc4);
                    count -= 3;
                }

                if (count == 2) {
                    b0 = getUnsignedByteFunc.apply(self);
                    b1 = getUnsignedByteFunc.apply(self);
                    enc1 = b0 >> 2;
                    enc2 = ((b0 & 3) << 4) | (b1 >> 4);
                    enc3 = ((b1 & 15) << 2);
                    r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + "=";
                } else if (count == 1) {
                    b0 = getUnsignedByteFunc.apply(self);
                    enc1 = b0 >> 2;
                    enc2 = ((b0 & 3) << 4);
                    r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + "==";
                }
                return r;
            };
            return ByteArrayBase;
        })();
        utils.ByteArrayBase = ByteArrayBase;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var ByteArray = (function (_super) {
            __extends(ByteArray, _super);
            function ByteArray() {
                _super.call(this);
                this.maxlength = 0;
                this._mode = "Typed array";
                this.maxlength = 4;
                this.arraybytes = new ArrayBuffer(this.maxlength);
                this.unalignedarraybytestemp = new ArrayBuffer(16);
            }
            ByteArray.prototype.ensureWriteableSpace = function (n) {
                this.ensureSpace(n + this.position);
            };

            ByteArray.prototype.setArrayBuffer = function (aBuffer) {
                this.ensureSpace(aBuffer.byteLength);

                this.length = aBuffer.byteLength;

                var inInt8AView = new Int8Array(aBuffer);
                var localInt8View = new Int8Array(this.arraybytes, 0, this.length);

                localInt8View.set(inInt8AView);

                this.position = 0;
            };

            ByteArray.prototype.getBytesAvailable = function () {
                return (this.length) - (this.position);
            };

            ByteArray.prototype.ensureSpace = function (n) {
                if (n > this.maxlength) {
                    var newmaxlength = (n + 255) & (~255);
                    var newarraybuffer = new ArrayBuffer(newmaxlength);
                    var view = new Uint8Array(this.arraybytes, 0, this.length);
                    var newview = new Uint8Array(newarraybuffer, 0, this.length);
                    newview.set(view);
                    this.arraybytes = newarraybuffer;
                    this.maxlength = newmaxlength;
                }
            };

            ByteArray.prototype.writeByte = function (b) {
                this.ensureWriteableSpace(1);
                var view = new Int8Array(this.arraybytes);
                view[this.position++] = (~~b);
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArray.prototype.readByte = function () {
                if (this.position >= this.length) {
                    throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
                }
                var view = new Int8Array(this.arraybytes);

                return view[this.position++];
            };

            ByteArray.prototype.readBytes = function (bytes, offset, length) {
                if (typeof offset === "undefined") { offset = 0; }
                if (typeof length === "undefined") { length = 0; }
                if (length == null) {
                    length = bytes.length;
                }

                bytes.ensureWriteableSpace(offset + length);

                var byteView = new Int8Array(bytes.arraybytes);
                var localByteView = new Int8Array(this.arraybytes);

                byteView.set(localByteView.subarray(this.position, this.position + length), offset);

                this.position += length;

                if (length + offset > bytes.length) {
                    bytes.length += (length + offset) - bytes.length;
                }
            };

            ByteArray.prototype.writeUnsignedByte = function (b) {
                this.ensureWriteableSpace(1);
                var view = new Uint8Array(this.arraybytes);
                view[this.position++] = (~~b) & 0xff;
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArray.prototype.readUnsignedByte = function () {
                if (this.position >= this.length) {
                    throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
                }
                var view = new Uint8Array(this.arraybytes);
                return view[this.position++];
            };

            ByteArray.prototype.writeUnsignedShort = function (b) {
                this.ensureWriteableSpace(2);
                if ((this.position & 1) == 0) {
                    var view = new Uint16Array(this.arraybytes);
                    view[this.position >> 1] = (~~b) & 0xffff;
                } else {
                    var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
                    view[0] = (~~b) & 0xffff;
                    var view2 = new Uint8Array(this.arraybytes, this.position, 2);
                    var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
                    view2.set(view3);
                }
                this.position += 2;
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArray.prototype.readUTFBytes = function (len) {
                var value = "";
                var max = this.position + len;
                var data = new DataView(this.arraybytes);

                while (this.position < max) {
                    var c = data.getUint8(this.position++);

                    if (c < 0x80) {
                        if (c == 0)
                            break;
                        value += String.fromCharCode(c);
                    } else if (c < 0xE0) {
                        value += String.fromCharCode(((c & 0x3F) << 6) | (data.getUint8(this.position++) & 0x7F));
                    } else if (c < 0xF0) {
                        var c2 = data.getUint8(this.position++);
                        value += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (data.getUint8(this.position++) & 0x7F));
                    } else {
                        var c2 = data.getUint8(this.position++);
                        var c3 = data.getUint8(this.position++);

                        value += String.fromCharCode(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (data.getUint8(this.position++) & 0x7F));
                    }
                }

                return value;
            };

            ByteArray.prototype.readInt = function () {
                var data = new DataView(this.arraybytes);
                var int = data.getInt32(this.position, true);

                this.position += 4;

                return int;
            };

            ByteArray.prototype.readShort = function () {
                var data = new DataView(this.arraybytes);
                var short = data.getInt16(this.position, true);

                this.position += 2;
                return short;
            };

            ByteArray.prototype.readDouble = function () {
                var data = new DataView(this.arraybytes);
                var double = data.getFloat64(this.position, true);

                this.position += 8;
                return double;
            };

            ByteArray.prototype.readUnsignedShort = function () {
                if (this.position > this.length + 2) {
                    throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
                }
                if ((this.position & 1) == 0) {
                    var view = new Uint16Array(this.arraybytes);
                    var pa = this.position >> 1;
                    this.position += 2;
                    return view[pa];
                } else {
                    var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
                    var view2 = new Uint8Array(this.arraybytes, this.position, 2);
                    var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
                    view3.set(view2);
                    this.position += 2;
                    return view[0];
                }
            };

            ByteArray.prototype.writeUnsignedInt = function (b) {
                this.ensureWriteableSpace(4);
                if ((this.position & 3) == 0) {
                    var view = new Uint32Array(this.arraybytes);
                    view[this.position >> 2] = (~~b) & 0xffffffff;
                } else {
                    var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
                    view[0] = (~~b) & 0xffffffff;
                    var view2 = new Uint8Array(this.arraybytes, this.position, 4);
                    var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
                    view2.set(view3);
                }
                this.position += 4;
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArray.prototype.readUnsignedInt = function () {
                if (this.position > this.length + 4) {
                    throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
                }
                if ((this.position & 3) == 0) {
                    var view = new Uint32Array(this.arraybytes);
                    var pa = this.position >> 2;
                    this.position += 4;
                    return view[pa];
                } else {
                    var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
                    var view2 = new Uint8Array(this.arraybytes, this.position, 4);
                    var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
                    view3.set(view2);
                    this.position += 4;
                    return view[0];
                }
            };

            ByteArray.prototype.writeFloat = function (b) {
                this.ensureWriteableSpace(4);
                if ((this.position & 3) == 0) {
                    var view = new Float32Array(this.arraybytes);
                    view[this.position >> 2] = b;
                } else {
                    var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
                    view[0] = b;
                    var view2 = new Uint8Array(this.arraybytes, this.position, 4);
                    var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
                    view2.set(view3);
                }
                this.position += 4;
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArray.prototype.readFloat = function () {
                if (this.position > this.length + 4) {
                    throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
                }
                if ((this.position & 3) == 0) {
                    var view = new Float32Array(this.arraybytes);
                    var pa = this.position >> 2;
                    this.position += 4;
                    return view[pa];
                } else {
                    var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
                    var view2 = new Uint8Array(this.arraybytes, this.position, 4);
                    var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
                    view3.set(view2);
                    this.position += 4;
                    return view[0];
                }
            };
            return ByteArray;
        })(utils.ByteArrayBase);
        utils.ByteArray = ByteArray;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
var away;
(function (away) {
    ///<reference path="../_definitions.ts"/>
    (function (utils) {
        var ByteArrayBuffer = (function (_super) {
            __extends(ByteArrayBuffer, _super);
            function ByteArrayBuffer() {
                _super.call(this);
                this._bytes = [];
                this._mode = "Array";
            }
            ByteArrayBuffer.prototype.writeByte = function (b) {
                var bi = ~~b;
                this._bytes[this.position++] = bi;
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArrayBuffer.prototype.readByte = function () {
                if (this.position >= this.length) {
                    throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
                }
                return this._bytes[this.position++];
            };

            ByteArrayBuffer.prototype.writeUnsignedByte = function (b) {
                var bi = ~~b;
                this._bytes[this.position++] = bi & 0xff;
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArrayBuffer.prototype.readUnsignedByte = function () {
                if (this.position >= this.length) {
                    throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
                }
                return this._bytes[this.position++];
            };

            ByteArrayBuffer.prototype.writeUnsignedShort = function (b) {
                var bi = ~~b;
                this._bytes[this.position++] = bi & 0xff;
                this._bytes[this.position++] = (bi >> 8) & 0xff;
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArrayBuffer.prototype.readUnsignedShort = function () {
                if (this.position + 2 > this.length) {
                    throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
                }
                var r = this._bytes[this.position] | (this._bytes[this.position + 1] << 8);
                this.position += 2;
                return r;
            };

            ByteArrayBuffer.prototype.writeUnsignedInt = function (b) {
                var bi = ~~b;
                this._bytes[this.position++] = bi & 0xff;
                this._bytes[this.position++] = (bi >>> 8) & 0xff;
                this._bytes[this.position++] = (bi >>> 16) & 0xff;
                this._bytes[this.position++] = (bi >>> 24) & 0xff;
                if (this.position > this.length) {
                    this.length = this.position;
                }
            };

            ByteArrayBuffer.prototype.readUnsignedInt = function () {
                if (this.position + 4 > this.length) {
                    throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
                }
                var r = this._bytes[this.position] | (this._bytes[this.position + 1] << 8) | (this._bytes[this.position + 2] << 16) | (this._bytes[this.position + 3] << 24);
                this.position += 4;
                return r >>> 0;
            };

            ByteArrayBuffer.prototype.writeFloat = function (b) {
                // this is crazy slow and silly, but as a fallback...
                this.writeUnsignedInt(this.toFloatBits(Number(b)));
            };

            ByteArrayBuffer.prototype.toFloatBits = function (x) {
                if (x == 0) {
                    return 0;
                }

                // remove the sign, after this we only deal with positive numbers
                var sign = 0;
                if (x < 0) {
                    x = -x;
                    sign = 1;
                } else {
                    sign = 0;
                }

                // a float value is now defined as: x = (1+(mantissa*2^-23))*(2^(exponent-127))
                var exponent = Math.log(x) / Math.log(2);
                exponent = Math.floor(exponent);
                x = x * Math.pow(2, 23 - exponent);
                var mantissa = Math.floor(x) - 0x800000;
                exponent = exponent + 127;
                return ((sign << 31) >>> 0) | (exponent << 23) | mantissa;
            };

            ByteArrayBuffer.prototype.readFloat = function (b) {
                return this.fromFloatBits(this.readUnsignedInt());
            };

            ByteArrayBuffer.prototype.fromFloatBits = function (x) {
                if (x == 0) {
                    return 0;
                }
                var exponent = (x >>> 23) & 0xff;
                var mantissa = (x & 0x7fffff) | 0x800000;
                var y = Math.pow(2, (exponent - 127) - 23) * mantissa;
                if (x >>> 31 != 0) {
                    y = -y;
                }
                return y;
            };
            return ByteArrayBuffer;
        })(utils.ByteArrayBase);
        utils.ByteArrayBuffer = ByteArrayBuffer;
    })(away.utils || (away.utils = {}));
    var utils = away.utils;
})(away || (away = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var Sampler = (function () {
        function Sampler() {
            this.lodbias = 0;
            this.dim = 0;
            this.readmode = 0;
            this.special = 0;
            this.wrap = 0;
            this.mipmap = 0;
            this.filter = 0;
        }
        return Sampler;
    })();
    aglsl.Sampler = Sampler;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var Token = (function () {
        function Token() {
            this.dest = new aglsl.Destination();
            this.opcode = 0;
            this.a = new aglsl.Destination();
            this.b = new aglsl.Destination();
        }
        return Token;
    })();
    aglsl.Token = Token;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var Header = (function () {
        function Header() {
            this.progid = 0;
            this.version = 0;
            this.type = "";
        }
        return Header;
    })();
    aglsl.Header = Header;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var OpLUT = (function () {
        function OpLUT(s, flags, dest, a, b, matrixwidth, matrixheight, ndwm, scaler, dm, lod) {
            this.s = s;
            this.flags = flags;
            this.dest = dest;
            this.a = a;
            this.b = b;
            this.matrixwidth = matrixwidth;
            this.matrixheight = matrixheight;
            this.ndwm = ndwm;
            this.scalar = scaler;
            this.dm = dm;
            this.lod = lod;
        }
        return OpLUT;
    })();
    aglsl.OpLUT = OpLUT;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var Description = (function () {
        function Description() {
            this.regread = [[], [], [], [], [], [], []];
            this.regwrite = [[], [], [], [], [], [], []];
            this.hasindirect = false;
            this.writedepth = false;
            this.hasmatrix = false;
            this.samplers = [];
            // added due to dynamic assignment 3*0xFFFFFFuuuu
            this.tokens = [];
            this.header = new aglsl.Header();
        }
        return Description;
    })();
    aglsl.Description = Description;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var Destination = (function () {
        function Destination() {
            this.mask = 0;
            this.regnum = 0;
            this.regtype = 0;
            this.dim = 0;
        }
        return Destination;
    })();
    aglsl.Destination = Destination;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var Context3D = (function () {
        function Context3D() {
            this.enableErrorChecking = false;
            this.resources = [];
            this.driverInfo = "Call getter function instead";
        }
        Context3D.maxvertexconstants = 128;
        Context3D.maxfragconstants = 28;
        Context3D.maxtemp = 8;
        Context3D.maxstreams = 8;
        Context3D.maxtextures = 8;
        Context3D.defaultsampler = new aglsl.Sampler();
        return Context3D;
    })();
    aglsl.Context3D = Context3D;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var Mapping = (function () {
        function Mapping() {
        }
        Mapping.agal2glsllut = [
            new aglsl.OpLUT("%dest = %cast(%a);\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(%a + %b);\n", 0, true, true, true, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(%a - %b);\n", 0, true, true, true, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(%a * %b);\n", 0, true, true, true, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(%a / %b);\n", 0, true, true, true, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(1.0) / %a;\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(min(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(max(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(fract(%a));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(sqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(inversesqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(pow(abs(%a),%b));\n", 0, true, true, true, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(log2(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(exp2(%a));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(normalize(vec3( %a ) ));\n", 0, true, true, false, null, null, true, null, null, null),
            new aglsl.OpLUT("%dest = %cast(sin(%a));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(cos(%a));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(cross(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
            new aglsl.OpLUT("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
            new aglsl.OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
            new aglsl.OpLUT("%dest = %cast(abs(%a));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(%a * -1.0);\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(clamp(%a,0.0,1.0));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", null, true, true, true, 3, 3, true, null, null, null),
            new aglsl.OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 4, true, null, null, null),
            new aglsl.OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 3, true, null, null, null),
            new aglsl.OpLUT("%dest = %cast(dFdx(%a));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(dFdx(%a));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("if (float(%a)==float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null),
            new aglsl.OpLUT("if (float(%a)!=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null),
            new aglsl.OpLUT("if (float(%a)>=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null),
            new aglsl.OpLUT("if (float(%a)<float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null),
            new aglsl.OpLUT("} else {;\n", 0, false, false, false, null, null, null, null, null, null),
            new aglsl.OpLUT("};\n", 0, false, false, false, null, null, null, null, null, null),
            new aglsl.OpLUT(null, null, null, null, false, null, null, null, null, null, null),
            new aglsl.OpLUT(null, null, null, null, false, null, null, null, null, null, null),
            new aglsl.OpLUT(null, null, null, null, false, null, null, null, null, null, null),
            new aglsl.OpLUT(null, null, null, null, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(texture%texdimLod(%b,%texsize(%a)).%dm);\n", null, true, true, true, null, null, null, null, true, null),
            new aglsl.OpLUT("if ( float(%a)<0.0 ) discard;\n", null, false, true, false, null, null, null, true, null, null),
            new aglsl.OpLUT("%dest = %cast(texture%texdim(%b,%texsize(%a)%lod).%dm);\n", null, true, true, true, null, null, true, null, true, true),
            new aglsl.OpLUT("%dest = %cast(greaterThanEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null),
            new aglsl.OpLUT("%dest = %cast(lessThan(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null),
            new aglsl.OpLUT("%dest = %cast(sign(%a));\n", 0, true, true, false, null, null, null, null, null, null),
            new aglsl.OpLUT("%dest = %cast(equal(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null),
            new aglsl.OpLUT("%dest = %cast(notEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null)
        ];
        return Mapping;
    })();
    aglsl.Mapping = Mapping;
})(aglsl || (aglsl = {}));
var aglsl;
(function (aglsl) {
    ///<reference path="../../away/_definitions.ts" />
    (function (assembler) {
        var Opcode = (function () {
            function Opcode(dest, aformat, asize, bformat, bsize, opcode, simple, horizontal, fragonly, matrix) {
                this.a = new aglsl.assembler.FS();
                this.b = new aglsl.assembler.FS();
                this.flags = new aglsl.assembler.Flags();

                this.dest = dest;
                this.a.format = aformat;
                this.a.size = asize;
                this.b.format = bformat;
                this.b.size = bsize;
                this.opcode = opcode;
                this.flags.simple = simple;
                this.flags.horizontal = horizontal;
                this.flags.fragonly = fragonly;
                this.flags.matrix = matrix;
            }
            return Opcode;
        })();
        assembler.Opcode = Opcode;

        var FS = (function () {
            function FS() {
            }
            return FS;
        })();
        assembler.FS = FS;

        var Flags = (function () {
            function Flags() {
            }
            return Flags;
        })();
        assembler.Flags = Flags;
    })(aglsl.assembler || (aglsl.assembler = {}));
    var assembler = aglsl.assembler;
})(aglsl || (aglsl = {}));
var aglsl;
(function (aglsl) {
    ///<reference path="../../away/_definitions.ts" />
    (function (assembler) {
        var OpcodeMap = (function () {
            function OpcodeMap() {
            }
            Object.defineProperty(OpcodeMap, "map", {
                get: function () {
                    if (!OpcodeMap._map) {
                        OpcodeMap._map = new Array();
                        OpcodeMap._map['mov'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x00, true, null, null, null);
                        OpcodeMap._map['add'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x01, true, null, null, null);
                        OpcodeMap._map['sub'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x02, true, null, null, null);
                        OpcodeMap._map['mul'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x03, true, null, null, null);
                        OpcodeMap._map['div'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x04, true, null, null, null);
                        OpcodeMap._map['rcp'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x05, true, null, null, null);
                        OpcodeMap._map['min'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x06, true, null, null, null);
                        OpcodeMap._map['max'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x07, true, null, null, null);
                        OpcodeMap._map['frc'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x08, true, null, null, null);
                        OpcodeMap._map['sqt'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x09, true, null, null, null);
                        OpcodeMap._map['rsq'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x0a, true, null, null, null);
                        OpcodeMap._map['pow'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x0b, true, null, null, null);
                        OpcodeMap._map['log'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x0c, true, null, null, null);
                        OpcodeMap._map['exp'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x0d, true, null, null, null);
                        OpcodeMap._map['nrm'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x0e, true, null, null, null);
                        OpcodeMap._map['sin'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x0f, true, null, null, null);
                        OpcodeMap._map['cos'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x10, true, null, null, null);
                        OpcodeMap._map['crs'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x11, true, true, null, null);
                        OpcodeMap._map['dp3'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x12, true, true, null, null);
                        OpcodeMap._map['dp4'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x13, true, true, null, null);
                        OpcodeMap._map['abs'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x14, true, null, null, null);
                        OpcodeMap._map['neg'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x15, true, null, null, null);
                        OpcodeMap._map['sat'] = new aglsl.assembler.Opcode("vector", "vector", 4, "none", 0, 0x16, true, null, null, null);

                        OpcodeMap._map['ted'] = new aglsl.assembler.Opcode("vector", "vector", 4, "sampler", 1, 0x26, true, null, true, null);
                        OpcodeMap._map['kil'] = new aglsl.assembler.Opcode("none", "scalar", 1, "none", 0, 0x27, true, null, true, null);
                        OpcodeMap._map['tex'] = new aglsl.assembler.Opcode("vector", "vector", 4, "sampler", 1, 0x28, true, null, true, null);

                        OpcodeMap._map['m33'] = new aglsl.assembler.Opcode("vector", "matrix", 3, "vector", 3, 0x17, true, null, null, true);
                        OpcodeMap._map['m44'] = new aglsl.assembler.Opcode("vector", "matrix", 4, "vector", 4, 0x18, true, null, null, true);
                        OpcodeMap._map['m43'] = new aglsl.assembler.Opcode("vector", "matrix", 3, "vector", 4, 0x19, true, null, null, true);

                        OpcodeMap._map['sge'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x29, true, null, null, null);
                        OpcodeMap._map['slt'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x2a, true, null, null, null);
                        OpcodeMap._map['sgn'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x2b, true, null, null, null);
                        OpcodeMap._map['seq'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x2c, true, null, null, null);
                        OpcodeMap._map['sne'] = new aglsl.assembler.Opcode("vector", "vector", 4, "vector", 4, 0x2d, true, null, null, null);
                    }

                    return OpcodeMap._map;
                },
                enumerable: true,
                configurable: true
            });
            return OpcodeMap;
        })();
        assembler.OpcodeMap = OpcodeMap;
    })(aglsl.assembler || (aglsl.assembler = {}));
    var assembler = aglsl.assembler;
})(aglsl || (aglsl = {}));
var aglsl;
(function (aglsl) {
    ///<reference path="../../away/_definitions.ts" />
    (function (assembler) {
        var Part = (function () {
            function Part(name, version) {
                if (typeof name === "undefined") { name = null; }
                if (typeof version === "undefined") { version = null; }
                this.name = "";
                this.version = 0;
                this.name = name;
                this.version = version;
                this.data = new away.utils.ByteArray();
            }
            return Part;
        })();
        assembler.Part = Part;
    })(aglsl.assembler || (aglsl.assembler = {}));
    var assembler = aglsl.assembler;
})(aglsl || (aglsl = {}));
var aglsl;
(function (aglsl) {
    ///<reference path="../../away/_definitions.ts" />
    (function (assembler) {
        var Reg = (function () {
            function Reg(code, desc) {
                this.code = code;
                this.desc = desc;
            }
            return Reg;
        })();
        assembler.Reg = Reg;

        var RegMap = (function () {
            /*
            public static va:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x00, "vertex attribute" );
            public static fc:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x01, "fragment constant" );
            public static vc:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x01, "vertex constant" );
            public static ft:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x02, "fragment temporary" );
            public static vt:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x02, "vertex temporary" );
            public static vo:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x03, "vertex output" );
            public static op:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x03, "vertex output" );
            public static fd:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x03, "fragment depth output" );
            public static fo:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x03, "fragment output" );
            public static oc:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x03, "fragment output" );
            public static v: aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x04, "varying" );
            public static vi:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x04, "varying output" );
            public static fi:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x04, "varying input" );
            public static fs:aglsl.assembler.Reg = new aglsl.assembler.Reg( 0x05, "sampler" );
            */
            function RegMap() {
            }
            Object.defineProperty(RegMap, "map", {
                get: function () {
                    if (!RegMap._map) {
                        RegMap._map = new Array();
                        RegMap._map['va'] = new aglsl.assembler.Reg(0x00, "vertex attribute");
                        RegMap._map['fc'] = new aglsl.assembler.Reg(0x01, "fragment constant");
                        RegMap._map['vc'] = new aglsl.assembler.Reg(0x01, "vertex constant");
                        RegMap._map['ft'] = new aglsl.assembler.Reg(0x02, "fragment temporary");
                        RegMap._map['vt'] = new aglsl.assembler.Reg(0x02, "vertex temporary");
                        RegMap._map['vo'] = new aglsl.assembler.Reg(0x03, "vertex output");
                        RegMap._map['op'] = new aglsl.assembler.Reg(0x03, "vertex output");
                        RegMap._map['fd'] = new aglsl.assembler.Reg(0x03, "fragment depth output");
                        RegMap._map['fo'] = new aglsl.assembler.Reg(0x03, "fragment output");
                        RegMap._map['oc'] = new aglsl.assembler.Reg(0x03, "fragment output");
                        RegMap._map['v'] = new aglsl.assembler.Reg(0x04, "varying");
                        RegMap._map['vi'] = new aglsl.assembler.Reg(0x04, "varying output");
                        RegMap._map['fi'] = new aglsl.assembler.Reg(0x04, "varying input");
                        RegMap._map['fs'] = new aglsl.assembler.Reg(0x05, "sampler");
                    }

                    return RegMap._map;
                },
                enumerable: true,
                configurable: true
            });
            return RegMap;
        })();
        assembler.RegMap = RegMap;
    })(aglsl.assembler || (aglsl.assembler = {}));
    var assembler = aglsl.assembler;
})(aglsl || (aglsl = {}));
var aglsl;
(function (aglsl) {
    ///<reference path="../../away/_definitions.ts" />
    (function (assembler) {
        var Sampler = (function () {
            function Sampler(shift, mask, value) {
                this.shift = shift;
                this.mask = mask;
                this.value = value;
            }
            return Sampler;
        })();
        assembler.Sampler = Sampler;

        var SamplerMap = (function () {
            /*
            public static map =     [ new aglsl.assembler.Sampler( 8, 0xf, 0 ),
            new aglsl.assembler.Sampler( 8, 0xf, 5 ),
            new aglsl.assembler.Sampler( 8, 0xf, 4 ),
            new aglsl.assembler.Sampler( 8, 0xf, 1 ),
            new aglsl.assembler.Sampler( 8, 0xf, 2 ),
            new aglsl.assembler.Sampler( 8, 0xf, 1 ),
            new aglsl.assembler.Sampler( 8, 0xf, 2 ),
            
            // dimension
            new aglsl.assembler.Sampler( 12, 0xf, 0 ),
            new aglsl.assembler.Sampler( 12, 0xf, 1 ),
            new aglsl.assembler.Sampler( 12, 0xf, 2 ),
            
            // special
            new aglsl.assembler.Sampler( 16, 1, 1 ),
            new aglsl.assembler.Sampler( 16, 4, 4 ),
            
            // repeat
            new aglsl.assembler.Sampler( 20, 0xf, 0 ),
            new aglsl.assembler.Sampler( 20, 0xf, 1 ),
            new aglsl.assembler.Sampler( 20, 0xf, 1 ),
            
            // mip
            new aglsl.assembler.Sampler( 24, 0xf, 0 ),
            new aglsl.assembler.Sampler( 24, 0xf, 0 ),
            new aglsl.assembler.Sampler( 24, 0xf, 1 ),
            new aglsl.assembler.Sampler( 24, 0xf, 2 ),
            
            // filter
            new aglsl.assembler.Sampler( 28, 0xf, 0 ),
            new aglsl.assembler.Sampler( 28, 0xf, 1 ) ]
            */
            /*
            public static rgba: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 8, 0xf, 0 );
            public static rg: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 8, 0xf, 5 );
            public static r: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 8, 0xf, 4 );
            public static compressed: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 8, 0xf, 1 );
            public static compressed_alpha: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 8, 0xf, 2 );
            public static dxt1: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 8, 0xf, 1 );
            public static dxt5: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 8, 0xf, 2 );
            
            // dimension
            public static sampler2d: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 12, 0xf, 0 );
            public static cube: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 12, 0xf, 1 );
            public static sampler3d: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 12, 0xf, 2 );
            
            // special
            public static centroid: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 16, 1, 1 );
            public static ignoresampler: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 16, 4, 4 );
            
            // repeat
            public static clamp: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 20, 0xf, 0 );
            public static repeat: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 20, 0xf, 1 );
            public static wrap: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 20, 0xf, 1 );
            
            // mip
            public static nomip: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 24, 0xf, 0 );
            public static mipnone: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 24, 0xf, 0 );
            public static mipnearest: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 24, 0xf, 1 );
            public static miplinear: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 24, 0xf, 2 );
            
            // filter
            public static nearest: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 28, 0xf, 0 );
            public static linear: aglsl.assembler.Sampler = new aglsl.assembler.Sampler( 28, 0xf, 1 );
            */
            function SamplerMap() {
            }
            Object.defineProperty(SamplerMap, "map", {
                get: function () {
                    if (!SamplerMap._map) {
                        SamplerMap._map = new Array();
                        SamplerMap._map['rgba'] = new aglsl.assembler.Sampler(8, 0xf, 0);
                        SamplerMap._map['rg'] = new aglsl.assembler.Sampler(8, 0xf, 5);
                        SamplerMap._map['r'] = new aglsl.assembler.Sampler(8, 0xf, 4);
                        SamplerMap._map['compressed'] = new aglsl.assembler.Sampler(8, 0xf, 1);
                        SamplerMap._map['compressed_alpha'] = new aglsl.assembler.Sampler(8, 0xf, 2);
                        SamplerMap._map['dxt1'] = new aglsl.assembler.Sampler(8, 0xf, 1);
                        SamplerMap._map['dxt5'] = new aglsl.assembler.Sampler(8, 0xf, 2);

                        // dimension
                        SamplerMap._map['2d'] = new aglsl.assembler.Sampler(12, 0xf, 0);
                        SamplerMap._map['cube'] = new aglsl.assembler.Sampler(12, 0xf, 1);
                        SamplerMap._map['3d'] = new aglsl.assembler.Sampler(12, 0xf, 2);

                        // special
                        SamplerMap._map['centroid'] = new aglsl.assembler.Sampler(16, 1, 1);
                        SamplerMap._map['ignoresampler'] = new aglsl.assembler.Sampler(16, 4, 4);

                        // repeat
                        SamplerMap._map['clamp'] = new aglsl.assembler.Sampler(20, 0xf, 0);
                        SamplerMap._map['repeat'] = new aglsl.assembler.Sampler(20, 0xf, 1);
                        SamplerMap._map['wrap'] = new aglsl.assembler.Sampler(20, 0xf, 1);

                        // mip
                        SamplerMap._map['nomip'] = new aglsl.assembler.Sampler(24, 0xf, 0);
                        SamplerMap._map['mipnone'] = new aglsl.assembler.Sampler(24, 0xf, 0);
                        SamplerMap._map['mipnearest'] = new aglsl.assembler.Sampler(24, 0xf, 1);
                        SamplerMap._map['miplinear'] = new aglsl.assembler.Sampler(24, 0xf, 2);

                        // filter
                        SamplerMap._map['nearest'] = new aglsl.assembler.Sampler(28, 0xf, 0);
                        SamplerMap._map['linear'] = new aglsl.assembler.Sampler(28, 0xf, 1);
                    }

                    return SamplerMap._map;
                },
                enumerable: true,
                configurable: true
            });
            return SamplerMap;
        })();
        assembler.SamplerMap = SamplerMap;
    })(aglsl.assembler || (aglsl.assembler = {}));
    var assembler = aglsl.assembler;
})(aglsl || (aglsl = {}));
var aglsl;
(function (aglsl) {
    ///<reference path="../../away/_definitions.ts" />
    (function (assembler) {
        var AGALMiniAssembler = (function () {
            function AGALMiniAssembler() {
                this.r = {};
                this.cur = new aglsl.assembler.Part();
            }
            AGALMiniAssembler.prototype.assemble = function (source, ext_part, ext_version) {
                if (typeof ext_part === "undefined") { ext_part = null; }
                if (typeof ext_version === "undefined") { ext_version = null; }
                if (!ext_version) {
                    ext_version = 1;
                }

                if (ext_part) {
                    this.addHeader(ext_part, ext_version);
                }

                var lines = source.replace(/[\f\n\r\v]+/g, "\n").split("\n");

                for (var i in lines) {
                    this.processLine(lines[i], i);
                }

                return this.r;
            };

            AGALMiniAssembler.prototype.processLine = function (line, linenr) {
                var startcomment = line.search("//");
                if (startcomment != -1) {
                    line = line.slice(0, startcomment);
                }
                line = line.replace(/^\s+|\s+$/g, "");
                if (!(line.length > 0)) {
                    return;
                }
                var optsi = line.search(/<.*>/g);
                var opts = null;
                if (optsi != -1) {
                    opts = line.slice(optsi).match(/([\w\.\-\+]+)/gi);
                    line = line.slice(0, optsi);
                }

                // get opcode/command
                var tokens = line.match(/([\w\.\+\[\]]+)/gi);
                if (!tokens || tokens.length < 1) {
                    if (line.length >= 3) {
                        console.log("Warning: bad line " + linenr + ": " + line);
                    }
                    return;
                }

                switch (tokens[0]) {
                    case "part":
                        this.addHeader(tokens[1], Number(tokens[2]));
                        break;
                    case "endpart":
                        if (!this.cur) {
                            throw "Unexpected endpart";
                        }
                        this.cur.data.position = 0;
                        this.cur = null;
                        return;
                    default:
                        if (!this.cur) {
                            console.log("Warning: bad line " + linenr + ": " + line + " (Outside of any part definition)");
                            return;
                        }
                        if (this.cur.name == "comment") {
                            return;
                        }
                        var op = assembler.OpcodeMap.map[tokens[0]];
                        if (!op) {
                            throw "Bad opcode " + tokens[0] + " " + linenr + ": " + line;
                        }

                        // console.log( 'AGALMiniAssembler' , 'op' , op );
                        this.emitOpcode(this.cur, op.opcode);
                        var ti = 1;
                        if (op.dest && op.dest != "none") {
                            if (!this.emitDest(this.cur, tokens[ti++], op.dest)) {
                                throw "Bad destination register " + tokens[ti - 1] + " " + linenr + ": " + line;
                            }
                        } else {
                            this.emitZeroDword(this.cur);
                        }

                        if (op.a && op.a.format != "none") {
                            if (!this.emitSource(this.cur, tokens[ti++], op.a))
                                throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
                        } else {
                            this.emitZeroQword(this.cur);
                        }

                        if (op.b && op.b.format != "none") {
                            if (op.b.format == "sampler") {
                                if (!this.emitSampler(this.cur, tokens[ti++], op.b, opts)) {
                                    throw "Bad sampler register " + tokens[ti - 1] + " " + linenr + ": " + line;
                                }
                            } else {
                                if (!this.emitSource(this.cur, tokens[ti++], op.b)) {
                                    throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
                                }
                            }
                        } else {
                            this.emitZeroQword(this.cur);
                        }
                        break;
                }
            };

            AGALMiniAssembler.prototype.emitHeader = function (pr) {
                pr.data.writeUnsignedByte(0xa0);
                pr.data.writeUnsignedInt(pr.version);
                if (pr.version >= 0x10) {
                    pr.data.writeUnsignedByte(0);
                }
                pr.data.writeUnsignedByte(0xa1);
                switch (pr.name) {
                    case "fragment":
                        pr.data.writeUnsignedByte(1);
                        break;
                    case "vertex":
                        pr.data.writeUnsignedByte(0);
                        break;
                    case "cpu":
                        pr.data.writeUnsignedByte(2);
                        break;
                    default:
                        pr.data.writeUnsignedByte(0xff);
                        break;
                }
            };

            AGALMiniAssembler.prototype.emitOpcode = function (pr, opcode) {
                pr.data.writeUnsignedInt(opcode);
                //console.log ( "Emit opcode: ", opcode );
            };

            AGALMiniAssembler.prototype.emitZeroDword = function (pr) {
                pr.data.writeUnsignedInt(0);
            };

            AGALMiniAssembler.prototype.emitZeroQword = function (pr) {
                pr.data.writeUnsignedInt(0);
                pr.data.writeUnsignedInt(0);
            };

            AGALMiniAssembler.prototype.emitDest = function (pr, token, opdest) {
                //console.log( 'aglsl.assembler.AGALMiniAssembler' , 'emitDest' , 'RegMap.map' , RegMap.map);
                var reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i);

                if (!assembler.RegMap.map[reg[1]])
                    return false;
                var em = { num: reg[2] ? reg[2] : 0, code: assembler.RegMap.map[reg[1]].code, mask: this.stringToMask(reg[3]) };
                pr.data.writeUnsignedShort(em.num);
                pr.data.writeUnsignedByte(em.mask);
                pr.data.writeUnsignedByte(em.code);

                //console.log ( "  Emit dest: ", em );
                return true;
            };

            AGALMiniAssembler.prototype.stringToMask = function (s) {
                if (!s)
                    return 0xf;
                var r = 0;
                if (s.indexOf("x") != -1)
                    r |= 1;
                if (s.indexOf("y") != -1)
                    r |= 2;
                if (s.indexOf("z") != -1)
                    r |= 4;
                if (s.indexOf("w") != -1)
                    r |= 8;
                return r;
            };

            AGALMiniAssembler.prototype.stringToSwizzle = function (s) {
                if (!s) {
                    return 0xe4;
                }
                var chartoindex = { x: 0, y: 1, z: 2, w: 3 };
                var sw = 0;

                if (s.charAt(0) != ".") {
                    throw "Missing . for swizzle";
                }

                if (s.length > 1) {
                    sw |= chartoindex[s.charAt(1)];
                }

                if (s.length > 2) {
                    sw |= chartoindex[s.charAt(2)] << 2;
                } else {
                    sw |= (sw & 3) << 2;
                }

                if (s.length > 3) {
                    sw |= chartoindex[s.charAt(3)] << 4;
                } else {
                    sw |= (sw & (3 << 2)) << 2;
                }

                if (s.length > 4) {
                    sw |= chartoindex[s.charAt(4)] << 6;
                } else {
                    sw |= (sw & (3 << 4)) << 2;
                }

                return sw;
            };

            AGALMiniAssembler.prototype.emitSampler = function (pr, token, opsrc, opts) {
                var reg = token.match(/fs(\d*)/i);
                if (!reg || !reg[1]) {
                    return false;
                }
                pr.data.writeUnsignedShort(reg[1]);
                pr.data.writeUnsignedByte(0);
                pr.data.writeUnsignedByte(0);

                /*
                pr.data.writeUnsignedByte ( 0x5 );
                pr.data.writeUnsignedByte ( 0 );   // readmode, dim
                pr.data.writeUnsignedByte ( 0 );   // special, wrap
                pr.data.writeUnsignedByte ( 0 );   // mip, filter
                */
                var samplerbits = 0x5;
                var sampleroptset = 0;
                for (var i = 0; i < opts.length; i++) {
                    var o = assembler.SamplerMap.map[opts[i].toLowerCase()];

                    if (o) {
                        if (((sampleroptset >> o.shift) & o.mask) != 0) {
                            console.log("Warning, duplicate sampler option");
                        }
                        sampleroptset |= o.mask << o.shift;
                        samplerbits &= ~(o.mask << o.shift);
                        samplerbits |= o.value << o.shift;
                    } else {
                        console.log("Warning, unknown sampler option: ", opts[i]);
                        // todo bias
                    }
                }
                pr.data.writeUnsignedInt(samplerbits);
                return true;
            };

            AGALMiniAssembler.prototype.emitSource = function (pr, token, opsrc) {
                var indexed = token.match(/vc\[(v[tcai])(\d+)\.([xyzw])([\+\-]\d+)?\](\.[xyzw]{1,4})?/i);
                var reg;
                if (indexed) {
                    if (!assembler.RegMap.map[indexed[1]]) {
                        return false;
                    }
                    var selindex = { x: 0, y: 1, z: 2, w: 3 };
                    var em = { num: indexed[2] | 0, code: assembler.RegMap.map[indexed[1]].code, swizzle: this.stringToSwizzle(indexed[5]), select: selindex[indexed[3]], offset: indexed[4] | 0 };
                    pr.data.writeUnsignedShort(em.num);
                    pr.data.writeByte(em.offset);
                    pr.data.writeUnsignedByte(em.swizzle);
                    pr.data.writeUnsignedByte(0x1);
                    pr.data.writeUnsignedByte(em.code);
                    pr.data.writeUnsignedByte(em.select);
                    pr.data.writeUnsignedByte(1 << 7);
                } else {
                    reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i);
                    if (!assembler.RegMap.map[reg[1]]) {
                        return false;
                    }
                    var em = { num: reg[2] | 0, code: assembler.RegMap.map[reg[1]].code, swizzle: this.stringToSwizzle(reg[3]) };
                    pr.data.writeUnsignedShort(em.num);
                    pr.data.writeUnsignedByte(0);
                    pr.data.writeUnsignedByte(em.swizzle);
                    pr.data.writeUnsignedByte(em.code);
                    pr.data.writeUnsignedByte(0);
                    pr.data.writeUnsignedByte(0);
                    pr.data.writeUnsignedByte(0);
                    //console.log ( "  Emit source: ", em, pr.data.length );
                }
                return true;
            };

            AGALMiniAssembler.prototype.addHeader = function (partname, version) {
                if (!version) {
                    version = 1;
                }
                if (this.r[partname] == undefined) {
                    this.r[partname] = new aglsl.assembler.Part(partname, version);
                    this.emitHeader(this.r[partname]);
                } else if (this.r[partname].version != version) {
                    throw "Multiple versions for part " + partname;
                }
                this.cur = this.r[partname];
            };
            return AGALMiniAssembler;
        })();
        assembler.AGALMiniAssembler = AGALMiniAssembler;
    })(aglsl.assembler || (aglsl.assembler = {}));
    var assembler = aglsl.assembler;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var AGALTokenizer = (function () {
        function AGALTokenizer() {
        }
        AGALTokenizer.prototype.decribeAGALByteArray = function (bytes) {
            var header = new aglsl.Header();

            if (bytes.readUnsignedByte() != 0xa0) {
                throw "Bad AGAL: Missing 0xa0 magic byte.";
            }

            header.version = bytes.readUnsignedInt();
            if (header.version >= 0x10) {
                bytes.readUnsignedByte();
                header.version >>= 1;
            }
            if (bytes.readUnsignedByte() != 0xa1) {
                throw "Bad AGAL: Missing 0xa1 magic byte.";
            }

            header.progid = bytes.readUnsignedByte();
            switch (header.progid) {
                case 1:
                    header.type = "fragment";
                    break;
                case 0:
                    header.type = "vertex";
                    break;
                case 2:
                    header.type = "cpu";
                    break;
                default:
                    header.type = "";
                    break;
            }

            var desc = new aglsl.Description();
            var tokens = [];
            while (bytes.position < bytes.length) {
                var token = new aglsl.Token();

                token.opcode = bytes.readUnsignedInt();
                var lutentry = aglsl.Mapping.agal2glsllut[token.opcode];
                if (!lutentry) {
                    throw "Opcode not valid or not implemented yet: " + token.opcode;
                }
                if (lutentry.matrixheight) {
                    desc.hasmatrix = true;
                }
                if (lutentry.dest) {
                    token.dest.regnum = bytes.readUnsignedShort();
                    token.dest.mask = bytes.readUnsignedByte();
                    token.dest.regtype = bytes.readUnsignedByte();
                    desc.regwrite[token.dest.regtype][token.dest.regnum] |= token.dest.mask;
                } else {
                    token.dest = null;
                    bytes.readUnsignedInt();
                }
                if (lutentry.a) {
                    this.readReg(token.a, 1, desc, bytes);
                } else {
                    token.a = null;
                    bytes.readUnsignedInt();
                    bytes.readUnsignedInt();
                }
                if (lutentry.b) {
                    this.readReg(token.b, lutentry.matrixheight | 0, desc, bytes);
                } else {
                    token.b = null;
                    bytes.readUnsignedInt();
                    bytes.readUnsignedInt();
                }
                tokens.push(token);
            }
            desc.header = header;
            desc.tokens = tokens;

            return desc;
        };

        AGALTokenizer.prototype.readReg = function (s, mh, desc, bytes) {
            s.regnum = bytes.readUnsignedShort();
            s.indexoffset = bytes.readByte();
            s.swizzle = bytes.readUnsignedByte();
            s.regtype = bytes.readUnsignedByte();
            desc.regread[s.regtype][s.regnum] = 0xf;
            if (s.regtype == 0x5) {
                // sampler
                s.lodbiad = s.indexoffset;
                s.indexoffset = undefined;
                s.swizzle = undefined;

                // sampler
                s.readmode = bytes.readUnsignedByte();
                s.dim = s.readmode >> 4;
                s.readmode &= 0xf;
                s.special = bytes.readUnsignedByte();
                s.wrap = s.special >> 4;
                s.special &= 0xf;
                s.mipmap = bytes.readUnsignedByte();
                s.filter = s.mipmap >> 4;
                s.mipmap &= 0xf;
                desc.samplers[s.regnum] = s;
            } else {
                s.indexregtype = bytes.readUnsignedByte();
                s.indexselect = bytes.readUnsignedByte();
                s.indirectflag = bytes.readUnsignedByte();
            }
            if (s.indirectflag) {
                desc.hasindirect = true;
            }
            if (!s.indirectflag && mh) {
                for (var mhi = 0; mhi < mh; mhi++) {
                    desc.regread[s.regtype][s.regnum + mhi] = desc.regread[s.regtype][s.regnum];
                }
            }
        };
        return AGALTokenizer;
    })();
    aglsl.AGALTokenizer = AGALTokenizer;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var AGLSLParser = (function () {
        function AGLSLParser() {
        }
        AGLSLParser.prototype.parse = function (desc) {
            var header = "";
            var body = "";

            header += "precision mediump float;\n";
            var tag = desc.header.type[0];

            if (desc.header.type == "vertex") {
                header += "uniform float yflip;\n";
            }
            if (!desc.hasindirect) {
                for (var i = 0; i < desc.regread[0x1].length; i++) {
                    if (desc.regread[0x1][i]) {
                        header += "uniform vec4 " + tag + "c" + i + ";\n";
                    }
                }
            } else {
                header += "uniform vec4 " + tag + "carrr[" + aglsl.Context3D.maxvertexconstants + "];\n";
            }

            for (var i = 0; i < desc.regread[0x2].length || i < desc.regwrite[0x2].length; i++) {
                if (desc.regread[0x2][i] || desc.regwrite[0x2][i]) {
                    header += "vec4 " + tag + "t" + i + ";\n";
                }
            }

            for (var i = 0; i < desc.regread[0x0].length; i++) {
                if (desc.regread[0x0][i]) {
                    header += "attribute vec4 va" + i + ";\n";
                }
            }

            for (var i = 0; i < desc.regread[0x4].length || i < desc.regwrite[0x4].length; i++) {
                if (desc.regread[0x4][i] || desc.regwrite[0x4][i]) {
                    header += "varying vec4 vi" + i + ";\n";
                }
            }

            // declare samplers
            var samptype = ["2D", "Cube", "3D", ""];
            for (var i = 0; i < desc.samplers.length; i++) {
                if (desc.samplers[i]) {
                    header += "uniform sampler" + samptype[desc.samplers[i].dim & 3] + " fs" + i + ";\n";
                }
            }

            if (desc.header.type == "vertex") {
                header += "vec4 outpos;\n";
            }
            if (desc.writedepth) {
                header += "vec4 tmp_FragDepth;\n";
            }

            //if ( desc.hasmatrix )
            //    header += "vec4 tmp_matrix;\n";
            // start body of code
            body += "void main() {\n";

            for (var i = 0; i < desc.tokens.length; i++) {
                var lutentry = aglsl.Mapping.agal2glsllut[desc.tokens[i].opcode];
                if (!lutentry) {
                    throw "Opcode not valid or not implemented yet: ";
                }
                var sublines = lutentry.matrixheight || 1;

                for (var sl = 0; sl < sublines; sl++) {
                    var line = "  " + lutentry.s;
                    if (desc.tokens[i].dest) {
                        if (lutentry.matrixheight) {
                            if (((desc.tokens[i].dest.mask >> sl) & 1) != 1) {
                                continue;
                            }
                            var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
                            var destcaststring = "float";
                            var destmaskstring = ["x", "y", "z", "w"][sl];
                            destregstring += "." + destmaskstring;
                        } else {
                            var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
                            var destcaststring;
                            var destmaskstring;
                            if (desc.tokens[i].dest.mask != 0xf) {
                                var ndest = 0;
                                destmaskstring = "";
                                if (desc.tokens[i].dest.mask & 1) {
                                    ndest++;
                                    destmaskstring += "x";
                                }
                                if (desc.tokens[i].dest.mask & 2) {
                                    ndest++;
                                    destmaskstring += "y";
                                }
                                if (desc.tokens[i].dest.mask & 4) {
                                    ndest++;
                                    destmaskstring += "z";
                                }
                                if (desc.tokens[i].dest.mask & 8) {
                                    ndest++;
                                    destmaskstring += "w";
                                }
                                destregstring += "." + destmaskstring;
                                switch (ndest) {
                                    case 1:
                                        destcaststring = "float";
                                        break;
                                    case 2:
                                        destcaststring = "vec2";
                                        break;
                                    case 3:
                                        destcaststring = "vec3";
                                        break;
                                    default:
                                        throw "Unexpected destination mask";
                                }
                            } else {
                                destcaststring = "vec4";
                                destmaskstring = "xyzw";
                            }
                        }
                        line = line.replace("%dest", destregstring);
                        line = line.replace("%cast", destcaststring);
                        line = line.replace("%dm", destmaskstring);
                    }
                    var dwm = 0xf;
                    if (!lutentry.ndwm && lutentry.dest && desc.tokens[i].dest) {
                        dwm = desc.tokens[i].dest.mask;
                    }
                    if (desc.tokens[i].a) {
                        line = line.replace("%a", this.sourcetostring(desc.tokens[i].a, 0, dwm, lutentry.scalar, desc, tag));
                    }
                    if (desc.tokens[i].b) {
                        line = line.replace("%b", this.sourcetostring(desc.tokens[i].b, sl, dwm, lutentry.scalar, desc, tag));
                        if (desc.tokens[i].b.regtype == 0x5) {
                            // sampler dim
                            var texdim = ["2D", "Cube", "3D"][desc.tokens[i].b.dim];
                            var texsize = ["vec2", "vec3", "vec3"][desc.tokens[i].b.dim];
                            line = line.replace("%texdim", texdim);
                            line = line.replace("%texsize", texsize);
                            var texlod = "";
                            line = line.replace("%lod", texlod);
                        }
                    }
                    body += line;
                }
            }

            if (desc.header.type == "vertex") {
                body += "  gl_Position = vec4(outpos.x, yflip*outpos.y, outpos.z*2.0 - outpos.w, outpos.w);\n";
            }

            if (desc.writedepth) {
                body += "  gl_FragDepth = clamp(tmp_FragDepth,0.0,1.0);\n";
            }

            // close main
            body += "}\n";

            return header + body;
        };

        AGLSLParser.prototype.regtostring = function (regtype, regnum, desc, tag) {
            switch (regtype) {
                case 0x0:
                    return "va" + regnum;
                case 0x1:
                    if (desc.hasindirect && desc.header.type == "vertex") {
                        return "vcarrr[" + regnum + "]";
                    } else {
                        return tag + "c" + regnum;
                    }
                case 0x2:
                    return tag + "t" + regnum;
                case 0x3:
                    return desc.header.type == "vertex" ? "outpos" : "gl_FragColor";
                case 0x4:
                    return "vi" + regnum;
                case 0x5:
                    return "fs" + regnum;
                case 0x6:
                    return "tmp_FragDepth";
                default:
                    throw "Unknown register type";
            }
        };

        AGLSLParser.prototype.sourcetostring = function (s, subline, dwm, isscalar, desc, tag) {
            var swiz = ["x", "y", "z", "w"];
            var r;

            if (s.indirectflag) {
                r = "vcarrr[int(" + this.regtostring(s.indexregtype, s.regnum, desc, tag) + "." + swiz[s.indexselect] + ")";
                var realofs = subline + s.indexoffset;
                if (realofs < 0)
                    r += realofs.toString();
                if (realofs > 0)
                    r += "+" + realofs.toString();
                r += "]";
            } else {
                r = this.regtostring(s.regtype, s.regnum + subline, desc, tag);
            }

            if (s.regtype == 0x5) {
                return r;
            }

            if (isscalar) {
                return r + "." + swiz[(s.swizzle >> 0) & 3];
            }

            if (s.swizzle == 0xe4 && dwm == 0xf) {
                return r;
            }

            // with destination write mask folded in
            r += ".";
            if (dwm & 1)
                r += swiz[(s.swizzle >> 0) & 3];
            if (dwm & 2)
                r += swiz[(s.swizzle >> 2) & 3];
            if (dwm & 4)
                r += swiz[(s.swizzle >> 4) & 3];
            if (dwm & 8)
                r += swiz[(s.swizzle >> 6) & 3];
            return r;
        };
        return AGLSLParser;
    })();
    aglsl.AGLSLParser = AGLSLParser;
})(aglsl || (aglsl = {}));
///<reference path="../away/_definitions.ts" />
var aglsl;
(function (aglsl) {
    var AGLSLCompiler = (function () {
        function AGLSLCompiler() {
        }
        AGLSLCompiler.prototype.compile = function (programType, source) {
            var agalMiniAssembler = new aglsl.assembler.AGALMiniAssembler();
            var tokenizer = new aglsl.AGALTokenizer();

            var data;
            var concatSource;
            switch (programType) {
                case "vertex":
                    concatSource = "part vertex 1\n" + source + "endpart";
                    agalMiniAssembler.assemble(concatSource);
                    data = agalMiniAssembler.r['vertex'].data;
                    break;
                case "fragment":
                    concatSource = "part fragment 1\n" + source + "endpart";
                    agalMiniAssembler.assemble(concatSource);
                    data = agalMiniAssembler.r['fragment'].data;
                    break;
                default:
                    throw "Unknown Context3DProgramType";
            }

            var description = tokenizer.decribeAGALByteArray(data);

            var parser = new aglsl.AGLSLParser();
            this.glsl = parser.parse(description);

            return this.glsl;
        };
        return AGLSLCompiler;
    })();
    aglsl.AGLSLCompiler = AGLSLCompiler;
})(aglsl || (aglsl = {}));
///<reference path="away/_definitions.ts"/>
away.Debug.THROW_ERRORS = false;
away.Debug.LOG_PI_ERRORS = false;

var away;
(function (away) {
    var Away3D = (function (_super) {
        __extends(Away3D, _super);
        function Away3D() {
            _super.call(this);
        }
        return Away3D;
    })(away.events.EventDispatcher);
    away.Away3D = Away3D;
})(away || (away = {}));
//# sourceMappingURL=Away3D.next.js.map
